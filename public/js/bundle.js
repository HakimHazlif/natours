(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name in all3)
      __defProp(target, name, { get: all3[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/core-js/internals/global-this.js
  var require_global_this = __commonJS({
    "node_modules/core-js/internals/global-this.js"(exports, module) {
      "use strict";
      var check = function(it2) {
        return it2 && it2.Math === Math && it2;
      };
      module.exports = // eslint-disable-next-line es/no-global-this -- safe
      check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
      /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")();
    }
  });

  // node_modules/core-js/internals/fails.js
  var require_fails = __commonJS({
    "node_modules/core-js/internals/fails.js"(exports, module) {
      "use strict";
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/internals/descriptors.js
  var require_descriptors = __commonJS({
    "node_modules/core-js/internals/descriptors.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] !== 7;
      });
    }
  });

  // node_modules/core-js/internals/function-bind-native.js
  var require_function_bind_native = __commonJS({
    "node_modules/core-js/internals/function-bind-native.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        var test2 = function() {
        }.bind();
        return typeof test2 != "function" || test2.hasOwnProperty("prototype");
      });
    }
  });

  // node_modules/core-js/internals/function-call.js
  var require_function_call = __commonJS({
    "node_modules/core-js/internals/function-call.js"(exports, module) {
      "use strict";
      var NATIVE_BIND = require_function_bind_native();
      var call = Function.prototype.call;
      module.exports = NATIVE_BIND ? call.bind(call) : function() {
        return call.apply(call, arguments);
      };
    }
  });

  // node_modules/core-js/internals/object-property-is-enumerable.js
  var require_object_property_is_enumerable = __commonJS({
    "node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
      "use strict";
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
      exports.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
        var descriptor = getOwnPropertyDescriptor(this, V2);
        return !!descriptor && descriptor.enumerable;
      } : $propertyIsEnumerable;
    }
  });

  // node_modules/core-js/internals/create-property-descriptor.js
  var require_create_property_descriptor = __commonJS({
    "node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
      "use strict";
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this.js
  var require_function_uncurry_this = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
      "use strict";
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var call = FunctionPrototype.call;
      var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
      module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn2) {
        return function() {
          return call.apply(fn2, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/classof-raw.js
  var require_classof_raw = __commonJS({
    "node_modules/core-js/internals/classof-raw.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toString3 = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module.exports = function(it2) {
        return stringSlice(toString3(it2), 8, -1);
      };
    }
  });

  // node_modules/core-js/internals/indexed-object.js
  var require_indexed_object = __commonJS({
    "node_modules/core-js/internals/indexed-object.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var classof = require_classof_raw();
      var $Object = Object;
      var split = uncurryThis("".split);
      module.exports = fails(function() {
        return !$Object("z").propertyIsEnumerable(0);
      }) ? function(it2) {
        return classof(it2) === "String" ? split(it2, "") : $Object(it2);
      } : $Object;
    }
  });

  // node_modules/core-js/internals/is-null-or-undefined.js
  var require_is_null_or_undefined = __commonJS({
    "node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
      "use strict";
      module.exports = function(it2) {
        return it2 === null || it2 === void 0;
      };
    }
  });

  // node_modules/core-js/internals/require-object-coercible.js
  var require_require_object_coercible = __commonJS({
    "node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
      "use strict";
      var isNullOrUndefined = require_is_null_or_undefined();
      var $TypeError = TypeError;
      module.exports = function(it2) {
        if (isNullOrUndefined(it2)) throw new $TypeError("Can't call method on " + it2);
        return it2;
      };
    }
  });

  // node_modules/core-js/internals/to-indexed-object.js
  var require_to_indexed_object = __commonJS({
    "node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
      "use strict";
      var IndexedObject = require_indexed_object();
      var requireObjectCoercible = require_require_object_coercible();
      module.exports = function(it2) {
        return IndexedObject(requireObjectCoercible(it2));
      };
    }
  });

  // node_modules/core-js/internals/is-callable.js
  var require_is_callable = __commonJS({
    "node_modules/core-js/internals/is-callable.js"(exports, module) {
      "use strict";
      var documentAll = typeof document == "object" && document.all;
      module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
        return typeof argument == "function" || argument === documentAll;
      } : function(argument) {
        return typeof argument == "function";
      };
    }
  });

  // node_modules/core-js/internals/is-object.js
  var require_is_object = __commonJS({
    "node_modules/core-js/internals/is-object.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      module.exports = function(it2) {
        return typeof it2 == "object" ? it2 !== null : isCallable(it2);
      };
    }
  });

  // node_modules/core-js/internals/get-built-in.js
  var require_get_built_in = __commonJS({
    "node_modules/core-js/internals/get-built-in.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var isCallable = require_is_callable();
      var aFunction = function(argument) {
        return isCallable(argument) ? argument : void 0;
      };
      module.exports = function(namespace, method) {
        return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
      };
    }
  });

  // node_modules/core-js/internals/object-is-prototype-of.js
  var require_object_is_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis({}.isPrototypeOf);
    }
  });

  // node_modules/core-js/internals/environment-user-agent.js
  var require_environment_user_agent = __commonJS({
    "node_modules/core-js/internals/environment-user-agent.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var navigator2 = globalThis2.navigator;
      var userAgent = navigator2 && navigator2.userAgent;
      module.exports = userAgent ? String(userAgent) : "";
    }
  });

  // node_modules/core-js/internals/environment-v8-version.js
  var require_environment_v8_version = __commonJS({
    "node_modules/core-js/internals/environment-v8-version.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var userAgent = require_environment_user_agent();
      var process2 = globalThis2.process;
      var Deno2 = globalThis2.Deno;
      var versions = process2 && process2.versions || Deno2 && Deno2.version;
      var v8 = versions && versions.v8;
      var match;
      var version2;
      if (v8) {
        match = v8.split(".");
        version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version2 && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match) version2 = +match[1];
        }
      }
      module.exports = version2;
    }
  });

  // node_modules/core-js/internals/symbol-constructor-detection.js
  var require_symbol_constructor_detection = __commonJS({
    "node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
      "use strict";
      var V8_VERSION = require_environment_v8_version();
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $String = globalThis2.String;
      module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        var symbol = Symbol("symbol detection");
        return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && V8_VERSION && V8_VERSION < 41;
      });
    }
  });

  // node_modules/core-js/internals/use-symbol-as-uid.js
  var require_use_symbol_as_uid = __commonJS({
    "node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
      "use strict";
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  });

  // node_modules/core-js/internals/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/core-js/internals/is-symbol.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var $Object = Object;
      module.exports = USE_SYMBOL_AS_UID ? function(it2) {
        return typeof it2 == "symbol";
      } : function(it2) {
        var $Symbol = getBuiltIn("Symbol");
        return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it2));
      };
    }
  });

  // node_modules/core-js/internals/try-to-string.js
  var require_try_to_string = __commonJS({
    "node_modules/core-js/internals/try-to-string.js"(exports, module) {
      "use strict";
      var $String = String;
      module.exports = function(argument) {
        try {
          return $String(argument);
        } catch (error) {
          return "Object";
        }
      };
    }
  });

  // node_modules/core-js/internals/a-callable.js
  var require_a_callable = __commonJS({
    "node_modules/core-js/internals/a-callable.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isCallable(argument)) return argument;
        throw new $TypeError(tryToString(argument) + " is not a function");
      };
    }
  });

  // node_modules/core-js/internals/get-method.js
  var require_get_method = __commonJS({
    "node_modules/core-js/internals/get-method.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var isNullOrUndefined = require_is_null_or_undefined();
      module.exports = function(V2, P) {
        var func = V2[P];
        return isNullOrUndefined(func) ? void 0 : aCallable(func);
      };
    }
  });

  // node_modules/core-js/internals/ordinary-to-primitive.js
  var require_ordinary_to_primitive = __commonJS({
    "node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var $TypeError = TypeError;
      module.exports = function(input, pref) {
        var fn2, val;
        if (pref === "string" && isCallable(fn2 = input.toString) && !isObject2(val = call(fn2, input))) return val;
        if (isCallable(fn2 = input.valueOf) && !isObject2(val = call(fn2, input))) return val;
        if (pref !== "string" && isCallable(fn2 = input.toString) && !isObject2(val = call(fn2, input))) return val;
        throw new $TypeError("Can't convert object to primitive value");
      };
    }
  });

  // node_modules/core-js/internals/is-pure.js
  var require_is_pure = __commonJS({
    "node_modules/core-js/internals/is-pure.js"(exports, module) {
      "use strict";
      module.exports = false;
    }
  });

  // node_modules/core-js/internals/define-global-property.js
  var require_define_global_property = __commonJS({
    "node_modules/core-js/internals/define-global-property.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var defineProperty = Object.defineProperty;
      module.exports = function(key, value) {
        try {
          defineProperty(globalThis2, key, { value, configurable: true, writable: true });
        } catch (error) {
          globalThis2[key] = value;
        }
        return value;
      };
    }
  });

  // node_modules/core-js/internals/shared-store.js
  var require_shared_store = __commonJS({
    "node_modules/core-js/internals/shared-store.js"(exports, module) {
      "use strict";
      var IS_PURE = require_is_pure();
      var globalThis2 = require_global_this();
      var defineGlobalProperty = require_define_global_property();
      var SHARED = "__core-js_shared__";
      var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
      (store.versions || (store.versions = [])).push({
        version: "3.42.0",
        mode: IS_PURE ? "pure" : "global",
        copyright: "\xA9 2014-2025 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.42.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  });

  // node_modules/core-js/internals/shared.js
  var require_shared = __commonJS({
    "node_modules/core-js/internals/shared.js"(exports, module) {
      "use strict";
      var store = require_shared_store();
      module.exports = function(key, value) {
        return store[key] || (store[key] = value || {});
      };
    }
  });

  // node_modules/core-js/internals/to-object.js
  var require_to_object = __commonJS({
    "node_modules/core-js/internals/to-object.js"(exports, module) {
      "use strict";
      var requireObjectCoercible = require_require_object_coercible();
      var $Object = Object;
      module.exports = function(argument) {
        return $Object(requireObjectCoercible(argument));
      };
    }
  });

  // node_modules/core-js/internals/has-own-property.js
  var require_has_own_property = __commonJS({
    "node_modules/core-js/internals/has-own-property.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
      module.exports = Object.hasOwn || function hasOwn(it2, key) {
        return hasOwnProperty2(toObject(it2), key);
      };
    }
  });

  // node_modules/core-js/internals/uid.js
  var require_uid = __commonJS({
    "node_modules/core-js/internals/uid.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var id = 0;
      var postfix = Math.random();
      var toString3 = uncurryThis(1 .toString);
      module.exports = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString3(++id + postfix, 36);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol.js
  var require_well_known_symbol = __commonJS({
    "node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var shared = require_shared();
      var hasOwn = require_has_own_property();
      var uid = require_uid();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
      var Symbol2 = globalThis2.Symbol;
      var WellKnownSymbolsStore = shared("wks");
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module.exports = function(name) {
        if (!hasOwn(WellKnownSymbolsStore, name)) {
          WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
        }
        return WellKnownSymbolsStore[name];
      };
    }
  });

  // node_modules/core-js/internals/to-primitive.js
  var require_to_primitive = __commonJS({
    "node_modules/core-js/internals/to-primitive.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var isObject2 = require_is_object();
      var isSymbol = require_is_symbol();
      var getMethod = require_get_method();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var $TypeError = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module.exports = function(input, pref) {
        if (!isObject2(input) || isSymbol(input)) return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0) pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject2(result) || isSymbol(result)) return result;
          throw new $TypeError("Can't convert object to primitive value");
        }
        if (pref === void 0) pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    }
  });

  // node_modules/core-js/internals/to-property-key.js
  var require_to_property_key = __commonJS({
    "node_modules/core-js/internals/to-property-key.js"(exports, module) {
      "use strict";
      var toPrimitive = require_to_primitive();
      var isSymbol = require_is_symbol();
      module.exports = function(argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    }
  });

  // node_modules/core-js/internals/document-create-element.js
  var require_document_create_element = __commonJS({
    "node_modules/core-js/internals/document-create-element.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var isObject2 = require_is_object();
      var document2 = globalThis2.document;
      var EXISTS = isObject2(document2) && isObject2(document2.createElement);
      module.exports = function(it2) {
        return EXISTS ? document2.createElement(it2) : {};
      };
    }
  });

  // node_modules/core-js/internals/ie8-dom-define.js
  var require_ie8_dom_define = __commonJS({
    "node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var createElement = require_document_create_element();
      module.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement("div"), "a", {
          get: function() {
            return 7;
          }
        }).a !== 7;
      });
    }
  });

  // node_modules/core-js/internals/object-get-own-property-descriptor.js
  var require_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var call = require_function_call();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var createPropertyDescriptor = require_create_property_descriptor();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P) {
        O2 = toIndexedObject(O2);
        P = toPropertyKey(P);
        if (IE8_DOM_DEFINE) try {
          return $getOwnPropertyDescriptor(O2, P);
        } catch (error) {
        }
        if (hasOwn(O2, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O2, P), O2[P]);
      };
    }
  });

  // node_modules/core-js/internals/v8-prototype-define-bug.js
  var require_v8_prototype_define_bug = __commonJS({
    "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      module.exports = DESCRIPTORS && fails(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype !== 42;
      });
    }
  });

  // node_modules/core-js/internals/an-object.js
  var require_an_object = __commonJS({
    "node_modules/core-js/internals/an-object.js"(exports, module) {
      "use strict";
      var isObject2 = require_is_object();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isObject2(argument)) return argument;
        throw new $TypeError($String(argument) + " is not an object");
      };
    }
  });

  // node_modules/core-js/internals/object-define-property.js
  var require_object_define_property = __commonJS({
    "node_modules/core-js/internals/object-define-property.js"(exports) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var IE8_DOM_DEFINE = require_ie8_dom_define();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var $TypeError = TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P, Attributes) {
        anObject(O2);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (typeof O2 === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current = $getOwnPropertyDescriptor(O2, P);
          if (current && current[WRITABLE]) {
            O2[P] = Attributes.value;
            Attributes = {
              configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
              enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
              writable: false
            };
          }
        }
        return $defineProperty(O2, P, Attributes);
      } : $defineProperty : function defineProperty(O2, P, Attributes) {
        anObject(O2);
        P = toPropertyKey(P);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return $defineProperty(O2, P, Attributes);
        } catch (error) {
        }
        if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
        if ("value" in Attributes) O2[P] = Attributes.value;
        return O2;
      };
    }
  });

  // node_modules/core-js/internals/create-non-enumerable-property.js
  var require_create_non_enumerable_property = __commonJS({
    "node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }
  });

  // node_modules/core-js/internals/function-name.js
  var require_function_name = __commonJS({
    "node_modules/core-js/internals/function-name.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var hasOwn = require_has_own_property();
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && function something() {
      }.name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
      module.exports = {
        EXISTS,
        PROPER,
        CONFIGURABLE
      };
    }
  });

  // node_modules/core-js/internals/inspect-source.js
  var require_inspect_source = __commonJS({
    "node_modules/core-js/internals/inspect-source.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var isCallable = require_is_callable();
      var store = require_shared_store();
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function(it2) {
          return functionToString(it2);
        };
      }
      module.exports = store.inspectSource;
    }
  });

  // node_modules/core-js/internals/weak-map-basic-detection.js
  var require_weak_map_basic_detection = __commonJS({
    "node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var isCallable = require_is_callable();
      var WeakMap2 = globalThis2.WeakMap;
      module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
    }
  });

  // node_modules/core-js/internals/shared-key.js
  var require_shared_key = __commonJS({
    "node_modules/core-js/internals/shared-key.js"(exports, module) {
      "use strict";
      var shared = require_shared();
      var uid = require_uid();
      var keys = shared("keys");
      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    }
  });

  // node_modules/core-js/internals/hidden-keys.js
  var require_hidden_keys = __commonJS({
    "node_modules/core-js/internals/hidden-keys.js"(exports, module) {
      "use strict";
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/internal-state.js
  var require_internal_state = __commonJS({
    "node_modules/core-js/internals/internal-state.js"(exports, module) {
      "use strict";
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var globalThis2 = require_global_this();
      var isObject2 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var hasOwn = require_has_own_property();
      var shared = require_shared_store();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = globalThis2.TypeError;
      var WeakMap2 = globalThis2.WeakMap;
      var set;
      var get;
      var has;
      var enforce = function(it2) {
        return has(it2) ? get(it2) : set(it2, {});
      };
      var getterFor = function(TYPE) {
        return function(it2) {
          var state;
          if (!isObject2(it2) || (state = get(it2)).type !== TYPE) {
            throw new TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP || shared.state) {
        store = shared.state || (shared.state = new WeakMap2());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set = function(it2, metadata) {
          if (store.has(it2)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it2;
          store.set(it2, metadata);
          return metadata;
        };
        get = function(it2) {
          return store.get(it2) || {};
        };
        has = function(it2) {
          return store.has(it2);
        };
      } else {
        STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = function(it2, metadata) {
          if (hasOwn(it2, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it2;
          createNonEnumerableProperty(it2, STATE, metadata);
          return metadata;
        };
        get = function(it2) {
          return hasOwn(it2, STATE) ? it2[STATE] : {};
        };
        has = function(it2) {
          return hasOwn(it2, STATE);
        };
      }
      var store;
      var STATE;
      module.exports = {
        set,
        get,
        has,
        enforce,
        getterFor
      };
    }
  });

  // node_modules/core-js/internals/make-built-in.js
  var require_make_built_in = __commonJS({
    "node_modules/core-js/internals/make-built-in.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var DESCRIPTORS = require_descriptors();
      var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
      var inspectSource = require_inspect_source();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var $String = String;
      var defineProperty = Object.defineProperty;
      var stringSlice = uncurryThis("".slice);
      var replace = uncurryThis("".replace);
      var join = uncurryThis([].join);
      var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
        return defineProperty(function() {
        }, "length", { value: 8 }).length !== 8;
      });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn = module.exports = function(value, name, options) {
        if (stringSlice($String(name), 0, 7) === "Symbol(") {
          name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
        }
        if (options && options.getter) name = "get " + name;
        if (options && options.setter) name = "set " + name;
        if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
          if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
          else value.name = name;
        }
        if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
          defineProperty(value, "length", { value: options.arity });
        }
        try {
          if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
          } else if (value.prototype) value.prototype = void 0;
        } catch (error) {
        }
        var state = enforceInternalState(value);
        if (!hasOwn(state, "source")) {
          state.source = join(TEMPLATE, typeof name == "string" ? name : "");
        }
        return value;
      };
      Function.prototype.toString = makeBuiltIn(function toString3() {
        return isCallable(this) && getInternalState(this).source || inspectSource(this);
      }, "toString");
    }
  });

  // node_modules/core-js/internals/define-built-in.js
  var require_define_built_in = __commonJS({
    "node_modules/core-js/internals/define-built-in.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var definePropertyModule = require_object_define_property();
      var makeBuiltIn = require_make_built_in();
      var defineGlobalProperty = require_define_global_property();
      module.exports = function(O2, key, value, options) {
        if (!options) options = {};
        var simple = options.enumerable;
        var name = options.name !== void 0 ? options.name : key;
        if (isCallable(value)) makeBuiltIn(value, name, options);
        if (options.global) {
          if (simple) O2[key] = value;
          else defineGlobalProperty(key, value);
        } else {
          try {
            if (!options.unsafe) delete O2[key];
            else if (O2[key]) simple = true;
          } catch (error) {
          }
          if (simple) O2[key] = value;
          else definePropertyModule.f(O2, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
        }
        return O2;
      };
    }
  });

  // node_modules/core-js/internals/math-trunc.js
  var require_math_trunc = __commonJS({
    "node_modules/core-js/internals/math-trunc.js"(exports, module) {
      "use strict";
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports = Math.trunc || function trunc(x2) {
        var n = +x2;
        return (n > 0 ? floor : ceil)(n);
      };
    }
  });

  // node_modules/core-js/internals/to-integer-or-infinity.js
  var require_to_integer_or_infinity = __commonJS({
    "node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
      "use strict";
      var trunc = require_math_trunc();
      module.exports = function(argument) {
        var number = +argument;
        return number !== number || number === 0 ? 0 : trunc(number);
      };
    }
  });

  // node_modules/core-js/internals/to-absolute-index.js
  var require_to_absolute_index = __commonJS({
    "node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var max = Math.max;
      var min = Math.min;
      module.exports = function(index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    }
  });

  // node_modules/core-js/internals/to-length.js
  var require_to_length = __commonJS({
    "node_modules/core-js/internals/to-length.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var min = Math.min;
      module.exports = function(argument) {
        var len = toIntegerOrInfinity(argument);
        return len > 0 ? min(len, 9007199254740991) : 0;
      };
    }
  });

  // node_modules/core-js/internals/length-of-array-like.js
  var require_length_of_array_like = __commonJS({
    "node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
      "use strict";
      var toLength = require_to_length();
      module.exports = function(obj) {
        return toLength(obj.length);
      };
    }
  });

  // node_modules/core-js/internals/array-includes.js
  var require_array_includes = __commonJS({
    "node_modules/core-js/internals/array-includes.js"(exports, module) {
      "use strict";
      var toIndexedObject = require_to_indexed_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O2 = toIndexedObject($this);
          var length = lengthOfArrayLike(O2);
          if (length === 0) return !IS_INCLUDES && -1;
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el !== el) while (length > index) {
            value = O2[index++];
            if (value !== value) return true;
          }
          else for (; length > index; index++) {
            if ((IS_INCLUDES || index in O2) && O2[index] === el) return IS_INCLUDES || index || 0;
          }
          return !IS_INCLUDES && -1;
        };
      };
      module.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
      };
    }
  });

  // node_modules/core-js/internals/object-keys-internal.js
  var require_object_keys_internal = __commonJS({
    "node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var toIndexedObject = require_to_indexed_object();
      var indexOf = require_array_includes().indexOf;
      var hiddenKeys = require_hidden_keys();
      var push = uncurryThis([].push);
      module.exports = function(object, names) {
        var O2 = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O2) !hasOwn(hiddenKeys, key) && hasOwn(O2, key) && push(result, key);
        while (names.length > i) if (hasOwn(O2, key = names[i++])) {
          ~indexOf(result, key) || push(result, key);
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/enum-bug-keys.js
  var require_enum_bug_keys = __commonJS({
    "node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
      "use strict";
      module.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names.js
  var require_object_get_own_property_names = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
      "use strict";
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
        return internalObjectKeys(O2, hiddenKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-get-own-property-symbols.js
  var require_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
      "use strict";
      exports.f = Object.getOwnPropertySymbols;
    }
  });

  // node_modules/core-js/internals/own-keys.js
  var require_own_keys = __commonJS({
    "node_modules/core-js/internals/own-keys.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var anObject = require_an_object();
      var concat = uncurryThis([].concat);
      module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it2) {
        var keys = getOwnPropertyNamesModule.f(anObject(it2));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it2)) : keys;
      };
    }
  });

  // node_modules/core-js/internals/copy-constructor-properties.js
  var require_copy_constructor_properties = __commonJS({
    "node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
      "use strict";
      var hasOwn = require_has_own_property();
      var ownKeys = require_own_keys();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      module.exports = function(target, source, exceptions) {
        var keys = ownKeys(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    }
  });

  // node_modules/core-js/internals/is-forced.js
  var require_is_forced = __commonJS({
    "node_modules/core-js/internals/is-forced.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isCallable = require_is_callable();
      var replacement = /#|\.prototype\./;
      var isForced = function(feature, detection) {
        var value = data2[normalize(feature)];
        return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data2 = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module.exports = isForced;
    }
  });

  // node_modules/core-js/internals/export.js
  var require_export = __commonJS({
    "node_modules/core-js/internals/export.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineGlobalProperty = require_define_global_property();
      var copyConstructorProperties = require_copy_constructor_properties();
      var isForced = require_is_forced();
      module.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = globalThis2;
        } else if (STATIC) {
          target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
        }
        if (target) for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
      };
    }
  });

  // node_modules/core-js/internals/to-string-tag-support.js
  var require_to_string_tag_support = __commonJS({
    "node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test2 = {};
      test2[TO_STRING_TAG] = "z";
      module.exports = String(test2) === "[object z]";
    }
  });

  // node_modules/core-js/internals/classof.js
  var require_classof = __commonJS({
    "node_modules/core-js/internals/classof.js"(exports, module) {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var isCallable = require_is_callable();
      var classofRaw = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Object = Object;
      var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
        return arguments;
      }()) === "Arguments";
      var tryGet = function(it2, key) {
        try {
          return it2[key];
        } catch (error) {
        }
      };
      module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
        var O2, tag, result;
        return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) === "Object" && isCallable(O2.callee) ? "Arguments" : result;
      };
    }
  });

  // node_modules/core-js/internals/to-string.js
  var require_to_string = __commonJS({
    "node_modules/core-js/internals/to-string.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var $String = String;
      module.exports = function(argument) {
        if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
        return $String(argument);
      };
    }
  });

  // node_modules/core-js/internals/object-keys.js
  var require_object_keys = __commonJS({
    "node_modules/core-js/internals/object-keys.js"(exports, module) {
      "use strict";
      var internalObjectKeys = require_object_keys_internal();
      var enumBugKeys = require_enum_bug_keys();
      module.exports = Object.keys || function keys(O2) {
        return internalObjectKeys(O2, enumBugKeys);
      };
    }
  });

  // node_modules/core-js/internals/object-define-properties.js
  var require_object_define_properties = __commonJS({
    "node_modules/core-js/internals/object-define-properties.js"(exports) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
      var definePropertyModule = require_object_define_property();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var objectKeys = require_object_keys();
      exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
        anObject(O2);
        var props = toIndexedObject(Properties);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index = 0;
        var key;
        while (length > index) definePropertyModule.f(O2, key = keys[index++], props[key]);
        return O2;
      };
    }
  });

  // node_modules/core-js/internals/html.js
  var require_html = __commonJS({
    "node_modules/core-js/internals/html.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      module.exports = getBuiltIn("document", "documentElement");
    }
  });

  // node_modules/core-js/internals/object-create.js
  var require_object_create = __commonJS({
    "node_modules/core-js/internals/object-create.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var definePropertiesModule = require_object_define_properties();
      var enumBugKeys = require_enum_bug_keys();
      var hiddenKeys = require_hidden_keys();
      var html = require_html();
      var documentCreateElement = require_document_create_element();
      var sharedKey = require_shared_key();
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = function() {
      };
      var scriptTag = function(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var NullProtoObject = function() {
        try {
          activeXDocument = new ActiveXObject("htmlfile");
        } catch (error) {
        }
        NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
        var length = enumBugKeys.length;
        while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return NullProtoObject();
      };
      hiddenKeys[IE_PROTO] = true;
      module.exports = Object.create || function create(O2, Properties) {
        var result;
        if (O2 !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O2);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result[IE_PROTO] = O2;
        } else result = NullProtoObject();
        return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
      };
    }
  });

  // node_modules/core-js/internals/array-slice.js
  var require_array_slice = __commonJS({
    "node_modules/core-js/internals/array-slice.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis([].slice);
    }
  });

  // node_modules/core-js/internals/object-get-own-property-names-external.js
  var require_object_get_own_property_names_external = __commonJS({
    "node_modules/core-js/internals/object-get-own-property-names-external.js"(exports, module) {
      "use strict";
      var classof = require_classof_raw();
      var toIndexedObject = require_to_indexed_object();
      var $getOwnPropertyNames = require_object_get_own_property_names().f;
      var arraySlice = require_array_slice();
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function(it2) {
        try {
          return $getOwnPropertyNames(it2);
        } catch (error) {
          return arraySlice(windowNames);
        }
      };
      module.exports.f = function getOwnPropertyNames(it2) {
        return windowNames && classof(it2) === "Window" ? getWindowNames(it2) : $getOwnPropertyNames(toIndexedObject(it2));
      };
    }
  });

  // node_modules/core-js/internals/define-built-in-accessor.js
  var require_define_built_in_accessor = __commonJS({
    "node_modules/core-js/internals/define-built-in-accessor.js"(exports, module) {
      "use strict";
      var makeBuiltIn = require_make_built_in();
      var defineProperty = require_object_define_property();
      module.exports = function(target, name, descriptor) {
        if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
        if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
        return defineProperty.f(target, name, descriptor);
      };
    }
  });

  // node_modules/core-js/internals/well-known-symbol-wrapped.js
  var require_well_known_symbol_wrapped = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-wrapped.js"(exports) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      exports.f = wellKnownSymbol;
    }
  });

  // node_modules/core-js/internals/path.js
  var require_path = __commonJS({
    "node_modules/core-js/internals/path.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = globalThis2;
    }
  });

  // node_modules/core-js/internals/well-known-symbol-define.js
  var require_well_known_symbol_define = __commonJS({
    "node_modules/core-js/internals/well-known-symbol-define.js"(exports, module) {
      "use strict";
      var path = require_path();
      var hasOwn = require_has_own_property();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineProperty = require_object_define_property().f;
      module.exports = function(NAME) {
        var Symbol2 = path.Symbol || (path.Symbol = {});
        if (!hasOwn(Symbol2, NAME)) defineProperty(Symbol2, NAME, {
          value: wrappedWellKnownSymbolModule.f(NAME)
        });
      };
    }
  });

  // node_modules/core-js/internals/symbol-define-to-primitive.js
  var require_symbol_define_to_primitive = __commonJS({
    "node_modules/core-js/internals/symbol-define-to-primitive.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var getBuiltIn = require_get_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var defineBuiltIn = require_define_built_in();
      module.exports = function() {
        var Symbol2 = getBuiltIn("Symbol");
        var SymbolPrototype = Symbol2 && Symbol2.prototype;
        var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
        var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
        if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
          defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
            return call(valueOf, this);
          }, { arity: 1 });
        }
      };
    }
  });

  // node_modules/core-js/internals/set-to-string-tag.js
  var require_set_to_string_tag = __commonJS({
    "node_modules/core-js/internals/set-to-string-tag.js"(exports, module) {
      "use strict";
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module.exports = function(target, TAG, STATIC) {
        if (target && !STATIC) target = target.prototype;
        if (target && !hasOwn(target, TO_STRING_TAG)) {
          defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
      };
    }
  });

  // node_modules/core-js/internals/function-uncurry-this-clause.js
  var require_function_uncurry_this_clause = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
      "use strict";
      var classofRaw = require_classof_raw();
      var uncurryThis = require_function_uncurry_this();
      module.exports = function(fn2) {
        if (classofRaw(fn2) === "Function") return uncurryThis(fn2);
      };
    }
  });

  // node_modules/core-js/internals/function-bind-context.js
  var require_function_bind_context = __commonJS({
    "node_modules/core-js/internals/function-bind-context.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this_clause();
      var aCallable = require_a_callable();
      var NATIVE_BIND = require_function_bind_native();
      var bind2 = uncurryThis(uncurryThis.bind);
      module.exports = function(fn2, that) {
        aCallable(fn2);
        return that === void 0 ? fn2 : NATIVE_BIND ? bind2(fn2, that) : function() {
          return fn2.apply(that, arguments);
        };
      };
    }
  });

  // node_modules/core-js/internals/is-array.js
  var require_is_array = __commonJS({
    "node_modules/core-js/internals/is-array.js"(exports, module) {
      "use strict";
      var classof = require_classof_raw();
      module.exports = Array.isArray || function isArray2(argument) {
        return classof(argument) === "Array";
      };
    }
  });

  // node_modules/core-js/internals/is-constructor.js
  var require_is_constructor = __commonJS({
    "node_modules/core-js/internals/is-constructor.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var classof = require_classof();
      var getBuiltIn = require_get_built_in();
      var inspectSource = require_inspect_source();
      var noop2 = function() {
      };
      var construct = getBuiltIn("Reflect", "construct");
      var constructorRegExp = /^\s*(?:class|function)\b/;
      var exec = uncurryThis(constructorRegExp.exec);
      var INCORRECT_TO_STRING = !constructorRegExp.test(noop2);
      var isConstructorModern = function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        try {
          construct(noop2, [], argument);
          return true;
        } catch (error) {
          return false;
        }
      };
      var isConstructorLegacy = function isConstructor(argument) {
        if (!isCallable(argument)) return false;
        switch (classof(argument)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
        } catch (error) {
          return true;
        }
      };
      isConstructorLegacy.sham = true;
      module.exports = !construct || fails(function() {
        var called;
        return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
          called = true;
        }) || called;
      }) ? isConstructorLegacy : isConstructorModern;
    }
  });

  // node_modules/core-js/internals/array-species-constructor.js
  var require_array_species_constructor = __commonJS({
    "node_modules/core-js/internals/array-species-constructor.js"(exports, module) {
      "use strict";
      var isArray2 = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject2 = require_is_object();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      module.exports = function(originalArray) {
        var C2;
        if (isArray2(originalArray)) {
          C2 = originalArray.constructor;
          if (isConstructor(C2) && (C2 === $Array || isArray2(C2.prototype))) C2 = void 0;
          else if (isObject2(C2)) {
            C2 = C2[SPECIES];
            if (C2 === null) C2 = void 0;
          }
        }
        return C2 === void 0 ? $Array : C2;
      };
    }
  });

  // node_modules/core-js/internals/array-species-create.js
  var require_array_species_create = __commonJS({
    "node_modules/core-js/internals/array-species-create.js"(exports, module) {
      "use strict";
      var arraySpeciesConstructor = require_array_species_constructor();
      module.exports = function(originalArray, length) {
        return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
      };
    }
  });

  // node_modules/core-js/internals/array-iteration.js
  var require_array_iteration = __commonJS({
    "node_modules/core-js/internals/array-iteration.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      var push = uncurryThis([].push);
      var createMethod = function(TYPE) {
        var IS_MAP = TYPE === 1;
        var IS_FILTER = TYPE === 2;
        var IS_SOME = TYPE === 3;
        var IS_EVERY = TYPE === 4;
        var IS_FIND_INDEX = TYPE === 6;
        var IS_FILTER_REJECT = TYPE === 7;
        var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O2 = toObject($this);
          var self2 = IndexedObject(O2);
          var length = lengthOfArrayLike(self2);
          var boundFunction = bind2(callbackfn, that);
          var index = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : void 0;
          var value, result;
          for (; length > index; index++) if (NO_HOLES || index in self2) {
            value = self2[index];
            result = boundFunction(value, index, O2);
            if (TYPE) {
              if (IS_MAP) target[index] = result;
              else if (result) switch (TYPE) {
                case 3:
                  return true;
                // some
                case 5:
                  return value;
                // find
                case 6:
                  return index;
                // findIndex
                case 2:
                  push(target, value);
              }
              else switch (TYPE) {
                case 4:
                  return false;
                // every
                case 7:
                  push(target, value);
              }
            }
          }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      module.exports = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0),
        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        map: createMethod(1),
        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        filter: createMethod(2),
        // `Array.prototype.some` method
        // https://tc39.es/ecma262/#sec-array.prototype.some
        some: createMethod(3),
        // `Array.prototype.every` method
        // https://tc39.es/ecma262/#sec-array.prototype.every
        every: createMethod(4),
        // `Array.prototype.find` method
        // https://tc39.es/ecma262/#sec-array.prototype.find
        find: createMethod(5),
        // `Array.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod(6),
        // `Array.prototype.filterReject` method
        // https://github.com/tc39/proposal-array-filtering
        filterReject: createMethod(7)
      };
    }
  });

  // node_modules/core-js/modules/es.symbol.constructor.js
  var require_es_symbol_constructor = __commonJS({
    "node_modules/core-js/modules/es.symbol.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var anObject = require_an_object();
      var toIndexedObject = require_to_indexed_object();
      var toPropertyKey = require_to_property_key();
      var $toString = require_to_string();
      var createPropertyDescriptor = require_create_property_descriptor();
      var nativeObjectCreate = require_object_create();
      var objectKeys = require_object_keys();
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternal = require_object_get_own_property_names_external();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var definePropertyModule = require_object_define_property();
      var definePropertiesModule = require_object_define_properties();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var shared = require_shared();
      var sharedKey = require_shared_key();
      var hiddenKeys = require_hidden_keys();
      var uid = require_uid();
      var wellKnownSymbol = require_well_known_symbol();
      var wrappedWellKnownSymbolModule = require_well_known_symbol_wrapped();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineSymbolToPrimitive = require_symbol_define_to_primitive();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var $forEach = require_array_iteration().forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = globalThis2.Symbol;
      var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
      var RangeError2 = globalThis2.RangeError;
      var TypeError2 = globalThis2.TypeError;
      var QObject = globalThis2.QObject;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var push = uncurryThis([].push);
      var AllSymbols = shared("symbols");
      var ObjectPrototypeSymbols = shared("op-symbols");
      var WellKnownSymbolsStore = shared("wks");
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var fallbackDefineProperty = function(O2, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
        nativeDefineProperty(O2, P, Attributes);
        if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
      };
      var setSymbolDescriptor = DESCRIPTORS && fails(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", {
          get: function() {
            return nativeDefineProperty(this, "a", { value: 7 }).a;
          }
        })).a !== 7;
      }) ? fallbackDefineProperty : nativeDefineProperty;
      var wrap = function(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
        setInternalState(symbol, {
          type: SYMBOL,
          tag,
          description
        });
        if (!DESCRIPTORS) symbol.description = description;
        return symbol;
      };
      var $defineProperty = function defineProperty(O2, P, Attributes) {
        if (O2 === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O2);
        var key = toPropertyKey(P);
        anObject(Attributes);
        if (hasOwn(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!hasOwn(O2, HIDDEN)) nativeDefineProperty(O2, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
            O2[HIDDEN][key] = true;
          } else {
            if (hasOwn(O2, HIDDEN) && O2[HIDDEN][key]) O2[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O2, key, Attributes);
        }
        return nativeDefineProperty(O2, key, Attributes);
      };
      var $defineProperties = function defineProperties(O2, Properties) {
        anObject(O2);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys, function(key) {
          if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O2, key, properties[key]);
        });
        return O2;
      };
      var $create = function create(O2, Properties) {
        return Properties === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V2) {
        var P = toPropertyKey(V2);
        var enumerable = call(nativePropertyIsEnumerable, this, P);
        if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
        return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O2, P) {
        var it2 = toIndexedObject(O2);
        var key = toPropertyKey(P);
        if (it2 === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
        var descriptor = nativeGetOwnPropertyDescriptor(it2, key);
        if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it2, HIDDEN) && it2[HIDDEN][key])) {
          descriptor.enumerable = true;
        }
        return descriptor;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O2) {
        var names = nativeGetOwnPropertyNames(toIndexedObject(O2));
        var result = [];
        $forEach(names, function(key) {
          if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function(O2) {
        var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype;
        var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O2));
        var result = [];
        $forEach(names, function(key) {
          if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
            push(result, AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol2() {
          if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError2("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
          var tag = uid(description);
          var setter = function(value) {
            var $this = this === void 0 ? globalThis2 : this;
            if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
            if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
            var descriptor = createPropertyDescriptor(1, value);
            try {
              setSymbolDescriptor($this, tag, descriptor);
            } catch (error) {
              if (!(error instanceof RangeError2)) throw error;
              fallbackDefineProperty($this, tag, descriptor);
            }
          };
          if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap(tag, description);
        };
        SymbolPrototype = $Symbol[PROTOTYPE];
        defineBuiltIn(SymbolPrototype, "toString", function toString3() {
          return getInternalState(this).tag;
        });
        defineBuiltIn($Symbol, "withoutSetter", function(description) {
          return wrap(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        definePropertiesModule.f = $defineProperties;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name) {
          return wrap(wellKnownSymbol(name), name);
        };
        if (DESCRIPTORS) {
          defineBuiltInAccessor(SymbolPrototype, "description", {
            configurable: true,
            get: function description() {
              return getInternalState(this).description;
            }
          });
          if (!IS_PURE) {
            defineBuiltIn(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $2({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
        Symbol: $Symbol
      });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
        defineWellKnownSymbol(name);
      });
      $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
        useSetter: function() {
          USE_SETTER = true;
        },
        useSimple: function() {
          USE_SETTER = false;
        }
      });
      $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
        // `Object.create` method
        // https://tc39.es/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.es/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.es/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.es/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames
      });
      defineSymbolToPrimitive();
      setToStringTag($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
    }
  });

  // node_modules/core-js/internals/symbol-registry-detection.js
  var require_symbol_registry_detection = __commonJS({
    "node_modules/core-js/internals/symbol-registry-detection.js"(exports, module) {
      "use strict";
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      module.exports = NATIVE_SYMBOL && !!Symbol["for"] && !!Symbol.keyFor;
    }
  });

  // node_modules/core-js/modules/es.symbol.for.js
  var require_es_symbol_for = __commonJS({
    "node_modules/core-js/modules/es.symbol.for.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var toString3 = require_to_string();
      var shared = require_shared();
      var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
      var StringToSymbolRegistry = shared("string-to-symbol-registry");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        "for": function(key) {
          var string = toString3(key);
          if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
          var symbol = getBuiltIn("Symbol")(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry[symbol] = string;
          return symbol;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.symbol.key-for.js
  var require_es_symbol_key_for = __commonJS({
    "node_modules/core-js/modules/es.symbol.key-for.js"() {
      "use strict";
      var $2 = require_export();
      var hasOwn = require_has_own_property();
      var isSymbol = require_is_symbol();
      var tryToString = require_try_to_string();
      var shared = require_shared();
      var NATIVE_SYMBOL_REGISTRY = require_symbol_registry_detection();
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      $2({ target: "Symbol", stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + " is not a symbol");
          if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
        }
      });
    }
  });

  // node_modules/core-js/internals/function-apply.js
  var require_function_apply = __commonJS({
    "node_modules/core-js/internals/function-apply.js"(exports, module) {
      "use strict";
      var NATIVE_BIND = require_function_bind_native();
      var FunctionPrototype = Function.prototype;
      var apply = FunctionPrototype.apply;
      var call = FunctionPrototype.call;
      module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
        return call.apply(apply, arguments);
      });
    }
  });

  // node_modules/core-js/internals/get-json-replacer-function.js
  var require_get_json_replacer_function = __commonJS({
    "node_modules/core-js/internals/get-json-replacer-function.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var isArray2 = require_is_array();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var toString3 = require_to_string();
      var push = uncurryThis([].push);
      module.exports = function(replacer) {
        if (isCallable(replacer)) return replacer;
        if (!isArray2(replacer)) return;
        var rawLength = replacer.length;
        var keys = [];
        for (var i = 0; i < rawLength; i++) {
          var element = replacer[i];
          if (typeof element == "string") push(keys, element);
          else if (typeof element == "number" || classof(element) === "Number" || classof(element) === "String") push(keys, toString3(element));
        }
        var keysLength = keys.length;
        var root = true;
        return function(key, value) {
          if (root) {
            root = false;
            return value;
          }
          if (isArray2(this)) return value;
          for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
        };
      };
    }
  });

  // node_modules/core-js/modules/es.json.stringify.js
  var require_es_json_stringify = __commonJS({
    "node_modules/core-js/modules/es.json.stringify.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isSymbol = require_is_symbol();
      var arraySlice = require_array_slice();
      var getReplacerFunction = require_get_json_replacer_function();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var $String = String;
      var $stringify = getBuiltIn("JSON", "stringify");
      var exec = uncurryThis(/./.exec);
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var replace = uncurryThis("".replace);
      var numberToString = uncurryThis(1 .toString);
      var tester = /[\uD800-\uDFFF]/g;
      var low = /^[\uD800-\uDBFF]$/;
      var hi2 = /^[\uDC00-\uDFFF]$/;
      var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
        var symbol = getBuiltIn("Symbol")("stringify detection");
        return $stringify([symbol]) !== "[null]" || $stringify({ a: symbol }) !== "{}" || $stringify(Object(symbol)) !== "{}";
      });
      var ILL_FORMED_UNICODE = fails(function() {
        return $stringify("\uDF06\uD834") !== '"\\udf06\\ud834"' || $stringify("\uDEAD") !== '"\\udead"';
      });
      var stringifyWithSymbolsFix = function(it2, replacer) {
        var args = arraySlice(arguments);
        var $replacer = getReplacerFunction(replacer);
        if (!isCallable($replacer) && (it2 === void 0 || isSymbol(it2))) return;
        args[1] = function(key, value) {
          if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
          if (!isSymbol(value)) return value;
        };
        return apply($stringify, null, args);
      };
      var fixIllFormed = function(match, offset, string) {
        var prev = charAt(string, offset - 1);
        var next = charAt(string, offset + 1);
        if (exec(low, match) && !exec(hi2, next) || exec(hi2, match) && !exec(low, prev)) {
          return "\\u" + numberToString(charCodeAt(match, 0), 16);
        }
        return match;
      };
      if ($stringify) {
        $2({ target: "JSON", stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
          // eslint-disable-next-line no-unused-vars -- required for `.length`
          stringify: function stringify(it2, replacer, space) {
            var args = arraySlice(arguments);
            var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
            return ILL_FORMED_UNICODE && typeof result == "string" ? replace(result, tester, fixIllFormed) : result;
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-symbols.js
  var require_es_object_get_own_property_symbols = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-symbols.js"() {
      "use strict";
      var $2 = require_export();
      var NATIVE_SYMBOL = require_symbol_constructor_detection();
      var fails = require_fails();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var toObject = require_to_object();
      var FORCED = !NATIVE_SYMBOL || fails(function() {
        getOwnPropertySymbolsModule.f(1);
      });
      $2({ target: "Object", stat: true, forced: FORCED }, {
        getOwnPropertySymbols: function getOwnPropertySymbols(it2) {
          var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
          return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it2)) : [];
        }
      });
    }
  });

  // node_modules/core-js/modules/es.symbol.js
  var require_es_symbol = __commonJS({
    "node_modules/core-js/modules/es.symbol.js"() {
      "use strict";
      require_es_symbol_constructor();
      require_es_symbol_for();
      require_es_symbol_key_for();
      require_es_json_stringify();
      require_es_object_get_own_property_symbols();
    }
  });

  // node_modules/core-js/modules/es.symbol.description.js
  var require_es_symbol_description = __commonJS({
    "node_modules/core-js/modules/es.symbol.description.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var isPrototypeOf = require_object_is_prototype_of();
      var toString3 = require_to_string();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var copyConstructorProperties = require_copy_constructor_properties();
      var NativeSymbol = globalThis2.Symbol;
      var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
      if (DESCRIPTORS && isCallable(NativeSymbol) && (!("description" in SymbolPrototype) || // Safari 12 bug
      NativeSymbol().description !== void 0)) {
        EmptyStringDescriptionStore = {};
        SymbolWrapper = function Symbol2() {
          var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString3(arguments[0]);
          var result = isPrototypeOf(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
          if (description === "") EmptyStringDescriptionStore[result] = true;
          return result;
        };
        copyConstructorProperties(SymbolWrapper, NativeSymbol);
        SymbolWrapper.prototype = SymbolPrototype;
        SymbolPrototype.constructor = SymbolWrapper;
        NATIVE_SYMBOL = String(NativeSymbol("description detection")) === "Symbol(description detection)";
        thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
        symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
        regexp = /^Symbol\((.*)\)[^)]+$/;
        replace = uncurryThis("".replace);
        stringSlice = uncurryThis("".slice);
        defineBuiltInAccessor(SymbolPrototype, "description", {
          configurable: true,
          get: function description() {
            var symbol = thisSymbolValue(this);
            if (hasOwn(EmptyStringDescriptionStore, symbol)) return "";
            var string = symbolDescriptiveString(symbol);
            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, "$1");
            return desc === "" ? void 0 : desc;
          }
        });
        $2({ global: true, constructor: true, forced: true }, {
          Symbol: SymbolWrapper
        });
      }
      var EmptyStringDescriptionStore;
      var SymbolWrapper;
      var NATIVE_SYMBOL;
      var thisSymbolValue;
      var symbolDescriptiveString;
      var regexp;
      var replace;
      var stringSlice;
    }
  });

  // node_modules/core-js/modules/es.symbol.async-iterator.js
  var require_es_symbol_async_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.async-iterator.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("asyncIterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.has-instance.js
  var require_es_symbol_has_instance = __commonJS({
    "node_modules/core-js/modules/es.symbol.has-instance.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("hasInstance");
    }
  });

  // node_modules/core-js/modules/es.symbol.is-concat-spreadable.js
  var require_es_symbol_is_concat_spreadable = __commonJS({
    "node_modules/core-js/modules/es.symbol.is-concat-spreadable.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("isConcatSpreadable");
    }
  });

  // node_modules/core-js/modules/es.symbol.iterator.js
  var require_es_symbol_iterator = __commonJS({
    "node_modules/core-js/modules/es.symbol.iterator.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("iterator");
    }
  });

  // node_modules/core-js/modules/es.symbol.match.js
  var require_es_symbol_match = __commonJS({
    "node_modules/core-js/modules/es.symbol.match.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("match");
    }
  });

  // node_modules/core-js/modules/es.symbol.match-all.js
  var require_es_symbol_match_all = __commonJS({
    "node_modules/core-js/modules/es.symbol.match-all.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("matchAll");
    }
  });

  // node_modules/core-js/modules/es.symbol.replace.js
  var require_es_symbol_replace = __commonJS({
    "node_modules/core-js/modules/es.symbol.replace.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("replace");
    }
  });

  // node_modules/core-js/modules/es.symbol.search.js
  var require_es_symbol_search = __commonJS({
    "node_modules/core-js/modules/es.symbol.search.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("search");
    }
  });

  // node_modules/core-js/modules/es.symbol.species.js
  var require_es_symbol_species = __commonJS({
    "node_modules/core-js/modules/es.symbol.species.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("species");
    }
  });

  // node_modules/core-js/modules/es.symbol.split.js
  var require_es_symbol_split = __commonJS({
    "node_modules/core-js/modules/es.symbol.split.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("split");
    }
  });

  // node_modules/core-js/modules/es.symbol.to-primitive.js
  var require_es_symbol_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-primitive.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var defineSymbolToPrimitive = require_symbol_define_to_primitive();
      defineWellKnownSymbol("toPrimitive");
      defineSymbolToPrimitive();
    }
  });

  // node_modules/core-js/modules/es.symbol.to-string-tag.js
  var require_es_symbol_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.symbol.to-string-tag.js"() {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var defineWellKnownSymbol = require_well_known_symbol_define();
      var setToStringTag = require_set_to_string_tag();
      defineWellKnownSymbol("toStringTag");
      setToStringTag(getBuiltIn("Symbol"), "Symbol");
    }
  });

  // node_modules/core-js/modules/es.symbol.unscopables.js
  var require_es_symbol_unscopables = __commonJS({
    "node_modules/core-js/modules/es.symbol.unscopables.js"() {
      "use strict";
      var defineWellKnownSymbol = require_well_known_symbol_define();
      defineWellKnownSymbol("unscopables");
    }
  });

  // node_modules/core-js/internals/function-uncurry-this-accessor.js
  var require_function_uncurry_this_accessor = __commonJS({
    "node_modules/core-js/internals/function-uncurry-this-accessor.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      module.exports = function(object, key, method) {
        try {
          return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/is-possible-prototype.js
  var require_is_possible_prototype = __commonJS({
    "node_modules/core-js/internals/is-possible-prototype.js"(exports, module) {
      "use strict";
      var isObject2 = require_is_object();
      module.exports = function(argument) {
        return isObject2(argument) || argument === null;
      };
    }
  });

  // node_modules/core-js/internals/a-possible-prototype.js
  var require_a_possible_prototype = __commonJS({
    "node_modules/core-js/internals/a-possible-prototype.js"(exports, module) {
      "use strict";
      var isPossiblePrototype = require_is_possible_prototype();
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isPossiblePrototype(argument)) return argument;
        throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
      };
    }
  });

  // node_modules/core-js/internals/object-set-prototype-of.js
  var require_object_set_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-set-prototype-of.js"(exports, module) {
      "use strict";
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var isObject2 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var aPossiblePrototype = require_a_possible_prototype();
      module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var CORRECT_SETTER = false;
        var test2 = {};
        var setter;
        try {
          setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
          setter(test2, []);
          CORRECT_SETTER = test2 instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf(O2, proto) {
          requireObjectCoercible(O2);
          aPossiblePrototype(proto);
          if (!isObject2(O2)) return O2;
          if (CORRECT_SETTER) setter(O2, proto);
          else O2.__proto__ = proto;
          return O2;
        };
      }() : void 0);
    }
  });

  // node_modules/core-js/internals/proxy-accessor.js
  var require_proxy_accessor = __commonJS({
    "node_modules/core-js/internals/proxy-accessor.js"(exports, module) {
      "use strict";
      var defineProperty = require_object_define_property().f;
      module.exports = function(Target, Source, key) {
        key in Target || defineProperty(Target, key, {
          configurable: true,
          get: function() {
            return Source[key];
          },
          set: function(it2) {
            Source[key] = it2;
          }
        });
      };
    }
  });

  // node_modules/core-js/internals/inherit-if-required.js
  var require_inherit_if_required = __commonJS({
    "node_modules/core-js/internals/inherit-if-required.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var setPrototypeOf = require_object_set_prototype_of();
      module.exports = function($this, dummy, Wrapper) {
        var NewTarget, NewTargetPrototype;
        if (
          // it can work only with native `setPrototypeOf`
          setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
          isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject2(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
        ) setPrototypeOf($this, NewTargetPrototype);
        return $this;
      };
    }
  });

  // node_modules/core-js/internals/normalize-string-argument.js
  var require_normalize_string_argument = __commonJS({
    "node_modules/core-js/internals/normalize-string-argument.js"(exports, module) {
      "use strict";
      var toString3 = require_to_string();
      module.exports = function(argument, $default) {
        return argument === void 0 ? arguments.length < 2 ? "" : $default : toString3(argument);
      };
    }
  });

  // node_modules/core-js/internals/install-error-cause.js
  var require_install_error_cause = __commonJS({
    "node_modules/core-js/internals/install-error-cause.js"(exports, module) {
      "use strict";
      var isObject2 = require_is_object();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      module.exports = function(O2, options) {
        if (isObject2(options) && "cause" in options) {
          createNonEnumerableProperty(O2, "cause", options.cause);
        }
      };
    }
  });

  // node_modules/core-js/internals/error-stack-clear.js
  var require_error_stack_clear = __commonJS({
    "node_modules/core-js/internals/error-stack-clear.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var $Error = Error;
      var replace = uncurryThis("".replace);
      var TEST = function(arg) {
        return String(new $Error(arg).stack);
      }("zxcasd");
      var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
      var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
      module.exports = function(stack, dropEntries) {
        if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
          while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
        }
        return stack;
      };
    }
  });

  // node_modules/core-js/internals/error-stack-installable.js
  var require_error_stack_installable = __commonJS({
    "node_modules/core-js/internals/error-stack-installable.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = !fails(function() {
        var error = new Error("a");
        if (!("stack" in error)) return true;
        Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
        return error.stack !== 7;
      });
    }
  });

  // node_modules/core-js/internals/error-stack-install.js
  var require_error_stack_install = __commonJS({
    "node_modules/core-js/internals/error-stack-install.js"(exports, module) {
      "use strict";
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var clearErrorStack = require_error_stack_clear();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var captureStackTrace = Error.captureStackTrace;
      module.exports = function(error, C2, stack, dropEntries) {
        if (ERROR_STACK_INSTALLABLE) {
          if (captureStackTrace) captureStackTrace(error, C2);
          else createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
        }
      };
    }
  });

  // node_modules/core-js/internals/wrap-error-constructor-with-cause.js
  var require_wrap_error_constructor_with_cause = __commonJS({
    "node_modules/core-js/internals/wrap-error-constructor-with-cause.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var hasOwn = require_has_own_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var proxyAccessor = require_proxy_accessor();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var installErrorCause = require_install_error_cause();
      var installErrorStack = require_error_stack_install();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
        var STACK_TRACE_LIMIT = "stackTraceLimit";
        var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
        var path = FULL_NAME.split(".");
        var ERROR_NAME = path[path.length - 1];
        var OriginalError = getBuiltIn.apply(null, path);
        if (!OriginalError) return;
        var OriginalErrorPrototype = OriginalError.prototype;
        if (!IS_PURE && hasOwn(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
        if (!FORCED) return OriginalError;
        var BaseError = getBuiltIn("Error");
        var WrappedError = wrapper(function(a, b) {
          var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
          var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
          if (message !== void 0) createNonEnumerableProperty(result, "message", message);
          installErrorStack(result, WrappedError, result.stack, 2);
          if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
          if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
          return result;
        });
        WrappedError.prototype = OriginalErrorPrototype;
        if (ERROR_NAME !== "Error") {
          if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
          else copyConstructorProperties(WrappedError, BaseError, { name: true });
        } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
          proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
          proxyAccessor(WrappedError, OriginalError, "prepareStackTrace");
        }
        copyConstructorProperties(WrappedError, OriginalError);
        if (!IS_PURE) try {
          if (OriginalErrorPrototype.name !== ERROR_NAME) {
            createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
          }
          OriginalErrorPrototype.constructor = WrappedError;
        } catch (error) {
        }
        return WrappedError;
      };
    }
  });

  // node_modules/core-js/modules/es.error.cause.js
  var require_es_error_cause = __commonJS({
    "node_modules/core-js/modules/es.error.cause.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var WEB_ASSEMBLY = "WebAssembly";
      var WebAssembly = globalThis2[WEB_ASSEMBLY];
      var FORCED = new Error("e", { cause: 7 }).cause !== 7;
      var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        var O2 = {};
        O2[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
        $2({ global: true, constructor: true, arity: 1, forced: FORCED }, O2);
      };
      var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
        if (WebAssembly && WebAssembly[ERROR_NAME]) {
          var O2 = {};
          O2[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
          $2({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O2);
        }
      };
      exportGlobalErrorCauseWrapper("Error", function(init) {
        return function Error2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("EvalError", function(init) {
        return function EvalError(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("RangeError", function(init) {
        return function RangeError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("ReferenceError", function(init) {
        return function ReferenceError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("SyntaxError", function(init) {
        return function SyntaxError(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("TypeError", function(init) {
        return function TypeError2(message) {
          return apply(init, this, arguments);
        };
      });
      exportGlobalErrorCauseWrapper("URIError", function(init) {
        return function URIError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("CompileError", function(init) {
        return function CompileError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("LinkError", function(init) {
        return function LinkError(message) {
          return apply(init, this, arguments);
        };
      });
      exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init) {
        return function RuntimeError(message) {
          return apply(init, this, arguments);
        };
      });
    }
  });

  // node_modules/core-js/internals/error-to-string.js
  var require_error_to_string = __commonJS({
    "node_modules/core-js/internals/error-to-string.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var anObject = require_an_object();
      var normalizeStringArgument = require_normalize_string_argument();
      var nativeErrorToString = Error.prototype.toString;
      var INCORRECT_TO_STRING = fails(function() {
        if (DESCRIPTORS) {
          var object = Object.create(Object.defineProperty({}, "name", { get: function() {
            return this === object;
          } }));
          if (nativeErrorToString.call(object) !== "true") return true;
        }
        return nativeErrorToString.call({ message: 1, name: 2 }) !== "2: 1" || nativeErrorToString.call({}) !== "Error";
      });
      module.exports = INCORRECT_TO_STRING ? function toString3() {
        var O2 = anObject(this);
        var name = normalizeStringArgument(O2.name, "Error");
        var message = normalizeStringArgument(O2.message);
        return !name ? message : !message ? name : name + ": " + message;
      } : nativeErrorToString;
    }
  });

  // node_modules/core-js/modules/es.error.to-string.js
  var require_es_error_to_string = __commonJS({
    "node_modules/core-js/modules/es.error.to-string.js"() {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      var errorToString = require_error_to_string();
      var ErrorPrototype = Error.prototype;
      if (ErrorPrototype.toString !== errorToString) {
        defineBuiltIn(ErrorPrototype, "toString", errorToString);
      }
    }
  });

  // node_modules/core-js/internals/correct-prototype-getter.js
  var require_correct_prototype_getter = __commonJS({
    "node_modules/core-js/internals/correct-prototype-getter.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        function F2() {
        }
        F2.prototype.constructor = null;
        return Object.getPrototypeOf(new F2()) !== F2.prototype;
      });
    }
  });

  // node_modules/core-js/internals/object-get-prototype-of.js
  var require_object_get_prototype_of = __commonJS({
    "node_modules/core-js/internals/object-get-prototype-of.js"(exports, module) {
      "use strict";
      var hasOwn = require_has_own_property();
      var isCallable = require_is_callable();
      var toObject = require_to_object();
      var sharedKey = require_shared_key();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var IE_PROTO = sharedKey("IE_PROTO");
      var $Object = Object;
      var ObjectPrototype = $Object.prototype;
      module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
        var object = toObject(O2);
        if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
        var constructor = object.constructor;
        if (isCallable(constructor) && object instanceof constructor) {
          return constructor.prototype;
        }
        return object instanceof $Object ? ObjectPrototype : null;
      };
    }
  });

  // node_modules/core-js/internals/iterators.js
  var require_iterators = __commonJS({
    "node_modules/core-js/internals/iterators.js"(exports, module) {
      "use strict";
      module.exports = {};
    }
  });

  // node_modules/core-js/internals/is-array-iterator-method.js
  var require_is_array_iterator_method = __commonJS({
    "node_modules/core-js/internals/is-array-iterator-method.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module.exports = function(it2) {
        return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
      };
    }
  });

  // node_modules/core-js/internals/get-iterator-method.js
  var require_get_iterator_method = __commonJS({
    "node_modules/core-js/internals/get-iterator-method.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var getMethod = require_get_method();
      var isNullOrUndefined = require_is_null_or_undefined();
      var Iterators = require_iterators();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = function(it2) {
        if (!isNullOrUndefined(it2)) return getMethod(it2, ITERATOR) || getMethod(it2, "@@iterator") || Iterators[classof(it2)];
      };
    }
  });

  // node_modules/core-js/internals/get-iterator.js
  var require_get_iterator = __commonJS({
    "node_modules/core-js/internals/get-iterator.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var getIteratorMethod = require_get_iterator_method();
      var $TypeError = TypeError;
      module.exports = function(argument, usingIterator) {
        var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
        if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
        throw new $TypeError(tryToString(argument) + " is not iterable");
      };
    }
  });

  // node_modules/core-js/internals/iterator-close.js
  var require_iterator_close = __commonJS({
    "node_modules/core-js/internals/iterator-close.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var getMethod = require_get_method();
      module.exports = function(iterator2, kind, value) {
        var innerResult, innerError;
        anObject(iterator2);
        try {
          innerResult = getMethod(iterator2, "return");
          if (!innerResult) {
            if (kind === "throw") throw value;
            return value;
          }
          innerResult = call(innerResult, iterator2);
        } catch (error) {
          innerError = true;
          innerResult = error;
        }
        if (kind === "throw") throw value;
        if (innerError) throw innerResult;
        anObject(innerResult);
        return value;
      };
    }
  });

  // node_modules/core-js/internals/iterate.js
  var require_iterate = __commonJS({
    "node_modules/core-js/internals/iterate.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var anObject = require_an_object();
      var tryToString = require_try_to_string();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var lengthOfArrayLike = require_length_of_array_like();
      var isPrototypeOf = require_object_is_prototype_of();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var iteratorClose = require_iterator_close();
      var $TypeError = TypeError;
      var Result = function(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var ResultPrototype = Result.prototype;
      module.exports = function(iterable, unboundFunction, options) {
        var that = options && options.that;
        var AS_ENTRIES = !!(options && options.AS_ENTRIES);
        var IS_RECORD = !!(options && options.IS_RECORD);
        var IS_ITERATOR = !!(options && options.IS_ITERATOR);
        var INTERRUPTED = !!(options && options.INTERRUPTED);
        var fn2 = bind2(unboundFunction, that);
        var iterator2, iterFn, index, length, result, next, step;
        var stop = function(condition) {
          if (iterator2) iteratorClose(iterator2, "normal", condition);
          return new Result(true, condition);
        };
        var callFn = function(value) {
          if (AS_ENTRIES) {
            anObject(value);
            return INTERRUPTED ? fn2(value[0], value[1], stop) : fn2(value[0], value[1]);
          }
          return INTERRUPTED ? fn2(value, stop) : fn2(value);
        };
        if (IS_RECORD) {
          iterator2 = iterable.iterator;
        } else if (IS_ITERATOR) {
          iterator2 = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
              result = callFn(iterable[index]);
              if (result && isPrototypeOf(ResultPrototype, result)) return result;
            }
            return new Result(false);
          }
          iterator2 = getIterator(iterable, iterFn);
        }
        next = IS_RECORD ? iterable.next : iterator2.next;
        while (!(step = call(next, iterator2)).done) {
          try {
            result = callFn(step.value);
          } catch (error) {
            iteratorClose(iterator2, "throw", error);
          }
          if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
        }
        return new Result(false);
      };
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.constructor.js
  var require_es_aggregate_error_constructor = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var copyConstructorProperties = require_copy_constructor_properties();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      var installErrorCause = require_install_error_cause();
      var installErrorStack = require_error_stack_install();
      var iterate = require_iterate();
      var normalizeStringArgument = require_normalize_string_argument();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Error = Error;
      var push = [].push;
      var $AggregateError = function AggregateError(errors, message) {
        var isInstance = isPrototypeOf(AggregateErrorPrototype, this);
        var that;
        if (setPrototypeOf) {
          that = setPrototypeOf(new $Error(), isInstance ? getPrototypeOf2(this) : AggregateErrorPrototype);
        } else {
          that = isInstance ? this : create(AggregateErrorPrototype);
          createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
        }
        if (message !== void 0) createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
        installErrorStack(that, $AggregateError, that.stack, 1);
        if (arguments.length > 2) installErrorCause(that, arguments[2]);
        var errorsArray = [];
        iterate(errors, push, { that: errorsArray });
        createNonEnumerableProperty(that, "errors", errorsArray);
        return that;
      };
      if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
      else copyConstructorProperties($AggregateError, $Error, { name: true });
      var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
        constructor: createPropertyDescriptor(1, $AggregateError),
        message: createPropertyDescriptor(1, ""),
        name: createPropertyDescriptor(1, "AggregateError")
      });
      $2({ global: true, constructor: true, arity: 2 }, {
        AggregateError: $AggregateError
      });
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.js
  var require_es_aggregate_error = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.js"() {
      "use strict";
      require_es_aggregate_error_constructor();
    }
  });

  // node_modules/core-js/modules/es.aggregate-error.cause.js
  var require_es_aggregate_error_cause = __commonJS({
    "node_modules/core-js/modules/es.aggregate-error.cause.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var fails = require_fails();
      var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
      var AGGREGATE_ERROR = "AggregateError";
      var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
      var FORCED = !fails(function() {
        return $AggregateError([1]).errors[0] !== 1;
      }) && fails(function() {
        return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
      });
      $2({ global: true, constructor: true, arity: 2, forced: FORCED }, {
        AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init) {
          return function AggregateError(errors, message) {
            return apply(init, this, arguments);
          };
        }, FORCED, true)
      });
    }
  });

  // node_modules/core-js/internals/add-to-unscopables.js
  var require_add_to_unscopables = __commonJS({
    "node_modules/core-js/internals/add-to-unscopables.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var create = require_object_create();
      var defineProperty = require_object_define_property().f;
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] === void 0) {
        defineProperty(ArrayPrototype, UNSCOPABLES, {
          configurable: true,
          value: create(null)
        });
      }
      module.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    }
  });

  // node_modules/core-js/modules/es.array.at.js
  var require_es_array_at = __commonJS({
    "node_modules/core-js/modules/es.array.at.js"() {
      "use strict";
      var $2 = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        at: function at2(index) {
          var O2 = toObject(this);
          var len = lengthOfArrayLike(O2);
          var relativeIndex = toIntegerOrInfinity(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : O2[k];
        }
      });
      addToUnscopables("at");
    }
  });

  // node_modules/core-js/internals/does-not-exceed-safe-integer.js
  var require_does_not_exceed_safe_integer = __commonJS({
    "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      var MAX_SAFE_INTEGER = 9007199254740991;
      module.exports = function(it2) {
        if (it2 > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
        return it2;
      };
    }
  });

  // node_modules/core-js/internals/create-property.js
  var require_create_property = __commonJS({
    "node_modules/core-js/internals/create-property.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var definePropertyModule = require_object_define_property();
      var createPropertyDescriptor = require_create_property_descriptor();
      module.exports = function(object, key, value) {
        if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
        else object[key] = value;
      };
    }
  });

  // node_modules/core-js/internals/array-method-has-species-support.js
  var require_array_method_has_species_support = __commonJS({
    "node_modules/core-js/internals/array-method-has-species-support.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_environment_v8_version();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(METHOD_NAME) {
        return V8_VERSION >= 51 || !fails(function() {
          var array = [];
          var constructor = array.constructor = {};
          constructor[SPECIES] = function() {
            return { foo: 1 };
          };
          return array[METHOD_NAME](Boolean).foo !== 1;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.concat.js
  var require_es_array_concat = __commonJS({
    "node_modules/core-js/modules/es.array.concat.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var isArray2 = require_is_array();
      var isObject2 = require_is_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var createProperty = require_create_property();
      var arraySpeciesCreate = require_array_species_create();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var wellKnownSymbol = require_well_known_symbol();
      var V8_VERSION = require_environment_v8_version();
      var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
      var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
        var array = [];
        array[IS_CONCAT_SPREADABLE] = false;
        return array.concat()[0] !== array;
      });
      var isConcatSpreadable = function(O2) {
        if (!isObject2(O2)) return false;
        var spreadable = O2[IS_CONCAT_SPREADABLE];
        return spreadable !== void 0 ? !!spreadable : isArray2(O2);
      };
      var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport("concat");
      $2({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        concat: function concat(arg) {
          var O2 = toObject(this);
          var A2 = arraySpeciesCreate(O2, 0);
          var n = 0;
          var i, k, length, len, E2;
          for (i = -1, length = arguments.length; i < length; i++) {
            E2 = i === -1 ? O2 : arguments[i];
            if (isConcatSpreadable(E2)) {
              len = lengthOfArrayLike(E2);
              doesNotExceedSafeInteger(n + len);
              for (k = 0; k < len; k++, n++) if (k in E2) createProperty(A2, n, E2[k]);
            } else {
              doesNotExceedSafeInteger(n + 1);
              createProperty(A2, n++, E2);
            }
          }
          A2.length = n;
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/internals/delete-property-or-throw.js
  var require_delete_property_or_throw = __commonJS({
    "node_modules/core-js/internals/delete-property-or-throw.js"(exports, module) {
      "use strict";
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(O2, P) {
        if (!delete O2[P]) throw new $TypeError("Cannot delete property " + tryToString(P) + " of " + tryToString(O2));
      };
    }
  });

  // node_modules/core-js/internals/array-copy-within.js
  var require_array_copy_within = __commonJS({
    "node_modules/core-js/internals/array-copy-within.js"(exports, module) {
      "use strict";
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var min = Math.min;
      module.exports = [].copyWithin || function copyWithin(target, start) {
        var O2 = toObject(this);
        var len = lengthOfArrayLike(O2);
        var to2 = toAbsoluteIndex(target, len);
        var from = toAbsoluteIndex(start, len);
        var end = arguments.length > 2 ? arguments[2] : void 0;
        var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to2);
        var inc = 1;
        if (from < to2 && to2 < from + count) {
          inc = -1;
          from += count - 1;
          to2 += count - 1;
        }
        while (count-- > 0) {
          if (from in O2) O2[to2] = O2[from];
          else deletePropertyOrThrow(O2, to2);
          to2 += inc;
          from += inc;
        }
        return O2;
      };
    }
  });

  // node_modules/core-js/modules/es.array.copy-within.js
  var require_es_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.array.copy-within.js"() {
      "use strict";
      var $2 = require_export();
      var copyWithin = require_array_copy_within();
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        copyWithin
      });
      addToUnscopables("copyWithin");
    }
  });

  // node_modules/core-js/internals/array-method-is-strict.js
  var require_array_method_is_strict = __commonJS({
    "node_modules/core-js/internals/array-method-is-strict.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = function(METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !!method && fails(function() {
          method.call(null, argument || function() {
            return 1;
          }, 1);
        });
      };
    }
  });

  // node_modules/core-js/modules/es.array.every.js
  var require_es_array_every = __commonJS({
    "node_modules/core-js/modules/es.array.every.js"() {
      "use strict";
      var $2 = require_export();
      var $every = require_array_iteration().every;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("every");
      $2({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        every: function every(callbackfn) {
          return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-fill.js
  var require_array_fill = __commonJS({
    "node_modules/core-js/internals/array-fill.js"(exports, module) {
      "use strict";
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function fill(value) {
        var O2 = toObject(this);
        var length = lengthOfArrayLike(O2);
        var argumentsLength = arguments.length;
        var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
        var end = argumentsLength > 2 ? arguments[2] : void 0;
        var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
        while (endPos > index) O2[index++] = value;
        return O2;
      };
    }
  });

  // node_modules/core-js/modules/es.array.fill.js
  var require_es_array_fill = __commonJS({
    "node_modules/core-js/modules/es.array.fill.js"() {
      "use strict";
      var $2 = require_export();
      var fill = require_array_fill();
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        fill
      });
      addToUnscopables("fill");
    }
  });

  // node_modules/core-js/modules/es.array.filter.js
  var require_es_array_filter = __commonJS({
    "node_modules/core-js/modules/es.array.filter.js"() {
      "use strict";
      var $2 = require_export();
      var $filter = require_array_iteration().filter;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        filter: function filter2(callbackfn) {
          return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.find.js
  var require_es_array_find = __commonJS({
    "node_modules/core-js/modules/es.array.find.js"() {
      "use strict";
      var $2 = require_export();
      var $find = require_array_iteration().find;
      var addToUnscopables = require_add_to_unscopables();
      var FIND = "find";
      var SKIPS_HOLES = true;
      if (FIND in []) Array(1)[FIND](function() {
        SKIPS_HOLES = false;
      });
      $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        find: function find(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND);
    }
  });

  // node_modules/core-js/modules/es.array.find-index.js
  var require_es_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-index.js"() {
      "use strict";
      var $2 = require_export();
      var $findIndex = require_array_iteration().findIndex;
      var addToUnscopables = require_add_to_unscopables();
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
        SKIPS_HOLES = false;
      });
      $2({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
        findIndex: function findIndex(callbackfn) {
          return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND_INDEX);
    }
  });

  // node_modules/core-js/internals/array-iteration-from-last.js
  var require_array_iteration_from_last = __commonJS({
    "node_modules/core-js/internals/array-iteration-from-last.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var IndexedObject = require_indexed_object();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var createMethod = function(TYPE) {
        var IS_FIND_LAST_INDEX = TYPE === 1;
        return function($this, callbackfn, that) {
          var O2 = toObject($this);
          var self2 = IndexedObject(O2);
          var index = lengthOfArrayLike(self2);
          var boundFunction = bind2(callbackfn, that);
          var value, result;
          while (index-- > 0) {
            value = self2[index];
            result = boundFunction(value, index, O2);
            if (result) switch (TYPE) {
              case 0:
                return value;
              // findLast
              case 1:
                return index;
            }
          }
          return IS_FIND_LAST_INDEX ? -1 : void 0;
        };
      };
      module.exports = {
        // `Array.prototype.findLast` method
        // https://github.com/tc39/proposal-array-find-from-last
        findLast: createMethod(0),
        // `Array.prototype.findLastIndex` method
        // https://github.com/tc39/proposal-array-find-from-last
        findLastIndex: createMethod(1)
      };
    }
  });

  // node_modules/core-js/modules/es.array.find-last.js
  var require_es_array_find_last = __commonJS({
    "node_modules/core-js/modules/es.array.find-last.js"() {
      "use strict";
      var $2 = require_export();
      var $findLast = require_array_iteration_from_last().findLast;
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        findLast: function findLast(callbackfn) {
          return $findLast(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("findLast");
    }
  });

  // node_modules/core-js/modules/es.array.find-last-index.js
  var require_es_array_find_last_index = __commonJS({
    "node_modules/core-js/modules/es.array.find-last-index.js"() {
      "use strict";
      var $2 = require_export();
      var $findLastIndex = require_array_iteration_from_last().findLastIndex;
      var addToUnscopables = require_add_to_unscopables();
      $2({ target: "Array", proto: true }, {
        findLastIndex: function findLastIndex(callbackfn) {
          return $findLastIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("findLastIndex");
    }
  });

  // node_modules/core-js/internals/flatten-into-array.js
  var require_flatten_into_array = __commonJS({
    "node_modules/core-js/internals/flatten-into-array.js"(exports, module) {
      "use strict";
      var isArray2 = require_is_array();
      var lengthOfArrayLike = require_length_of_array_like();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var bind2 = require_function_bind_context();
      var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
        var targetIndex = start;
        var sourceIndex = 0;
        var mapFn = mapper ? bind2(mapper, thisArg) : false;
        var element, elementLen;
        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            if (depth > 0 && isArray2(element)) {
              elementLen = lengthOfArrayLike(element);
              targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
            } else {
              doesNotExceedSafeInteger(targetIndex + 1);
              target[targetIndex] = element;
            }
            targetIndex++;
          }
          sourceIndex++;
        }
        return targetIndex;
      };
      module.exports = flattenIntoArray;
    }
  });

  // node_modules/core-js/modules/es.array.flat.js
  var require_es_array_flat = __commonJS({
    "node_modules/core-js/modules/es.array.flat.js"() {
      "use strict";
      var $2 = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var arraySpeciesCreate = require_array_species_create();
      $2({ target: "Array", proto: true }, {
        flat: function flat() {
          var depthArg = arguments.length ? arguments[0] : void 0;
          var O2 = toObject(this);
          var sourceLen = lengthOfArrayLike(O2);
          var A2 = arraySpeciesCreate(O2, 0);
          A2.length = flattenIntoArray(A2, O2, O2, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.flat-map.js
  var require_es_array_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.flat-map.js"() {
      "use strict";
      var $2 = require_export();
      var flattenIntoArray = require_flatten_into_array();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var arraySpeciesCreate = require_array_species_create();
      $2({ target: "Array", proto: true }, {
        flatMap: function flatMap(callbackfn) {
          var O2 = toObject(this);
          var sourceLen = lengthOfArrayLike(O2);
          var A2;
          aCallable(callbackfn);
          A2 = arraySpeciesCreate(O2, 0);
          A2.length = flattenIntoArray(A2, O2, O2, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-for-each.js
  var require_array_for_each = __commonJS({
    "node_modules/core-js/internals/array-for-each.js"(exports, module) {
      "use strict";
      var $forEach = require_array_iteration().forEach;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("forEach");
      module.exports = !STRICT_METHOD ? function forEach2(callbackfn) {
        return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } : [].forEach;
    }
  });

  // node_modules/core-js/modules/es.array.for-each.js
  var require_es_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.array.for-each.js"() {
      "use strict";
      var $2 = require_export();
      var forEach2 = require_array_for_each();
      $2({ target: "Array", proto: true, forced: [].forEach !== forEach2 }, {
        forEach: forEach2
      });
    }
  });

  // node_modules/core-js/internals/call-with-safe-iteration-closing.js
  var require_call_with_safe_iteration_closing = __commonJS({
    "node_modules/core-js/internals/call-with-safe-iteration-closing.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var iteratorClose = require_iterator_close();
      module.exports = function(iterator2, fn2, value, ENTRIES) {
        try {
          return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
        } catch (error) {
          iteratorClose(iterator2, "throw", error);
        }
      };
    }
  });

  // node_modules/core-js/internals/array-from.js
  var require_array_from = __commonJS({
    "node_modules/core-js/internals/array-from.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var toObject = require_to_object();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isConstructor = require_is_constructor();
      var lengthOfArrayLike = require_length_of_array_like();
      var createProperty = require_create_property();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var $Array = Array;
      module.exports = function from(arrayLike) {
        var O2 = toObject(arrayLike);
        var IS_CONSTRUCTOR = isConstructor(this);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        if (mapping) mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0);
        var iteratorMethod = getIteratorMethod(O2);
        var index = 0;
        var length, result, step, iterator2, next, value;
        if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
          result = IS_CONSTRUCTOR ? new this() : [];
          iterator2 = getIterator(O2, iteratorMethod);
          next = iterator2.next;
          for (; !(step = call(next, iterator2)).done; index++) {
            value = mapping ? callWithSafeIterationClosing(iterator2, mapfn, [step.value, index], true) : step.value;
            createProperty(result, index, value);
          }
        } else {
          length = lengthOfArrayLike(O2);
          result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
          for (; length > index; index++) {
            value = mapping ? mapfn(O2[index], index) : O2[index];
            createProperty(result, index, value);
          }
        }
        result.length = index;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/check-correctness-of-iteration.js
  var require_check_correctness_of_iteration = __commonJS({
    "node_modules/core-js/internals/check-correctness-of-iteration.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        called = 0;
        iteratorWithReturn = {
          next: function() {
            return { done: !!called++ };
          },
          "return": function() {
            SAFE_CLOSING = true;
          }
        };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      var called;
      var iteratorWithReturn;
      module.exports = function(exec, SKIP_CLOSING) {
        try {
          if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
        } catch (error) {
          return false;
        }
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return {
              next: function() {
                return { done: ITERATION_SUPPORT = true };
              }
            };
          };
          exec(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
    }
  });

  // node_modules/core-js/modules/es.array.from.js
  var require_es_array_from = __commonJS({
    "node_modules/core-js/modules/es.array.from.js"() {
      "use strict";
      var $2 = require_export();
      var from = require_array_from();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
        Array.from(iterable);
      });
      $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
        from
      });
    }
  });

  // node_modules/core-js/modules/es.array.includes.js
  var require_es_array_includes = __commonJS({
    "node_modules/core-js/modules/es.array.includes.js"() {
      "use strict";
      var $2 = require_export();
      var $includes = require_array_includes().includes;
      var fails = require_fails();
      var addToUnscopables = require_add_to_unscopables();
      var BROKEN_ON_SPARSE = fails(function() {
        return !Array(1).includes();
      });
      $2({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
        includes: function includes(el) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("includes");
    }
  });

  // node_modules/core-js/modules/es.array.index-of.js
  var require_es_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.index-of.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var $indexOf = require_array_includes().indexOf;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var nativeIndexOf = uncurryThis([].indexOf);
      var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
      var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict("indexOf");
      $2({ target: "Array", proto: true, forced: FORCED }, {
        indexOf: function indexOf(searchElement) {
          var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
          return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.is-array.js
  var require_es_array_is_array = __commonJS({
    "node_modules/core-js/modules/es.array.is-array.js"() {
      "use strict";
      var $2 = require_export();
      var isArray2 = require_is_array();
      $2({ target: "Array", stat: true }, {
        isArray: isArray2
      });
    }
  });

  // node_modules/core-js/internals/iterators-core.js
  var require_iterators_core = __commonJS({
    "node_modules/core-js/internals/iterators-core.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var create = require_object_create();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var IteratorPrototype;
      var PrototypeOfArrayIteratorPrototype;
      var arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf2(getPrototypeOf2(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails(function() {
        var test2 = {};
        return IteratorPrototype[ITERATOR].call(test2) !== test2;
      });
      if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
      else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);
      if (!isCallable(IteratorPrototype[ITERATOR])) {
        defineBuiltIn(IteratorPrototype, ITERATOR, function() {
          return this;
        });
      }
      module.exports = {
        IteratorPrototype,
        BUGGY_SAFARI_ITERATORS
      };
    }
  });

  // node_modules/core-js/internals/iterator-create-constructor.js
  var require_iterator_create_constructor = __commonJS({
    "node_modules/core-js/internals/iterator-create-constructor.js"(exports, module) {
      "use strict";
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var setToStringTag = require_set_to_string_tag();
      var Iterators = require_iterators();
      var returnThis = function() {
        return this;
      };
      module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    }
  });

  // node_modules/core-js/internals/iterator-define.js
  var require_iterator_define = __commonJS({
    "node_modules/core-js/internals/iterator-define.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var IS_PURE = require_is_pure();
      var FunctionName = require_function_name();
      var isCallable = require_is_callable();
      var createIteratorConstructor = require_iterator_create_constructor();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var wellKnownSymbol = require_well_known_symbol();
      var Iterators = require_iterators();
      var IteratorsCore = require_iterators_core();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function() {
        return this;
      };
      module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function(KIND) {
          if (KIND === DEFAULT && defaultIterator) return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
          if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
            createNonEnumerableProperty(IterablePrototype, "name", VALUES);
          } else {
            INCORRECT_VALUES_NAME = true;
            defaultIterator = function values() {
              return call(nativeIterator, this);
            };
          }
        }
        if (DEFAULT) {
          methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
          };
          if (FORCED) for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
            }
          }
          else $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
        }
        Iterators[NAME] = defaultIterator;
        return methods;
      };
    }
  });

  // node_modules/core-js/internals/create-iter-result-object.js
  var require_create_iter_result_object = __commonJS({
    "node_modules/core-js/internals/create-iter-result-object.js"(exports, module) {
      "use strict";
      module.exports = function(value, done) {
        return { value, done };
      };
    }
  });

  // node_modules/core-js/modules/es.array.iterator.js
  var require_es_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.array.iterator.js"(exports, module) {
      "use strict";
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var Iterators = require_iterators();
      var InternalStateModule = require_internal_state();
      var defineProperty = require_object_define_property().f;
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module.exports = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          // target
          index: 0,
          // next index
          kind
          // kind
        });
      }, function() {
        var state = getInternalState(this);
        var target = state.target;
        var index = state.index++;
        if (!target || index >= target.length) {
          state.target = null;
          return createIterResultObject(void 0, true);
        }
        switch (state.kind) {
          case "keys":
            return createIterResultObject(index, false);
          case "values":
            return createIterResultObject(target[index], false);
        }
        return createIterResultObject([index, target[index]], false);
      }, "values");
      var values = Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
      if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
        defineProperty(values, "name", { value: "values" });
      } catch (error) {
      }
    }
  });

  // node_modules/core-js/modules/es.array.join.js
  var require_es_array_join = __commonJS({
    "node_modules/core-js/modules/es.array.join.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var IndexedObject = require_indexed_object();
      var toIndexedObject = require_to_indexed_object();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var nativeJoin = uncurryThis([].join);
      var ES3_STRINGS = IndexedObject !== Object;
      var FORCED = ES3_STRINGS || !arrayMethodIsStrict("join", ",");
      $2({ target: "Array", proto: true, forced: FORCED }, {
        join: function join(separator) {
          return nativeJoin(toIndexedObject(this), separator === void 0 ? "," : separator);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-last-index-of.js
  var require_array_last_index_of = __commonJS({
    "node_modules/core-js/internals/array-last-index-of.js"(exports, module) {
      "use strict";
      var apply = require_function_apply();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var min = Math.min;
      var $lastIndexOf = [].lastIndexOf;
      var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
      var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
      var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
      module.exports = FORCED ? function lastIndexOf(searchElement) {
        if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
        var O2 = toIndexedObject(this);
        var length = lengthOfArrayLike(O2);
        if (length === 0) return -1;
        var index = length - 1;
        if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
        if (index < 0) index = length + index;
        for (; index >= 0; index--) if (index in O2 && O2[index] === searchElement) return index || 0;
        return -1;
      } : $lastIndexOf;
    }
  });

  // node_modules/core-js/modules/es.array.last-index-of.js
  var require_es_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.array.last-index-of.js"() {
      "use strict";
      var $2 = require_export();
      var lastIndexOf = require_array_last_index_of();
      $2({ target: "Array", proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
        lastIndexOf
      });
    }
  });

  // node_modules/core-js/modules/es.array.map.js
  var require_es_array_map = __commonJS({
    "node_modules/core-js/modules/es.array.map.js"() {
      "use strict";
      var $2 = require_export();
      var $map = require_array_iteration().map;
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        map: function map(callbackfn) {
          return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.of.js
  var require_es_array_of = __commonJS({
    "node_modules/core-js/modules/es.array.of.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var isConstructor = require_is_constructor();
      var createProperty = require_create_property();
      var $Array = Array;
      var ISNT_GENERIC = fails(function() {
        function F2() {
        }
        return !($Array.of.call(F2) instanceof F2);
      });
      $2({ target: "Array", stat: true, forced: ISNT_GENERIC }, {
        of: function of() {
          var index = 0;
          var argumentsLength = arguments.length;
          var result = new (isConstructor(this) ? this : $Array)(argumentsLength);
          while (argumentsLength > index) createProperty(result, index, arguments[index++]);
          result.length = argumentsLength;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-set-length.js
  var require_array_set_length = __commonJS({
    "node_modules/core-js/internals/array-set-length.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var isArray2 = require_is_array();
      var $TypeError = TypeError;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function() {
        if (this !== void 0) return true;
        try {
          Object.defineProperty([], "length", { writable: false }).length = 1;
        } catch (error) {
          return error instanceof TypeError;
        }
      }();
      module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O2, length) {
        if (isArray2(O2) && !getOwnPropertyDescriptor(O2, "length").writable) {
          throw new $TypeError("Cannot set read only .length");
        }
        return O2.length = length;
      } : function(O2, length) {
        return O2.length = length;
      };
    }
  });

  // node_modules/core-js/modules/es.array.push.js
  var require_es_array_push = __commonJS({
    "node_modules/core-js/modules/es.array.push.js"() {
      "use strict";
      var $2 = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var fails = require_fails();
      var INCORRECT_TO_LENGTH = fails(function() {
        return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
      });
      var properErrorOnNonWritableLength = function() {
        try {
          Object.defineProperty([], "length", { writable: false }).push();
        } catch (error) {
          return error instanceof TypeError;
        }
      };
      var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
      $2({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        push: function push(item) {
          var O2 = toObject(this);
          var len = lengthOfArrayLike(O2);
          var argCount = arguments.length;
          doesNotExceedSafeInteger(len + argCount);
          for (var i = 0; i < argCount; i++) {
            O2[len] = arguments[i];
            len++;
          }
          setArrayLength(O2, len);
          return len;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-reduce.js
  var require_array_reduce = __commonJS({
    "node_modules/core-js/internals/array-reduce.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var $TypeError = TypeError;
      var REDUCE_EMPTY = "Reduce of empty array with no initial value";
      var createMethod = function(IS_RIGHT) {
        return function(that, callbackfn, argumentsLength, memo) {
          var O2 = toObject(that);
          var self2 = IndexedObject(O2);
          var length = lengthOfArrayLike(O2);
          aCallable(callbackfn);
          if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
          var index = IS_RIGHT ? length - 1 : 0;
          var i = IS_RIGHT ? -1 : 1;
          if (argumentsLength < 2) while (true) {
            if (index in self2) {
              memo = self2[index];
              index += i;
              break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) {
              throw new $TypeError(REDUCE_EMPTY);
            }
          }
          for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self2) {
            memo = callbackfn(memo, self2[index], index, O2);
          }
          return memo;
        };
      };
      module.exports = {
        // `Array.prototype.reduce` method
        // https://tc39.es/ecma262/#sec-array.prototype.reduce
        left: createMethod(false),
        // `Array.prototype.reduceRight` method
        // https://tc39.es/ecma262/#sec-array.prototype.reduceright
        right: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/environment.js
  var require_environment = __commonJS({
    "node_modules/core-js/internals/environment.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var userAgent = require_environment_user_agent();
      var classof = require_classof_raw();
      var userAgentStartsWith = function(string) {
        return userAgent.slice(0, string.length) === string;
      };
      module.exports = function() {
        if (userAgentStartsWith("Bun/")) return "BUN";
        if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
        if (userAgentStartsWith("Deno/")) return "DENO";
        if (userAgentStartsWith("Node.js/")) return "NODE";
        if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
        if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
        if (classof(globalThis2.process) === "process") return "NODE";
        if (globalThis2.window && globalThis2.document) return "BROWSER";
        return "REST";
      }();
    }
  });

  // node_modules/core-js/internals/environment-is-node.js
  var require_environment_is_node = __commonJS({
    "node_modules/core-js/internals/environment-is-node.js"(exports, module) {
      "use strict";
      var ENVIRONMENT = require_environment();
      module.exports = ENVIRONMENT === "NODE";
    }
  });

  // node_modules/core-js/modules/es.array.reduce.js
  var require_es_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.array.reduce.js"() {
      "use strict";
      var $2 = require_export();
      var $reduce = require_array_reduce().left;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_environment_v8_version();
      var IS_NODE = require_environment_is_node();
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
      $2({ target: "Array", proto: true, forced: FORCED }, {
        reduce: function reduce(callbackfn) {
          var length = arguments.length;
          return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reduce-right.js
  var require_es_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.array.reduce-right.js"() {
      "use strict";
      var $2 = require_export();
      var $reduceRight = require_array_reduce().right;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var CHROME_VERSION = require_environment_v8_version();
      var IS_NODE = require_environment_is_node();
      var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
      var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduceRight");
      $2({ target: "Array", proto: true, forced: FORCED }, {
        reduceRight: function reduceRight(callbackfn) {
          return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.reverse.js
  var require_es_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.array.reverse.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var isArray2 = require_is_array();
      var nativeReverse = uncurryThis([].reverse);
      var test2 = [1, 2];
      $2({ target: "Array", proto: true, forced: String(test2) === String(test2.reverse()) }, {
        reverse: function reverse() {
          if (isArray2(this)) this.length = this.length;
          return nativeReverse(this);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.slice.js
  var require_es_array_slice = __commonJS({
    "node_modules/core-js/modules/es.array.slice.js"() {
      "use strict";
      var $2 = require_export();
      var isArray2 = require_is_array();
      var isConstructor = require_is_constructor();
      var isObject2 = require_is_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIndexedObject = require_to_indexed_object();
      var createProperty = require_create_property();
      var wellKnownSymbol = require_well_known_symbol();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var nativeSlice = require_array_slice();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
      var SPECIES = wellKnownSymbol("species");
      var $Array = Array;
      var max = Math.max;
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        slice: function slice(start, end) {
          var O2 = toIndexedObject(this);
          var length = lengthOfArrayLike(O2);
          var k = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var Constructor, result, n;
          if (isArray2(O2)) {
            Constructor = O2.constructor;
            if (isConstructor(Constructor) && (Constructor === $Array || isArray2(Constructor.prototype))) {
              Constructor = void 0;
            } else if (isObject2(Constructor)) {
              Constructor = Constructor[SPECIES];
              if (Constructor === null) Constructor = void 0;
            }
            if (Constructor === $Array || Constructor === void 0) {
              return nativeSlice(O2, k, fin);
            }
          }
          result = new (Constructor === void 0 ? $Array : Constructor)(max(fin - k, 0));
          for (n = 0; k < fin; k++, n++) if (k in O2) createProperty(result, n, O2[k]);
          result.length = n;
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array.some.js
  var require_es_array_some = __commonJS({
    "node_modules/core-js/modules/es.array.some.js"() {
      "use strict";
      var $2 = require_export();
      var $some = require_array_iteration().some;
      var arrayMethodIsStrict = require_array_method_is_strict();
      var STRICT_METHOD = arrayMethodIsStrict("some");
      $2({ target: "Array", proto: true, forced: !STRICT_METHOD }, {
        some: function some(callbackfn) {
          return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-sort.js
  var require_array_sort = __commonJS({
    "node_modules/core-js/internals/array-sort.js"(exports, module) {
      "use strict";
      var arraySlice = require_array_slice();
      var floor = Math.floor;
      var sort = function(array, comparefn) {
        var length = array.length;
        if (length < 8) {
          var i = 1;
          var element, j;
          while (i < length) {
            j = i;
            element = array[i];
            while (j && comparefn(array[j - 1], element) > 0) {
              array[j] = array[--j];
            }
            if (j !== i++) array[j] = element;
          }
        } else {
          var middle = floor(length / 2);
          var left = sort(arraySlice(array, 0, middle), comparefn);
          var right = sort(arraySlice(array, middle), comparefn);
          var llength = left.length;
          var rlength = right.length;
          var lindex = 0;
          var rindex = 0;
          while (lindex < llength || rindex < rlength) {
            array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
          }
        }
        return array;
      };
      module.exports = sort;
    }
  });

  // node_modules/core-js/internals/environment-ff-version.js
  var require_environment_ff_version = __commonJS({
    "node_modules/core-js/internals/environment-ff-version.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      var firefox = userAgent.match(/firefox\/(\d+)/i);
      module.exports = !!firefox && +firefox[1];
    }
  });

  // node_modules/core-js/internals/environment-is-ie-or-edge.js
  var require_environment_is_ie_or_edge = __commonJS({
    "node_modules/core-js/internals/environment-is-ie-or-edge.js"(exports, module) {
      "use strict";
      var UA = require_environment_user_agent();
      module.exports = /MSIE|Trident/.test(UA);
    }
  });

  // node_modules/core-js/internals/environment-webkit-version.js
  var require_environment_webkit_version = __commonJS({
    "node_modules/core-js/internals/environment-webkit-version.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
      module.exports = !!webkit && +webkit[1];
    }
  });

  // node_modules/core-js/modules/es.array.sort.js
  var require_es_array_sort = __commonJS({
    "node_modules/core-js/modules/es.array.sort.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var toString3 = require_to_string();
      var fails = require_fails();
      var internalSort = require_array_sort();
      var arrayMethodIsStrict = require_array_method_is_strict();
      var FF = require_environment_ff_version();
      var IE_OR_EDGE = require_environment_is_ie_or_edge();
      var V8 = require_environment_v8_version();
      var WEBKIT = require_environment_webkit_version();
      var test2 = [];
      var nativeSort = uncurryThis(test2.sort);
      var push = uncurryThis(test2.push);
      var FAILS_ON_UNDEFINED = fails(function() {
        test2.sort(void 0);
      });
      var FAILS_ON_NULL = fails(function() {
        test2.sort(null);
      });
      var STRICT_METHOD = arrayMethodIsStrict("sort");
      var STABLE_SORT = !fails(function() {
        if (V8) return V8 < 70;
        if (FF && FF > 3) return;
        if (IE_OR_EDGE) return true;
        if (WEBKIT) return WEBKIT < 603;
        var result = "";
        var code, chr, value, index;
        for (code = 65; code < 76; code++) {
          chr = String.fromCharCode(code);
          switch (code) {
            case 66:
            case 69:
            case 70:
            case 72:
              value = 3;
              break;
            case 68:
            case 71:
              value = 4;
              break;
            default:
              value = 2;
          }
          for (index = 0; index < 47; index++) {
            test2.push({ k: chr + index, v: value });
          }
        }
        test2.sort(function(a, b) {
          return b.v - a.v;
        });
        for (index = 0; index < test2.length; index++) {
          chr = test2[index].k.charAt(0);
          if (result.charAt(result.length - 1) !== chr) result += chr;
        }
        return result !== "DGBEFHACIJK";
      });
      var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
      var getSortCompare = function(comparefn) {
        return function(x2, y) {
          if (y === void 0) return -1;
          if (x2 === void 0) return 1;
          if (comparefn !== void 0) return +comparefn(x2, y) || 0;
          return toString3(x2) > toString3(y) ? 1 : -1;
        };
      };
      $2({ target: "Array", proto: true, forced: FORCED }, {
        sort: function sort(comparefn) {
          if (comparefn !== void 0) aCallable(comparefn);
          var array = toObject(this);
          if (STABLE_SORT) return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
          var items = [];
          var arrayLength = lengthOfArrayLike(array);
          var itemsLength, index;
          for (index = 0; index < arrayLength; index++) {
            if (index in array) push(items, array[index]);
          }
          internalSort(items, getSortCompare(comparefn));
          itemsLength = lengthOfArrayLike(items);
          index = 0;
          while (index < itemsLength) array[index] = items[index++];
          while (index < arrayLength) deletePropertyOrThrow(array, index++);
          return array;
        }
      });
    }
  });

  // node_modules/core-js/internals/set-species.js
  var require_set_species = __commonJS({
    "node_modules/core-js/internals/set-species.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineBuiltInAccessor(Constructor, SPECIES, {
            configurable: true,
            get: function() {
              return this;
            }
          });
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array.species.js
  var require_es_array_species = __commonJS({
    "node_modules/core-js/modules/es.array.species.js"() {
      "use strict";
      var setSpecies = require_set_species();
      setSpecies("Array");
    }
  });

  // node_modules/core-js/modules/es.array.splice.js
  var require_es_array_splice = __commonJS({
    "node_modules/core-js/modules/es.array.splice.js"() {
      "use strict";
      var $2 = require_export();
      var toObject = require_to_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var arraySpeciesCreate = require_array_species_create();
      var createProperty = require_create_property();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var arrayMethodHasSpeciesSupport = require_array_method_has_species_support();
      var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
      var max = Math.max;
      var min = Math.min;
      $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
        splice: function splice(start, deleteCount) {
          var O2 = toObject(this);
          var len = lengthOfArrayLike(O2);
          var actualStart = toAbsoluteIndex(start, len);
          var argumentsLength = arguments.length;
          var insertCount, actualDeleteCount, A2, k, from, to2;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
          A2 = arraySpeciesCreate(O2, actualDeleteCount);
          for (k = 0; k < actualDeleteCount; k++) {
            from = actualStart + k;
            if (from in O2) createProperty(A2, k, O2[from]);
          }
          A2.length = actualDeleteCount;
          if (insertCount < actualDeleteCount) {
            for (k = actualStart; k < len - actualDeleteCount; k++) {
              from = k + actualDeleteCount;
              to2 = k + insertCount;
              if (from in O2) O2[to2] = O2[from];
              else deletePropertyOrThrow(O2, to2);
            }
            for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O2, k - 1);
          } else if (insertCount > actualDeleteCount) {
            for (k = len - actualDeleteCount; k > actualStart; k--) {
              from = k + actualDeleteCount - 1;
              to2 = k + insertCount - 1;
              if (from in O2) O2[to2] = O2[from];
              else deletePropertyOrThrow(O2, to2);
            }
          }
          for (k = 0; k < insertCount; k++) {
            O2[k + actualStart] = arguments[k + 2];
          }
          setArrayLength(O2, len - actualDeleteCount + insertCount);
          return A2;
        }
      });
    }
  });

  // node_modules/core-js/internals/array-to-reversed.js
  var require_array_to_reversed = __commonJS({
    "node_modules/core-js/internals/array-to-reversed.js"(exports, module) {
      "use strict";
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(O2, C2) {
        var len = lengthOfArrayLike(O2);
        var A2 = new C2(len);
        var k = 0;
        for (; k < len; k++) A2[k] = O2[len - k - 1];
        return A2;
      };
    }
  });

  // node_modules/core-js/modules/es.array.to-reversed.js
  var require_es_array_to_reversed = __commonJS({
    "node_modules/core-js/modules/es.array.to-reversed.js"() {
      "use strict";
      var $2 = require_export();
      var arrayToReversed = require_array_to_reversed();
      var toIndexedObject = require_to_indexed_object();
      var addToUnscopables = require_add_to_unscopables();
      var $Array = Array;
      $2({ target: "Array", proto: true }, {
        toReversed: function toReversed() {
          return arrayToReversed(toIndexedObject(this), $Array);
        }
      });
      addToUnscopables("toReversed");
    }
  });

  // node_modules/core-js/internals/array-from-constructor-and-list.js
  var require_array_from_constructor_and_list = __commonJS({
    "node_modules/core-js/internals/array-from-constructor-and-list.js"(exports, module) {
      "use strict";
      var lengthOfArrayLike = require_length_of_array_like();
      module.exports = function(Constructor, list, $length) {
        var index = 0;
        var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
        var result = new Constructor(length);
        while (length > index) result[index] = list[index++];
        return result;
      };
    }
  });

  // node_modules/core-js/internals/get-built-in-prototype-method.js
  var require_get_built_in_prototype_method = __commonJS({
    "node_modules/core-js/internals/get-built-in-prototype-method.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = function(CONSTRUCTOR, METHOD) {
        var Constructor = globalThis2[CONSTRUCTOR];
        var Prototype = Constructor && Constructor.prototype;
        return Prototype && Prototype[METHOD];
      };
    }
  });

  // node_modules/core-js/modules/es.array.to-sorted.js
  var require_es_array_to_sorted = __commonJS({
    "node_modules/core-js/modules/es.array.to-sorted.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var toIndexedObject = require_to_indexed_object();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
      var addToUnscopables = require_add_to_unscopables();
      var $Array = Array;
      var sort = uncurryThis(getBuiltInPrototypeMethod("Array", "sort"));
      $2({ target: "Array", proto: true }, {
        toSorted: function toSorted(compareFn) {
          if (compareFn !== void 0) aCallable(compareFn);
          var O2 = toIndexedObject(this);
          var A2 = arrayFromConstructorAndList($Array, O2);
          return sort(A2, compareFn);
        }
      });
      addToUnscopables("toSorted");
    }
  });

  // node_modules/core-js/modules/es.array.to-spliced.js
  var require_es_array_to_spliced = __commonJS({
    "node_modules/core-js/modules/es.array.to-spliced.js"() {
      "use strict";
      var $2 = require_export();
      var addToUnscopables = require_add_to_unscopables();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var lengthOfArrayLike = require_length_of_array_like();
      var toAbsoluteIndex = require_to_absolute_index();
      var toIndexedObject = require_to_indexed_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $Array = Array;
      var max = Math.max;
      var min = Math.min;
      $2({ target: "Array", proto: true }, {
        toSpliced: function toSpliced(start, deleteCount) {
          var O2 = toIndexedObject(this);
          var len = lengthOfArrayLike(O2);
          var actualStart = toAbsoluteIndex(start, len);
          var argumentsLength = arguments.length;
          var k = 0;
          var insertCount, actualDeleteCount, newLen, A2;
          if (argumentsLength === 0) {
            insertCount = actualDeleteCount = 0;
          } else if (argumentsLength === 1) {
            insertCount = 0;
            actualDeleteCount = len - actualStart;
          } else {
            insertCount = argumentsLength - 2;
            actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
          }
          newLen = doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
          A2 = $Array(newLen);
          for (; k < actualStart; k++) A2[k] = O2[k];
          for (; k < actualStart + insertCount; k++) A2[k] = arguments[k - actualStart + 2];
          for (; k < newLen; k++) A2[k] = O2[k + actualDeleteCount - insertCount];
          return A2;
        }
      });
      addToUnscopables("toSpliced");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat.js
  var require_es_array_unscopables_flat = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat.js"() {
      "use strict";
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flat");
    }
  });

  // node_modules/core-js/modules/es.array.unscopables.flat-map.js
  var require_es_array_unscopables_flat_map = __commonJS({
    "node_modules/core-js/modules/es.array.unscopables.flat-map.js"() {
      "use strict";
      var addToUnscopables = require_add_to_unscopables();
      addToUnscopables("flatMap");
    }
  });

  // node_modules/core-js/modules/es.array.unshift.js
  var require_es_array_unshift = __commonJS({
    "node_modules/core-js/modules/es.array.unshift.js"() {
      "use strict";
      var $2 = require_export();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var setArrayLength = require_array_set_length();
      var deletePropertyOrThrow = require_delete_property_or_throw();
      var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();
      var INCORRECT_RESULT = [].unshift(0) !== 1;
      var properErrorOnNonWritableLength = function() {
        try {
          Object.defineProperty([], "length", { writable: false }).unshift();
        } catch (error) {
          return error instanceof TypeError;
        }
      };
      var FORCED = INCORRECT_RESULT || !properErrorOnNonWritableLength();
      $2({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        unshift: function unshift(item) {
          var O2 = toObject(this);
          var len = lengthOfArrayLike(O2);
          var argCount = arguments.length;
          if (argCount) {
            doesNotExceedSafeInteger(len + argCount);
            var k = len;
            while (k--) {
              var to2 = k + argCount;
              if (k in O2) O2[to2] = O2[k];
              else deletePropertyOrThrow(O2, to2);
            }
            for (var j = 0; j < argCount; j++) {
              O2[j] = arguments[j];
            }
          }
          return setArrayLength(O2, len + argCount);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-with.js
  var require_array_with = __commonJS({
    "node_modules/core-js/internals/array-with.js"(exports, module) {
      "use strict";
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $RangeError = RangeError;
      module.exports = function(O2, C2, index, value) {
        var len = lengthOfArrayLike(O2);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
        if (actualIndex >= len || actualIndex < 0) throw new $RangeError("Incorrect index");
        var A2 = new C2(len);
        var k = 0;
        for (; k < len; k++) A2[k] = k === actualIndex ? value : O2[k];
        return A2;
      };
    }
  });

  // node_modules/core-js/modules/es.array.with.js
  var require_es_array_with = __commonJS({
    "node_modules/core-js/modules/es.array.with.js"() {
      "use strict";
      var $2 = require_export();
      var arrayWith = require_array_with();
      var toIndexedObject = require_to_indexed_object();
      var $Array = Array;
      $2({ target: "Array", proto: true }, {
        "with": function(index, value) {
          return arrayWith(toIndexedObject(this), $Array, index, value);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-buffer-basic-detection.js
  var require_array_buffer_basic_detection = __commonJS({
    "node_modules/core-js/internals/array-buffer-basic-detection.js"(exports, module) {
      "use strict";
      module.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
    }
  });

  // node_modules/core-js/internals/define-built-ins.js
  var require_define_built_ins = __commonJS({
    "node_modules/core-js/internals/define-built-ins.js"(exports, module) {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      module.exports = function(target, src, options) {
        for (var key in src) defineBuiltIn(target, key, src[key], options);
        return target;
      };
    }
  });

  // node_modules/core-js/internals/an-instance.js
  var require_an_instance = __commonJS({
    "node_modules/core-js/internals/an-instance.js"(exports, module) {
      "use strict";
      var isPrototypeOf = require_object_is_prototype_of();
      var $TypeError = TypeError;
      module.exports = function(it2, Prototype) {
        if (isPrototypeOf(Prototype, it2)) return it2;
        throw new $TypeError("Incorrect invocation");
      };
    }
  });

  // node_modules/core-js/internals/to-index.js
  var require_to_index = __commonJS({
    "node_modules/core-js/internals/to-index.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var $RangeError = RangeError;
      module.exports = function(it2) {
        if (it2 === void 0) return 0;
        var number = toIntegerOrInfinity(it2);
        var length = toLength(number);
        if (number !== length) throw new $RangeError("Wrong length or index");
        return length;
      };
    }
  });

  // node_modules/core-js/internals/math-sign.js
  var require_math_sign = __commonJS({
    "node_modules/core-js/internals/math-sign.js"(exports, module) {
      "use strict";
      module.exports = Math.sign || function sign(x2) {
        var n = +x2;
        return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
      };
    }
  });

  // node_modules/core-js/internals/math-round-ties-to-even.js
  var require_math_round_ties_to_even = __commonJS({
    "node_modules/core-js/internals/math-round-ties-to-even.js"(exports, module) {
      "use strict";
      var EPSILON = 2220446049250313e-31;
      var INVERSE_EPSILON = 1 / EPSILON;
      module.exports = function(n) {
        return n + INVERSE_EPSILON - INVERSE_EPSILON;
      };
    }
  });

  // node_modules/core-js/internals/math-float-round.js
  var require_math_float_round = __commonJS({
    "node_modules/core-js/internals/math-float-round.js"(exports, module) {
      "use strict";
      var sign = require_math_sign();
      var roundTiesToEven = require_math_round_ties_to_even();
      var abs = Math.abs;
      var EPSILON = 2220446049250313e-31;
      module.exports = function(x2, FLOAT_EPSILON, FLOAT_MAX_VALUE, FLOAT_MIN_VALUE) {
        var n = +x2;
        var absolute = abs(n);
        var s = sign(n);
        if (absolute < FLOAT_MIN_VALUE) return s * roundTiesToEven(absolute / FLOAT_MIN_VALUE / FLOAT_EPSILON) * FLOAT_MIN_VALUE * FLOAT_EPSILON;
        var a = (1 + FLOAT_EPSILON / EPSILON) * absolute;
        var result = a - (a - absolute);
        if (result > FLOAT_MAX_VALUE || result !== result) return s * Infinity;
        return s * result;
      };
    }
  });

  // node_modules/core-js/internals/math-fround.js
  var require_math_fround = __commonJS({
    "node_modules/core-js/internals/math-fround.js"(exports, module) {
      "use strict";
      var floatRound = require_math_float_round();
      var FLOAT32_EPSILON = 11920928955078125e-23;
      var FLOAT32_MAX_VALUE = 34028234663852886e22;
      var FLOAT32_MIN_VALUE = 11754943508222875e-54;
      module.exports = Math.fround || function fround(x2) {
        return floatRound(x2, FLOAT32_EPSILON, FLOAT32_MAX_VALUE, FLOAT32_MIN_VALUE);
      };
    }
  });

  // node_modules/core-js/internals/ieee754.js
  var require_ieee754 = __commonJS({
    "node_modules/core-js/internals/ieee754.js"(exports, module) {
      "use strict";
      var $Array = Array;
      var abs = Math.abs;
      var pow = Math.pow;
      var floor = Math.floor;
      var log = Math.log;
      var LN2 = Math.LN2;
      var pack = function(number, mantissaLength, bytes) {
        var buffer = $Array(bytes);
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
        var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
        var index = 0;
        var exponent, mantissa, c;
        number = abs(number);
        if (number !== number || number === Infinity) {
          mantissa = number !== number ? 1 : 0;
          exponent = eMax;
        } else {
          exponent = floor(log(number) / LN2);
          c = pow(2, -exponent);
          if (number * c < 1) {
            exponent--;
            c *= 2;
          }
          if (exponent + eBias >= 1) {
            number += rt / c;
          } else {
            number += rt * pow(2, 1 - eBias);
          }
          if (number * c >= 2) {
            exponent++;
            c /= 2;
          }
          if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
          } else if (exponent + eBias >= 1) {
            mantissa = (number * c - 1) * pow(2, mantissaLength);
            exponent += eBias;
          } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
          }
        }
        while (mantissaLength >= 8) {
          buffer[index++] = mantissa & 255;
          mantissa /= 256;
          mantissaLength -= 8;
        }
        exponent = exponent << mantissaLength | mantissa;
        exponentLength += mantissaLength;
        while (exponentLength > 0) {
          buffer[index++] = exponent & 255;
          exponent /= 256;
          exponentLength -= 8;
        }
        buffer[index - 1] |= sign * 128;
        return buffer;
      };
      var unpack = function(buffer, mantissaLength) {
        var bytes = buffer.length;
        var exponentLength = bytes * 8 - mantissaLength - 1;
        var eMax = (1 << exponentLength) - 1;
        var eBias = eMax >> 1;
        var nBits = exponentLength - 7;
        var index = bytes - 1;
        var sign = buffer[index--];
        var exponent = sign & 127;
        var mantissa;
        sign >>= 7;
        while (nBits > 0) {
          exponent = exponent * 256 + buffer[index--];
          nBits -= 8;
        }
        mantissa = exponent & (1 << -nBits) - 1;
        exponent >>= -nBits;
        nBits += mantissaLength;
        while (nBits > 0) {
          mantissa = mantissa * 256 + buffer[index--];
          nBits -= 8;
        }
        if (exponent === 0) {
          exponent = 1 - eBias;
        } else if (exponent === eMax) {
          return mantissa ? NaN : sign ? -Infinity : Infinity;
        } else {
          mantissa += pow(2, mantissaLength);
          exponent -= eBias;
        }
        return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
      };
      module.exports = {
        pack,
        unpack
      };
    }
  });

  // node_modules/core-js/internals/array-buffer.js
  var require_array_buffer = __commonJS({
    "node_modules/core-js/internals/array-buffer.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var FunctionName = require_function_name();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var fails = require_fails();
      var anInstance = require_an_instance();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var fround = require_math_fround();
      var IEEE754 = require_ieee754();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var arrayFill = require_array_fill();
      var arraySlice = require_array_slice();
      var inheritIfRequired = require_inherit_if_required();
      var copyConstructorProperties = require_copy_constructor_properties();
      var setToStringTag = require_set_to_string_tag();
      var InternalStateModule = require_internal_state();
      var PROPER_FUNCTION_NAME = FunctionName.PROPER;
      var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
      var ARRAY_BUFFER = "ArrayBuffer";
      var DATA_VIEW = "DataView";
      var PROTOTYPE = "prototype";
      var WRONG_LENGTH = "Wrong length";
      var WRONG_INDEX = "Wrong index";
      var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
      var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
      var setInternalState = InternalStateModule.set;
      var NativeArrayBuffer = globalThis2[ARRAY_BUFFER];
      var $ArrayBuffer = NativeArrayBuffer;
      var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
      var $DataView = globalThis2[DATA_VIEW];
      var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
      var ObjectPrototype = Object.prototype;
      var Array2 = globalThis2.Array;
      var RangeError2 = globalThis2.RangeError;
      var fill = uncurryThis(arrayFill);
      var reverse = uncurryThis([].reverse);
      var packIEEE754 = IEEE754.pack;
      var unpackIEEE754 = IEEE754.unpack;
      var packInt8 = function(number) {
        return [number & 255];
      };
      var packInt16 = function(number) {
        return [number & 255, number >> 8 & 255];
      };
      var packInt32 = function(number) {
        return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
      };
      var unpackInt32 = function(buffer) {
        return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
      };
      var packFloat32 = function(number) {
        return packIEEE754(fround(number), 23, 4);
      };
      var packFloat64 = function(number) {
        return packIEEE754(number, 52, 8);
      };
      var addGetter = function(Constructor, key, getInternalState) {
        defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
          configurable: true,
          get: function() {
            return getInternalState(this)[key];
          }
        });
      };
      var get = function(view, count, index, isLittleEndian) {
        var store = getInternalDataViewState(view);
        var intIndex = toIndex(index);
        var boolIsLittleEndian = !!isLittleEndian;
        if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
        var bytes = store.bytes;
        var start = intIndex + store.byteOffset;
        var pack = arraySlice(bytes, start, start + count);
        return boolIsLittleEndian ? pack : reverse(pack);
      };
      var set = function(view, count, index, conversion, value, isLittleEndian) {
        var store = getInternalDataViewState(view);
        var intIndex = toIndex(index);
        var pack = conversion(+value);
        var boolIsLittleEndian = !!isLittleEndian;
        if (intIndex + count > store.byteLength) throw new RangeError2(WRONG_INDEX);
        var bytes = store.bytes;
        var start = intIndex + store.byteOffset;
        for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
      };
      if (!NATIVE_ARRAY_BUFFER) {
        $ArrayBuffer = function ArrayBuffer2(length) {
          anInstance(this, ArrayBufferPrototype);
          var byteLength = toIndex(length);
          setInternalState(this, {
            type: ARRAY_BUFFER,
            bytes: fill(Array2(byteLength), 0),
            byteLength
          });
          if (!DESCRIPTORS) {
            this.byteLength = byteLength;
            this.detached = false;
          }
        };
        ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];
        $DataView = function DataView2(buffer, byteOffset, byteLength) {
          anInstance(this, DataViewPrototype);
          anInstance(buffer, ArrayBufferPrototype);
          var bufferState = getInternalArrayBufferState(buffer);
          var bufferLength = bufferState.byteLength;
          var offset = toIntegerOrInfinity(byteOffset);
          if (offset < 0 || offset > bufferLength) throw new RangeError2("Wrong offset");
          byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
          if (offset + byteLength > bufferLength) throw new RangeError2(WRONG_LENGTH);
          setInternalState(this, {
            type: DATA_VIEW,
            buffer,
            byteLength,
            byteOffset: offset,
            bytes: bufferState.bytes
          });
          if (!DESCRIPTORS) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset;
          }
        };
        DataViewPrototype = $DataView[PROTOTYPE];
        if (DESCRIPTORS) {
          addGetter($ArrayBuffer, "byteLength", getInternalArrayBufferState);
          addGetter($DataView, "buffer", getInternalDataViewState);
          addGetter($DataView, "byteLength", getInternalDataViewState);
          addGetter($DataView, "byteOffset", getInternalDataViewState);
        }
        defineBuiltIns(DataViewPrototype, {
          getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
          },
          getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
          },
          getInt16: function getInt16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          },
          getUint16: function getUint16(byteOffset) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
            return bytes[1] << 8 | bytes[0];
          },
          getInt32: function getInt32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
          },
          getUint32: function getUint32(byteOffset) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
          },
          getFloat32: function getFloat32(byteOffset) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
          },
          getFloat64: function getFloat64(byteOffset) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
          },
          setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          },
          setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
          },
          setInt16: function setInt16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
          },
          setUint16: function setUint16(byteOffset, value) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
          },
          setInt32: function setInt32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setUint32: function setUint32(byteOffset, value) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setFloat32: function setFloat32(byteOffset, value) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
          },
          setFloat64: function setFloat64(byteOffset, value) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
          }
        });
      } else {
        INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
        if (!fails(function() {
          NativeArrayBuffer(1);
        }) || !fails(function() {
          new NativeArrayBuffer(-1);
        }) || fails(function() {
          new NativeArrayBuffer();
          new NativeArrayBuffer(1.5);
          new NativeArrayBuffer(NaN);
          return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
        })) {
          $ArrayBuffer = function ArrayBuffer2(length) {
            anInstance(this, ArrayBufferPrototype);
            return inheritIfRequired(new NativeArrayBuffer(toIndex(length)), this, $ArrayBuffer);
          };
          $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;
          ArrayBufferPrototype.constructor = $ArrayBuffer;
          copyConstructorProperties($ArrayBuffer, NativeArrayBuffer);
        } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(NativeArrayBuffer, "name", ARRAY_BUFFER);
        }
        if (setPrototypeOf && getPrototypeOf2(DataViewPrototype) !== ObjectPrototype) {
          setPrototypeOf(DataViewPrototype, ObjectPrototype);
        }
        testView = new $DataView(new $ArrayBuffer(2));
        $setInt8 = uncurryThis(DataViewPrototype.setInt8);
        testView.setInt8(0, 2147483648);
        testView.setInt8(1, 2147483649);
        if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
          setInt8: function setInt8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          },
          setUint8: function setUint8(byteOffset, value) {
            $setInt8(this, byteOffset, value << 24 >> 24);
          }
        }, { unsafe: true });
      }
      var INCORRECT_ARRAY_BUFFER_NAME;
      var testView;
      var $setInt8;
      setToStringTag($ArrayBuffer, ARRAY_BUFFER);
      setToStringTag($DataView, DATA_VIEW);
      module.exports = {
        ArrayBuffer: $ArrayBuffer,
        DataView: $DataView
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.constructor.js
  var require_es_array_buffer_constructor = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var arrayBufferModule = require_array_buffer();
      var setSpecies = require_set_species();
      var ARRAY_BUFFER = "ArrayBuffer";
      var ArrayBuffer2 = arrayBufferModule[ARRAY_BUFFER];
      var NativeArrayBuffer = globalThis2[ARRAY_BUFFER];
      $2({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer2 }, {
        ArrayBuffer: ArrayBuffer2
      });
      setSpecies(ARRAY_BUFFER);
    }
  });

  // node_modules/core-js/internals/array-buffer-view-core.js
  var require_array_buffer_view_core = __commonJS({
    "node_modules/core-js/internals/array-buffer-view-core.js"(exports, module) {
      "use strict";
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var tryToString = require_try_to_string();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isPrototypeOf = require_object_is_prototype_of();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var uid = require_uid();
      var InternalStateModule = require_internal_state();
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var Int8Array2 = globalThis2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;
      var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
      var TypedArray = Int8Array2 && getPrototypeOf2(Int8Array2);
      var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf2(Int8ArrayPrototype);
      var ObjectPrototype = Object.prototype;
      var TypeError2 = globalThis2.TypeError;
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
      var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
      var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== "Opera";
      var TYPED_ARRAY_TAG_REQUIRED = false;
      var NAME;
      var Constructor;
      var Prototype;
      var TypedArrayConstructorsList = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
      };
      var BigIntArrayConstructorsList = {
        BigInt64Array: 8,
        BigUint64Array: 8
      };
      var isView = function isView2(it2) {
        if (!isObject2(it2)) return false;
        var klass = classof(it2);
        return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var getTypedArrayConstructor = function(it2) {
        var proto = getPrototypeOf2(it2);
        if (!isObject2(proto)) return;
        var state = getInternalState(proto);
        return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
      };
      var isTypedArray2 = function(it2) {
        if (!isObject2(it2)) return false;
        var klass = classof(it2);
        return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
      };
      var aTypedArray = function(it2) {
        if (isTypedArray2(it2)) return it2;
        throw new TypeError2("Target is not a typed array");
      };
      var aTypedArrayConstructor = function(C2) {
        if (isCallable(C2) && (!setPrototypeOf || isPrototypeOf(TypedArray, C2))) return C2;
        throw new TypeError2(tryToString(C2) + " is not a typed array constructor");
      };
      var exportTypedArrayMethod = function(KEY, property, forced, options) {
        if (!DESCRIPTORS) return;
        if (forced) for (var ARRAY in TypedArrayConstructorsList) {
          var TypedArrayConstructor = globalThis2[ARRAY];
          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
            delete TypedArrayConstructor.prototype[KEY];
          } catch (error) {
            try {
              TypedArrayConstructor.prototype[KEY] = property;
            } catch (error2) {
            }
          }
        }
        if (!TypedArrayPrototype[KEY] || forced) {
          defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
        }
      };
      var exportTypedArrayStaticMethod = function(KEY, property, forced) {
        var ARRAY, TypedArrayConstructor;
        if (!DESCRIPTORS) return;
        if (setPrototypeOf) {
          if (forced) for (ARRAY in TypedArrayConstructorsList) {
            TypedArrayConstructor = globalThis2[ARRAY];
            if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
              delete TypedArrayConstructor[KEY];
            } catch (error) {
            }
          }
          if (!TypedArray[KEY] || forced) {
            try {
              return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
            } catch (error) {
            }
          } else return;
        }
        for (ARRAY in TypedArrayConstructorsList) {
          TypedArrayConstructor = globalThis2[ARRAY];
          if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
            defineBuiltIn(TypedArrayConstructor, KEY, property);
          }
        }
      };
      for (NAME in TypedArrayConstructorsList) {
        Constructor = globalThis2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
        else NATIVE_ARRAY_BUFFER_VIEWS = false;
      }
      for (NAME in BigIntArrayConstructorsList) {
        Constructor = globalThis2[NAME];
        Prototype = Constructor && Constructor.prototype;
        if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
        TypedArray = function TypedArray2() {
          throw new TypeError2("Incorrect invocation");
        };
        if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
          if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);
        }
      }
      if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
        TypedArrayPrototype = TypedArray.prototype;
        if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
          if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);
        }
      }
      if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf2(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
        setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
      }
      if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
        TYPED_ARRAY_TAG_REQUIRED = true;
        defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
          configurable: true,
          get: function() {
            return isObject2(this) ? this[TYPED_ARRAY_TAG] : void 0;
          }
        });
        for (NAME in TypedArrayConstructorsList) if (globalThis2[NAME]) {
          createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);
        }
      }
      module.exports = {
        NATIVE_ARRAY_BUFFER_VIEWS,
        TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
        aTypedArray,
        aTypedArrayConstructor,
        exportTypedArrayMethod,
        exportTypedArrayStaticMethod,
        getTypedArrayConstructor,
        isView,
        isTypedArray: isTypedArray2,
        TypedArray,
        TypedArrayPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.is-view.js
  var require_es_array_buffer_is_view = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.is-view.js"() {
      "use strict";
      var $2 = require_export();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      $2({ target: "ArrayBuffer", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
        isView: ArrayBufferViewCore.isView
      });
    }
  });

  // node_modules/core-js/modules/es.array-buffer.slice.js
  var require_es_array_buffer_slice = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.slice.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var fails = require_fails();
      var ArrayBufferModule = require_array_buffer();
      var anObject = require_an_object();
      var toAbsoluteIndex = require_to_absolute_index();
      var toLength = require_to_length();
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var DataView2 = ArrayBufferModule.DataView;
      var DataViewPrototype = DataView2.prototype;
      var nativeArrayBufferSlice = uncurryThis(ArrayBuffer2.prototype.slice);
      var getUint8 = uncurryThis(DataViewPrototype.getUint8);
      var setUint8 = uncurryThis(DataViewPrototype.setUint8);
      var INCORRECT_SLICE = fails(function() {
        return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
      });
      $2({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
        slice: function slice(start, end) {
          if (nativeArrayBufferSlice && end === void 0) {
            return nativeArrayBufferSlice(anObject(this), start);
          }
          var length = anObject(this).byteLength;
          var first = toAbsoluteIndex(start, length);
          var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
          var result = new ArrayBuffer2(toLength(fin - first));
          var viewSource = new DataView2(this);
          var viewTarget = new DataView2(result);
          var index = 0;
          while (first < fin) {
            setUint8(viewTarget, index++, getUint8(viewSource, first++));
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.constructor.js
  var require_es_data_view_constructor = __commonJS({
    "node_modules/core-js/modules/es.data-view.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var ArrayBufferModule = require_array_buffer();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      $2({ global: true, constructor: true, forced: !NATIVE_ARRAY_BUFFER }, {
        DataView: ArrayBufferModule.DataView
      });
    }
  });

  // node_modules/core-js/modules/es.data-view.js
  var require_es_data_view = __commonJS({
    "node_modules/core-js/modules/es.data-view.js"() {
      "use strict";
      require_es_data_view_constructor();
    }
  });

  // node_modules/core-js/modules/es.data-view.get-float16.js
  var require_es_data_view_get_float16 = __commonJS({
    "node_modules/core-js/modules/es.data-view.get-float16.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var pow = Math.pow;
      var EXP_MASK16 = 31;
      var SIGNIFICAND_MASK16 = 1023;
      var MIN_SUBNORMAL16 = pow(2, -24);
      var SIGNIFICAND_DENOM16 = 9765625e-10;
      var unpackFloat16 = function(bytes) {
        var sign = bytes >>> 15;
        var exponent = bytes >>> 10 & EXP_MASK16;
        var significand = bytes & SIGNIFICAND_MASK16;
        if (exponent === EXP_MASK16) return significand === 0 ? sign === 0 ? Infinity : -Infinity : NaN;
        if (exponent === 0) return significand * (sign === 0 ? MIN_SUBNORMAL16 : -MIN_SUBNORMAL16);
        return pow(2, exponent - 15) * (sign === 0 ? 1 + significand * SIGNIFICAND_DENOM16 : -1 - significand * SIGNIFICAND_DENOM16);
      };
      var getUint16 = uncurryThis(DataView.prototype.getUint16);
      $2({ target: "DataView", proto: true }, {
        getFloat16: function getFloat16(byteOffset) {
          var uint16 = getUint16(this, byteOffset, arguments.length > 1 ? arguments[1] : false);
          return unpackFloat16(uint16);
        }
      });
    }
  });

  // node_modules/core-js/internals/a-data-view.js
  var require_a_data_view = __commonJS({
    "node_modules/core-js/internals/a-data-view.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (classof(argument) === "DataView") return argument;
        throw new $TypeError("Argument is not a DataView");
      };
    }
  });

  // node_modules/core-js/internals/math-log2.js
  var require_math_log2 = __commonJS({
    "node_modules/core-js/internals/math-log2.js"(exports, module) {
      "use strict";
      var log = Math.log;
      var LN2 = Math.LN2;
      module.exports = Math.log2 || function log2(x2) {
        return log(x2) / LN2;
      };
    }
  });

  // node_modules/core-js/modules/es.data-view.set-float16.js
  var require_es_data_view_set_float16 = __commonJS({
    "node_modules/core-js/modules/es.data-view.set-float16.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aDataView = require_a_data_view();
      var toIndex = require_to_index();
      var log2 = require_math_log2();
      var roundTiesToEven = require_math_round_ties_to_even();
      var pow = Math.pow;
      var MIN_INFINITY16 = 65520;
      var MIN_NORMAL16 = 61005353927612305e-21;
      var REC_MIN_SUBNORMAL16 = 16777216;
      var REC_SIGNIFICAND_DENOM16 = 1024;
      var packFloat16 = function(value) {
        if (value !== value) return 32256;
        if (value === 0) return (1 / value === -Infinity) << 15;
        var neg = value < 0;
        if (neg) value = -value;
        if (value >= MIN_INFINITY16) return neg << 15 | 31744;
        if (value < MIN_NORMAL16) return neg << 15 | roundTiesToEven(value * REC_MIN_SUBNORMAL16);
        var exponent = log2(value) | 0;
        if (exponent === -15) {
          return neg << 15 | REC_SIGNIFICAND_DENOM16;
        }
        var significand = roundTiesToEven((value * pow(2, -exponent) - 1) * REC_SIGNIFICAND_DENOM16);
        if (significand === REC_SIGNIFICAND_DENOM16) {
          return neg << 15 | exponent + 16 << 10;
        }
        return neg << 15 | exponent + 15 << 10 | significand;
      };
      var setUint16 = uncurryThis(DataView.prototype.setUint16);
      $2({ target: "DataView", proto: true }, {
        setFloat16: function setFloat16(byteOffset, value) {
          aDataView(this);
          var offset = toIndex(byteOffset);
          var bytes = packFloat16(+value);
          return setUint16(this, offset, bytes, arguments.length > 2 ? arguments[2] : false);
        }
      });
    }
  });

  // node_modules/core-js/internals/array-buffer-byte-length.js
  var require_array_buffer_byte_length = __commonJS({
    "node_modules/core-js/internals/array-buffer-byte-length.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var classof = require_classof_raw();
      var ArrayBuffer2 = globalThis2.ArrayBuffer;
      var TypeError2 = globalThis2.TypeError;
      module.exports = ArrayBuffer2 && uncurryThisAccessor(ArrayBuffer2.prototype, "byteLength", "get") || function(O2) {
        if (classof(O2) !== "ArrayBuffer") throw new TypeError2("ArrayBuffer expected");
        return O2.byteLength;
      };
    }
  });

  // node_modules/core-js/internals/array-buffer-is-detached.js
  var require_array_buffer_is_detached = __commonJS({
    "node_modules/core-js/internals/array-buffer-is-detached.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var NATIVE_ARRAY_BUFFER = require_array_buffer_basic_detection();
      var arrayBufferByteLength = require_array_buffer_byte_length();
      var DataView2 = globalThis2.DataView;
      module.exports = function(O2) {
        if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O2) !== 0) return false;
        try {
          new DataView2(O2);
          return false;
        } catch (error) {
          return true;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.detached.js
  var require_es_array_buffer_detached = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.detached.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isDetached = require_array_buffer_is_detached();
      var ArrayBufferPrototype = ArrayBuffer.prototype;
      if (DESCRIPTORS && !("detached" in ArrayBufferPrototype)) {
        defineBuiltInAccessor(ArrayBufferPrototype, "detached", {
          configurable: true,
          get: function detached() {
            return isDetached(this);
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/array-buffer-not-detached.js
  var require_array_buffer_not_detached = __commonJS({
    "node_modules/core-js/internals/array-buffer-not-detached.js"(exports, module) {
      "use strict";
      var isDetached = require_array_buffer_is_detached();
      var $TypeError = TypeError;
      module.exports = function(it2) {
        if (isDetached(it2)) throw new $TypeError("ArrayBuffer is detached");
        return it2;
      };
    }
  });

  // node_modules/core-js/internals/get-built-in-node-module.js
  var require_get_built_in_node_module = __commonJS({
    "node_modules/core-js/internals/get-built-in-node-module.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var IS_NODE = require_environment_is_node();
      module.exports = function(name) {
        if (IS_NODE) {
          try {
            return globalThis2.process.getBuiltinModule(name);
          } catch (error) {
          }
          try {
            return Function('return require("' + name + '")')();
          } catch (error) {
          }
        }
      };
    }
  });

  // node_modules/core-js/internals/structured-clone-proper-transfer.js
  var require_structured_clone_proper_transfer = __commonJS({
    "node_modules/core-js/internals/structured-clone-proper-transfer.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var V8 = require_environment_v8_version();
      var ENVIRONMENT = require_environment();
      var structuredClone2 = globalThis2.structuredClone;
      module.exports = !!structuredClone2 && !fails(function() {
        if (ENVIRONMENT === "DENO" && V8 > 92 || ENVIRONMENT === "NODE" && V8 > 94 || ENVIRONMENT === "BROWSER" && V8 > 97) return false;
        var buffer = new ArrayBuffer(8);
        var clone = structuredClone2(buffer, { transfer: [buffer] });
        return buffer.byteLength !== 0 || clone.byteLength !== 8;
      });
    }
  });

  // node_modules/core-js/internals/detach-transferable.js
  var require_detach_transferable = __commonJS({
    "node_modules/core-js/internals/detach-transferable.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var getBuiltInNodeModule = require_get_built_in_node_module();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var structuredClone2 = globalThis2.structuredClone;
      var $ArrayBuffer = globalThis2.ArrayBuffer;
      var $MessageChannel = globalThis2.MessageChannel;
      var detach = false;
      var WorkerThreads;
      var channel;
      var buffer;
      var $detach;
      if (PROPER_STRUCTURED_CLONE_TRANSFER) {
        detach = function(transferable) {
          structuredClone2(transferable, { transfer: [transferable] });
        };
      } else if ($ArrayBuffer) try {
        if (!$MessageChannel) {
          WorkerThreads = getBuiltInNodeModule("worker_threads");
          if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
        }
        if ($MessageChannel) {
          channel = new $MessageChannel();
          buffer = new $ArrayBuffer(2);
          $detach = function(transferable) {
            channel.port1.postMessage(null, [transferable]);
          };
          if (buffer.byteLength === 2) {
            $detach(buffer);
            if (buffer.byteLength === 0) detach = $detach;
          }
        }
      } catch (error) {
      }
      module.exports = detach;
    }
  });

  // node_modules/core-js/internals/array-buffer-transfer.js
  var require_array_buffer_transfer = __commonJS({
    "node_modules/core-js/internals/array-buffer-transfer.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var toIndex = require_to_index();
      var notDetached = require_array_buffer_not_detached();
      var arrayBufferByteLength = require_array_buffer_byte_length();
      var detachTransferable = require_detach_transferable();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var structuredClone2 = globalThis2.structuredClone;
      var ArrayBuffer2 = globalThis2.ArrayBuffer;
      var DataView2 = globalThis2.DataView;
      var min = Math.min;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataViewPrototype = DataView2.prototype;
      var slice = uncurryThis(ArrayBufferPrototype.slice);
      var isResizable = uncurryThisAccessor(ArrayBufferPrototype, "resizable", "get");
      var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, "maxByteLength", "get");
      var getInt8 = uncurryThis(DataViewPrototype.getInt8);
      var setInt8 = uncurryThis(DataViewPrototype.setInt8);
      module.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {
        var byteLength = arrayBufferByteLength(arrayBuffer);
        var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);
        var fixedLength = !isResizable || !isResizable(arrayBuffer);
        var newBuffer;
        notDetached(arrayBuffer);
        if (PROPER_STRUCTURED_CLONE_TRANSFER) {
          arrayBuffer = structuredClone2(arrayBuffer, { transfer: [arrayBuffer] });
          if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
        }
        if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
          newBuffer = slice(arrayBuffer, 0, newByteLength);
        } else {
          var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer) } : void 0;
          newBuffer = new ArrayBuffer2(newByteLength, options);
          var a = new DataView2(arrayBuffer);
          var b = new DataView2(newBuffer);
          var copyLength = min(newByteLength, byteLength);
          for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
        }
        if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
        return newBuffer;
      };
    }
  });

  // node_modules/core-js/modules/es.array-buffer.transfer.js
  var require_es_array_buffer_transfer = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.transfer.js"() {
      "use strict";
      var $2 = require_export();
      var $transfer = require_array_buffer_transfer();
      if ($transfer) $2({ target: "ArrayBuffer", proto: true }, {
        transfer: function transfer() {
          return $transfer(this, arguments.length ? arguments[0] : void 0, true);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js
  var require_es_array_buffer_transfer_to_fixed_length = __commonJS({
    "node_modules/core-js/modules/es.array-buffer.transfer-to-fixed-length.js"() {
      "use strict";
      var $2 = require_export();
      var $transfer = require_array_buffer_transfer();
      if ($transfer) $2({ target: "ArrayBuffer", proto: true }, {
        transferToFixedLength: function transferToFixedLength() {
          return $transfer(this, arguments.length ? arguments[0] : void 0, false);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.get-year.js
  var require_es_date_get_year = __commonJS({
    "node_modules/core-js/modules/es.date.get-year.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var FORCED = fails(function() {
        return (/* @__PURE__ */ new Date(16e11)).getYear() !== 120;
      });
      var getFullYear = uncurryThis(Date.prototype.getFullYear);
      $2({ target: "Date", proto: true, forced: FORCED }, {
        getYear: function getYear() {
          return getFullYear(this) - 1900;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.now.js
  var require_es_date_now = __commonJS({
    "node_modules/core-js/modules/es.date.now.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var $Date = Date;
      var thisTimeValue = uncurryThis($Date.prototype.getTime);
      $2({ target: "Date", stat: true }, {
        now: function now() {
          return thisTimeValue(new $Date());
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.set-year.js
  var require_es_date_set_year = __commonJS({
    "node_modules/core-js/modules/es.date.set-year.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var DatePrototype = Date.prototype;
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      var setFullYear = uncurryThis(DatePrototype.setFullYear);
      $2({ target: "Date", proto: true }, {
        setYear: function setYear(year) {
          thisTimeValue(this);
          var yi2 = toIntegerOrInfinity(year);
          var yyyy = yi2 >= 0 && yi2 <= 99 ? yi2 + 1900 : yi2;
          return setFullYear(this, yyyy);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-gmt-string.js
  var require_es_date_to_gmt_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-gmt-string.js"() {
      "use strict";
      var $2 = require_export();
      $2({ target: "Date", proto: true }, {
        toGMTString: Date.prototype.toUTCString
      });
    }
  });

  // node_modules/core-js/internals/string-repeat.js
  var require_string_repeat = __commonJS({
    "node_modules/core-js/internals/string-repeat.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString3 = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var $RangeError = RangeError;
      module.exports = function repeat(count) {
        var str = toString3(requireObjectCoercible(this));
        var result = "";
        var n = toIntegerOrInfinity(count);
        if (n < 0 || n === Infinity) throw new $RangeError("Wrong number of repetitions");
        for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
        return result;
      };
    }
  });

  // node_modules/core-js/internals/string-pad.js
  var require_string_pad = __commonJS({
    "node_modules/core-js/internals/string-pad.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var $repeat = require_string_repeat();
      var requireObjectCoercible = require_require_object_coercible();
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ceil = Math.ceil;
      var createMethod = function(IS_END) {
        return function($this, maxLength, fillString) {
          var S2 = toString3(requireObjectCoercible($this));
          var intMaxLength = toLength(maxLength);
          var stringLength = S2.length;
          var fillStr = fillString === void 0 ? " " : toString3(fillString);
          var fillLen, stringFiller;
          if (intMaxLength <= stringLength || fillStr === "") return S2;
          fillLen = intMaxLength - stringLength;
          stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
          if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
          return IS_END ? S2 + stringFiller : stringFiller + S2;
        };
      };
      module.exports = {
        // `String.prototype.padStart` method
        // https://tc39.es/ecma262/#sec-string.prototype.padstart
        start: createMethod(false),
        // `String.prototype.padEnd` method
        // https://tc39.es/ecma262/#sec-string.prototype.padend
        end: createMethod(true)
      };
    }
  });

  // node_modules/core-js/internals/date-to-iso-string.js
  var require_date_to_iso_string = __commonJS({
    "node_modules/core-js/internals/date-to-iso-string.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var padStart = require_string_pad().start;
      var $RangeError = RangeError;
      var $isFinite = isFinite;
      var abs = Math.abs;
      var DatePrototype = Date.prototype;
      var nativeDateToISOString = DatePrototype.toISOString;
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      var getUTCDate = uncurryThis(DatePrototype.getUTCDate);
      var getUTCFullYear = uncurryThis(DatePrototype.getUTCFullYear);
      var getUTCHours = uncurryThis(DatePrototype.getUTCHours);
      var getUTCMilliseconds = uncurryThis(DatePrototype.getUTCMilliseconds);
      var getUTCMinutes = uncurryThis(DatePrototype.getUTCMinutes);
      var getUTCMonth = uncurryThis(DatePrototype.getUTCMonth);
      var getUTCSeconds = uncurryThis(DatePrototype.getUTCSeconds);
      module.exports = fails(function() {
        return nativeDateToISOString.call(new Date(-5e13 - 1)) !== "0385-07-25T07:06:39.999Z";
      }) || !fails(function() {
        nativeDateToISOString.call(/* @__PURE__ */ new Date(NaN));
      }) ? function toISOString() {
        if (!$isFinite(thisTimeValue(this))) throw new $RangeError("Invalid time value");
        var date = this;
        var year = getUTCFullYear(date);
        var milliseconds = getUTCMilliseconds(date);
        var sign = year < 0 ? "-" : year > 9999 ? "+" : "";
        return sign + padStart(abs(year), sign ? 6 : 4, 0) + "-" + padStart(getUTCMonth(date) + 1, 2, 0) + "-" + padStart(getUTCDate(date), 2, 0) + "T" + padStart(getUTCHours(date), 2, 0) + ":" + padStart(getUTCMinutes(date), 2, 0) + ":" + padStart(getUTCSeconds(date), 2, 0) + "." + padStart(milliseconds, 3, 0) + "Z";
      } : nativeDateToISOString;
    }
  });

  // node_modules/core-js/modules/es.date.to-iso-string.js
  var require_es_date_to_iso_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-iso-string.js"() {
      "use strict";
      var $2 = require_export();
      var toISOString = require_date_to_iso_string();
      $2({ target: "Date", proto: true, forced: Date.prototype.toISOString !== toISOString }, {
        toISOString
      });
    }
  });

  // node_modules/core-js/modules/es.date.to-json.js
  var require_es_date_to_json = __commonJS({
    "node_modules/core-js/modules/es.date.to-json.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var toPrimitive = require_to_primitive();
      var FORCED = fails(function() {
        return (/* @__PURE__ */ new Date(NaN)).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function() {
          return 1;
        } }) !== 1;
      });
      $2({ target: "Date", proto: true, arity: 1, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        toJSON: function toJSON2(key) {
          var O2 = toObject(this);
          var pv = toPrimitive(O2, "number");
          return typeof pv == "number" && !isFinite(pv) ? null : O2.toISOString();
        }
      });
    }
  });

  // node_modules/core-js/internals/date-to-primitive.js
  var require_date_to_primitive = __commonJS({
    "node_modules/core-js/internals/date-to-primitive.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var ordinaryToPrimitive = require_ordinary_to_primitive();
      var $TypeError = TypeError;
      module.exports = function(hint) {
        anObject(this);
        if (hint === "string" || hint === "default") hint = "string";
        else if (hint !== "number") throw new $TypeError("Incorrect hint");
        return ordinaryToPrimitive(this, hint);
      };
    }
  });

  // node_modules/core-js/modules/es.date.to-primitive.js
  var require_es_date_to_primitive = __commonJS({
    "node_modules/core-js/modules/es.date.to-primitive.js"() {
      "use strict";
      var hasOwn = require_has_own_property();
      var defineBuiltIn = require_define_built_in();
      var dateToPrimitive = require_date_to_primitive();
      var wellKnownSymbol = require_well_known_symbol();
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      var DatePrototype = Date.prototype;
      if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
        defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
      }
    }
  });

  // node_modules/core-js/modules/es.date.to-string.js
  var require_es_date_to_string = __commonJS({
    "node_modules/core-js/modules/es.date.to-string.js"() {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIn = require_define_built_in();
      var DatePrototype = Date.prototype;
      var INVALID_DATE = "Invalid Date";
      var TO_STRING = "toString";
      var nativeDateToString = uncurryThis(DatePrototype[TO_STRING]);
      var thisTimeValue = uncurryThis(DatePrototype.getTime);
      if (String(/* @__PURE__ */ new Date(NaN)) !== INVALID_DATE) {
        defineBuiltIn(DatePrototype, TO_STRING, function toString3() {
          var value = thisTimeValue(this);
          return value === value ? nativeDateToString(this) : INVALID_DATE;
        });
      }
    }
  });

  // node_modules/core-js/modules/es.escape.js
  var require_es_escape = __commonJS({
    "node_modules/core-js/modules/es.escape.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var exec = uncurryThis(/./.exec);
      var numberToString = uncurryThis(1 .toString);
      var toUpperCase = uncurryThis("".toUpperCase);
      var raw = /[\w*+\-./@]/;
      var hex = function(code, length) {
        var result = numberToString(code, 16);
        while (result.length < length) result = "0" + result;
        return result;
      };
      $2({ global: true }, {
        escape: function escape(string) {
          var str = toString3(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, code;
          while (index < length) {
            chr = charAt(str, index++);
            if (exec(raw, chr)) {
              result += chr;
            } else {
              code = charCodeAt(chr, 0);
              if (code < 256) {
                result += "%" + hex(code, 2);
              } else {
                result += "%u" + toUpperCase(hex(code, 4));
              }
            }
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/function-bind.js
  var require_function_bind = __commonJS({
    "node_modules/core-js/internals/function-bind.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var isObject2 = require_is_object();
      var hasOwn = require_has_own_property();
      var arraySlice = require_array_slice();
      var NATIVE_BIND = require_function_bind_native();
      var $Function = Function;
      var concat = uncurryThis([].concat);
      var join = uncurryThis([].join);
      var factories = {};
      var construct = function(C2, argsLength, args) {
        if (!hasOwn(factories, argsLength)) {
          var list = [];
          var i = 0;
          for (; i < argsLength; i++) list[i] = "a[" + i + "]";
          factories[argsLength] = $Function("C,a", "return new C(" + join(list, ",") + ")");
        }
        return factories[argsLength](C2, args);
      };
      module.exports = NATIVE_BIND ? $Function.bind : function bind2(that) {
        var F2 = aCallable(this);
        var Prototype = F2.prototype;
        var partArgs = arraySlice(arguments, 1);
        var boundFunction = function bound() {
          var args = concat(partArgs, arraySlice(arguments));
          return this instanceof boundFunction ? construct(F2, args.length, args) : F2.apply(that, args);
        };
        if (isObject2(Prototype)) boundFunction.prototype = Prototype;
        return boundFunction;
      };
    }
  });

  // node_modules/core-js/modules/es.function.bind.js
  var require_es_function_bind = __commonJS({
    "node_modules/core-js/modules/es.function.bind.js"() {
      "use strict";
      var $2 = require_export();
      var bind2 = require_function_bind();
      $2({ target: "Function", proto: true, forced: Function.bind !== bind2 }, {
        bind: bind2
      });
    }
  });

  // node_modules/core-js/modules/es.function.has-instance.js
  var require_es_function_has_instance = __commonJS({
    "node_modules/core-js/modules/es.function.has-instance.js"() {
      "use strict";
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var definePropertyModule = require_object_define_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var wellKnownSymbol = require_well_known_symbol();
      var makeBuiltIn = require_make_built_in();
      var HAS_INSTANCE = wellKnownSymbol("hasInstance");
      var FunctionPrototype = Function.prototype;
      if (!(HAS_INSTANCE in FunctionPrototype)) {
        definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: makeBuiltIn(function(O2) {
          if (!isCallable(this) || !isObject2(O2)) return false;
          var P = this.prototype;
          return isObject2(P) ? isPrototypeOf(P, O2) : O2 instanceof this;
        }, HAS_INSTANCE) });
      }
    }
  });

  // node_modules/core-js/modules/es.function.name.js
  var require_es_function_name = __commonJS({
    "node_modules/core-js/modules/es.function.name.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var FUNCTION_NAME_EXISTS = require_function_name().EXISTS;
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var FunctionPrototype = Function.prototype;
      var functionToString = uncurryThis(FunctionPrototype.toString);
      var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
      var regExpExec = uncurryThis(nameRE.exec);
      var NAME = "name";
      if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
        defineBuiltInAccessor(FunctionPrototype, NAME, {
          configurable: true,
          get: function() {
            try {
              return regExpExec(nameRE, functionToString(this))[1];
            } catch (error) {
              return "";
            }
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.global-this.js
  var require_es_global_this = __commonJS({
    "node_modules/core-js/modules/es.global-this.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      $2({ global: true, forced: globalThis2.globalThis !== globalThis2 }, {
        globalThis: globalThis2
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.constructor.js
  var require_es_iterator_constructor = __commonJS({
    "node_modules/core-js/modules/es.iterator.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var createProperty = require_create_property();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var wellKnownSymbol = require_well_known_symbol();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var CONSTRUCTOR = "constructor";
      var ITERATOR = "Iterator";
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $TypeError = TypeError;
      var NativeIterator = globalThis2[ITERATOR];
      var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {
        NativeIterator({});
      });
      var IteratorConstructor = function Iterator() {
        anInstance(this, IteratorPrototype);
        if (getPrototypeOf2(this) === IteratorPrototype) throw new $TypeError("Abstract class Iterator not directly constructable");
      };
      var defineIteratorPrototypeAccessor = function(key, value) {
        if (DESCRIPTORS) {
          defineBuiltInAccessor(IteratorPrototype, key, {
            configurable: true,
            get: function() {
              return value;
            },
            set: function(replacement) {
              anObject(this);
              if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
              if (hasOwn(this, key)) this[key] = replacement;
              else createProperty(this, key, replacement);
            }
          });
        } else IteratorPrototype[key] = value;
      };
      if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);
      if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
        defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
      }
      IteratorConstructor.prototype = IteratorPrototype;
      $2({ global: true, constructor: true, forced: FORCED }, {
        Iterator: IteratorConstructor
      });
    }
  });

  // node_modules/core-js/internals/get-iterator-direct.js
  var require_get_iterator_direct = __commonJS({
    "node_modules/core-js/internals/get-iterator-direct.js"(exports, module) {
      "use strict";
      module.exports = function(obj) {
        return {
          iterator: obj,
          next: obj.next,
          done: false
        };
      };
    }
  });

  // node_modules/core-js/internals/not-a-nan.js
  var require_not_a_nan = __commonJS({
    "node_modules/core-js/internals/not-a-nan.js"(exports, module) {
      "use strict";
      var $RangeError = RangeError;
      module.exports = function(it2) {
        if (it2 === it2) return it2;
        throw new $RangeError("NaN is not allowed");
      };
    }
  });

  // node_modules/core-js/internals/to-positive-integer.js
  var require_to_positive_integer = __commonJS({
    "node_modules/core-js/internals/to-positive-integer.js"(exports, module) {
      "use strict";
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var $RangeError = RangeError;
      module.exports = function(it2) {
        var result = toIntegerOrInfinity(it2);
        if (result < 0) throw new $RangeError("The argument can't be less than 0");
        return result;
      };
    }
  });

  // node_modules/core-js/internals/iterator-create-proxy.js
  var require_iterator_create_proxy = __commonJS({
    "node_modules/core-js/internals/iterator-create-proxy.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var create = require_object_create();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var defineBuiltIns = require_define_built_ins();
      var wellKnownSymbol = require_well_known_symbol();
      var InternalStateModule = require_internal_state();
      var getMethod = require_get_method();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var createIterResultObject = require_create_iter_result_object();
      var iteratorClose = require_iterator_close();
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var ITERATOR_HELPER = "IteratorHelper";
      var WRAP_FOR_VALID_ITERATOR = "WrapForValidIterator";
      var setInternalState = InternalStateModule.set;
      var createIteratorProxyPrototype = function(IS_ITERATOR) {
        var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
        return defineBuiltIns(create(IteratorPrototype), {
          next: function next() {
            var state = getInternalState(this);
            if (IS_ITERATOR) return state.nextHandler();
            if (state.done) return createIterResultObject(void 0, true);
            try {
              var result = state.nextHandler();
              return state.returnHandlerResult ? result : createIterResultObject(result, state.done);
            } catch (error) {
              state.done = true;
              throw error;
            }
          },
          "return": function() {
            var state = getInternalState(this);
            var iterator2 = state.iterator;
            state.done = true;
            if (IS_ITERATOR) {
              var returnMethod = getMethod(iterator2, "return");
              return returnMethod ? call(returnMethod, iterator2) : createIterResultObject(void 0, true);
            }
            if (state.inner) try {
              iteratorClose(state.inner.iterator, "normal");
            } catch (error) {
              return iteratorClose(iterator2, "throw", error);
            }
            if (iterator2) iteratorClose(iterator2, "normal");
            return createIterResultObject(void 0, true);
          }
        });
      };
      var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
      var IteratorHelperPrototype = createIteratorProxyPrototype(false);
      createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, "Iterator Helper");
      module.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
        var IteratorProxy = function Iterator(record, state) {
          if (state) {
            state.iterator = record.iterator;
            state.next = record.next;
          } else state = record;
          state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
          state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
          state.nextHandler = nextHandler;
          state.counter = 0;
          state.done = false;
          setInternalState(this, state);
        };
        IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
        return IteratorProxy;
      };
    }
  });

  // node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js
  var require_iterator_helper_without_closing_on_early_error = __commonJS({
    "node_modules/core-js/internals/iterator-helper-without-closing-on-early-error.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = function(METHOD_NAME, ExpectedError) {
        var Iterator = globalThis2.Iterator;
        var IteratorPrototype = Iterator && Iterator.prototype;
        var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];
        var CLOSED = false;
        if (method) try {
          method.call({
            next: function() {
              return { done: true };
            },
            "return": function() {
              CLOSED = true;
            }
          }, -1);
        } catch (error) {
          if (!(error instanceof ExpectedError)) CLOSED = false;
        }
        if (!CLOSED) return method;
      };
    }
  });

  // node_modules/core-js/modules/es.iterator.drop.js
  var require_es_iterator_drop = __commonJS({
    "node_modules/core-js/modules/es.iterator.drop.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var notANaN = require_not_a_nan();
      var toPositiveInteger = require_to_positive_integer();
      var iteratorClose = require_iterator_close();
      var createIteratorProxy = require_iterator_create_proxy();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var IS_PURE = require_is_pure();
      var dropWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("drop", RangeError);
      var IteratorProxy = createIteratorProxy(function() {
        var iterator2 = this.iterator;
        var next = this.next;
        var result, done;
        while (this.remaining) {
          this.remaining--;
          result = anObject(call(next, iterator2));
          done = this.done = !!result.done;
          if (done) return;
        }
        result = anObject(call(next, iterator2));
        done = this.done = !!result.done;
        if (!done) return result.value;
      });
      $2({ target: "Iterator", proto: true, real: true, forced: IS_PURE || dropWithoutClosingOnEarlyError }, {
        drop: function drop(limit) {
          anObject(this);
          var remaining;
          try {
            remaining = toPositiveInteger(notANaN(+limit));
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);
          return new IteratorProxy(getIteratorDirect(this), {
            remaining
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.every.js
  var require_es_iterator_every = __commonJS({
    "node_modules/core-js/modules/es.iterator.every.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("every", TypeError);
      $2({ target: "Iterator", proto: true, real: true, forced: everyWithoutClosingOnEarlyError }, {
        every: function every(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);
          var record = getIteratorDirect(this);
          var counter = 0;
          return !iterate(record, function(value, stop) {
            if (!predicate(value, counter++)) return stop();
          }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.filter.js
  var require_es_iterator_filter = __commonJS({
    "node_modules/core-js/modules/es.iterator.filter.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var createIteratorProxy = require_iterator_create_proxy();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var IS_PURE = require_is_pure();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var filterWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("filter", TypeError);
      var IteratorProxy = createIteratorProxy(function() {
        var iterator2 = this.iterator;
        var predicate = this.predicate;
        var next = this.next;
        var result, done, value;
        while (true) {
          result = anObject(call(next, iterator2));
          done = this.done = !!result.done;
          if (done) return;
          value = result.value;
          if (callWithSafeIterationClosing(iterator2, predicate, [value, this.counter++], true)) return value;
        }
      });
      $2({ target: "Iterator", proto: true, real: true, forced: IS_PURE || filterWithoutClosingOnEarlyError }, {
        filter: function filter2(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);
          return new IteratorProxy(getIteratorDirect(this), {
            predicate
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.find.js
  var require_es_iterator_find = __commonJS({
    "node_modules/core-js/modules/es.iterator.find.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("find", TypeError);
      $2({ target: "Iterator", proto: true, real: true, forced: findWithoutClosingOnEarlyError }, {
        find: function find(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);
          var record = getIteratorDirect(this);
          var counter = 0;
          return iterate(record, function(value, stop) {
            if (predicate(value, counter++)) return stop(value);
          }, { IS_RECORD: true, INTERRUPTED: true }).result;
        }
      });
    }
  });

  // node_modules/core-js/internals/get-iterator-flattenable.js
  var require_get_iterator_flattenable = __commonJS({
    "node_modules/core-js/internals/get-iterator-flattenable.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var getIteratorMethod = require_get_iterator_method();
      module.exports = function(obj, stringHandling) {
        if (!stringHandling || typeof obj !== "string") anObject(obj);
        var method = getIteratorMethod(obj);
        return getIteratorDirect(anObject(method !== void 0 ? call(method, obj) : obj));
      };
    }
  });

  // node_modules/core-js/modules/es.iterator.flat-map.js
  var require_es_iterator_flat_map = __commonJS({
    "node_modules/core-js/modules/es.iterator.flat-map.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var getIteratorFlattenable = require_get_iterator_flattenable();
      var createIteratorProxy = require_iterator_create_proxy();
      var iteratorClose = require_iterator_close();
      var IS_PURE = require_is_pure();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var flatMapWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("flatMap", TypeError);
      var IteratorProxy = createIteratorProxy(function() {
        var iterator2 = this.iterator;
        var mapper = this.mapper;
        var result, inner;
        while (true) {
          if (inner = this.inner) try {
            result = anObject(call(inner.next, inner.iterator));
            if (!result.done) return result.value;
            this.inner = null;
          } catch (error) {
            iteratorClose(iterator2, "throw", error);
          }
          result = anObject(call(this.next, iterator2));
          if (this.done = !!result.done) return;
          try {
            this.inner = getIteratorFlattenable(mapper(result.value, this.counter++), false);
          } catch (error) {
            iteratorClose(iterator2, "throw", error);
          }
        }
      });
      $2({ target: "Iterator", proto: true, real: true, forced: IS_PURE || flatMapWithoutClosingOnEarlyError }, {
        flatMap: function flatMap(mapper) {
          anObject(this);
          try {
            aCallable(mapper);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);
          return new IteratorProxy(getIteratorDirect(this), {
            mapper,
            inner: null
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.for-each.js
  var require_es_iterator_for_each = __commonJS({
    "node_modules/core-js/modules/es.iterator.for-each.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("forEach", TypeError);
      $2({ target: "Iterator", proto: true, real: true, forced: forEachWithoutClosingOnEarlyError }, {
        forEach: function forEach2(fn2) {
          anObject(this);
          try {
            aCallable(fn2);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn2);
          var record = getIteratorDirect(this);
          var counter = 0;
          iterate(record, function(value) {
            fn2(value, counter++);
          }, { IS_RECORD: true });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.from.js
  var require_es_iterator_from = __commonJS({
    "node_modules/core-js/modules/es.iterator.from.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var toObject = require_to_object();
      var isPrototypeOf = require_object_is_prototype_of();
      var IteratorPrototype = require_iterators_core().IteratorPrototype;
      var createIteratorProxy = require_iterator_create_proxy();
      var getIteratorFlattenable = require_get_iterator_flattenable();
      var IS_PURE = require_is_pure();
      var IteratorProxy = createIteratorProxy(function() {
        return call(this.next, this.iterator);
      }, true);
      $2({ target: "Iterator", stat: true, forced: IS_PURE }, {
        from: function from(O2) {
          var iteratorRecord = getIteratorFlattenable(typeof O2 == "string" ? toObject(O2) : O2, true);
          return isPrototypeOf(IteratorPrototype, iteratorRecord.iterator) ? iteratorRecord.iterator : new IteratorProxy(iteratorRecord);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.map.js
  var require_es_iterator_map = __commonJS({
    "node_modules/core-js/modules/es.iterator.map.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var createIteratorProxy = require_iterator_create_proxy();
      var callWithSafeIterationClosing = require_call_with_safe_iteration_closing();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var IS_PURE = require_is_pure();
      var mapWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("map", TypeError);
      var IteratorProxy = createIteratorProxy(function() {
        var iterator2 = this.iterator;
        var result = anObject(call(this.next, iterator2));
        var done = this.done = !!result.done;
        if (!done) return callWithSafeIterationClosing(iterator2, this.mapper, [result.value, this.counter++], true);
      });
      $2({ target: "Iterator", proto: true, real: true, forced: IS_PURE || mapWithoutClosingOnEarlyError }, {
        map: function map(mapper) {
          anObject(this);
          try {
            aCallable(mapper);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);
          return new IteratorProxy(getIteratorDirect(this), {
            mapper
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.reduce.js
  var require_es_iterator_reduce = __commonJS({
    "node_modules/core-js/modules/es.iterator.reduce.js"() {
      "use strict";
      var $2 = require_export();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var apply = require_function_apply();
      var fails = require_fails();
      var $TypeError = TypeError;
      var FAILS_ON_INITIAL_UNDEFINED = fails(function() {
        [].keys().reduce(function() {
        }, void 0);
      });
      var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError("reduce", $TypeError);
      $2({ target: "Iterator", proto: true, real: true, forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError }, {
        reduce: function reduce(reducer) {
          anObject(this);
          try {
            aCallable(reducer);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          var noInitial = arguments.length < 2;
          var accumulator = noInitial ? void 0 : arguments[1];
          if (reduceWithoutClosingOnEarlyError) {
            return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [reducer] : [reducer, accumulator]);
          }
          var record = getIteratorDirect(this);
          var counter = 0;
          iterate(record, function(value) {
            if (noInitial) {
              noInitial = false;
              accumulator = value;
            } else {
              accumulator = reducer(accumulator, value, counter);
            }
            counter++;
          }, { IS_RECORD: true });
          if (noInitial) throw new $TypeError("Reduce of empty iterator with no initial value");
          return accumulator;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.some.js
  var require_es_iterator_some = __commonJS({
    "node_modules/core-js/modules/es.iterator.some.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var iterate = require_iterate();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("some", TypeError);
      $2({ target: "Iterator", proto: true, real: true, forced: someWithoutClosingOnEarlyError }, {
        some: function some(predicate) {
          anObject(this);
          try {
            aCallable(predicate);
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);
          var record = getIteratorDirect(this);
          var counter = 0;
          return iterate(record, function(value, stop) {
            if (predicate(value, counter++)) return stop();
          }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.take.js
  var require_es_iterator_take = __commonJS({
    "node_modules/core-js/modules/es.iterator.take.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var getIteratorDirect = require_get_iterator_direct();
      var notANaN = require_not_a_nan();
      var toPositiveInteger = require_to_positive_integer();
      var createIteratorProxy = require_iterator_create_proxy();
      var iteratorClose = require_iterator_close();
      var iteratorHelperWithoutClosingOnEarlyError = require_iterator_helper_without_closing_on_early_error();
      var IS_PURE = require_is_pure();
      var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("take", RangeError);
      var IteratorProxy = createIteratorProxy(function() {
        var iterator2 = this.iterator;
        if (!this.remaining--) {
          this.done = true;
          return iteratorClose(iterator2, "normal", void 0);
        }
        var result = anObject(call(this.next, iterator2));
        var done = this.done = !!result.done;
        if (!done) return result.value;
      });
      $2({ target: "Iterator", proto: true, real: true, forced: IS_PURE || takeWithoutClosingOnEarlyError }, {
        take: function take(limit) {
          anObject(this);
          var remaining;
          try {
            remaining = toPositiveInteger(notANaN(+limit));
          } catch (error) {
            iteratorClose(this, "throw", error);
          }
          if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);
          return new IteratorProxy(getIteratorDirect(this), {
            remaining
          });
        }
      });
    }
  });

  // node_modules/core-js/modules/es.iterator.to-array.js
  var require_es_iterator_to_array = __commonJS({
    "node_modules/core-js/modules/es.iterator.to-array.js"() {
      "use strict";
      var $2 = require_export();
      var anObject = require_an_object();
      var iterate = require_iterate();
      var getIteratorDirect = require_get_iterator_direct();
      var push = [].push;
      $2({ target: "Iterator", proto: true, real: true }, {
        toArray: function toArray2() {
          var result = [];
          iterate(getIteratorDirect(anObject(this)), push, { that: result, IS_RECORD: true });
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.json.to-string-tag.js
  var require_es_json_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.json.to-string-tag.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(globalThis2.JSON, "JSON", true);
    }
  });

  // node_modules/core-js/internals/array-buffer-non-extensible.js
  var require_array_buffer_non_extensible = __commonJS({
    "node_modules/core-js/internals/array-buffer-non-extensible.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = fails(function() {
        if (typeof ArrayBuffer == "function") {
          var buffer = new ArrayBuffer(8);
          if (Object.isExtensible(buffer)) Object.defineProperty(buffer, "a", { value: 8 });
        }
      });
    }
  });

  // node_modules/core-js/internals/object-is-extensible.js
  var require_object_is_extensible = __commonJS({
    "node_modules/core-js/internals/object-is-extensible.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isExtensible = Object.isExtensible;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $isExtensible(1);
      });
      module.exports = FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE ? function isExtensible(it2) {
        if (!isObject2(it2)) return false;
        if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it2) === "ArrayBuffer") return false;
        return $isExtensible ? $isExtensible(it2) : true;
      } : $isExtensible;
    }
  });

  // node_modules/core-js/internals/freezing.js
  var require_freezing = __commonJS({
    "node_modules/core-js/internals/freezing.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = !fails(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      });
    }
  });

  // node_modules/core-js/internals/internal-metadata.js
  var require_internal_metadata = __commonJS({
    "node_modules/core-js/internals/internal-metadata.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var hiddenKeys = require_hidden_keys();
      var isObject2 = require_is_object();
      var hasOwn = require_has_own_property();
      var defineProperty = require_object_define_property().f;
      var getOwnPropertyNamesModule = require_object_get_own_property_names();
      var getOwnPropertyNamesExternalModule = require_object_get_own_property_names_external();
      var isExtensible = require_object_is_extensible();
      var uid = require_uid();
      var FREEZING = require_freezing();
      var REQUIRED = false;
      var METADATA = uid("meta");
      var id = 0;
      var setMetadata = function(it2) {
        defineProperty(it2, METADATA, { value: {
          objectID: "O" + id++,
          // object ID
          weakData: {}
          // weak collections IDs
        } });
      };
      var fastKey = function(it2, create) {
        if (!isObject2(it2)) return typeof it2 == "symbol" ? it2 : (typeof it2 == "string" ? "S" : "P") + it2;
        if (!hasOwn(it2, METADATA)) {
          if (!isExtensible(it2)) return "F";
          if (!create) return "E";
          setMetadata(it2);
        }
        return it2[METADATA].objectID;
      };
      var getWeakData = function(it2, create) {
        if (!hasOwn(it2, METADATA)) {
          if (!isExtensible(it2)) return true;
          if (!create) return false;
          setMetadata(it2);
        }
        return it2[METADATA].weakData;
      };
      var onFreeze = function(it2) {
        if (FREEZING && REQUIRED && isExtensible(it2) && !hasOwn(it2, METADATA)) setMetadata(it2);
        return it2;
      };
      var enable = function() {
        meta.enable = function() {
        };
        REQUIRED = true;
        var getOwnPropertyNames = getOwnPropertyNamesModule.f;
        var splice = uncurryThis([].splice);
        var test2 = {};
        test2[METADATA] = 1;
        if (getOwnPropertyNames(test2).length) {
          getOwnPropertyNamesModule.f = function(it2) {
            var result = getOwnPropertyNames(it2);
            for (var i = 0, length = result.length; i < length; i++) {
              if (result[i] === METADATA) {
                splice(result, i, 1);
                break;
              }
            }
            return result;
          };
          $2({ target: "Object", stat: true, forced: true }, {
            getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
          });
        }
      };
      var meta = module.exports = {
        enable,
        fastKey,
        getWeakData,
        onFreeze
      };
      hiddenKeys[METADATA] = true;
    }
  });

  // node_modules/core-js/internals/collection.js
  var require_collection = __commonJS({
    "node_modules/core-js/internals/collection.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var defineBuiltIn = require_define_built_in();
      var InternalMetadataModule = require_internal_metadata();
      var iterate = require_iterate();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var isNullOrUndefined = require_is_null_or_undefined();
      var isObject2 = require_is_object();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var setToStringTag = require_set_to_string_tag();
      var inheritIfRequired = require_inherit_if_required();
      module.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
        var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
        var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
        var ADDER = IS_MAP ? "set" : "add";
        var NativeConstructor = globalThis2[CONSTRUCTOR_NAME];
        var NativePrototype = NativeConstructor && NativeConstructor.prototype;
        var Constructor = NativeConstructor;
        var exported = {};
        var fixMethod = function(KEY) {
          var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
          defineBuiltIn(
            NativePrototype,
            KEY,
            KEY === "add" ? function add(value) {
              uncurriedNativeMethod(this, value === 0 ? 0 : value);
              return this;
            } : KEY === "delete" ? function(key) {
              return IS_WEAK && !isObject2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "get" ? function get(key) {
              return IS_WEAK && !isObject2(key) ? void 0 : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : KEY === "has" ? function has(key) {
              return IS_WEAK && !isObject2(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
            } : function set(key, value) {
              uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
              return this;
            }
          );
        };
        var REPLACE = isForced(
          CONSTRUCTOR_NAME,
          !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
            new NativeConstructor().entries().next();
          }))
        );
        if (REPLACE) {
          Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
          InternalMetadataModule.enable();
        } else if (isForced(CONSTRUCTOR_NAME, true)) {
          var instance = new Constructor();
          var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
          var THROWS_ON_PRIMITIVES = fails(function() {
            instance.has(1);
          });
          var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
            new NativeConstructor(iterable);
          });
          var BUGGY_ZERO = !IS_WEAK && fails(function() {
            var $instance = new NativeConstructor();
            var index = 5;
            while (index--) $instance[ADDER](index, index);
            return !$instance.has(-0);
          });
          if (!ACCEPT_ITERABLES) {
            Constructor = wrapper(function(dummy, iterable) {
              anInstance(dummy, NativePrototype);
              var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
              if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
              return that;
            });
            Constructor.prototype = NativePrototype;
            NativePrototype.constructor = Constructor;
          }
          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod("delete");
            fixMethod("has");
            IS_MAP && fixMethod("get");
          }
          if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
          if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
        }
        exported[CONSTRUCTOR_NAME] = Constructor;
        $2({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);
        setToStringTag(Constructor, CONSTRUCTOR_NAME);
        if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
        return Constructor;
      };
    }
  });

  // node_modules/core-js/internals/collection-strong.js
  var require_collection_strong = __commonJS({
    "node_modules/core-js/internals/collection-strong.js"(exports, module) {
      "use strict";
      var create = require_object_create();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var bind2 = require_function_bind_context();
      var anInstance = require_an_instance();
      var isNullOrUndefined = require_is_null_or_undefined();
      var iterate = require_iterate();
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var setSpecies = require_set_species();
      var DESCRIPTORS = require_descriptors();
      var fastKey = require_internal_metadata().fastKey;
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              index: create(null),
              first: null,
              last: null,
              size: 0
            });
            if (!DESCRIPTORS) that.size = 0;
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define2 = function(that, key, value) {
            var state = getInternalState(that);
            var entry = getEntry(that, key);
            var previous, index;
            if (entry) {
              entry.value = value;
            } else {
              state.last = entry = {
                index: index = fastKey(key, true),
                key,
                value,
                previous: previous = state.last,
                next: null,
                removed: false
              };
              if (!state.first) state.first = entry;
              if (previous) previous.next = entry;
              if (DESCRIPTORS) state.size++;
              else that.size++;
              if (index !== "F") state.index[index] = entry;
            }
            return that;
          };
          var getEntry = function(that, key) {
            var state = getInternalState(that);
            var index = fastKey(key);
            var entry;
            if (index !== "F") return state.index[index];
            for (entry = state.first; entry; entry = entry.next) {
              if (entry.key === key) return entry;
            }
          };
          defineBuiltIns(Prototype, {
            // `{ Map, Set }.prototype.clear()` methods
            // https://tc39.es/ecma262/#sec-map.prototype.clear
            // https://tc39.es/ecma262/#sec-set.prototype.clear
            clear: function clear() {
              var that = this;
              var state = getInternalState(that);
              var entry = state.first;
              while (entry) {
                entry.removed = true;
                if (entry.previous) entry.previous = entry.previous.next = null;
                entry = entry.next;
              }
              state.first = state.last = null;
              state.index = create(null);
              if (DESCRIPTORS) state.size = 0;
              else that.size = 0;
            },
            // `{ Map, Set }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.delete
            // https://tc39.es/ecma262/#sec-set.prototype.delete
            "delete": function(key) {
              var that = this;
              var state = getInternalState(that);
              var entry = getEntry(that, key);
              if (entry) {
                var next = entry.next;
                var prev = entry.previous;
                delete state.index[entry.index];
                entry.removed = true;
                if (prev) prev.next = next;
                if (next) next.previous = prev;
                if (state.first === entry) state.first = next;
                if (state.last === entry) state.last = prev;
                if (DESCRIPTORS) state.size--;
                else that.size--;
              }
              return !!entry;
            },
            // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.foreach
            // https://tc39.es/ecma262/#sec-set.prototype.foreach
            forEach: function forEach2(callbackfn) {
              var state = getInternalState(this);
              var boundFunction = bind2(callbackfn, arguments.length > 1 ? arguments[1] : void 0);
              var entry;
              while (entry = entry ? entry.next : state.first) {
                boundFunction(entry.value, entry.key, this);
                while (entry && entry.removed) entry = entry.previous;
              }
            },
            // `{ Map, Set}.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-map.prototype.has
            // https://tc39.es/ecma262/#sec-set.prototype.has
            has: function has(key) {
              return !!getEntry(this, key);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `Map.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-map.prototype.get
            get: function get(key) {
              var entry = getEntry(this, key);
              return entry && entry.value;
            },
            // `Map.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-map.prototype.set
            set: function set(key, value) {
              return define2(this, key === 0 ? 0 : key, value);
            }
          } : {
            // `Set.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-set.prototype.add
            add: function add(value) {
              return define2(this, value = value === 0 ? 0 : value, value);
            }
          });
          if (DESCRIPTORS) defineBuiltInAccessor(Prototype, "size", {
            configurable: true,
            get: function() {
              return getInternalState(this).size;
            }
          });
          return Constructor;
        },
        setStrong: function(Constructor, CONSTRUCTOR_NAME, IS_MAP) {
          var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
          var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
          defineIterator(Constructor, CONSTRUCTOR_NAME, function(iterated, kind) {
            setInternalState(this, {
              type: ITERATOR_NAME,
              target: iterated,
              state: getInternalCollectionState(iterated),
              kind,
              last: null
            });
          }, function() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var entry = state.last;
            while (entry && entry.removed) entry = entry.previous;
            if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
              state.target = null;
              return createIterResultObject(void 0, true);
            }
            if (kind === "keys") return createIterResultObject(entry.key, false);
            if (kind === "values") return createIterResultObject(entry.value, false);
            return createIterResultObject([entry.key, entry.value], false);
          }, IS_MAP ? "entries" : "values", !IS_MAP, true);
          setSpecies(CONSTRUCTOR_NAME);
        }
      };
    }
  });

  // node_modules/core-js/modules/es.map.constructor.js
  var require_es_map_constructor = __commonJS({
    "node_modules/core-js/modules/es.map.constructor.js"() {
      "use strict";
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Map", function(init) {
        return function Map2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.map.js
  var require_es_map = __commonJS({
    "node_modules/core-js/modules/es.map.js"() {
      "use strict";
      require_es_map_constructor();
    }
  });

  // node_modules/core-js/internals/map-helpers.js
  var require_map_helpers = __commonJS({
    "node_modules/core-js/internals/map-helpers.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var MapPrototype = Map.prototype;
      module.exports = {
        // eslint-disable-next-line es/no-map -- safe
        Map,
        set: uncurryThis(MapPrototype.set),
        get: uncurryThis(MapPrototype.get),
        has: uncurryThis(MapPrototype.has),
        remove: uncurryThis(MapPrototype["delete"]),
        proto: MapPrototype
      };
    }
  });

  // node_modules/core-js/modules/es.map.group-by.js
  var require_es_map_group_by = __commonJS({
    "node_modules/core-js/modules/es.map.group-by.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var requireObjectCoercible = require_require_object_coercible();
      var iterate = require_iterate();
      var MapHelpers = require_map_helpers();
      var IS_PURE = require_is_pure();
      var fails = require_fails();
      var Map2 = MapHelpers.Map;
      var has = MapHelpers.has;
      var get = MapHelpers.get;
      var set = MapHelpers.set;
      var push = uncurryThis([].push);
      var DOES_NOT_WORK_WITH_PRIMITIVES = IS_PURE || fails(function() {
        return Map2.groupBy("ab", function(it2) {
          return it2;
        }).get("a").length !== 1;
      });
      $2({ target: "Map", stat: true, forced: IS_PURE || DOES_NOT_WORK_WITH_PRIMITIVES }, {
        groupBy: function groupBy(items, callbackfn) {
          requireObjectCoercible(items);
          aCallable(callbackfn);
          var map = new Map2();
          var k = 0;
          iterate(items, function(value) {
            var key = callbackfn(value, k++);
            if (!has(map, key)) set(map, key, [value]);
            else push(get(map, key), value);
          });
          return map;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log1p.js
  var require_math_log1p = __commonJS({
    "node_modules/core-js/internals/math-log1p.js"(exports, module) {
      "use strict";
      var log = Math.log;
      module.exports = Math.log1p || function log1p(x2) {
        var n = +x2;
        return n > -1e-8 && n < 1e-8 ? n - n * n / 2 : log(1 + n);
      };
    }
  });

  // node_modules/core-js/modules/es.math.acosh.js
  var require_es_math_acosh = __commonJS({
    "node_modules/core-js/modules/es.math.acosh.js"() {
      "use strict";
      var $2 = require_export();
      var log1p = require_math_log1p();
      var $acosh = Math.acosh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      var LN2 = Math.LN2;
      var FORCED = !$acosh || Math.floor($acosh(Number.MAX_VALUE)) !== 710 || $acosh(Infinity) !== Infinity;
      $2({ target: "Math", stat: true, forced: FORCED }, {
        acosh: function acosh(x2) {
          var n = +x2;
          return n < 1 ? NaN : n > 9490626562425156e-8 ? log(n) + LN2 : log1p(n - 1 + sqrt(n - 1) * sqrt(n + 1));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.asinh.js
  var require_es_math_asinh = __commonJS({
    "node_modules/core-js/modules/es.math.asinh.js"() {
      "use strict";
      var $2 = require_export();
      var $asinh = Math.asinh;
      var log = Math.log;
      var sqrt = Math.sqrt;
      function asinh(x2) {
        var n = +x2;
        return !isFinite(n) || n === 0 ? n : n < 0 ? -asinh(-n) : log(n + sqrt(n * n + 1));
      }
      var FORCED = !($asinh && 1 / $asinh(0) > 0);
      $2({ target: "Math", stat: true, forced: FORCED }, {
        asinh
      });
    }
  });

  // node_modules/core-js/modules/es.math.atanh.js
  var require_es_math_atanh = __commonJS({
    "node_modules/core-js/modules/es.math.atanh.js"() {
      "use strict";
      var $2 = require_export();
      var $atanh = Math.atanh;
      var log = Math.log;
      var FORCED = !($atanh && 1 / $atanh(-0) < 0);
      $2({ target: "Math", stat: true, forced: FORCED }, {
        atanh: function atanh(x2) {
          var n = +x2;
          return n === 0 ? n : log((1 + n) / (1 - n)) / 2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.cbrt.js
  var require_es_math_cbrt = __commonJS({
    "node_modules/core-js/modules/es.math.cbrt.js"() {
      "use strict";
      var $2 = require_export();
      var sign = require_math_sign();
      var abs = Math.abs;
      var pow = Math.pow;
      $2({ target: "Math", stat: true }, {
        cbrt: function cbrt(x2) {
          var n = +x2;
          return sign(n) * pow(abs(n), 1 / 3);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.clz32.js
  var require_es_math_clz32 = __commonJS({
    "node_modules/core-js/modules/es.math.clz32.js"() {
      "use strict";
      var $2 = require_export();
      var floor = Math.floor;
      var log = Math.log;
      var LOG2E = Math.LOG2E;
      $2({ target: "Math", stat: true }, {
        clz32: function clz32(x2) {
          var n = x2 >>> 0;
          return n ? 31 - floor(log(n + 0.5) * LOG2E) : 32;
        }
      });
    }
  });

  // node_modules/core-js/internals/math-expm1.js
  var require_math_expm1 = __commonJS({
    "node_modules/core-js/internals/math-expm1.js"(exports, module) {
      "use strict";
      var $expm1 = Math.expm1;
      var exp = Math.exp;
      module.exports = !$expm1 || $expm1(10) > 22025.465794806718 || $expm1(10) < 22025.465794806718 || $expm1(-2e-17) !== -2e-17 ? function expm1(x2) {
        var n = +x2;
        return n === 0 ? n : n > -1e-6 && n < 1e-6 ? n + n * n / 2 : exp(n) - 1;
      } : $expm1;
    }
  });

  // node_modules/core-js/modules/es.math.cosh.js
  var require_es_math_cosh = __commonJS({
    "node_modules/core-js/modules/es.math.cosh.js"() {
      "use strict";
      var $2 = require_export();
      var expm1 = require_math_expm1();
      var $cosh = Math.cosh;
      var abs = Math.abs;
      var E2 = Math.E;
      var FORCED = !$cosh || $cosh(710) === Infinity;
      $2({ target: "Math", stat: true, forced: FORCED }, {
        cosh: function cosh(x2) {
          var t = expm1(abs(x2) - 1) + 1;
          return (t + 1 / (t * E2 * E2)) * (E2 / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.expm1.js
  var require_es_math_expm1 = __commonJS({
    "node_modules/core-js/modules/es.math.expm1.js"() {
      "use strict";
      var $2 = require_export();
      var expm1 = require_math_expm1();
      $2({ target: "Math", stat: true, forced: expm1 !== Math.expm1 }, { expm1 });
    }
  });

  // node_modules/core-js/modules/es.math.fround.js
  var require_es_math_fround = __commonJS({
    "node_modules/core-js/modules/es.math.fround.js"() {
      "use strict";
      var $2 = require_export();
      var fround = require_math_fround();
      $2({ target: "Math", stat: true }, { fround });
    }
  });

  // node_modules/core-js/modules/es.math.f16round.js
  var require_es_math_f16round = __commonJS({
    "node_modules/core-js/modules/es.math.f16round.js"() {
      "use strict";
      var $2 = require_export();
      var floatRound = require_math_float_round();
      var FLOAT16_EPSILON = 9765625e-10;
      var FLOAT16_MAX_VALUE = 65504;
      var FLOAT16_MIN_VALUE = 6103515625e-14;
      $2({ target: "Math", stat: true }, {
        f16round: function f16round(x2) {
          return floatRound(x2, FLOAT16_EPSILON, FLOAT16_MAX_VALUE, FLOAT16_MIN_VALUE);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.hypot.js
  var require_es_math_hypot = __commonJS({
    "node_modules/core-js/modules/es.math.hypot.js"() {
      "use strict";
      var $2 = require_export();
      var $hypot = Math.hypot;
      var abs = Math.abs;
      var sqrt = Math.sqrt;
      var FORCED = !!$hypot && $hypot(Infinity, NaN) !== Infinity;
      $2({ target: "Math", stat: true, arity: 2, forced: FORCED }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        hypot: function hypot(value1, value2) {
          var sum = 0;
          var i = 0;
          var aLen = arguments.length;
          var larg = 0;
          var arg, div;
          while (i < aLen) {
            arg = abs(arguments[i++]);
            if (larg < arg) {
              div = larg / arg;
              sum = sum * div * div + 1;
              larg = arg;
            } else if (arg > 0) {
              div = arg / larg;
              sum += div * div;
            } else sum += arg;
          }
          return larg === Infinity ? Infinity : larg * sqrt(sum);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.imul.js
  var require_es_math_imul = __commonJS({
    "node_modules/core-js/modules/es.math.imul.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var $imul = Math.imul;
      var FORCED = fails(function() {
        return $imul(4294967295, 5) !== -5 || $imul.length !== 2;
      });
      $2({ target: "Math", stat: true, forced: FORCED }, {
        imul: function imul(x2, y) {
          var UINT16 = 65535;
          var xn2 = +x2;
          var yn2 = +y;
          var xl2 = UINT16 & xn2;
          var yl = UINT16 & yn2;
          return 0 | xl2 * yl + ((UINT16 & xn2 >>> 16) * yl + xl2 * (UINT16 & yn2 >>> 16) << 16 >>> 0);
        }
      });
    }
  });

  // node_modules/core-js/internals/math-log10.js
  var require_math_log10 = __commonJS({
    "node_modules/core-js/internals/math-log10.js"(exports, module) {
      "use strict";
      var log = Math.log;
      var LOG10E = Math.LOG10E;
      module.exports = Math.log10 || function log10(x2) {
        return log(x2) * LOG10E;
      };
    }
  });

  // node_modules/core-js/modules/es.math.log10.js
  var require_es_math_log10 = __commonJS({
    "node_modules/core-js/modules/es.math.log10.js"() {
      "use strict";
      var $2 = require_export();
      var log10 = require_math_log10();
      $2({ target: "Math", stat: true }, {
        log10
      });
    }
  });

  // node_modules/core-js/modules/es.math.log1p.js
  var require_es_math_log1p = __commonJS({
    "node_modules/core-js/modules/es.math.log1p.js"() {
      "use strict";
      var $2 = require_export();
      var log1p = require_math_log1p();
      $2({ target: "Math", stat: true }, { log1p });
    }
  });

  // node_modules/core-js/modules/es.math.log2.js
  var require_es_math_log2 = __commonJS({
    "node_modules/core-js/modules/es.math.log2.js"() {
      "use strict";
      var $2 = require_export();
      var log2 = require_math_log2();
      $2({ target: "Math", stat: true }, {
        log2
      });
    }
  });

  // node_modules/core-js/modules/es.math.sign.js
  var require_es_math_sign = __commonJS({
    "node_modules/core-js/modules/es.math.sign.js"() {
      "use strict";
      var $2 = require_export();
      var sign = require_math_sign();
      $2({ target: "Math", stat: true }, {
        sign
      });
    }
  });

  // node_modules/core-js/modules/es.math.sinh.js
  var require_es_math_sinh = __commonJS({
    "node_modules/core-js/modules/es.math.sinh.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var expm1 = require_math_expm1();
      var abs = Math.abs;
      var exp = Math.exp;
      var E2 = Math.E;
      var FORCED = fails(function() {
        return Math.sinh(-2e-17) !== -2e-17;
      });
      $2({ target: "Math", stat: true, forced: FORCED }, {
        sinh: function sinh(x2) {
          var n = +x2;
          return abs(n) < 1 ? (expm1(n) - expm1(-n)) / 2 : (exp(n - 1) - exp(-n - 1)) * (E2 / 2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.tanh.js
  var require_es_math_tanh = __commonJS({
    "node_modules/core-js/modules/es.math.tanh.js"() {
      "use strict";
      var $2 = require_export();
      var expm1 = require_math_expm1();
      var exp = Math.exp;
      $2({ target: "Math", stat: true }, {
        tanh: function tanh(x2) {
          var n = +x2;
          var a = expm1(n);
          var b = expm1(-n);
          return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (exp(n) + exp(-n));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.math.to-string-tag.js
  var require_es_math_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.math.to-string-tag.js"() {
      "use strict";
      var setToStringTag = require_set_to_string_tag();
      setToStringTag(Math, "Math", true);
    }
  });

  // node_modules/core-js/modules/es.math.trunc.js
  var require_es_math_trunc = __commonJS({
    "node_modules/core-js/modules/es.math.trunc.js"() {
      "use strict";
      var $2 = require_export();
      var trunc = require_math_trunc();
      $2({ target: "Math", stat: true }, {
        trunc
      });
    }
  });

  // node_modules/core-js/internals/this-number-value.js
  var require_this_number_value = __commonJS({
    "node_modules/core-js/internals/this-number-value.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      module.exports = uncurryThis(1 .valueOf);
    }
  });

  // node_modules/core-js/internals/whitespaces.js
  var require_whitespaces = __commonJS({
    "node_modules/core-js/internals/whitespaces.js"(exports, module) {
      "use strict";
      module.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }
  });

  // node_modules/core-js/internals/string-trim.js
  var require_string_trim = __commonJS({
    "node_modules/core-js/internals/string-trim.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString3 = require_to_string();
      var whitespaces = require_whitespaces();
      var replace = uncurryThis("".replace);
      var ltrim = RegExp("^[" + whitespaces + "]+");
      var rtrim = RegExp("(^|[^" + whitespaces + "])[" + whitespaces + "]+$");
      var createMethod = function(TYPE) {
        return function($this) {
          var string = toString3(requireObjectCoercible($this));
          if (TYPE & 1) string = replace(string, ltrim, "");
          if (TYPE & 2) string = replace(string, rtrim, "$1");
          return string;
        };
      };
      module.exports = {
        // `String.prototype.{ trimLeft, trimStart }` methods
        // https://tc39.es/ecma262/#sec-string.prototype.trimstart
        start: createMethod(1),
        // `String.prototype.{ trimRight, trimEnd }` methods
        // https://tc39.es/ecma262/#sec-string.prototype.trimend
        end: createMethod(2),
        // `String.prototype.trim` method
        // https://tc39.es/ecma262/#sec-string.prototype.trim
        trim: createMethod(3)
      };
    }
  });

  // node_modules/core-js/modules/es.number.constructor.js
  var require_es_number_constructor = __commonJS({
    "node_modules/core-js/modules/es.number.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var IS_PURE = require_is_pure();
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var path = require_path();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var hasOwn = require_has_own_property();
      var inheritIfRequired = require_inherit_if_required();
      var isPrototypeOf = require_object_is_prototype_of();
      var isSymbol = require_is_symbol();
      var toPrimitive = require_to_primitive();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var defineProperty = require_object_define_property().f;
      var thisNumberValue = require_this_number_value();
      var trim2 = require_string_trim().trim;
      var NUMBER = "Number";
      var NativeNumber = globalThis2[NUMBER];
      var PureNumberNamespace = path[NUMBER];
      var NumberPrototype = NativeNumber.prototype;
      var TypeError2 = globalThis2.TypeError;
      var stringSlice = uncurryThis("".slice);
      var charCodeAt = uncurryThis("".charCodeAt);
      var toNumeric = function(value) {
        var primValue = toPrimitive(value, "number");
        return typeof primValue == "bigint" ? primValue : toNumber(primValue);
      };
      var toNumber = function(argument) {
        var it2 = toPrimitive(argument, "number");
        var first, third, radix, maxCode, digits, length, index, code;
        if (isSymbol(it2)) throw new TypeError2("Cannot convert a Symbol value to a number");
        if (typeof it2 == "string" && it2.length > 2) {
          it2 = trim2(it2);
          first = charCodeAt(it2, 0);
          if (first === 43 || first === 45) {
            third = charCodeAt(it2, 2);
            if (third === 88 || third === 120) return NaN;
          } else if (first === 48) {
            switch (charCodeAt(it2, 1)) {
              // fast equal of /^0b[01]+$/i
              case 66:
              case 98:
                radix = 2;
                maxCode = 49;
                break;
              // fast equal of /^0o[0-7]+$/i
              case 79:
              case 111:
                radix = 8;
                maxCode = 55;
                break;
              default:
                return +it2;
            }
            digits = stringSlice(it2, 2);
            length = digits.length;
            for (index = 0; index < length; index++) {
              code = charCodeAt(digits, index);
              if (code < 48 || code > maxCode) return NaN;
            }
            return parseInt(digits, radix);
          }
        }
        return +it2;
      };
      var FORCED = isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"));
      var calledWithNew = function(dummy) {
        return isPrototypeOf(NumberPrototype, dummy) && fails(function() {
          thisNumberValue(dummy);
        });
      };
      var NumberWrapper = function Number2(value) {
        var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
        return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
      };
      NumberWrapper.prototype = NumberPrototype;
      if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;
      $2({ global: true, constructor: true, wrap: true, forced: FORCED }, {
        Number: NumberWrapper
      });
      var copyConstructorProperties = function(target, source) {
        for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
          // ES3:
          "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(",")
        ), j = 0, key; keys.length > j; j++) {
          if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
      if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
      if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);
    }
  });

  // node_modules/core-js/modules/es.number.epsilon.js
  var require_es_number_epsilon = __commonJS({
    "node_modules/core-js/modules/es.number.epsilon.js"() {
      "use strict";
      var $2 = require_export();
      $2({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        EPSILON: Math.pow(2, -52)
      });
    }
  });

  // node_modules/core-js/internals/number-is-finite.js
  var require_number_is_finite = __commonJS({
    "node_modules/core-js/internals/number-is-finite.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var globalIsFinite = globalThis2.isFinite;
      module.exports = Number.isFinite || function isFinite2(it2) {
        return typeof it2 == "number" && globalIsFinite(it2);
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-finite.js
  var require_es_number_is_finite = __commonJS({
    "node_modules/core-js/modules/es.number.is-finite.js"() {
      "use strict";
      var $2 = require_export();
      var numberIsFinite = require_number_is_finite();
      $2({ target: "Number", stat: true }, { isFinite: numberIsFinite });
    }
  });

  // node_modules/core-js/internals/is-integral-number.js
  var require_is_integral_number = __commonJS({
    "node_modules/core-js/internals/is-integral-number.js"(exports, module) {
      "use strict";
      var isObject2 = require_is_object();
      var floor = Math.floor;
      module.exports = Number.isInteger || function isInteger(it2) {
        return !isObject2(it2) && isFinite(it2) && floor(it2) === it2;
      };
    }
  });

  // node_modules/core-js/modules/es.number.is-integer.js
  var require_es_number_is_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-integer.js"() {
      "use strict";
      var $2 = require_export();
      var isIntegralNumber = require_is_integral_number();
      $2({ target: "Number", stat: true }, {
        isInteger: isIntegralNumber
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-nan.js
  var require_es_number_is_nan = __commonJS({
    "node_modules/core-js/modules/es.number.is-nan.js"() {
      "use strict";
      var $2 = require_export();
      $2({ target: "Number", stat: true }, {
        isNaN: function isNaN2(number) {
          return number !== number;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.is-safe-integer.js
  var require_es_number_is_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.is-safe-integer.js"() {
      "use strict";
      var $2 = require_export();
      var isIntegralNumber = require_is_integral_number();
      var abs = Math.abs;
      $2({ target: "Number", stat: true }, {
        isSafeInteger: function isSafeInteger(number) {
          return isIntegralNumber(number) && abs(number) <= 9007199254740991;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.max-safe-integer.js
  var require_es_number_max_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.max-safe-integer.js"() {
      "use strict";
      var $2 = require_export();
      $2({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        MAX_SAFE_INTEGER: 9007199254740991
      });
    }
  });

  // node_modules/core-js/modules/es.number.min-safe-integer.js
  var require_es_number_min_safe_integer = __commonJS({
    "node_modules/core-js/modules/es.number.min-safe-integer.js"() {
      "use strict";
      var $2 = require_export();
      $2({ target: "Number", stat: true, nonConfigurable: true, nonWritable: true }, {
        MIN_SAFE_INTEGER: -9007199254740991
      });
    }
  });

  // node_modules/core-js/internals/number-parse-float.js
  var require_number_parse_float = __commonJS({
    "node_modules/core-js/internals/number-parse-float.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var trim2 = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var charAt = uncurryThis("".charAt);
      var $parseFloat = globalThis2.parseFloat;
      var Symbol2 = globalThis2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var FORCED = 1 / $parseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
        $parseFloat(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseFloat2(string) {
        var trimmedString = trim2(toString3(string));
        var result = $parseFloat(trimmedString);
        return result === 0 && charAt(trimmedString, 0) === "-" ? -0 : result;
      } : $parseFloat;
    }
  });

  // node_modules/core-js/modules/es.number.parse-float.js
  var require_es_number_parse_float = __commonJS({
    "node_modules/core-js/modules/es.number.parse-float.js"() {
      "use strict";
      var $2 = require_export();
      var parseFloat2 = require_number_parse_float();
      $2({ target: "Number", stat: true, forced: Number.parseFloat !== parseFloat2 }, {
        parseFloat: parseFloat2
      });
    }
  });

  // node_modules/core-js/internals/number-parse-int.js
  var require_number_parse_int = __commonJS({
    "node_modules/core-js/internals/number-parse-int.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var trim2 = require_string_trim().trim;
      var whitespaces = require_whitespaces();
      var $parseInt = globalThis2.parseInt;
      var Symbol2 = globalThis2.Symbol;
      var ITERATOR = Symbol2 && Symbol2.iterator;
      var hex = /^[+-]?0x/i;
      var exec = uncurryThis(hex.exec);
      var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
        $parseInt(Object(ITERATOR));
      });
      module.exports = FORCED ? function parseInt2(string, radix) {
        var S2 = trim2(toString3(string));
        return $parseInt(S2, radix >>> 0 || (exec(hex, S2) ? 16 : 10));
      } : $parseInt;
    }
  });

  // node_modules/core-js/modules/es.number.parse-int.js
  var require_es_number_parse_int = __commonJS({
    "node_modules/core-js/modules/es.number.parse-int.js"() {
      "use strict";
      var $2 = require_export();
      var parseInt2 = require_number_parse_int();
      $2({ target: "Number", stat: true, forced: Number.parseInt !== parseInt2 }, {
        parseInt: parseInt2
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-exponential.js
  var require_es_number_to_exponential = __commonJS({
    "node_modules/core-js/modules/es.number.to-exponential.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var log10 = require_math_log10();
      var fails = require_fails();
      var $RangeError = RangeError;
      var $String = String;
      var $isFinite = isFinite;
      var abs = Math.abs;
      var floor = Math.floor;
      var pow = Math.pow;
      var round = Math.round;
      var nativeToExponential = uncurryThis(1 .toExponential);
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var ROUNDS_PROPERLY = nativeToExponential(-69e-12, 4) === "-6.9000e-11" && nativeToExponential(1.255, 2) === "1.25e+0" && nativeToExponential(12345, 3) === "1.235e+4" && nativeToExponential(25, 0) === "3e+1";
      var throwsOnInfinityFraction = function() {
        return fails(function() {
          nativeToExponential(1, Infinity);
        }) && fails(function() {
          nativeToExponential(1, -Infinity);
        });
      };
      var properNonFiniteThisCheck = function() {
        return !fails(function() {
          nativeToExponential(Infinity, Infinity);
          nativeToExponential(NaN, Infinity);
        });
      };
      var FORCED = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();
      $2({ target: "Number", proto: true, forced: FORCED }, {
        toExponential: function toExponential(fractionDigits) {
          var x2 = thisNumberValue(this);
          if (fractionDigits === void 0) return nativeToExponential(x2);
          var f = toIntegerOrInfinity(fractionDigits);
          if (!$isFinite(x2)) return String(x2);
          if (f < 0 || f > 20) throw new $RangeError("Incorrect fraction digits");
          if (ROUNDS_PROPERLY) return nativeToExponential(x2, f);
          var s = "";
          var m, e, c, d;
          if (x2 < 0) {
            s = "-";
            x2 = -x2;
          }
          if (x2 === 0) {
            e = 0;
            m = repeat("0", f + 1);
          } else {
            var l = log10(x2);
            e = floor(l);
            var w = pow(10, e - f);
            var n = round(x2 / w);
            if (2 * x2 >= (2 * n + 1) * w) {
              n += 1;
            }
            if (n >= pow(10, f + 1)) {
              n /= 10;
              e += 1;
            }
            m = $String(n);
          }
          if (f !== 0) {
            m = stringSlice(m, 0, 1) + "." + stringSlice(m, 1);
          }
          if (e === 0) {
            c = "+";
            d = "0";
          } else {
            c = e > 0 ? "+" : "-";
            d = $String(abs(e));
          }
          m += "e" + c + d;
          return s + m;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-fixed.js
  var require_es_number_to_fixed = __commonJS({
    "node_modules/core-js/modules/es.number.to-fixed.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var thisNumberValue = require_this_number_value();
      var $repeat = require_string_repeat();
      var fails = require_fails();
      var $RangeError = RangeError;
      var $String = String;
      var floor = Math.floor;
      var repeat = uncurryThis($repeat);
      var stringSlice = uncurryThis("".slice);
      var nativeToFixed = uncurryThis(1 .toFixed);
      var pow = function(x2, n, acc) {
        return n === 0 ? acc : n % 2 === 1 ? pow(x2, n - 1, acc * x2) : pow(x2 * x2, n / 2, acc);
      };
      var log = function(x2) {
        var n = 0;
        var x22 = x2;
        while (x22 >= 4096) {
          n += 12;
          x22 /= 4096;
        }
        while (x22 >= 2) {
          n += 1;
          x22 /= 2;
        }
        return n;
      };
      var multiply = function(data2, n, c) {
        var index = -1;
        var c2 = c;
        while (++index < 6) {
          c2 += n * data2[index];
          data2[index] = c2 % 1e7;
          c2 = floor(c2 / 1e7);
        }
      };
      var divide = function(data2, n) {
        var index = 6;
        var c = 0;
        while (--index >= 0) {
          c += data2[index];
          data2[index] = floor(c / n);
          c = c % n * 1e7;
        }
      };
      var dataToString = function(data2) {
        var index = 6;
        var s = "";
        while (--index >= 0) {
          if (s !== "" || index === 0 || data2[index] !== 0) {
            var t = $String(data2[index]);
            s = s === "" ? t : s + repeat("0", 7 - t.length) + t;
          }
        }
        return s;
      };
      var FORCED = fails(function() {
        return nativeToFixed(8e-5, 3) !== "0.000" || nativeToFixed(0.9, 0) !== "1" || nativeToFixed(1.255, 2) !== "1.25" || nativeToFixed(1000000000000000100, 0) !== "1000000000000000128";
      }) || !fails(function() {
        nativeToFixed({});
      });
      $2({ target: "Number", proto: true, forced: FORCED }, {
        toFixed: function toFixed(fractionDigits) {
          var number = thisNumberValue(this);
          var fractDigits = toIntegerOrInfinity(fractionDigits);
          var data2 = [0, 0, 0, 0, 0, 0];
          var sign = "";
          var result = "0";
          var e, z, j, k;
          if (fractDigits < 0 || fractDigits > 20) throw new $RangeError("Incorrect fraction digits");
          if (number !== number) return "NaN";
          if (number <= -1e21 || number >= 1e21) return $String(number);
          if (number < 0) {
            sign = "-";
            number = -number;
          }
          if (number > 1e-21) {
            e = log(number * pow(2, 69, 1)) - 69;
            z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
            z *= 4503599627370496;
            e = 52 - e;
            if (e > 0) {
              multiply(data2, 0, z);
              j = fractDigits;
              while (j >= 7) {
                multiply(data2, 1e7, 0);
                j -= 7;
              }
              multiply(data2, pow(10, j, 1), 0);
              j = e - 1;
              while (j >= 23) {
                divide(data2, 1 << 23);
                j -= 23;
              }
              divide(data2, 1 << j);
              multiply(data2, 1, 1);
              divide(data2, 2);
              result = dataToString(data2);
            } else {
              multiply(data2, 0, z);
              multiply(data2, 1 << -e, 0);
              result = dataToString(data2) + repeat("0", fractDigits);
            }
          }
          if (fractDigits > 0) {
            k = result.length;
            result = sign + (k <= fractDigits ? "0." + repeat("0", fractDigits - k) + result : stringSlice(result, 0, k - fractDigits) + "." + stringSlice(result, k - fractDigits));
          } else {
            result = sign + result;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.number.to-precision.js
  var require_es_number_to_precision = __commonJS({
    "node_modules/core-js/modules/es.number.to-precision.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var thisNumberValue = require_this_number_value();
      var nativeToPrecision = uncurryThis(1 .toPrecision);
      var FORCED = fails(function() {
        return nativeToPrecision(1, void 0) !== "1";
      }) || !fails(function() {
        nativeToPrecision({});
      });
      $2({ target: "Number", proto: true, forced: FORCED }, {
        toPrecision: function toPrecision(precision) {
          return precision === void 0 ? nativeToPrecision(thisNumberValue(this)) : nativeToPrecision(thisNumberValue(this), precision);
        }
      });
    }
  });

  // node_modules/core-js/internals/object-assign.js
  var require_object_assign = __commonJS({
    "node_modules/core-js/internals/object-assign.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var objectKeys = require_object_keys();
      var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
      var propertyIsEnumerableModule = require_object_property_is_enumerable();
      var toObject = require_to_object();
      var IndexedObject = require_indexed_object();
      var $assign = Object.assign;
      var defineProperty = Object.defineProperty;
      var concat = uncurryThis([].concat);
      module.exports = !$assign || fails(function() {
        if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
          enumerable: true,
          get: function() {
            defineProperty(this, "b", {
              value: 3,
              enumerable: false
            });
          }
        }), { b: 2 })).b !== 1) return true;
        var A2 = {};
        var B2 = {};
        var symbol = Symbol("assign detection");
        var alphabet = "abcdefghijklmnopqrst";
        A2[symbol] = 7;
        alphabet.split("").forEach(function(chr) {
          B2[chr] = chr;
        });
        return $assign({}, A2)[symbol] !== 7 || objectKeys($assign({}, B2)).join("") !== alphabet;
      }) ? function assign(target, source) {
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable = propertyIsEnumerableModule.f;
        while (argumentsLength > index) {
          var S2 = IndexedObject(arguments[index++]);
          var keys = getOwnPropertySymbols ? concat(objectKeys(S2), getOwnPropertySymbols(S2)) : objectKeys(S2);
          var length = keys.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS || call(propertyIsEnumerable, S2, key)) T[key] = S2[key];
          }
        }
        return T;
      } : $assign;
    }
  });

  // node_modules/core-js/modules/es.object.assign.js
  var require_es_object_assign = __commonJS({
    "node_modules/core-js/modules/es.object.assign.js"() {
      "use strict";
      var $2 = require_export();
      var assign = require_object_assign();
      $2({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign }, {
        assign
      });
    }
  });

  // node_modules/core-js/modules/es.object.create.js
  var require_es_object_create = __commonJS({
    "node_modules/core-js/modules/es.object.create.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var create = require_object_create();
      $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        create
      });
    }
  });

  // node_modules/core-js/internals/object-prototype-accessors-forced.js
  var require_object_prototype_accessors_forced = __commonJS({
    "node_modules/core-js/internals/object-prototype-accessors-forced.js"(exports, module) {
      "use strict";
      var IS_PURE = require_is_pure();
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var WEBKIT = require_environment_webkit_version();
      module.exports = IS_PURE || !fails(function() {
        if (WEBKIT && WEBKIT < 535) return;
        var key = Math.random();
        __defineSetter__.call(null, key, function() {
        });
        delete globalThis2[key];
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-getter.js
  var require_es_object_define_getter = __commonJS({
    "node_modules/core-js/modules/es.object.define-getter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __defineGetter__: function __defineGetter__(P, getter) {
            definePropertyModule.f(toObject(this), P, { get: aCallable(getter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.define-properties.js
  var require_es_object_define_properties = __commonJS({
    "node_modules/core-js/modules/es.object.define-properties.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperties = require_object_define_properties().f;
      $2({ target: "Object", stat: true, forced: Object.defineProperties !== defineProperties, sham: !DESCRIPTORS }, {
        defineProperties
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-property.js
  var require_es_object_define_property = __commonJS({
    "node_modules/core-js/modules/es.object.define-property.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var defineProperty = require_object_define_property().f;
      $2({ target: "Object", stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
        defineProperty
      });
    }
  });

  // node_modules/core-js/modules/es.object.define-setter.js
  var require_es_object_define_setter = __commonJS({
    "node_modules/core-js/modules/es.object.define-setter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var aCallable = require_a_callable();
      var toObject = require_to_object();
      var definePropertyModule = require_object_define_property();
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __defineSetter__: function __defineSetter__2(P, setter) {
            definePropertyModule.f(toObject(this), P, { set: aCallable(setter), enumerable: true, configurable: true });
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/object-to-array.js
  var require_object_to_array = __commonJS({
    "node_modules/core-js/internals/object-to-array.js"(exports, module) {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var objectKeys = require_object_keys();
      var toIndexedObject = require_to_indexed_object();
      var $propertyIsEnumerable = require_object_property_is_enumerable().f;
      var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
      var push = uncurryThis([].push);
      var IE_BUG = DESCRIPTORS && fails(function() {
        var O2 = /* @__PURE__ */ Object.create(null);
        O2[2] = 2;
        return !propertyIsEnumerable(O2, 2);
      });
      var createMethod = function(TO_ENTRIES) {
        return function(it2) {
          var O2 = toIndexedObject(it2);
          var keys = objectKeys(O2);
          var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O2) === null;
          var length = keys.length;
          var i = 0;
          var result = [];
          var key;
          while (length > i) {
            key = keys[i++];
            if (!DESCRIPTORS || (IE_WORKAROUND ? key in O2 : propertyIsEnumerable(O2, key))) {
              push(result, TO_ENTRIES ? [key, O2[key]] : O2[key]);
            }
          }
          return result;
        };
      };
      module.exports = {
        // `Object.entries` method
        // https://tc39.es/ecma262/#sec-object.entries
        entries: createMethod(true),
        // `Object.values` method
        // https://tc39.es/ecma262/#sec-object.values
        values: createMethod(false)
      };
    }
  });

  // node_modules/core-js/modules/es.object.entries.js
  var require_es_object_entries = __commonJS({
    "node_modules/core-js/modules/es.object.entries.js"() {
      "use strict";
      var $2 = require_export();
      var $entries = require_object_to_array().entries;
      $2({ target: "Object", stat: true }, {
        entries: function entries(O2) {
          return $entries(O2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.freeze.js
  var require_es_object_freeze = __commonJS({
    "node_modules/core-js/modules/es.object.freeze.js"() {
      "use strict";
      var $2 = require_export();
      var FREEZING = require_freezing();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var $freeze = Object.freeze;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $freeze(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        freeze: function freeze(it2) {
          return $freeze && isObject2(it2) ? $freeze(onFreeze(it2)) : it2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.from-entries.js
  var require_es_object_from_entries = __commonJS({
    "node_modules/core-js/modules/es.object.from-entries.js"() {
      "use strict";
      var $2 = require_export();
      var iterate = require_iterate();
      var createProperty = require_create_property();
      $2({ target: "Object", stat: true }, {
        fromEntries: function fromEntries(iterable) {
          var obj = {};
          iterate(iterable, function(k, v) {
            createProperty(obj, k, v);
          }, { AS_ENTRIES: true });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptor.js
  var require_es_object_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptor.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var toIndexedObject = require_to_indexed_object();
      var nativeGetOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var DESCRIPTORS = require_descriptors();
      var FORCED = !DESCRIPTORS || fails(function() {
        nativeGetOwnPropertyDescriptor(1);
      });
      $2({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it2, key) {
          return nativeGetOwnPropertyDescriptor(toIndexedObject(it2), key);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-descriptors.js
  var require_es_object_get_own_property_descriptors = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-descriptors.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var ownKeys = require_own_keys();
      var toIndexedObject = require_to_indexed_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var createProperty = require_create_property();
      $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
          var O2 = toIndexedObject(object);
          var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var keys = ownKeys(O2);
          var result = {};
          var index = 0;
          var key, descriptor;
          while (keys.length > index) {
            descriptor = getOwnPropertyDescriptor(O2, key = keys[index++]);
            if (descriptor !== void 0) createProperty(result, key, descriptor);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-own-property-names.js
  var require_es_object_get_own_property_names = __commonJS({
    "node_modules/core-js/modules/es.object.get-own-property-names.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var getOwnPropertyNames = require_object_get_own_property_names_external().f;
      var FAILS_ON_PRIMITIVES = fails(function() {
        return !Object.getOwnPropertyNames(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        getOwnPropertyNames
      });
    }
  });

  // node_modules/core-js/modules/es.object.get-prototype-of.js
  var require_es_object_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.get-prototype-of.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var toObject = require_to_object();
      var nativeGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeGetPrototypeOf(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf2(it2) {
          return nativeGetPrototypeOf(toObject(it2));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.group-by.js
  var require_es_object_group_by = __commonJS({
    "node_modules/core-js/modules/es.object.group-by.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var requireObjectCoercible = require_require_object_coercible();
      var toPropertyKey = require_to_property_key();
      var iterate = require_iterate();
      var fails = require_fails();
      var nativeGroupBy = Object.groupBy;
      var create = getBuiltIn("Object", "create");
      var push = uncurryThis([].push);
      var DOES_NOT_WORK_WITH_PRIMITIVES = !nativeGroupBy || fails(function() {
        return nativeGroupBy("ab", function(it2) {
          return it2;
        }).a.length !== 1;
      });
      $2({ target: "Object", stat: true, forced: DOES_NOT_WORK_WITH_PRIMITIVES }, {
        groupBy: function groupBy(items, callbackfn) {
          requireObjectCoercible(items);
          aCallable(callbackfn);
          var obj = create(null);
          var k = 0;
          iterate(items, function(value) {
            var key = toPropertyKey(callbackfn(value, k++));
            if (key in obj) push(obj[key], value);
            else obj[key] = [value];
          });
          return obj;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.has-own.js
  var require_es_object_has_own = __commonJS({
    "node_modules/core-js/modules/es.object.has-own.js"() {
      "use strict";
      var $2 = require_export();
      var hasOwn = require_has_own_property();
      $2({ target: "Object", stat: true }, {
        hasOwn
      });
    }
  });

  // node_modules/core-js/internals/same-value.js
  var require_same_value = __commonJS({
    "node_modules/core-js/internals/same-value.js"(exports, module) {
      "use strict";
      module.exports = Object.is || function is2(x2, y) {
        return x2 === y ? x2 !== 0 || 1 / x2 === 1 / y : x2 !== x2 && y !== y;
      };
    }
  });

  // node_modules/core-js/modules/es.object.is.js
  var require_es_object_is = __commonJS({
    "node_modules/core-js/modules/es.object.is.js"() {
      "use strict";
      var $2 = require_export();
      var is2 = require_same_value();
      $2({ target: "Object", stat: true }, {
        is: is2
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-extensible.js
  var require_es_object_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.object.is-extensible.js"() {
      "use strict";
      var $2 = require_export();
      var $isExtensible = require_object_is_extensible();
      $2({ target: "Object", stat: true, forced: Object.isExtensible !== $isExtensible }, {
        isExtensible: $isExtensible
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-frozen.js
  var require_es_object_is_frozen = __commonJS({
    "node_modules/core-js/modules/es.object.is-frozen.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isFrozen = Object.isFrozen;
      var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function() {
        $isFrozen(1);
      });
      $2({ target: "Object", stat: true, forced: FORCED }, {
        isFrozen: function isFrozen(it2) {
          if (!isObject2(it2)) return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it2) === "ArrayBuffer") return true;
          return $isFrozen ? $isFrozen(it2) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.is-sealed.js
  var require_es_object_is_sealed = __commonJS({
    "node_modules/core-js/modules/es.object.is-sealed.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var ARRAY_BUFFER_NON_EXTENSIBLE = require_array_buffer_non_extensible();
      var $isSealed = Object.isSealed;
      var FORCED = ARRAY_BUFFER_NON_EXTENSIBLE || fails(function() {
        $isSealed(1);
      });
      $2({ target: "Object", stat: true, forced: FORCED }, {
        isSealed: function isSealed(it2) {
          if (!isObject2(it2)) return true;
          if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it2) === "ArrayBuffer") return true;
          return $isSealed ? $isSealed(it2) : false;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.keys.js
  var require_es_object_keys = __commonJS({
    "node_modules/core-js/modules/es.object.keys.js"() {
      "use strict";
      var $2 = require_export();
      var toObject = require_to_object();
      var nativeKeys = require_object_keys();
      var fails = require_fails();
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        keys: function keys(it2) {
          return nativeKeys(toObject(it2));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.lookup-getter.js
  var require_es_object_lookup_getter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-getter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __lookupGetter__: function __lookupGetter__(P) {
            var O2 = toObject(this);
            var key = toPropertyKey(P);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O2, key)) return desc.get;
            } while (O2 = getPrototypeOf2(O2));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.lookup-setter.js
  var require_es_object_lookup_setter = __commonJS({
    "node_modules/core-js/modules/es.object.lookup-setter.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var FORCED = require_object_prototype_accessors_forced();
      var toObject = require_to_object();
      var toPropertyKey = require_to_property_key();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      if (DESCRIPTORS) {
        $2({ target: "Object", proto: true, forced: FORCED }, {
          __lookupSetter__: function __lookupSetter__(P) {
            var O2 = toObject(this);
            var key = toPropertyKey(P);
            var desc;
            do {
              if (desc = getOwnPropertyDescriptor(O2, key)) return desc.set;
            } while (O2 = getPrototypeOf2(O2));
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.object.prevent-extensions.js
  var require_es_object_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.object.prevent-extensions.js"() {
      "use strict";
      var $2 = require_export();
      var isObject2 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $preventExtensions = Object.preventExtensions;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $preventExtensions(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(it2) {
          return $preventExtensions && isObject2(it2) ? $preventExtensions(onFreeze(it2)) : it2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.proto.js
  var require_es_object_proto = __commonJS({
    "node_modules/core-js/modules/es.object.proto.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var isObject2 = require_is_object();
      var isPossiblePrototype = require_is_possible_prototype();
      var toObject = require_to_object();
      var requireObjectCoercible = require_require_object_coercible();
      var getPrototypeOf2 = Object.getPrototypeOf;
      var setPrototypeOf = Object.setPrototypeOf;
      var ObjectPrototype = Object.prototype;
      var PROTO = "__proto__";
      if (DESCRIPTORS && getPrototypeOf2 && setPrototypeOf && !(PROTO in ObjectPrototype)) try {
        defineBuiltInAccessor(ObjectPrototype, PROTO, {
          configurable: true,
          get: function __proto__() {
            return getPrototypeOf2(toObject(this));
          },
          set: function __proto__(proto) {
            var O2 = requireObjectCoercible(this);
            if (isPossiblePrototype(proto) && isObject2(O2)) {
              setPrototypeOf(O2, proto);
            }
          }
        });
      } catch (error) {
      }
    }
  });

  // node_modules/core-js/modules/es.object.seal.js
  var require_es_object_seal = __commonJS({
    "node_modules/core-js/modules/es.object.seal.js"() {
      "use strict";
      var $2 = require_export();
      var isObject2 = require_is_object();
      var onFreeze = require_internal_metadata().onFreeze;
      var FREEZING = require_freezing();
      var fails = require_fails();
      var $seal = Object.seal;
      var FAILS_ON_PRIMITIVES = fails(function() {
        $seal(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
        seal: function seal(it2) {
          return $seal && isObject2(it2) ? $seal(onFreeze(it2)) : it2;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.object.set-prototype-of.js
  var require_es_object_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.object.set-prototype-of.js"() {
      "use strict";
      var $2 = require_export();
      var setPrototypeOf = require_object_set_prototype_of();
      $2({ target: "Object", stat: true }, {
        setPrototypeOf
      });
    }
  });

  // node_modules/core-js/internals/object-to-string.js
  var require_object_to_string = __commonJS({
    "node_modules/core-js/internals/object-to-string.js"(exports, module) {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var classof = require_classof();
      module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString3() {
        return "[object " + classof(this) + "]";
      };
    }
  });

  // node_modules/core-js/modules/es.object.to-string.js
  var require_es_object_to_string = __commonJS({
    "node_modules/core-js/modules/es.object.to-string.js"() {
      "use strict";
      var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
      var defineBuiltIn = require_define_built_in();
      var toString3 = require_object_to_string();
      if (!TO_STRING_TAG_SUPPORT) {
        defineBuiltIn(Object.prototype, "toString", toString3, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.object.values.js
  var require_es_object_values = __commonJS({
    "node_modules/core-js/modules/es.object.values.js"() {
      "use strict";
      var $2 = require_export();
      var $values = require_object_to_array().values;
      $2({ target: "Object", stat: true }, {
        values: function values(O2) {
          return $values(O2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.parse-float.js
  var require_es_parse_float = __commonJS({
    "node_modules/core-js/modules/es.parse-float.js"() {
      "use strict";
      var $2 = require_export();
      var $parseFloat = require_number_parse_float();
      $2({ global: true, forced: parseFloat !== $parseFloat }, {
        parseFloat: $parseFloat
      });
    }
  });

  // node_modules/core-js/modules/es.parse-int.js
  var require_es_parse_int = __commonJS({
    "node_modules/core-js/modules/es.parse-int.js"() {
      "use strict";
      var $2 = require_export();
      var $parseInt = require_number_parse_int();
      $2({ global: true, forced: parseInt !== $parseInt }, {
        parseInt: $parseInt
      });
    }
  });

  // node_modules/core-js/internals/a-constructor.js
  var require_a_constructor = __commonJS({
    "node_modules/core-js/internals/a-constructor.js"(exports, module) {
      "use strict";
      var isConstructor = require_is_constructor();
      var tryToString = require_try_to_string();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isConstructor(argument)) return argument;
        throw new $TypeError(tryToString(argument) + " is not a constructor");
      };
    }
  });

  // node_modules/core-js/internals/species-constructor.js
  var require_species_constructor = __commonJS({
    "node_modules/core-js/internals/species-constructor.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var aConstructor = require_a_constructor();
      var isNullOrUndefined = require_is_null_or_undefined();
      var wellKnownSymbol = require_well_known_symbol();
      var SPECIES = wellKnownSymbol("species");
      module.exports = function(O2, defaultConstructor) {
        var C2 = anObject(O2).constructor;
        var S2;
        return C2 === void 0 || isNullOrUndefined(S2 = anObject(C2)[SPECIES]) ? defaultConstructor : aConstructor(S2);
      };
    }
  });

  // node_modules/core-js/internals/validate-arguments-length.js
  var require_validate_arguments_length = __commonJS({
    "node_modules/core-js/internals/validate-arguments-length.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      module.exports = function(passed, required) {
        if (passed < required) throw new $TypeError("Not enough arguments");
        return passed;
      };
    }
  });

  // node_modules/core-js/internals/environment-is-ios.js
  var require_environment_is_ios = __commonJS({
    "node_modules/core-js/internals/environment-is-ios.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/task.js
  var require_task = __commonJS({
    "node_modules/core-js/internals/task.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var bind2 = require_function_bind_context();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var fails = require_fails();
      var html = require_html();
      var arraySlice = require_array_slice();
      var createElement = require_document_create_element();
      var validateArgumentsLength = require_validate_arguments_length();
      var IS_IOS = require_environment_is_ios();
      var IS_NODE = require_environment_is_node();
      var set = globalThis2.setImmediate;
      var clear = globalThis2.clearImmediate;
      var process2 = globalThis2.process;
      var Dispatch = globalThis2.Dispatch;
      var Function2 = globalThis2.Function;
      var MessageChannel2 = globalThis2.MessageChannel;
      var String2 = globalThis2.String;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var $location;
      var defer;
      var channel;
      var port;
      fails(function() {
        $location = globalThis2.location;
      });
      var run = function(id) {
        if (hasOwn(queue, id)) {
          var fn2 = queue[id];
          delete queue[id];
          fn2();
        }
      };
      var runner = function(id) {
        return function() {
          run(id);
        };
      };
      var eventListener = function(event) {
        run(event.data);
      };
      var globalPostMessageDefer = function(id) {
        globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
      };
      if (!set || !clear) {
        set = function setImmediate2(handler) {
          validateArgumentsLength(arguments.length, 1);
          var fn2 = isCallable(handler) ? handler : Function2(handler);
          var args = arraySlice(arguments, 1);
          queue[++counter] = function() {
            apply(fn2, void 0, args);
          };
          defer(counter);
          return counter;
        };
        clear = function clearImmediate(id) {
          delete queue[id];
        };
        if (IS_NODE) {
          defer = function(id) {
            process2.nextTick(runner(id));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function(id) {
            Dispatch.now(runner(id));
          };
        } else if (MessageChannel2 && !IS_IOS) {
          channel = new MessageChannel2();
          port = channel.port2;
          channel.port1.onmessage = eventListener;
          defer = bind2(port.postMessage, port);
        } else if (globalThis2.addEventListener && isCallable(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails(globalPostMessageDefer)) {
          defer = globalPostMessageDefer;
          globalThis2.addEventListener("message", eventListener, false);
        } else if (ONREADYSTATECHANGE in createElement("script")) {
          defer = function(id) {
            html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run(id);
            };
          };
        } else {
          defer = function(id) {
            setTimeout(runner(id), 0);
          };
        }
      }
      module.exports = {
        set,
        clear
      };
    }
  });

  // node_modules/core-js/internals/safe-get-built-in.js
  var require_safe_get_built_in = __commonJS({
    "node_modules/core-js/internals/safe-get-built-in.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var DESCRIPTORS = require_descriptors();
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      module.exports = function(name) {
        if (!DESCRIPTORS) return globalThis2[name];
        var descriptor = getOwnPropertyDescriptor(globalThis2, name);
        return descriptor && descriptor.value;
      };
    }
  });

  // node_modules/core-js/internals/queue.js
  var require_queue = __commonJS({
    "node_modules/core-js/internals/queue.js"(exports, module) {
      "use strict";
      var Queue = function() {
        this.head = null;
        this.tail = null;
      };
      Queue.prototype = {
        add: function(item) {
          var entry = { item, next: null };
          var tail = this.tail;
          if (tail) tail.next = entry;
          else this.head = entry;
          this.tail = entry;
        },
        get: function() {
          var entry = this.head;
          if (entry) {
            var next = this.head = entry.next;
            if (next === null) this.tail = null;
            return entry.item;
          }
        }
      };
      module.exports = Queue;
    }
  });

  // node_modules/core-js/internals/environment-is-ios-pebble.js
  var require_environment_is_ios_pebble = __commonJS({
    "node_modules/core-js/internals/environment-is-ios-pebble.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
    }
  });

  // node_modules/core-js/internals/environment-is-webos-webkit.js
  var require_environment_is_webos_webkit = __commonJS({
    "node_modules/core-js/internals/environment-is-webos-webkit.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /web0s(?!.*chrome)/i.test(userAgent);
    }
  });

  // node_modules/core-js/internals/microtask.js
  var require_microtask = __commonJS({
    "node_modules/core-js/internals/microtask.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var safeGetBuiltIn = require_safe_get_built_in();
      var bind2 = require_function_bind_context();
      var macrotask = require_task().set;
      var Queue = require_queue();
      var IS_IOS = require_environment_is_ios();
      var IS_IOS_PEBBLE = require_environment_is_ios_pebble();
      var IS_WEBOS_WEBKIT = require_environment_is_webos_webkit();
      var IS_NODE = require_environment_is_node();
      var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
      var document2 = globalThis2.document;
      var process2 = globalThis2.process;
      var Promise2 = globalThis2.Promise;
      var microtask = safeGetBuiltIn("queueMicrotask");
      var notify;
      var toggle;
      var node;
      var promise;
      var then;
      if (!microtask) {
        queue = new Queue();
        flush = function() {
          var parent, fn2;
          if (IS_NODE && (parent = process2.domain)) parent.exit();
          while (fn2 = queue.get()) try {
            fn2();
          } catch (error) {
            if (queue.head) notify();
            throw error;
          }
          if (parent) parent.enter();
        };
        if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
          toggle = true;
          node = document2.createTextNode("");
          new MutationObserver(flush).observe(node, { characterData: true });
          notify = function() {
            node.data = toggle = !toggle;
          };
        } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
          promise = Promise2.resolve(void 0);
          promise.constructor = Promise2;
          then = bind2(promise.then, promise);
          notify = function() {
            then(flush);
          };
        } else if (IS_NODE) {
          notify = function() {
            process2.nextTick(flush);
          };
        } else {
          macrotask = bind2(macrotask, globalThis2);
          notify = function() {
            macrotask(flush);
          };
        }
        microtask = function(fn2) {
          if (!queue.head) notify();
          queue.add(fn2);
        };
      }
      var queue;
      var flush;
      module.exports = microtask;
    }
  });

  // node_modules/core-js/internals/host-report-errors.js
  var require_host_report_errors = __commonJS({
    "node_modules/core-js/internals/host-report-errors.js"(exports, module) {
      "use strict";
      module.exports = function(a, b) {
        try {
          arguments.length === 1 ? console.error(a) : console.error(a, b);
        } catch (error) {
        }
      };
    }
  });

  // node_modules/core-js/internals/perform.js
  var require_perform = __commonJS({
    "node_modules/core-js/internals/perform.js"(exports, module) {
      "use strict";
      module.exports = function(exec) {
        try {
          return { error: false, value: exec() };
        } catch (error) {
          return { error: true, value: error };
        }
      };
    }
  });

  // node_modules/core-js/internals/promise-native-constructor.js
  var require_promise_native_constructor = __commonJS({
    "node_modules/core-js/internals/promise-native-constructor.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      module.exports = globalThis2.Promise;
    }
  });

  // node_modules/core-js/internals/promise-constructor-detection.js
  var require_promise_constructor_detection = __commonJS({
    "node_modules/core-js/internals/promise-constructor-detection.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var NativePromiseConstructor = require_promise_native_constructor();
      var isCallable = require_is_callable();
      var isForced = require_is_forced();
      var inspectSource = require_inspect_source();
      var wellKnownSymbol = require_well_known_symbol();
      var ENVIRONMENT = require_environment();
      var IS_PURE = require_is_pure();
      var V8_VERSION = require_environment_v8_version();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var SPECIES = wellKnownSymbol("species");
      var SUBCLASSING = false;
      var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis2.PromiseRejectionEvent);
      var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
        var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
        var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
        if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
        if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
        if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
          var promise = new NativePromiseConstructor(function(resolve) {
            resolve(1);
          });
          var FakePromise = function(exec) {
            exec(function() {
            }, function() {
            });
          };
          var constructor = promise.constructor = {};
          constructor[SPECIES] = FakePromise;
          SUBCLASSING = promise.then(function() {
          }) instanceof FakePromise;
          if (!SUBCLASSING) return true;
        }
        return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
      });
      module.exports = {
        CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
        REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
        SUBCLASSING
      };
    }
  });

  // node_modules/core-js/internals/new-promise-capability.js
  var require_new_promise_capability = __commonJS({
    "node_modules/core-js/internals/new-promise-capability.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var $TypeError = TypeError;
      var PromiseCapability = function(C2) {
        var resolve, reject;
        this.promise = new C2(function($$resolve, $$reject) {
          if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aCallable(resolve);
        this.reject = aCallable(reject);
      };
      module.exports.f = function(C2) {
        return new PromiseCapability(C2);
      };
    }
  });

  // node_modules/core-js/modules/es.promise.constructor.js
  var require_es_promise_constructor = __commonJS({
    "node_modules/core-js/modules/es.promise.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var IS_PURE = require_is_pure();
      var IS_NODE = require_environment_is_node();
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var setPrototypeOf = require_object_set_prototype_of();
      var setToStringTag = require_set_to_string_tag();
      var setSpecies = require_set_species();
      var aCallable = require_a_callable();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var anInstance = require_an_instance();
      var speciesConstructor = require_species_constructor();
      var task = require_task().set;
      var microtask = require_microtask();
      var hostReportErrors = require_host_report_errors();
      var perform = require_perform();
      var Queue = require_queue();
      var InternalStateModule = require_internal_state();
      var NativePromiseConstructor = require_promise_native_constructor();
      var PromiseConstructorDetection = require_promise_constructor_detection();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var PROMISE = "Promise";
      var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
      var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
      var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
      var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
      var setInternalState = InternalStateModule.set;
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var PromiseConstructor = NativePromiseConstructor;
      var PromisePrototype = NativePromisePrototype;
      var TypeError2 = globalThis2.TypeError;
      var document2 = globalThis2.document;
      var process2 = globalThis2.process;
      var newPromiseCapability = newPromiseCapabilityModule.f;
      var newGenericPromiseCapability = newPromiseCapability;
      var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
      var UNHANDLED_REJECTION = "unhandledrejection";
      var REJECTION_HANDLED = "rejectionhandled";
      var PENDING = 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var HANDLED = 1;
      var UNHANDLED = 2;
      var Internal;
      var OwnPromiseCapability;
      var PromiseWrapper;
      var nativeThen;
      var isThenable2 = function(it2) {
        var then;
        return isObject2(it2) && isCallable(then = it2.then) ? then : false;
      };
      var callReaction = function(reaction, state) {
        var value = state.value;
        var ok = state.state === FULFILLED;
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(state);
              state.rejection = HANDLED;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(new TypeError2("Promise-chain cycle"));
            } else if (then = isThenable2(result)) {
              call(then, result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      };
      var notify = function(state, isReject) {
        if (state.notified) return;
        state.notified = true;
        microtask(function() {
          var reactions = state.reactions;
          var reaction;
          while (reaction = reactions.get()) {
            callReaction(reaction, state);
          }
          state.notified = false;
          if (isReject && !state.rejection) onUnhandled(state);
        });
      };
      var dispatchEvent = function(name, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
          event = document2.createEvent("Event");
          event.promise = promise;
          event.reason = reason;
          event.initEvent(name, false, true);
          globalThis2.dispatchEvent(event);
        } else event = { promise, reason };
        if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name])) handler(event);
        else if (name === UNHANDLED_REJECTION) hostReportErrors("Unhandled promise rejection", reason);
      };
      var onUnhandled = function(state) {
        call(task, globalThis2, function() {
          var promise = state.facade;
          var value = state.value;
          var IS_UNHANDLED = isUnhandled(state);
          var result;
          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process2.emit("unhandledRejection", value, promise);
              } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
          }
        });
      };
      var isUnhandled = function(state) {
        return state.rejection !== HANDLED && !state.parent;
      };
      var onHandleUnhandled = function(state) {
        call(task, globalThis2, function() {
          var promise = state.facade;
          if (IS_NODE) {
            process2.emit("rejectionHandled", promise);
          } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
        });
      };
      var bind2 = function(fn2, state, unwrap) {
        return function(value) {
          fn2(state, value, unwrap);
        };
      };
      var internalReject = function(state, value, unwrap) {
        if (state.done) return;
        state.done = true;
        if (unwrap) state = unwrap;
        state.value = value;
        state.state = REJECTED;
        notify(state, true);
      };
      var internalResolve = function(state, value, unwrap) {
        if (state.done) return;
        state.done = true;
        if (unwrap) state = unwrap;
        try {
          if (state.facade === value) throw new TypeError2("Promise can't be resolved itself");
          var then = isThenable2(value);
          if (then) {
            microtask(function() {
              var wrapper = { done: false };
              try {
                call(
                  then,
                  value,
                  bind2(internalResolve, wrapper, state),
                  bind2(internalReject, wrapper, state)
                );
              } catch (error) {
                internalReject(wrapper, error, state);
              }
            });
          } else {
            state.value = value;
            state.state = FULFILLED;
            notify(state, false);
          }
        } catch (error) {
          internalReject({ done: false }, error, state);
        }
      };
      if (FORCED_PROMISE_CONSTRUCTOR) {
        PromiseConstructor = function Promise2(executor) {
          anInstance(this, PromisePrototype);
          aCallable(executor);
          call(Internal, this);
          var state = getInternalPromiseState(this);
          try {
            executor(bind2(internalResolve, state), bind2(internalReject, state));
          } catch (error) {
            internalReject(state, error);
          }
        };
        PromisePrototype = PromiseConstructor.prototype;
        Internal = function Promise2(executor) {
          setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: new Queue(),
            rejection: false,
            state: PENDING,
            value: null
          });
        };
        Internal.prototype = defineBuiltIn(PromisePrototype, "then", function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          state.parent = true;
          reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
          reaction.fail = isCallable(onRejected) && onRejected;
          reaction.domain = IS_NODE ? process2.domain : void 0;
          if (state.state === PENDING) state.reactions.add(reaction);
          else microtask(function() {
            callReaction(reaction, state);
          });
          return reaction.promise;
        });
        OwnPromiseCapability = function() {
          var promise = new Internal();
          var state = getInternalPromiseState(promise);
          this.promise = promise;
          this.resolve = bind2(internalResolve, state);
          this.reject = bind2(internalReject, state);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function(C2) {
          return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
        };
        if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
          nativeThen = NativePromisePrototype.then;
          if (!NATIVE_PROMISE_SUBCLASSING) {
            defineBuiltIn(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
              var that = this;
              return new PromiseConstructor(function(resolve, reject) {
                call(nativeThen, that, resolve, reject);
              }).then(onFulfilled, onRejected);
            }, { unsafe: true });
          }
          try {
            delete NativePromisePrototype.constructor;
          } catch (error) {
          }
          if (setPrototypeOf) {
            setPrototypeOf(NativePromisePrototype, PromisePrototype);
          }
        }
      }
      $2({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
        Promise: PromiseConstructor
      });
      setToStringTag(PromiseConstructor, PROMISE, false, true);
      setSpecies(PROMISE);
    }
  });

  // node_modules/core-js/internals/promise-statics-incorrect-iteration.js
  var require_promise_statics_incorrect_iteration = __commonJS({
    "node_modules/core-js/internals/promise-statics-incorrect-iteration.js"(exports, module) {
      "use strict";
      var NativePromiseConstructor = require_promise_native_constructor();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function(iterable) {
        NativePromiseConstructor.all(iterable).then(void 0, function() {
        });
      });
    }
  });

  // node_modules/core-js/modules/es.promise.all.js
  var require_es_promise_all = __commonJS({
    "node_modules/core-js/modules/es.promise.all.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        all: function all3(iterable) {
          var C2 = this;
          var capability = newPromiseCapabilityModule.f(C2);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C2.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call($promiseResolve, C2, promise).then(function(value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.catch.js
  var require_es_promise_catch = __commonJS({
    "node_modules/core-js/modules/es.promise.catch.js"() {
      "use strict";
      var $2 = require_export();
      var IS_PURE = require_is_pure();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      var NativePromiseConstructor = require_promise_native_constructor();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var defineBuiltIn = require_define_built_in();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
        "catch": function(onRejected) {
          return this.then(void 0, onRejected);
        }
      });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        method = getBuiltIn("Promise").prototype["catch"];
        if (NativePromisePrototype["catch"] !== method) {
          defineBuiltIn(NativePromisePrototype, "catch", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.promise.race.js
  var require_es_promise_race = __commonJS({
    "node_modules/core-js/modules/es.promise.race.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        race: function race(iterable) {
          var C2 = this;
          var capability = newPromiseCapabilityModule.f(C2);
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aCallable(C2.resolve);
            iterate(iterable, function(promise) {
              call($promiseResolve, C2, promise).then(capability.resolve, reject);
            });
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.reject.js
  var require_es_promise_reject = __commonJS({
    "node_modules/core-js/modules/es.promise.reject.js"() {
      "use strict";
      var $2 = require_export();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
        reject: function reject(r) {
          var capability = newPromiseCapabilityModule.f(this);
          var capabilityReject = capability.reject;
          capabilityReject(r);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/internals/promise-resolve.js
  var require_promise_resolve = __commonJS({
    "node_modules/core-js/internals/promise-resolve.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var newPromiseCapability = require_new_promise_capability();
      module.exports = function(C2, x2) {
        anObject(C2);
        if (isObject2(x2) && x2.constructor === C2) return x2;
        var promiseCapability = newPromiseCapability.f(C2);
        var resolve = promiseCapability.resolve;
        resolve(x2);
        return promiseCapability.promise;
      };
    }
  });

  // node_modules/core-js/modules/es.promise.resolve.js
  var require_es_promise_resolve = __commonJS({
    "node_modules/core-js/modules/es.promise.resolve.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var IS_PURE = require_is_pure();
      var NativePromiseConstructor = require_promise_native_constructor();
      var FORCED_PROMISE_CONSTRUCTOR = require_promise_constructor_detection().CONSTRUCTOR;
      var promiseResolve = require_promise_resolve();
      var PromiseConstructorWrapper = getBuiltIn("Promise");
      var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
      $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
        resolve: function resolve(x2) {
          return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.js
  var require_es_promise = __commonJS({
    "node_modules/core-js/modules/es.promise.js"() {
      "use strict";
      require_es_promise_constructor();
      require_es_promise_all();
      require_es_promise_catch();
      require_es_promise_race();
      require_es_promise_reject();
      require_es_promise_resolve();
    }
  });

  // node_modules/core-js/modules/es.promise.all-settled.js
  var require_es_promise_all_settled = __commonJS({
    "node_modules/core-js/modules/es.promise.all-settled.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        allSettled: function allSettled(iterable) {
          var C2 = this;
          var capability = newPromiseCapabilityModule.f(C2);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C2.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyCalled = false;
              remaining++;
              call(promiseResolve, C2, promise).then(function(value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = { status: "fulfilled", value };
                --remaining || resolve(values);
              }, function(error) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[index] = { status: "rejected", reason: error };
                --remaining || resolve(values);
              });
            });
            --remaining || resolve(values);
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.any.js
  var require_es_promise_any = __commonJS({
    "node_modules/core-js/modules/es.promise.any.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var aCallable = require_a_callable();
      var getBuiltIn = require_get_built_in();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var perform = require_perform();
      var iterate = require_iterate();
      var PROMISE_STATICS_INCORRECT_ITERATION = require_promise_statics_incorrect_iteration();
      var PROMISE_ANY_ERROR = "No one promise resolved";
      $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
        any: function any(iterable) {
          var C2 = this;
          var AggregateError = getBuiltIn("AggregateError");
          var capability = newPromiseCapabilityModule.f(C2);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var promiseResolve = aCallable(C2.resolve);
            var errors = [];
            var counter = 0;
            var remaining = 1;
            var alreadyResolved = false;
            iterate(iterable, function(promise) {
              var index = counter++;
              var alreadyRejected = false;
              remaining++;
              call(promiseResolve, C2, promise).then(function(value) {
                if (alreadyRejected || alreadyResolved) return;
                alreadyResolved = true;
                resolve(value);
              }, function(error) {
                if (alreadyRejected || alreadyResolved) return;
                alreadyRejected = true;
                errors[index] = error;
                --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
              });
            });
            --remaining || reject(new AggregateError(errors, PROMISE_ANY_ERROR));
          });
          if (result.error) reject(result.value);
          return capability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.finally.js
  var require_es_promise_finally = __commonJS({
    "node_modules/core-js/modules/es.promise.finally.js"() {
      "use strict";
      var $2 = require_export();
      var IS_PURE = require_is_pure();
      var NativePromiseConstructor = require_promise_native_constructor();
      var fails = require_fails();
      var getBuiltIn = require_get_built_in();
      var isCallable = require_is_callable();
      var speciesConstructor = require_species_constructor();
      var promiseResolve = require_promise_resolve();
      var defineBuiltIn = require_define_built_in();
      var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
      var NON_GENERIC = !!NativePromiseConstructor && fails(function() {
        NativePromisePrototype["finally"].call({ then: function() {
        } }, function() {
        });
      });
      $2({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
        "finally": function(onFinally) {
          var C2 = speciesConstructor(this, getBuiltIn("Promise"));
          var isFunction2 = isCallable(onFinally);
          return this.then(
            isFunction2 ? function(x2) {
              return promiseResolve(C2, onFinally()).then(function() {
                return x2;
              });
            } : onFinally,
            isFunction2 ? function(e) {
              return promiseResolve(C2, onFinally()).then(function() {
                throw e;
              });
            } : onFinally
          );
        }
      });
      if (!IS_PURE && isCallable(NativePromiseConstructor)) {
        method = getBuiltIn("Promise").prototype["finally"];
        if (NativePromisePrototype["finally"] !== method) {
          defineBuiltIn(NativePromisePrototype, "finally", method, { unsafe: true });
        }
      }
      var method;
    }
  });

  // node_modules/core-js/modules/es.promise.try.js
  var require_es_promise_try = __commonJS({
    "node_modules/core-js/modules/es.promise.try.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var slice = require_array_slice();
      var newPromiseCapabilityModule = require_new_promise_capability();
      var aCallable = require_a_callable();
      var perform = require_perform();
      var Promise2 = globalThis2.Promise;
      var ACCEPT_ARGUMENTS = false;
      var FORCED = !Promise2 || !Promise2["try"] || perform(function() {
        Promise2["try"](function(argument) {
          ACCEPT_ARGUMENTS = argument === 8;
        }, 8);
      }).error || !ACCEPT_ARGUMENTS;
      $2({ target: "Promise", stat: true, forced: FORCED }, {
        "try": function(callbackfn) {
          var args = arguments.length > 1 ? slice(arguments, 1) : [];
          var promiseCapability = newPromiseCapabilityModule.f(this);
          var result = perform(function() {
            return apply(aCallable(callbackfn), void 0, args);
          });
          (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
          return promiseCapability.promise;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.promise.with-resolvers.js
  var require_es_promise_with_resolvers = __commonJS({
    "node_modules/core-js/modules/es.promise.with-resolvers.js"() {
      "use strict";
      var $2 = require_export();
      var newPromiseCapabilityModule = require_new_promise_capability();
      $2({ target: "Promise", stat: true }, {
        withResolvers: function withResolvers() {
          var promiseCapability = newPromiseCapabilityModule.f(this);
          return {
            promise: promiseCapability.promise,
            resolve: promiseCapability.resolve,
            reject: promiseCapability.reject
          };
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.apply.js
  var require_es_reflect_apply = __commonJS({
    "node_modules/core-js/modules/es.reflect.apply.js"() {
      "use strict";
      var $2 = require_export();
      var functionApply = require_function_apply();
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var fails = require_fails();
      var OPTIONAL_ARGUMENTS_LIST = !fails(function() {
        Reflect.apply(function() {
        });
      });
      $2({ target: "Reflect", stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
        apply: function apply(target, thisArgument, argumentsList) {
          return functionApply(aCallable(target), thisArgument, anObject(argumentsList));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.construct.js
  var require_es_reflect_construct = __commonJS({
    "node_modules/core-js/modules/es.reflect.construct.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var apply = require_function_apply();
      var bind2 = require_function_bind();
      var aConstructor = require_a_constructor();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var create = require_object_create();
      var fails = require_fails();
      var nativeConstruct = getBuiltIn("Reflect", "construct");
      var ObjectPrototype = Object.prototype;
      var push = [].push;
      var NEW_TARGET_BUG = fails(function() {
        function F2() {
        }
        return !(nativeConstruct(function() {
        }, [], F2) instanceof F2);
      });
      var ARGS_BUG = !fails(function() {
        nativeConstruct(function() {
        });
      });
      var FORCED = NEW_TARGET_BUG || ARGS_BUG;
      $2({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
        construct: function construct(Target, args) {
          aConstructor(Target);
          anObject(args);
          var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
          if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
          if (Target === newTarget) {
            switch (args.length) {
              case 0:
                return new Target();
              case 1:
                return new Target(args[0]);
              case 2:
                return new Target(args[0], args[1]);
              case 3:
                return new Target(args[0], args[1], args[2]);
              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            }
            var $args = [null];
            apply(push, $args, args);
            return new (apply(bind2, Target, $args))();
          }
          var proto = newTarget.prototype;
          var instance = create(isObject2(proto) ? proto : ObjectPrototype);
          var result = apply(Target, instance, args);
          return isObject2(result) ? result : instance;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.define-property.js
  var require_es_reflect_define_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.define-property.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var toPropertyKey = require_to_property_key();
      var definePropertyModule = require_object_define_property();
      var fails = require_fails();
      var ERROR_INSTEAD_OF_FALSE = fails(function() {
        Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
      });
      $2({ target: "Reflect", stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          anObject(target);
          var key = toPropertyKey(propertyKey);
          anObject(attributes);
          try {
            definePropertyModule.f(target, key, attributes);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.delete-property.js
  var require_es_reflect_delete_property = __commonJS({
    "node_modules/core-js/modules/es.reflect.delete-property.js"() {
      "use strict";
      var $2 = require_export();
      var anObject = require_an_object();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      $2({ target: "Reflect", stat: true }, {
        deleteProperty: function deleteProperty(target, propertyKey) {
          var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
          return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
        }
      });
    }
  });

  // node_modules/core-js/internals/is-data-descriptor.js
  var require_is_data_descriptor = __commonJS({
    "node_modules/core-js/internals/is-data-descriptor.js"(exports, module) {
      "use strict";
      var hasOwn = require_has_own_property();
      module.exports = function(descriptor) {
        return descriptor !== void 0 && (hasOwn(descriptor, "value") || hasOwn(descriptor, "writable"));
      };
    }
  });

  // node_modules/core-js/modules/es.reflect.get.js
  var require_es_reflect_get = __commonJS({
    "node_modules/core-js/modules/es.reflect.get.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var isObject2 = require_is_object();
      var anObject = require_an_object();
      var isDataDescriptor = require_is_data_descriptor();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf2 = require_object_get_prototype_of();
      function get(target, propertyKey) {
        var receiver = arguments.length < 3 ? target : arguments[2];
        var descriptor, prototype3;
        if (anObject(target) === receiver) return target[propertyKey];
        descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);
        if (descriptor) return isDataDescriptor(descriptor) ? descriptor.value : descriptor.get === void 0 ? void 0 : call(descriptor.get, receiver);
        if (isObject2(prototype3 = getPrototypeOf2(target))) return get(prototype3, propertyKey, receiver);
      }
      $2({ target: "Reflect", stat: true }, {
        get
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js
  var require_es_reflect_get_own_property_descriptor = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js"() {
      "use strict";
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var anObject = require_an_object();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      $2({ target: "Reflect", stat: true, sham: !DESCRIPTORS }, {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.get-prototype-of.js
  var require_es_reflect_get_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.get-prototype-of.js"() {
      "use strict";
      var $2 = require_export();
      var anObject = require_an_object();
      var objectGetPrototypeOf = require_object_get_prototype_of();
      var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
      $2({ target: "Reflect", stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
        getPrototypeOf: function getPrototypeOf2(target) {
          return objectGetPrototypeOf(anObject(target));
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.has.js
  var require_es_reflect_has = __commonJS({
    "node_modules/core-js/modules/es.reflect.has.js"() {
      "use strict";
      var $2 = require_export();
      $2({ target: "Reflect", stat: true }, {
        has: function has(target, propertyKey) {
          return propertyKey in target;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.is-extensible.js
  var require_es_reflect_is_extensible = __commonJS({
    "node_modules/core-js/modules/es.reflect.is-extensible.js"() {
      "use strict";
      var $2 = require_export();
      var anObject = require_an_object();
      var $isExtensible = require_object_is_extensible();
      $2({ target: "Reflect", stat: true }, {
        isExtensible: function isExtensible(target) {
          anObject(target);
          return $isExtensible(target);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.own-keys.js
  var require_es_reflect_own_keys = __commonJS({
    "node_modules/core-js/modules/es.reflect.own-keys.js"() {
      "use strict";
      var $2 = require_export();
      var ownKeys = require_own_keys();
      $2({ target: "Reflect", stat: true }, {
        ownKeys
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.prevent-extensions.js
  var require_es_reflect_prevent_extensions = __commonJS({
    "node_modules/core-js/modules/es.reflect.prevent-extensions.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var anObject = require_an_object();
      var FREEZING = require_freezing();
      $2({ target: "Reflect", stat: true, sham: !FREEZING }, {
        preventExtensions: function preventExtensions(target) {
          anObject(target);
          try {
            var objectPreventExtensions = getBuiltIn("Object", "preventExtensions");
            if (objectPreventExtensions) objectPreventExtensions(target);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set.js
  var require_es_reflect_set = __commonJS({
    "node_modules/core-js/modules/es.reflect.set.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var isDataDescriptor = require_is_data_descriptor();
      var fails = require_fails();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var getPrototypeOf2 = require_object_get_prototype_of();
      var createPropertyDescriptor = require_create_property_descriptor();
      function set(target, propertyKey, V2) {
        var receiver = arguments.length < 4 ? target : arguments[3];
        var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
        var existingDescriptor, prototype3, setter;
        if (!ownDescriptor) {
          if (isObject2(prototype3 = getPrototypeOf2(target))) {
            return set(prototype3, propertyKey, V2, receiver);
          }
          ownDescriptor = createPropertyDescriptor(0);
        }
        if (isDataDescriptor(ownDescriptor)) {
          if (ownDescriptor.writable === false || !isObject2(receiver)) return false;
          if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
            if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
            existingDescriptor.value = V2;
            definePropertyModule.f(receiver, propertyKey, existingDescriptor);
          } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V2));
        } else {
          setter = ownDescriptor.set;
          if (setter === void 0) return false;
          call(setter, receiver, V2);
        }
        return true;
      }
      var MS_EDGE_BUG = fails(function() {
        var Constructor = function() {
        };
        var object = definePropertyModule.f(new Constructor(), "a", { configurable: true });
        return Reflect.set(Constructor.prototype, "a", 1, object) !== false;
      });
      $2({ target: "Reflect", stat: true, forced: MS_EDGE_BUG }, {
        set
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.set-prototype-of.js
  var require_es_reflect_set_prototype_of = __commonJS({
    "node_modules/core-js/modules/es.reflect.set-prototype-of.js"() {
      "use strict";
      var $2 = require_export();
      var anObject = require_an_object();
      var aPossiblePrototype = require_a_possible_prototype();
      var objectSetPrototypeOf = require_object_set_prototype_of();
      if (objectSetPrototypeOf) $2({ target: "Reflect", stat: true }, {
        setPrototypeOf: function setPrototypeOf(target, proto) {
          anObject(target);
          aPossiblePrototype(proto);
          try {
            objectSetPrototypeOf(target, proto);
            return true;
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.reflect.to-string-tag.js
  var require_es_reflect_to_string_tag = __commonJS({
    "node_modules/core-js/modules/es.reflect.to-string-tag.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var setToStringTag = require_set_to_string_tag();
      $2({ global: true }, { Reflect: {} });
      setToStringTag(globalThis2.Reflect, "Reflect", true);
    }
  });

  // node_modules/core-js/internals/is-regexp.js
  var require_is_regexp = __commonJS({
    "node_modules/core-js/internals/is-regexp.js"(exports, module) {
      "use strict";
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(it2) {
        var isRegExp2;
        return isObject2(it2) && ((isRegExp2 = it2[MATCH]) !== void 0 ? !!isRegExp2 : classof(it2) === "RegExp");
      };
    }
  });

  // node_modules/core-js/internals/regexp-flags.js
  var require_regexp_flags = __commonJS({
    "node_modules/core-js/internals/regexp-flags.js"(exports, module) {
      "use strict";
      var anObject = require_an_object();
      module.exports = function() {
        var that = anObject(this);
        var result = "";
        if (that.hasIndices) result += "d";
        if (that.global) result += "g";
        if (that.ignoreCase) result += "i";
        if (that.multiline) result += "m";
        if (that.dotAll) result += "s";
        if (that.unicode) result += "u";
        if (that.unicodeSets) result += "v";
        if (that.sticky) result += "y";
        return result;
      };
    }
  });

  // node_modules/core-js/internals/regexp-get-flags.js
  var require_regexp_get_flags = __commonJS({
    "node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var hasOwn = require_has_own_property();
      var isPrototypeOf = require_object_is_prototype_of();
      var regExpFlags = require_regexp_flags();
      var RegExpPrototype = RegExp.prototype;
      module.exports = function(R) {
        var flags = R.flags;
        return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
      };
    }
  });

  // node_modules/core-js/internals/regexp-sticky-helpers.js
  var require_regexp_sticky_helpers = __commonJS({
    "node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $RegExp = globalThis2.RegExp;
      var UNSUPPORTED_Y = fails(function() {
        var re2 = $RegExp("a", "y");
        re2.lastIndex = 2;
        return re2.exec("abcd") !== null;
      });
      var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
        return !$RegExp("a", "y").sticky;
      });
      var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
        var re2 = $RegExp("^r", "gy");
        re2.lastIndex = 2;
        return re2.exec("str") !== null;
      });
      module.exports = {
        BROKEN_CARET,
        MISSED_STICKY,
        UNSUPPORTED_Y
      };
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-dot-all.js
  var require_regexp_unsupported_dot_all = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $RegExp = globalThis2.RegExp;
      module.exports = fails(function() {
        var re2 = $RegExp(".", "s");
        return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
      });
    }
  });

  // node_modules/core-js/internals/regexp-unsupported-ncg.js
  var require_regexp_unsupported_ncg = __commonJS({
    "node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var $RegExp = globalThis2.RegExp;
      module.exports = fails(function() {
        var re2 = $RegExp("(?<a>b)", "g");
        return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.constructor.js
  var require_es_regexp_constructor = __commonJS({
    "node_modules/core-js/modules/es.regexp.constructor.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var isForced = require_is_forced();
      var inheritIfRequired = require_inherit_if_required();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var create = require_object_create();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var isPrototypeOf = require_object_is_prototype_of();
      var isRegExp2 = require_is_regexp();
      var toString3 = require_to_string();
      var getRegExpFlags = require_regexp_get_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var proxyAccessor = require_proxy_accessor();
      var defineBuiltIn = require_define_built_in();
      var fails = require_fails();
      var hasOwn = require_has_own_property();
      var enforceInternalState = require_internal_state().enforce;
      var setSpecies = require_set_species();
      var wellKnownSymbol = require_well_known_symbol();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var MATCH = wellKnownSymbol("match");
      var NativeRegExp = globalThis2.RegExp;
      var RegExpPrototype = NativeRegExp.prototype;
      var SyntaxError = globalThis2.SyntaxError;
      var exec = uncurryThis(RegExpPrototype.exec);
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
      var re1 = /a/g;
      var re2 = /a/g;
      var CORRECT_NEW = new NativeRegExp(re1) !== re1;
      var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var BASE_FORCED = DESCRIPTORS && (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function() {
        re2[MATCH] = false;
        return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, "i")) !== "/a/i";
      }));
      var handleDotAll = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var brackets = false;
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            result += chr + charAt(string, ++index2);
            continue;
          }
          if (!brackets && chr === ".") {
            result += "[\\s\\S]";
          } else {
            if (chr === "[") {
              brackets = true;
            } else if (chr === "]") {
              brackets = false;
            }
            result += chr;
          }
        }
        return result;
      };
      var handleNCG = function(string) {
        var length = string.length;
        var index2 = 0;
        var result = "";
        var named = [];
        var names = create(null);
        var brackets = false;
        var ncg = false;
        var groupid = 0;
        var groupname = "";
        var chr;
        for (; index2 <= length; index2++) {
          chr = charAt(string, index2);
          if (chr === "\\") {
            chr += charAt(string, ++index2);
          } else if (chr === "]") {
            brackets = false;
          } else if (!brackets) switch (true) {
            case chr === "[":
              brackets = true;
              break;
            case chr === "(":
              result += chr;
              if (stringSlice(string, index2 + 1, index2 + 3) === "?:") {
                continue;
              }
              if (exec(IS_NCG, stringSlice(string, index2 + 1))) {
                index2 += 2;
                ncg = true;
              }
              groupid++;
              continue;
            case (chr === ">" && ncg):
              if (groupname === "" || hasOwn(names, groupname)) {
                throw new SyntaxError("Invalid capture group name");
              }
              names[groupname] = true;
              named[named.length] = [groupname, groupid];
              ncg = false;
              groupname = "";
              continue;
          }
          if (ncg) groupname += chr;
          else result += chr;
        }
        return [result, named];
      };
      if (isForced("RegExp", BASE_FORCED)) {
        RegExpWrapper = function RegExp2(pattern, flags) {
          var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
          var patternIsRegExp = isRegExp2(pattern);
          var flagsAreUndefined = flags === void 0;
          var groups = [];
          var rawPattern = pattern;
          var rawFlags, dotAll, sticky, handled, result, state;
          if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
            return pattern;
          }
          if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
            pattern = pattern.source;
            if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
          }
          pattern = pattern === void 0 ? "" : toString3(pattern);
          flags = flags === void 0 ? "" : toString3(flags);
          rawPattern = pattern;
          if (UNSUPPORTED_DOT_ALL && "dotAll" in re1) {
            dotAll = !!flags && stringIndexOf(flags, "s") > -1;
            if (dotAll) flags = replace(flags, /s/g, "");
          }
          rawFlags = flags;
          if (MISSED_STICKY && "sticky" in re1) {
            sticky = !!flags && stringIndexOf(flags, "y") > -1;
            if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, "");
          }
          if (UNSUPPORTED_NCG) {
            handled = handleNCG(pattern);
            pattern = handled[0];
            groups = handled[1];
          }
          result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
          if (dotAll || sticky || groups.length) {
            state = enforceInternalState(result);
            if (dotAll) {
              state.dotAll = true;
              state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
            }
            if (sticky) state.sticky = true;
            if (groups.length) state.groups = groups;
          }
          if (pattern !== rawPattern) try {
            createNonEnumerableProperty(result, "source", rawPattern === "" ? "(?:)" : rawPattern);
          } catch (error) {
          }
          return result;
        };
        for (keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index; ) {
          proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
        }
        RegExpPrototype.constructor = RegExpWrapper;
        RegExpWrapper.prototype = RegExpPrototype;
        defineBuiltIn(globalThis2, "RegExp", RegExpWrapper, { constructor: true });
      }
      var RegExpWrapper;
      var keys;
      var index;
      setSpecies("RegExp");
    }
  });

  // node_modules/core-js/internals/a-string.js
  var require_a_string = __commonJS({
    "node_modules/core-js/internals/a-string.js"(exports, module) {
      "use strict";
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (typeof argument == "string") return argument;
        throw new $TypeError("Argument is not a string");
      };
    }
  });

  // node_modules/core-js/modules/es.regexp.escape.js
  var require_es_regexp_escape = __commonJS({
    "node_modules/core-js/modules/es.regexp.escape.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var aString = require_a_string();
      var hasOwn = require_has_own_property();
      var padStart = require_string_pad().start;
      var WHITESPACES = require_whitespaces();
      var $Array = Array;
      var $escape = RegExp.escape;
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var numberToString = uncurryThis(1.1.toString);
      var join = uncurryThis([].join);
      var FIRST_DIGIT_OR_ASCII = /^[0-9a-z]/i;
      var SYNTAX_SOLIDUS = /^[$()*+./?[\\\]^{|}]/;
      var OTHER_PUNCTUATORS_AND_WHITESPACES = RegExp("^[!\"#%&',\\-:;<=>@`~" + WHITESPACES + "]");
      var exec = uncurryThis(FIRST_DIGIT_OR_ASCII.exec);
      var ControlEscape = {
        "	": "t",
        "\n": "n",
        "\v": "v",
        "\f": "f",
        "\r": "r"
      };
      var escapeChar = function(chr) {
        var hex = numberToString(charCodeAt(chr, 0), 16);
        return hex.length < 3 ? "\\x" + padStart(hex, 2, "0") : "\\u" + padStart(hex, 4, "0");
      };
      var FORCED = !$escape || $escape("ab") !== "\\x61b";
      $2({ target: "RegExp", stat: true, forced: FORCED }, {
        escape: function escape(S2) {
          aString(S2);
          var length = S2.length;
          var result = $Array(length);
          for (var i = 0; i < length; i++) {
            var chr = charAt(S2, i);
            if (i === 0 && exec(FIRST_DIGIT_OR_ASCII, chr)) {
              result[i] = escapeChar(chr);
            } else if (hasOwn(ControlEscape, chr)) {
              result[i] = "\\" + ControlEscape[chr];
            } else if (exec(SYNTAX_SOLIDUS, chr)) {
              result[i] = "\\" + chr;
            } else if (exec(OTHER_PUNCTUATORS_AND_WHITESPACES, chr)) {
              result[i] = escapeChar(chr);
            } else {
              var charCode = charCodeAt(chr, 0);
              if ((charCode & 63488) !== 55296) result[i] = chr;
              else if (charCode >= 56320 || i + 1 >= length || (charCodeAt(S2, i + 1) & 64512) !== 56320) result[i] = escapeChar(chr);
              else {
                result[i] = chr;
                result[++i] = charAt(S2, i);
              }
            }
          }
          return join(result, "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.dot-all.js
  var require_es_regexp_dot_all = __commonJS({
    "node_modules/core-js/modules/es.regexp.dot-all.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var classof = require_classof_raw();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
        defineBuiltInAccessor(RegExpPrototype, "dotAll", {
          configurable: true,
          get: function dotAll() {
            if (this === RegExpPrototype) return;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).dotAll;
            }
            throw new $TypeError("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/internals/regexp-exec.js
  var require_regexp_exec = __commonJS({
    "node_modules/core-js/internals/regexp-exec.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var regexpFlags = require_regexp_flags();
      var stickyHelpers = require_regexp_sticky_helpers();
      var shared = require_shared();
      var create = require_object_create();
      var getInternalState = require_internal_state().get;
      var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
      var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
      var nativeReplace = shared("native-string-replace", String.prototype.replace);
      var nativeExec = RegExp.prototype.exec;
      var patchedExec = nativeExec;
      var charAt = uncurryThis("".charAt);
      var indexOf = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var UPDATES_LAST_INDEX_WRONG = function() {
        var re1 = /a/;
        var re2 = /b*/g;
        call(nativeExec, re1, "a");
        call(nativeExec, re2, "a");
        return re1.lastIndex !== 0 || re2.lastIndex !== 0;
      }();
      var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
      var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
      var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
      if (PATCH) {
        patchedExec = function exec(string) {
          var re2 = this;
          var state = getInternalState(re2);
          var str = toString3(string);
          var raw = state.raw;
          var result, reCopy, lastIndex, match, i, object, group;
          if (raw) {
            raw.lastIndex = re2.lastIndex;
            result = call(patchedExec, raw, str);
            re2.lastIndex = raw.lastIndex;
            return result;
          }
          var groups = state.groups;
          var sticky = UNSUPPORTED_Y && re2.sticky;
          var flags = call(regexpFlags, re2);
          var source = re2.source;
          var charsAdded = 0;
          var strCopy = str;
          if (sticky) {
            flags = replace(flags, "y", "");
            if (indexOf(flags, "g") === -1) {
              flags += "g";
            }
            strCopy = stringSlice(str, re2.lastIndex);
            if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt(str, re2.lastIndex - 1) !== "\n")) {
              source = "(?: " + source + ")";
              strCopy = " " + strCopy;
              charsAdded++;
            }
            reCopy = new RegExp("^(?:" + source + ")", flags);
          }
          if (NPCG_INCLUDED) {
            reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
          }
          if (UPDATES_LAST_INDEX_WRONG) lastIndex = re2.lastIndex;
          match = call(nativeExec, sticky ? reCopy : re2, strCopy);
          if (sticky) {
            if (match) {
              match.input = stringSlice(match.input, charsAdded);
              match[0] = stringSlice(match[0], charsAdded);
              match.index = re2.lastIndex;
              re2.lastIndex += match[0].length;
            } else re2.lastIndex = 0;
          } else if (UPDATES_LAST_INDEX_WRONG && match) {
            re2.lastIndex = re2.global ? match.index + match[0].length : lastIndex;
          }
          if (NPCG_INCLUDED && match && match.length > 1) {
            call(nativeReplace, match[0], reCopy, function() {
              for (i = 1; i < arguments.length - 2; i++) {
                if (arguments[i] === void 0) match[i] = void 0;
              }
            });
          }
          if (match && groups) {
            match.groups = object = create(null);
            for (i = 0; i < groups.length; i++) {
              group = groups[i];
              object[group[0]] = match[group[1]];
            }
          }
          return match;
        };
      }
      module.exports = patchedExec;
    }
  });

  // node_modules/core-js/modules/es.regexp.exec.js
  var require_es_regexp_exec = __commonJS({
    "node_modules/core-js/modules/es.regexp.exec.js"() {
      "use strict";
      var $2 = require_export();
      var exec = require_regexp_exec();
      $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
        exec
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.flags.js
  var require_es_regexp_flags = __commonJS({
    "node_modules/core-js/modules/es.regexp.flags.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var DESCRIPTORS = require_descriptors();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var regExpFlags = require_regexp_flags();
      var fails = require_fails();
      var RegExp2 = globalThis2.RegExp;
      var RegExpPrototype = RegExp2.prototype;
      var FORCED = DESCRIPTORS && fails(function() {
        var INDICES_SUPPORT = true;
        try {
          RegExp2(".", "d");
        } catch (error) {
          INDICES_SUPPORT = false;
        }
        var O2 = {};
        var calls = "";
        var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
        var addGetter = function(key2, chr) {
          Object.defineProperty(O2, key2, { get: function() {
            calls += chr;
            return true;
          } });
        };
        var pairs = {
          dotAll: "s",
          global: "g",
          ignoreCase: "i",
          multiline: "m",
          sticky: "y"
        };
        if (INDICES_SUPPORT) pairs.hasIndices = "d";
        for (var key in pairs) addGetter(key, pairs[key]);
        var result = Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call(O2);
        return result !== expected || calls !== expected;
      });
      if (FORCED) defineBuiltInAccessor(RegExpPrototype, "flags", {
        configurable: true,
        get: regExpFlags
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.sticky.js
  var require_es_regexp_sticky = __commonJS({
    "node_modules/core-js/modules/es.regexp.sticky.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var MISSED_STICKY = require_regexp_sticky_helpers().MISSED_STICKY;
      var classof = require_classof_raw();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var getInternalState = require_internal_state().get;
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      if (DESCRIPTORS && MISSED_STICKY) {
        defineBuiltInAccessor(RegExpPrototype, "sticky", {
          configurable: true,
          get: function sticky() {
            if (this === RegExpPrototype) return;
            if (classof(this) === "RegExp") {
              return !!getInternalState(this).sticky;
            }
            throw new $TypeError("Incompatible receiver, RegExp required");
          }
        });
      }
    }
  });

  // node_modules/core-js/modules/es.regexp.test.js
  var require_es_regexp_test = __commonJS({
    "node_modules/core-js/modules/es.regexp.test.js"() {
      "use strict";
      require_es_regexp_exec();
      var $2 = require_export();
      var call = require_function_call();
      var isCallable = require_is_callable();
      var anObject = require_an_object();
      var toString3 = require_to_string();
      var DELEGATES_TO_EXEC = function() {
        var execCalled = false;
        var re2 = /[ac]/;
        re2.exec = function() {
          execCalled = true;
          return /./.exec.apply(this, arguments);
        };
        return re2.test("abc") === true && execCalled;
      }();
      var nativeTest = /./.test;
      $2({ target: "RegExp", proto: true, forced: !DELEGATES_TO_EXEC }, {
        test: function(S2) {
          var R = anObject(this);
          var string = toString3(S2);
          var exec = R.exec;
          if (!isCallable(exec)) return call(nativeTest, R, string);
          var result = call(exec, R, string);
          if (result === null) return false;
          anObject(result);
          return true;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.regexp.to-string.js
  var require_es_regexp_to_string = __commonJS({
    "node_modules/core-js/modules/es.regexp.to-string.js"() {
      "use strict";
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var defineBuiltIn = require_define_built_in();
      var anObject = require_an_object();
      var $toString = require_to_string();
      var fails = require_fails();
      var getRegExpFlags = require_regexp_get_flags();
      var TO_STRING = "toString";
      var RegExpPrototype = RegExp.prototype;
      var nativeToString = RegExpPrototype[TO_STRING];
      var NOT_GENERIC = fails(function() {
        return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
      });
      var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
      if (NOT_GENERIC || INCORRECT_NAME) {
        defineBuiltIn(RegExpPrototype, TO_STRING, function toString3() {
          var R = anObject(this);
          var pattern = $toString(R.source);
          var flags = $toString(getRegExpFlags(R));
          return "/" + pattern + "/" + flags;
        }, { unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/es.set.constructor.js
  var require_es_set_constructor = __commonJS({
    "node_modules/core-js/modules/es.set.constructor.js"() {
      "use strict";
      var collection = require_collection();
      var collectionStrong = require_collection_strong();
      collection("Set", function(init) {
        return function Set2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionStrong);
    }
  });

  // node_modules/core-js/modules/es.set.js
  var require_es_set = __commonJS({
    "node_modules/core-js/modules/es.set.js"() {
      "use strict";
      require_es_set_constructor();
    }
  });

  // node_modules/core-js/internals/set-helpers.js
  var require_set_helpers = __commonJS({
    "node_modules/core-js/internals/set-helpers.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var SetPrototype = Set.prototype;
      module.exports = {
        // eslint-disable-next-line es/no-set -- safe
        Set,
        add: uncurryThis(SetPrototype.add),
        has: uncurryThis(SetPrototype.has),
        remove: uncurryThis(SetPrototype["delete"]),
        proto: SetPrototype
      };
    }
  });

  // node_modules/core-js/internals/a-set.js
  var require_a_set = __commonJS({
    "node_modules/core-js/internals/a-set.js"(exports, module) {
      "use strict";
      var has = require_set_helpers().has;
      module.exports = function(it2) {
        has(it2);
        return it2;
      };
    }
  });

  // node_modules/core-js/internals/iterate-simple.js
  var require_iterate_simple = __commonJS({
    "node_modules/core-js/internals/iterate-simple.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      module.exports = function(record, fn2, ITERATOR_INSTEAD_OF_RECORD) {
        var iterator2 = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
        var next = record.next;
        var step, result;
        while (!(step = call(next, iterator2)).done) {
          result = fn2(step.value);
          if (result !== void 0) return result;
        }
      };
    }
  });

  // node_modules/core-js/internals/set-iterate.js
  var require_set_iterate = __commonJS({
    "node_modules/core-js/internals/set-iterate.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var iterateSimple = require_iterate_simple();
      var SetHelpers = require_set_helpers();
      var Set2 = SetHelpers.Set;
      var SetPrototype = SetHelpers.proto;
      var forEach2 = uncurryThis(SetPrototype.forEach);
      var keys = uncurryThis(SetPrototype.keys);
      var next = keys(new Set2()).next;
      module.exports = function(set, fn2, interruptible) {
        return interruptible ? iterateSimple({ iterator: keys(set), next }, fn2) : forEach2(set, fn2);
      };
    }
  });

  // node_modules/core-js/internals/set-clone.js
  var require_set_clone = __commonJS({
    "node_modules/core-js/internals/set-clone.js"(exports, module) {
      "use strict";
      var SetHelpers = require_set_helpers();
      var iterate = require_set_iterate();
      var Set2 = SetHelpers.Set;
      var add = SetHelpers.add;
      module.exports = function(set) {
        var result = new Set2();
        iterate(set, function(it2) {
          add(result, it2);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-size.js
  var require_set_size = __commonJS({
    "node_modules/core-js/internals/set-size.js"(exports, module) {
      "use strict";
      var uncurryThisAccessor = require_function_uncurry_this_accessor();
      var SetHelpers = require_set_helpers();
      module.exports = uncurryThisAccessor(SetHelpers.proto, "size", "get") || function(set) {
        return set.size;
      };
    }
  });

  // node_modules/core-js/internals/get-set-record.js
  var require_get_set_record = __commonJS({
    "node_modules/core-js/internals/get-set-record.js"(exports, module) {
      "use strict";
      var aCallable = require_a_callable();
      var anObject = require_an_object();
      var call = require_function_call();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var getIteratorDirect = require_get_iterator_direct();
      var INVALID_SIZE = "Invalid size";
      var $RangeError = RangeError;
      var $TypeError = TypeError;
      var max = Math.max;
      var SetRecord = function(set, intSize) {
        this.set = set;
        this.size = max(intSize, 0);
        this.has = aCallable(set.has);
        this.keys = aCallable(set.keys);
      };
      SetRecord.prototype = {
        getIterator: function() {
          return getIteratorDirect(anObject(call(this.keys, this.set)));
        },
        includes: function(it2) {
          return call(this.has, this.set, it2);
        }
      };
      module.exports = function(obj) {
        anObject(obj);
        var numSize = +obj.size;
        if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
        var intSize = toIntegerOrInfinity(numSize);
        if (intSize < 0) throw new $RangeError(INVALID_SIZE);
        return new SetRecord(obj, intSize);
      };
    }
  });

  // node_modules/core-js/internals/set-difference.js
  var require_set_difference = __commonJS({
    "node_modules/core-js/internals/set-difference.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var clone = require_set_clone();
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var has = SetHelpers.has;
      var remove = SetHelpers.remove;
      module.exports = function difference(other) {
        var O2 = aSet(this);
        var otherRec = getSetRecord(other);
        var result = clone(O2);
        if (size(O2) <= otherRec.size) iterateSet(O2, function(e) {
          if (otherRec.includes(e)) remove(result, e);
        });
        else iterateSimple(otherRec.getIterator(), function(e) {
          if (has(O2, e)) remove(result, e);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/internals/set-method-accept-set-like.js
  var require_set_method_accept_set_like = __commonJS({
    "node_modules/core-js/internals/set-method-accept-set-like.js"(exports, module) {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var createSetLike = function(size) {
        return {
          size,
          has: function() {
            return false;
          },
          keys: function() {
            return {
              next: function() {
                return { done: true };
              }
            };
          }
        };
      };
      var createSetLikeWithInfinitySize = function(size) {
        return {
          size,
          has: function() {
            return true;
          },
          keys: function() {
            throw new Error("e");
          }
        };
      };
      module.exports = function(name, callback) {
        var Set2 = getBuiltIn("Set");
        try {
          new Set2()[name](createSetLike(0));
          try {
            new Set2()[name](createSetLike(-1));
            return false;
          } catch (error2) {
            if (!callback) return true;
            try {
              new Set2()[name](createSetLikeWithInfinitySize(-Infinity));
              return false;
            } catch (error) {
              var set = new Set2();
              set.add(1);
              set.add(2);
              return callback(set[name](createSetLikeWithInfinitySize(Infinity)));
            }
          }
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.set.difference.v2.js
  var require_es_set_difference_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.difference.v2.js"() {
      "use strict";
      var $2 = require_export();
      var difference = require_set_difference();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("difference", function(result) {
        return result.size === 0;
      });
      $2({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        difference
      });
    }
  });

  // node_modules/core-js/internals/set-intersection.js
  var require_set_intersection = __commonJS({
    "node_modules/core-js/internals/set-intersection.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var Set2 = SetHelpers.Set;
      var add = SetHelpers.add;
      var has = SetHelpers.has;
      module.exports = function intersection(other) {
        var O2 = aSet(this);
        var otherRec = getSetRecord(other);
        var result = new Set2();
        if (size(O2) > otherRec.size) {
          iterateSimple(otherRec.getIterator(), function(e) {
            if (has(O2, e)) add(result, e);
          });
        } else {
          iterateSet(O2, function(e) {
            if (otherRec.includes(e)) add(result, e);
          });
        }
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.intersection.v2.js
  var require_es_set_intersection_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.intersection.v2.js"() {
      "use strict";
      var $2 = require_export();
      var fails = require_fails();
      var intersection = require_set_intersection();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("intersection", function(result) {
        return result.size === 2 && result.has(1) && result.has(2);
      }) || fails(function() {
        return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
      });
      $2({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        intersection
      });
    }
  });

  // node_modules/core-js/internals/set-is-disjoint-from.js
  var require_set_is_disjoint_from = __commonJS({
    "node_modules/core-js/internals/set-is-disjoint-from.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var has = require_set_helpers().has;
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSet = require_set_iterate();
      var iterateSimple = require_iterate_simple();
      var iteratorClose = require_iterator_close();
      module.exports = function isDisjointFrom(other) {
        var O2 = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O2) <= otherRec.size) return iterateSet(O2, function(e) {
          if (otherRec.includes(e)) return false;
        }, true) !== false;
        var iterator2 = otherRec.getIterator();
        return iterateSimple(iterator2, function(e) {
          if (has(O2, e)) return iteratorClose(iterator2, "normal", false);
        }) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-disjoint-from.v2.js
  var require_es_set_is_disjoint_from_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-disjoint-from.v2.js"() {
      "use strict";
      var $2 = require_export();
      var isDisjointFrom = require_set_is_disjoint_from();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("isDisjointFrom", function(result) {
        return !result;
      });
      $2({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        isDisjointFrom
      });
    }
  });

  // node_modules/core-js/internals/set-is-subset-of.js
  var require_set_is_subset_of = __commonJS({
    "node_modules/core-js/internals/set-is-subset-of.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var size = require_set_size();
      var iterate = require_set_iterate();
      var getSetRecord = require_get_set_record();
      module.exports = function isSubsetOf(other) {
        var O2 = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O2) > otherRec.size) return false;
        return iterate(O2, function(e) {
          if (!otherRec.includes(e)) return false;
        }, true) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-subset-of.v2.js
  var require_es_set_is_subset_of_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-subset-of.v2.js"() {
      "use strict";
      var $2 = require_export();
      var isSubsetOf = require_set_is_subset_of();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("isSubsetOf", function(result) {
        return result;
      });
      $2({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        isSubsetOf
      });
    }
  });

  // node_modules/core-js/internals/set-is-superset-of.js
  var require_set_is_superset_of = __commonJS({
    "node_modules/core-js/internals/set-is-superset-of.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var has = require_set_helpers().has;
      var size = require_set_size();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      var iteratorClose = require_iterator_close();
      module.exports = function isSupersetOf(other) {
        var O2 = aSet(this);
        var otherRec = getSetRecord(other);
        if (size(O2) < otherRec.size) return false;
        var iterator2 = otherRec.getIterator();
        return iterateSimple(iterator2, function(e) {
          if (!has(O2, e)) return iteratorClose(iterator2, "normal", false);
        }) !== false;
      };
    }
  });

  // node_modules/core-js/modules/es.set.is-superset-of.v2.js
  var require_es_set_is_superset_of_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.is-superset-of.v2.js"() {
      "use strict";
      var $2 = require_export();
      var isSupersetOf = require_set_is_superset_of();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      var INCORRECT = !setMethodAcceptSetLike("isSupersetOf", function(result) {
        return !result;
      });
      $2({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
        isSupersetOf
      });
    }
  });

  // node_modules/core-js/internals/set-symmetric-difference.js
  var require_set_symmetric_difference = __commonJS({
    "node_modules/core-js/internals/set-symmetric-difference.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var SetHelpers = require_set_helpers();
      var clone = require_set_clone();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      var add = SetHelpers.add;
      var has = SetHelpers.has;
      var remove = SetHelpers.remove;
      module.exports = function symmetricDifference(other) {
        var O2 = aSet(this);
        var keysIter = getSetRecord(other).getIterator();
        var result = clone(O2);
        iterateSimple(keysIter, function(e) {
          if (has(O2, e)) remove(result, e);
          else add(result, e);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.symmetric-difference.v2.js
  var require_es_set_symmetric_difference_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.symmetric-difference.v2.js"() {
      "use strict";
      var $2 = require_export();
      var symmetricDifference = require_set_symmetric_difference();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $2({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("symmetricDifference") }, {
        symmetricDifference
      });
    }
  });

  // node_modules/core-js/internals/set-union.js
  var require_set_union = __commonJS({
    "node_modules/core-js/internals/set-union.js"(exports, module) {
      "use strict";
      var aSet = require_a_set();
      var add = require_set_helpers().add;
      var clone = require_set_clone();
      var getSetRecord = require_get_set_record();
      var iterateSimple = require_iterate_simple();
      module.exports = function union(other) {
        var O2 = aSet(this);
        var keysIter = getSetRecord(other).getIterator();
        var result = clone(O2);
        iterateSimple(keysIter, function(it2) {
          add(result, it2);
        });
        return result;
      };
    }
  });

  // node_modules/core-js/modules/es.set.union.v2.js
  var require_es_set_union_v2 = __commonJS({
    "node_modules/core-js/modules/es.set.union.v2.js"() {
      "use strict";
      var $2 = require_export();
      var union = require_set_union();
      var setMethodAcceptSetLike = require_set_method_accept_set_like();
      $2({ target: "Set", proto: true, real: true, forced: !setMethodAcceptSetLike("union") }, {
        union
      });
    }
  });

  // node_modules/core-js/modules/es.string.at-alternative.js
  var require_es_string_at_alternative = __commonJS({
    "node_modules/core-js/modules/es.string.at-alternative.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString3 = require_to_string();
      var fails = require_fails();
      var charAt = uncurryThis("".charAt);
      var FORCED = fails(function() {
        return "\u{20BB7}".at(-2) !== "\uD842";
      });
      $2({ target: "String", proto: true, forced: FORCED }, {
        at: function at2(index) {
          var S2 = toString3(requireObjectCoercible(this));
          var len = S2.length;
          var relativeIndex = toIntegerOrInfinity(index);
          var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
          return k < 0 || k >= len ? void 0 : charAt(S2, k);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-multibyte.js
  var require_string_multibyte = __commonJS({
    "node_modules/core-js/internals/string-multibyte.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString3 = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var stringSlice = uncurryThis("".slice);
      var createMethod = function(CONVERT_TO_STRING) {
        return function($this, pos) {
          var S2 = toString3(requireObjectCoercible($this));
          var position = toIntegerOrInfinity(pos);
          var size = S2.length;
          var first, second;
          if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
          first = charCodeAt(S2, position);
          return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position) : first : CONVERT_TO_STRING ? stringSlice(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
        };
      };
      module.exports = {
        // `String.prototype.codePointAt` method
        // https://tc39.es/ecma262/#sec-string.prototype.codepointat
        codeAt: createMethod(false),
        // `String.prototype.at` method
        // https://github.com/mathiasbynens/String.prototype.at
        charAt: createMethod(true)
      };
    }
  });

  // node_modules/core-js/modules/es.string.code-point-at.js
  var require_es_string_code_point_at = __commonJS({
    "node_modules/core-js/modules/es.string.code-point-at.js"() {
      "use strict";
      var $2 = require_export();
      var codeAt = require_string_multibyte().codeAt;
      $2({ target: "String", proto: true }, {
        codePointAt: function codePointAt(pos) {
          return codeAt(this, pos);
        }
      });
    }
  });

  // node_modules/core-js/internals/not-a-regexp.js
  var require_not_a_regexp = __commonJS({
    "node_modules/core-js/internals/not-a-regexp.js"(exports, module) {
      "use strict";
      var isRegExp2 = require_is_regexp();
      var $TypeError = TypeError;
      module.exports = function(it2) {
        if (isRegExp2(it2)) {
          throw new $TypeError("The method doesn't accept regular expressions");
        }
        return it2;
      };
    }
  });

  // node_modules/core-js/internals/correct-is-regexp-logic.js
  var require_correct_is_regexp_logic = __commonJS({
    "node_modules/core-js/internals/correct-is-regexp-logic.js"(exports, module) {
      "use strict";
      var wellKnownSymbol = require_well_known_symbol();
      var MATCH = wellKnownSymbol("match");
      module.exports = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (error1) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (error2) {
          }
        }
        return false;
      };
    }
  });

  // node_modules/core-js/modules/es.string.ends-with.js
  var require_es_string_ends_with = __commonJS({
    "node_modules/core-js/modules/es.string.ends-with.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var slice = uncurryThis("".slice);
      var min = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "endsWith");
        return descriptor && !descriptor.writable;
      }();
      $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        endsWith: function endsWith2(searchString) {
          var that = toString3(requireObjectCoercible(this));
          notARegExp(searchString);
          var endPosition = arguments.length > 1 ? arguments[1] : void 0;
          var len = that.length;
          var end = endPosition === void 0 ? len : min(toLength(endPosition), len);
          var search = toString3(searchString);
          return slice(that, end - search.length, end) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.from-code-point.js
  var require_es_string_from_code_point = __commonJS({
    "node_modules/core-js/modules/es.string.from-code-point.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toAbsoluteIndex = require_to_absolute_index();
      var $RangeError = RangeError;
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      var join = uncurryThis([].join);
      var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;
      $2({ target: "String", stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
        // eslint-disable-next-line no-unused-vars -- required for `.length`
        fromCodePoint: function fromCodePoint(x2) {
          var elements = [];
          var length = arguments.length;
          var i = 0;
          var code;
          while (length > i) {
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 1114111) !== code) throw new $RangeError(code + " is not a valid code point");
            elements[i] = code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320);
          }
          return join(elements, "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.includes.js
  var require_es_string_includes = __commonJS({
    "node_modules/core-js/modules/es.string.includes.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var toString3 = require_to_string();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var stringIndexOf = uncurryThis("".indexOf);
      $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
        includes: function includes(searchString) {
          return !!~stringIndexOf(
            toString3(requireObjectCoercible(this)),
            toString3(notARegExp(searchString)),
            arguments.length > 1 ? arguments[1] : void 0
          );
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.is-well-formed.js
  var require_es_string_is_well_formed = __commonJS({
    "node_modules/core-js/modules/es.string.is-well-formed.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString3 = require_to_string();
      var charCodeAt = uncurryThis("".charCodeAt);
      $2({ target: "String", proto: true }, {
        isWellFormed: function isWellFormed() {
          var S2 = toString3(requireObjectCoercible(this));
          var length = S2.length;
          for (var i = 0; i < length; i++) {
            var charCode = charCodeAt(S2, i);
            if ((charCode & 63488) !== 55296) continue;
            if (charCode >= 56320 || ++i >= length || (charCodeAt(S2, i) & 64512) !== 56320) return false;
          }
          return true;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.iterator.js
  var require_es_string_iterator = __commonJS({
    "node_modules/core-js/modules/es.string.iterator.js"() {
      "use strict";
      var charAt = require_string_multibyte().charAt;
      var toString3 = require_to_string();
      var InternalStateModule = require_internal_state();
      var defineIterator = require_iterator_define();
      var createIterResultObject = require_create_iter_result_object();
      var STRING_ITERATOR = "String Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
      defineIterator(String, "String", function(iterated) {
        setInternalState(this, {
          type: STRING_ITERATOR,
          string: toString3(iterated),
          index: 0
        });
      }, function next() {
        var state = getInternalState(this);
        var string = state.string;
        var index = state.index;
        var point;
        if (index >= string.length) return createIterResultObject(void 0, true);
        point = charAt(string, index);
        state.index += point.length;
        return createIterResultObject(point, false);
      });
    }
  });

  // node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
  var require_fix_regexp_well_known_symbol_logic = __commonJS({
    "node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
      "use strict";
      require_es_regexp_exec();
      var call = require_function_call();
      var defineBuiltIn = require_define_built_in();
      var regexpExec = require_regexp_exec();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var SPECIES = wellKnownSymbol("species");
      var RegExpPrototype = RegExp.prototype;
      module.exports = function(KEY, exec, FORCED, SHAM) {
        var SYMBOL = wellKnownSymbol(KEY);
        var DELEGATES_TO_SYMBOL = !fails(function() {
          var O2 = {};
          O2[SYMBOL] = function() {
            return 7;
          };
          return ""[KEY](O2) !== 7;
        });
        var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
          var execCalled = false;
          var re2 = /a/;
          if (KEY === "split") {
            re2 = {};
            re2.constructor = {};
            re2.constructor[SPECIES] = function() {
              return re2;
            };
            re2.flags = "";
            re2[SYMBOL] = /./[SYMBOL];
          }
          re2.exec = function() {
            execCalled = true;
            return null;
          };
          re2[SYMBOL]("");
          return !execCalled;
        });
        if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
          var nativeRegExpMethod = /./[SYMBOL];
          var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
            var $exec = regexp.exec;
            if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
              if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
              }
              return { done: true, value: call(nativeMethod, str, regexp, arg2) };
            }
            return { done: false };
          });
          defineBuiltIn(String.prototype, KEY, methods[0]);
          defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
        }
        if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
      };
    }
  });

  // node_modules/core-js/internals/advance-string-index.js
  var require_advance_string_index = __commonJS({
    "node_modules/core-js/internals/advance-string-index.js"(exports, module) {
      "use strict";
      var charAt = require_string_multibyte().charAt;
      module.exports = function(S2, index, unicode) {
        return index + (unicode ? charAt(S2, index).length : 1);
      };
    }
  });

  // node_modules/core-js/internals/regexp-exec-abstract.js
  var require_regexp_exec_abstract = __commonJS({
    "node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
      "use strict";
      var call = require_function_call();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var classof = require_classof_raw();
      var regexpExec = require_regexp_exec();
      var $TypeError = TypeError;
      module.exports = function(R, S2) {
        var exec = R.exec;
        if (isCallable(exec)) {
          var result = call(exec, R, S2);
          if (result !== null) anObject(result);
          return result;
        }
        if (classof(R) === "RegExp") return call(regexpExec, R, S2);
        throw new $TypeError("RegExp#exec called on incompatible receiver");
      };
    }
  });

  // node_modules/core-js/modules/es.string.match.js
  var require_es_string_match = __commonJS({
    "node_modules/core-js/modules/es.string.match.js"() {
      "use strict";
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var getMethod = require_get_method();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("match", function(MATCH, nativeMatch, maybeCallNative) {
        return [
          // `String.prototype.match` method
          // https://tc39.es/ecma262/#sec-string.prototype.match
          function match(regexp) {
            var O2 = requireObjectCoercible(this);
            var matcher = isObject2(regexp) ? getMethod(regexp, MATCH) : void 0;
            return matcher ? call(matcher, regexp, O2) : new RegExp(regexp)[MATCH](toString3(O2));
          },
          // `RegExp.prototype[@@match]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
          function(string) {
            var rx = anObject(this);
            var S2 = toString3(string);
            var res = maybeCallNative(nativeMatch, rx, S2);
            if (res.done) return res.value;
            if (!rx.global) return regExpExec(rx, S2);
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
            var A2 = [];
            var n = 0;
            var result;
            while ((result = regExpExec(rx, S2)) !== null) {
              var matchStr = toString3(result[0]);
              A2[n] = matchStr;
              if (matchStr === "") rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
              n++;
            }
            return n === 0 ? null : A2;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.match-all.js
  var require_es_string_match_all = __commonJS({
    "node_modules/core-js/modules/es.string.match-all.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this_clause();
      var createIteratorConstructor = require_iterator_create_constructor();
      var createIterResultObject = require_create_iter_result_object();
      var requireObjectCoercible = require_require_object_coercible();
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var classof = require_classof_raw();
      var isRegExp2 = require_is_regexp();
      var getRegExpFlags = require_regexp_get_flags();
      var getMethod = require_get_method();
      var defineBuiltIn = require_define_built_in();
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var regExpExec = require_regexp_exec_abstract();
      var InternalStateModule = require_internal_state();
      var IS_PURE = require_is_pure();
      var MATCH_ALL = wellKnownSymbol("matchAll");
      var REGEXP_STRING = "RegExp String";
      var REGEXP_STRING_ITERATOR = REGEXP_STRING + " Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
      var RegExpPrototype = RegExp.prototype;
      var $TypeError = TypeError;
      var stringIndexOf = uncurryThis("".indexOf);
      var nativeMatchAll = uncurryThis("".matchAll);
      var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function() {
        nativeMatchAll("a", /./);
      });
      var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, $global, fullUnicode) {
        setInternalState(this, {
          type: REGEXP_STRING_ITERATOR,
          regexp,
          string,
          global: $global,
          unicode: fullUnicode,
          done: false
        });
      }, REGEXP_STRING, function next() {
        var state = getInternalState(this);
        if (state.done) return createIterResultObject(void 0, true);
        var R = state.regexp;
        var S2 = state.string;
        var match = regExpExec(R, S2);
        if (match === null) {
          state.done = true;
          return createIterResultObject(void 0, true);
        }
        if (state.global) {
          if (toString3(match[0]) === "") R.lastIndex = advanceStringIndex(S2, toLength(R.lastIndex), state.unicode);
          return createIterResultObject(match, false);
        }
        state.done = true;
        return createIterResultObject(match, false);
      });
      var $matchAll = function(string) {
        var R = anObject(this);
        var S2 = toString3(string);
        var C2 = speciesConstructor(R, RegExp);
        var flags = toString3(getRegExpFlags(R));
        var matcher, $global, fullUnicode;
        matcher = new C2(C2 === RegExp ? R.source : R, flags);
        $global = !!~stringIndexOf(flags, "g");
        fullUnicode = !!~stringIndexOf(flags, "u");
        matcher.lastIndex = toLength(R.lastIndex);
        return new $RegExpStringIterator(matcher, S2, $global, fullUnicode);
      };
      $2({ target: "String", proto: true, forced: WORKS_WITH_NON_GLOBAL_REGEX }, {
        matchAll: function matchAll2(regexp) {
          var O2 = requireObjectCoercible(this);
          var flags, S2, matcher, rx;
          if (isObject2(regexp)) {
            if (isRegExp2(regexp)) {
              flags = toString3(requireObjectCoercible(getRegExpFlags(regexp)));
              if (!~stringIndexOf(flags, "g")) throw new $TypeError("`.matchAll` does not allow non-global regexes");
            }
            if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O2, regexp);
            matcher = getMethod(regexp, MATCH_ALL);
            if (matcher === void 0 && IS_PURE && classof(regexp) === "RegExp") matcher = $matchAll;
            if (matcher) return call(matcher, regexp, O2);
          } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll(O2, regexp);
          S2 = toString3(O2);
          rx = new RegExp(regexp, "g");
          return IS_PURE ? call($matchAll, rx, S2) : rx[MATCH_ALL](S2);
        }
      });
      IS_PURE || MATCH_ALL in RegExpPrototype || defineBuiltIn(RegExpPrototype, MATCH_ALL, $matchAll);
    }
  });

  // node_modules/core-js/internals/string-pad-webkit-bug.js
  var require_string_pad_webkit_bug = __commonJS({
    "node_modules/core-js/internals/string-pad-webkit-bug.js"(exports, module) {
      "use strict";
      var userAgent = require_environment_user_agent();
      module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
    }
  });

  // node_modules/core-js/modules/es.string.pad-end.js
  var require_es_string_pad_end = __commonJS({
    "node_modules/core-js/modules/es.string.pad-end.js"() {
      "use strict";
      var $2 = require_export();
      var $padEnd = require_string_pad().end;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $2({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padEnd: function padEnd(maxLength) {
          return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.pad-start.js
  var require_es_string_pad_start = __commonJS({
    "node_modules/core-js/modules/es.string.pad-start.js"() {
      "use strict";
      var $2 = require_export();
      var $padStart = require_string_pad().start;
      var WEBKIT_BUG = require_string_pad_webkit_bug();
      $2({ target: "String", proto: true, forced: WEBKIT_BUG }, {
        padStart: function padStart(maxLength) {
          return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.raw.js
  var require_es_string_raw = __commonJS({
    "node_modules/core-js/modules/es.string.raw.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toIndexedObject = require_to_indexed_object();
      var toObject = require_to_object();
      var toString3 = require_to_string();
      var lengthOfArrayLike = require_length_of_array_like();
      var push = uncurryThis([].push);
      var join = uncurryThis([].join);
      $2({ target: "String", stat: true }, {
        raw: function raw(template) {
          var rawTemplate = toIndexedObject(toObject(template).raw);
          var literalSegments = lengthOfArrayLike(rawTemplate);
          if (!literalSegments) return "";
          var argumentsLength = arguments.length;
          var elements = [];
          var i = 0;
          while (true) {
            push(elements, toString3(rawTemplate[i++]));
            if (i === literalSegments) return join(elements, "");
            if (i < argumentsLength) push(elements, toString3(arguments[i]));
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.repeat.js
  var require_es_string_repeat = __commonJS({
    "node_modules/core-js/modules/es.string.repeat.js"() {
      "use strict";
      var $2 = require_export();
      var repeat = require_string_repeat();
      $2({ target: "String", proto: true }, {
        repeat
      });
    }
  });

  // node_modules/core-js/internals/get-substitution.js
  var require_get_substitution = __commonJS({
    "node_modules/core-js/internals/get-substitution.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var toObject = require_to_object();
      var floor = Math.floor;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
      var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
      module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
        if (namedCaptures !== void 0) {
          namedCaptures = toObject(namedCaptures);
          symbols = SUBSTITUTION_SYMBOLS;
        }
        return replace(replacement, symbols, function(match, ch) {
          var capture;
          switch (charAt(ch, 0)) {
            case "$":
              return "$";
            case "&":
              return matched;
            case "`":
              return stringSlice(str, 0, position);
            case "'":
              return stringSlice(str, tailPos);
            case "<":
              capture = namedCaptures[stringSlice(ch, 1, -1)];
              break;
            default:
              var n = +ch;
              if (n === 0) return match;
              if (n > m) {
                var f = floor(n / 10);
                if (f === 0) return match;
                if (f <= m) return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
                return match;
              }
              capture = captures[n - 1];
          }
          return capture === void 0 ? "" : capture;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.replace.js
  var require_es_string_replace = __commonJS({
    "node_modules/core-js/modules/es.string.replace.js"() {
      "use strict";
      var apply = require_function_apply();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var fails = require_fails();
      var anObject = require_an_object();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var requireObjectCoercible = require_require_object_coercible();
      var advanceStringIndex = require_advance_string_index();
      var getMethod = require_get_method();
      var getSubstitution = require_get_substitution();
      var regExpExec = require_regexp_exec_abstract();
      var wellKnownSymbol = require_well_known_symbol();
      var REPLACE = wellKnownSymbol("replace");
      var max = Math.max;
      var min = Math.min;
      var concat = uncurryThis([].concat);
      var push = uncurryThis([].push);
      var stringIndexOf = uncurryThis("".indexOf);
      var stringSlice = uncurryThis("".slice);
      var maybeToString = function(it2) {
        return it2 === void 0 ? it2 : String(it2);
      };
      var REPLACE_KEEPS_$0 = function() {
        return "a".replace(/./, "$0") === "$0";
      }();
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
        if (/./[REPLACE]) {
          return /./[REPLACE]("a", "$0") === "";
        }
        return false;
      }();
      var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
        var re2 = /./;
        re2.exec = function() {
          var result = [];
          result.groups = { a: "7" };
          return result;
        };
        return "".replace(re2, "$<a>") !== "7";
      });
      fixRegExpWellKnownSymbolLogic("replace", function(_2, nativeReplace, maybeCallNative) {
        var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
        return [
          // `String.prototype.replace` method
          // https://tc39.es/ecma262/#sec-string.prototype.replace
          function replace(searchValue, replaceValue) {
            var O2 = requireObjectCoercible(this);
            var replacer = isObject2(searchValue) ? getMethod(searchValue, REPLACE) : void 0;
            return replacer ? call(replacer, searchValue, O2, replaceValue) : call(nativeReplace, toString3(O2), searchValue, replaceValue);
          },
          // `RegExp.prototype[@@replace]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
          function(string, replaceValue) {
            var rx = anObject(this);
            var S2 = toString3(string);
            if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
              var res = maybeCallNative(nativeReplace, rx, S2, replaceValue);
              if (res.done) return res.value;
            }
            var functionalReplace = isCallable(replaceValue);
            if (!functionalReplace) replaceValue = toString3(replaceValue);
            var global2 = rx.global;
            var fullUnicode;
            if (global2) {
              fullUnicode = rx.unicode;
              rx.lastIndex = 0;
            }
            var results = [];
            var result;
            while (true) {
              result = regExpExec(rx, S2);
              if (result === null) break;
              push(results, result);
              if (!global2) break;
              var matchStr = toString3(result[0]);
              if (matchStr === "") rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
            }
            var accumulatedResult = "";
            var nextSourcePosition = 0;
            for (var i = 0; i < results.length; i++) {
              result = results[i];
              var matched = toString3(result[0]);
              var position = max(min(toIntegerOrInfinity(result.index), S2.length), 0);
              var captures = [];
              var replacement;
              for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
              var namedCaptures = result.groups;
              if (functionalReplace) {
                var replacerArgs = concat([matched], captures, position, S2);
                if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
                replacement = toString3(apply(replaceValue, void 0, replacerArgs));
              } else {
                replacement = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
              }
              if (position >= nextSourcePosition) {
                accumulatedResult += stringSlice(S2, nextSourcePosition, position) + replacement;
                nextSourcePosition = position + matched.length;
              }
            }
            return accumulatedResult + stringSlice(S2, nextSourcePosition);
          }
        ];
      }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    }
  });

  // node_modules/core-js/modules/es.string.replace-all.js
  var require_es_string_replace_all = __commonJS({
    "node_modules/core-js/modules/es.string.replace-all.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var isCallable = require_is_callable();
      var isObject2 = require_is_object();
      var isRegExp2 = require_is_regexp();
      var toString3 = require_to_string();
      var getMethod = require_get_method();
      var getRegExpFlags = require_regexp_get_flags();
      var getSubstitution = require_get_substitution();
      var wellKnownSymbol = require_well_known_symbol();
      var IS_PURE = require_is_pure();
      var REPLACE = wellKnownSymbol("replace");
      var $TypeError = TypeError;
      var indexOf = uncurryThis("".indexOf);
      var replace = uncurryThis("".replace);
      var stringSlice = uncurryThis("".slice);
      var max = Math.max;
      $2({ target: "String", proto: true }, {
        replaceAll: function replaceAll(searchValue, replaceValue) {
          var O2 = requireObjectCoercible(this);
          var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
          var endOfLastMatch = 0;
          var result = "";
          if (isObject2(searchValue)) {
            IS_REG_EXP = isRegExp2(searchValue);
            if (IS_REG_EXP) {
              flags = toString3(requireObjectCoercible(getRegExpFlags(searchValue)));
              if (!~indexOf(flags, "g")) throw new $TypeError("`.replaceAll` does not allow non-global regexes");
            }
            replacer = getMethod(searchValue, REPLACE);
            if (replacer) return call(replacer, searchValue, O2, replaceValue);
            if (IS_PURE && IS_REG_EXP) return replace(toString3(O2), searchValue, replaceValue);
          }
          string = toString3(O2);
          searchString = toString3(searchValue);
          functionalReplace = isCallable(replaceValue);
          if (!functionalReplace) replaceValue = toString3(replaceValue);
          searchLength = searchString.length;
          advanceBy = max(1, searchLength);
          position = indexOf(string, searchString);
          while (position !== -1) {
            replacement = functionalReplace ? toString3(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
            result += stringSlice(string, endOfLastMatch, position) + replacement;
            endOfLastMatch = position + searchLength;
            position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
          }
          if (endOfLastMatch < string.length) {
            result += stringSlice(string, endOfLastMatch);
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.search.js
  var require_es_string_search = __commonJS({
    "node_modules/core-js/modules/es.string.search.js"() {
      "use strict";
      var call = require_function_call();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var sameValue = require_same_value();
      var toString3 = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
        return [
          // `String.prototype.search` method
          // https://tc39.es/ecma262/#sec-string.prototype.search
          function search(regexp) {
            var O2 = requireObjectCoercible(this);
            var searcher = isObject2(regexp) ? getMethod(regexp, SEARCH) : void 0;
            return searcher ? call(searcher, regexp, O2) : new RegExp(regexp)[SEARCH](toString3(O2));
          },
          // `RegExp.prototype[@@search]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
          function(string) {
            var rx = anObject(this);
            var S2 = toString3(string);
            var res = maybeCallNative(nativeSearch, rx, S2);
            if (res.done) return res.value;
            var previousLastIndex = rx.lastIndex;
            if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
            var result = regExpExec(rx, S2);
            if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
            return result === null ? -1 : result.index;
          }
        ];
      });
    }
  });

  // node_modules/core-js/modules/es.string.split.js
  var require_es_string_split = __commonJS({
    "node_modules/core-js/modules/es.string.split.js"() {
      "use strict";
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var requireObjectCoercible = require_require_object_coercible();
      var speciesConstructor = require_species_constructor();
      var advanceStringIndex = require_advance_string_index();
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var getMethod = require_get_method();
      var regExpExec = require_regexp_exec_abstract();
      var stickyHelpers = require_regexp_sticky_helpers();
      var fails = require_fails();
      var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
      var MAX_UINT32 = 4294967295;
      var min = Math.min;
      var push = uncurryThis([].push);
      var stringSlice = uncurryThis("".slice);
      var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
        var re2 = /(?:)/;
        var originalExec = re2.exec;
        re2.exec = function() {
          return originalExec.apply(this, arguments);
        };
        var result = "ab".split(re2);
        return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
      });
      var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
      "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
      ".".split(/()()/).length > 1 || "".split(/.?/).length;
      fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
        var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
        } : nativeSplit;
        return [
          // `String.prototype.split` method
          // https://tc39.es/ecma262/#sec-string.prototype.split
          function split(separator, limit) {
            var O2 = requireObjectCoercible(this);
            var splitter = isObject2(separator) ? getMethod(separator, SPLIT) : void 0;
            return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString3(O2), separator, limit);
          },
          // `RegExp.prototype[@@split]` method
          // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
          //
          // NOTE: This cannot be properly polyfilled in engines that don't support
          // the 'y' flag.
          function(string, limit) {
            var rx = anObject(this);
            var S2 = toString3(string);
            if (!BUGGY) {
              var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
              if (res.done) return res.value;
            }
            var C2 = speciesConstructor(rx, RegExp);
            var unicodeMatching = rx.unicode;
            var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
            var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
            var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
            if (lim === 0) return [];
            if (S2.length === 0) return regExpExec(splitter, S2) === null ? [S2] : [];
            var p = 0;
            var q2 = 0;
            var A2 = [];
            while (q2 < S2.length) {
              splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
              var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
              var e;
              if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p) {
                q2 = advanceStringIndex(S2, q2, unicodeMatching);
              } else {
                push(A2, stringSlice(S2, p, q2));
                if (A2.length === lim) return A2;
                for (var i = 1; i <= z.length - 1; i++) {
                  push(A2, z[i]);
                  if (A2.length === lim) return A2;
                }
                q2 = p = e;
              }
            }
            push(A2, stringSlice(S2, p));
            return A2;
          }
        ];
      }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    }
  });

  // node_modules/core-js/modules/es.string.starts-with.js
  var require_es_string_starts_with = __commonJS({
    "node_modules/core-js/modules/es.string.starts-with.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this_clause();
      var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
      var toLength = require_to_length();
      var toString3 = require_to_string();
      var notARegExp = require_not_a_regexp();
      var requireObjectCoercible = require_require_object_coercible();
      var correctIsRegExpLogic = require_correct_is_regexp_logic();
      var IS_PURE = require_is_pure();
      var stringSlice = uncurryThis("".slice);
      var min = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
      var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
        return descriptor && !descriptor.writable;
      }();
      $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        startsWith: function startsWith(searchString) {
          var that = toString3(requireObjectCoercible(this));
          notARegExp(searchString);
          var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
          var search = toString3(searchString);
          return stringSlice(that, index, index + search.length) === search;
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.substr.js
  var require_es_string_substr = __commonJS({
    "node_modules/core-js/modules/es.string.substr.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toString3 = require_to_string();
      var stringSlice = uncurryThis("".slice);
      var max = Math.max;
      var min = Math.min;
      var FORCED = !"".substr || "ab".substr(-1) !== "b";
      $2({ target: "String", proto: true, forced: FORCED }, {
        substr: function substr(start, length) {
          var that = toString3(requireObjectCoercible(this));
          var size = that.length;
          var intStart = toIntegerOrInfinity(start);
          var intLength, intEnd;
          if (intStart === Infinity) intStart = 0;
          if (intStart < 0) intStart = max(size + intStart, 0);
          intLength = length === void 0 ? size : toIntegerOrInfinity(length);
          if (intLength <= 0 || intLength === Infinity) return "";
          intEnd = min(intStart + intLength, size);
          return intStart >= intEnd ? "" : stringSlice(that, intStart, intEnd);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.to-well-formed.js
  var require_es_string_to_well_formed = __commonJS({
    "node_modules/core-js/modules/es.string.to-well-formed.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString3 = require_to_string();
      var fails = require_fails();
      var $Array = Array;
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var $toWellFormed = "".toWellFormed;
      var REPLACEMENT_CHARACTER = "\uFFFD";
      var TO_STRING_CONVERSION_BUG = $toWellFormed && fails(function() {
        return call($toWellFormed, 1) !== "1";
      });
      $2({ target: "String", proto: true, forced: TO_STRING_CONVERSION_BUG }, {
        toWellFormed: function toWellFormed() {
          var S2 = toString3(requireObjectCoercible(this));
          if (TO_STRING_CONVERSION_BUG) return call($toWellFormed, S2);
          var length = S2.length;
          var result = $Array(length);
          for (var i = 0; i < length; i++) {
            var charCode = charCodeAt(S2, i);
            if ((charCode & 63488) !== 55296) result[i] = charAt(S2, i);
            else if (charCode >= 56320 || i + 1 >= length || (charCodeAt(S2, i + 1) & 64512) !== 56320) result[i] = REPLACEMENT_CHARACTER;
            else {
              result[i] = charAt(S2, i);
              result[++i] = charAt(S2, i);
            }
          }
          return join(result, "");
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-forced.js
  var require_string_trim_forced = __commonJS({
    "node_modules/core-js/internals/string-trim-forced.js"(exports, module) {
      "use strict";
      var PROPER_FUNCTION_NAME = require_function_name().PROPER;
      var fails = require_fails();
      var whitespaces = require_whitespaces();
      var non = "\u200B\x85\u180E";
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.trim.js
  var require_es_string_trim = __commonJS({
    "node_modules/core-js/modules/es.string.trim.js"() {
      "use strict";
      var $2 = require_export();
      var $trim = require_string_trim().trim;
      var forcedStringTrimMethod = require_string_trim_forced();
      $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
        trim: function trim2() {
          return $trim(this);
        }
      });
    }
  });

  // node_modules/core-js/internals/string-trim-end.js
  var require_string_trim_end = __commonJS({
    "node_modules/core-js/internals/string-trim-end.js"(exports, module) {
      "use strict";
      var $trimEnd = require_string_trim().end;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimEnd") ? function trimEnd() {
        return $trimEnd(this);
      } : "".trimEnd;
    }
  });

  // node_modules/core-js/modules/es.string.trim-right.js
  var require_es_string_trim_right = __commonJS({
    "node_modules/core-js/modules/es.string.trim-right.js"() {
      "use strict";
      var $2 = require_export();
      var trimEnd = require_string_trim_end();
      $2({ target: "String", proto: true, name: "trimEnd", forced: "".trimRight !== trimEnd }, {
        trimRight: trimEnd
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-end.js
  var require_es_string_trim_end = __commonJS({
    "node_modules/core-js/modules/es.string.trim-end.js"() {
      "use strict";
      require_es_string_trim_right();
      var $2 = require_export();
      var trimEnd = require_string_trim_end();
      $2({ target: "String", proto: true, name: "trimEnd", forced: "".trimEnd !== trimEnd }, {
        trimEnd
      });
    }
  });

  // node_modules/core-js/internals/string-trim-start.js
  var require_string_trim_start = __commonJS({
    "node_modules/core-js/internals/string-trim-start.js"(exports, module) {
      "use strict";
      var $trimStart = require_string_trim().start;
      var forcedStringTrimMethod = require_string_trim_forced();
      module.exports = forcedStringTrimMethod("trimStart") ? function trimStart() {
        return $trimStart(this);
      } : "".trimStart;
    }
  });

  // node_modules/core-js/modules/es.string.trim-left.js
  var require_es_string_trim_left = __commonJS({
    "node_modules/core-js/modules/es.string.trim-left.js"() {
      "use strict";
      var $2 = require_export();
      var trimStart = require_string_trim_start();
      $2({ target: "String", proto: true, name: "trimStart", forced: "".trimLeft !== trimStart }, {
        trimLeft: trimStart
      });
    }
  });

  // node_modules/core-js/modules/es.string.trim-start.js
  var require_es_string_trim_start = __commonJS({
    "node_modules/core-js/modules/es.string.trim-start.js"() {
      "use strict";
      require_es_string_trim_left();
      var $2 = require_export();
      var trimStart = require_string_trim_start();
      $2({ target: "String", proto: true, name: "trimStart", forced: "".trimStart !== trimStart }, {
        trimStart
      });
    }
  });

  // node_modules/core-js/internals/create-html.js
  var require_create_html = __commonJS({
    "node_modules/core-js/internals/create-html.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var requireObjectCoercible = require_require_object_coercible();
      var toString3 = require_to_string();
      var quot = /"/g;
      var replace = uncurryThis("".replace);
      module.exports = function(string, tag, attribute, value) {
        var S2 = toString3(requireObjectCoercible(string));
        var p1 = "<" + tag;
        if (attribute !== "") p1 += " " + attribute + '="' + replace(toString3(value), quot, "&quot;") + '"';
        return p1 + ">" + S2 + "</" + tag + ">";
      };
    }
  });

  // node_modules/core-js/internals/string-html-forced.js
  var require_string_html_forced = __commonJS({
    "node_modules/core-js/internals/string-html-forced.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      module.exports = function(METHOD_NAME) {
        return fails(function() {
          var test2 = ""[METHOD_NAME]('"');
          return test2 !== test2.toLowerCase() || test2.split('"').length > 3;
        });
      };
    }
  });

  // node_modules/core-js/modules/es.string.anchor.js
  var require_es_string_anchor = __commonJS({
    "node_modules/core-js/modules/es.string.anchor.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("anchor") }, {
        anchor: function anchor(name) {
          return createHTML(this, "a", "name", name);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.big.js
  var require_es_string_big = __commonJS({
    "node_modules/core-js/modules/es.string.big.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("big") }, {
        big: function big() {
          return createHTML(this, "big", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.blink.js
  var require_es_string_blink = __commonJS({
    "node_modules/core-js/modules/es.string.blink.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("blink") }, {
        blink: function blink() {
          return createHTML(this, "blink", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.bold.js
  var require_es_string_bold = __commonJS({
    "node_modules/core-js/modules/es.string.bold.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("bold") }, {
        bold: function bold() {
          return createHTML(this, "b", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fixed.js
  var require_es_string_fixed = __commonJS({
    "node_modules/core-js/modules/es.string.fixed.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("fixed") }, {
        fixed: function fixed() {
          return createHTML(this, "tt", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontcolor.js
  var require_es_string_fontcolor = __commonJS({
    "node_modules/core-js/modules/es.string.fontcolor.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontcolor") }, {
        fontcolor: function fontcolor(color) {
          return createHTML(this, "font", "color", color);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.fontsize.js
  var require_es_string_fontsize = __commonJS({
    "node_modules/core-js/modules/es.string.fontsize.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("fontsize") }, {
        fontsize: function fontsize(size) {
          return createHTML(this, "font", "size", size);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.italics.js
  var require_es_string_italics = __commonJS({
    "node_modules/core-js/modules/es.string.italics.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("italics") }, {
        italics: function italics() {
          return createHTML(this, "i", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.link.js
  var require_es_string_link = __commonJS({
    "node_modules/core-js/modules/es.string.link.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("link") }, {
        link: function link(url) {
          return createHTML(this, "a", "href", url);
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.small.js
  var require_es_string_small = __commonJS({
    "node_modules/core-js/modules/es.string.small.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("small") }, {
        small: function small() {
          return createHTML(this, "small", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.strike.js
  var require_es_string_strike = __commonJS({
    "node_modules/core-js/modules/es.string.strike.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("strike") }, {
        strike: function strike() {
          return createHTML(this, "strike", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sub.js
  var require_es_string_sub = __commonJS({
    "node_modules/core-js/modules/es.string.sub.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("sub") }, {
        sub: function sub() {
          return createHTML(this, "sub", "", "");
        }
      });
    }
  });

  // node_modules/core-js/modules/es.string.sup.js
  var require_es_string_sup = __commonJS({
    "node_modules/core-js/modules/es.string.sup.js"() {
      "use strict";
      var $2 = require_export();
      var createHTML = require_create_html();
      var forcedStringHTMLMethod = require_string_html_forced();
      $2({ target: "String", proto: true, forced: forcedStringHTMLMethod("sup") }, {
        sup: function sup() {
          return createHTML(this, "sup", "", "");
        }
      });
    }
  });

  // node_modules/core-js/internals/typed-array-constructors-require-wrappers.js
  var require_typed_array_constructors_require_wrappers = __commonJS({
    "node_modules/core-js/internals/typed-array-constructors-require-wrappers.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var checkCorrectnessOfIteration = require_check_correctness_of_iteration();
      var NATIVE_ARRAY_BUFFER_VIEWS = require_array_buffer_view_core().NATIVE_ARRAY_BUFFER_VIEWS;
      var ArrayBuffer2 = globalThis2.ArrayBuffer;
      var Int8Array2 = globalThis2.Int8Array;
      module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
        Int8Array2(1);
      }) || !fails(function() {
        new Int8Array2(-1);
      }) || !checkCorrectnessOfIteration(function(iterable) {
        new Int8Array2();
        new Int8Array2(null);
        new Int8Array2(1.5);
        new Int8Array2(iterable);
      }, true) || fails(function() {
        return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
      });
    }
  });

  // node_modules/core-js/internals/to-offset.js
  var require_to_offset = __commonJS({
    "node_modules/core-js/internals/to-offset.js"(exports, module) {
      "use strict";
      var toPositiveInteger = require_to_positive_integer();
      var $RangeError = RangeError;
      module.exports = function(it2, BYTES) {
        var offset = toPositiveInteger(it2);
        if (offset % BYTES) throw new $RangeError("Wrong offset");
        return offset;
      };
    }
  });

  // node_modules/core-js/internals/to-uint8-clamped.js
  var require_to_uint8_clamped = __commonJS({
    "node_modules/core-js/internals/to-uint8-clamped.js"(exports, module) {
      "use strict";
      var round = Math.round;
      module.exports = function(it2) {
        var value = round(it2);
        return value < 0 ? 0 : value > 255 ? 255 : value & 255;
      };
    }
  });

  // node_modules/core-js/internals/is-big-int-array.js
  var require_is_big_int_array = __commonJS({
    "node_modules/core-js/internals/is-big-int-array.js"(exports, module) {
      "use strict";
      var classof = require_classof();
      module.exports = function(it2) {
        var klass = classof(it2);
        return klass === "BigInt64Array" || klass === "BigUint64Array";
      };
    }
  });

  // node_modules/core-js/internals/to-big-int.js
  var require_to_big_int = __commonJS({
    "node_modules/core-js/internals/to-big-int.js"(exports, module) {
      "use strict";
      var toPrimitive = require_to_primitive();
      var $TypeError = TypeError;
      module.exports = function(argument) {
        var prim = toPrimitive(argument, "number");
        if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
        return BigInt(prim);
      };
    }
  });

  // node_modules/core-js/internals/typed-array-from.js
  var require_typed_array_from = __commonJS({
    "node_modules/core-js/internals/typed-array-from.js"(exports, module) {
      "use strict";
      var bind2 = require_function_bind_context();
      var call = require_function_call();
      var aConstructor = require_a_constructor();
      var toObject = require_to_object();
      var lengthOfArrayLike = require_length_of_array_like();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var isArrayIteratorMethod = require_is_array_iterator_method();
      var isBigIntArray = require_is_big_int_array();
      var aTypedArrayConstructor = require_array_buffer_view_core().aTypedArrayConstructor;
      var toBigInt = require_to_big_int();
      module.exports = function from(source) {
        var C2 = aConstructor(this);
        var O2 = toObject(source);
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var iteratorMethod = getIteratorMethod(O2);
        var i, length, result, thisIsBigIntArray, value, step, iterator2, next;
        if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
          iterator2 = getIterator(O2, iteratorMethod);
          next = iterator2.next;
          O2 = [];
          while (!(step = call(next, iterator2)).done) {
            O2.push(step.value);
          }
        }
        if (mapping && argumentsLength > 2) {
          mapfn = bind2(mapfn, arguments[2]);
        }
        length = lengthOfArrayLike(O2);
        result = new (aTypedArrayConstructor(C2))(length);
        thisIsBigIntArray = isBigIntArray(result);
        for (i = 0; length > i; i++) {
          value = mapping ? mapfn(O2[i], i) : O2[i];
          result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
        }
        return result;
      };
    }
  });

  // node_modules/core-js/internals/typed-array-constructor.js
  var require_typed_array_constructor = __commonJS({
    "node_modules/core-js/internals/typed-array-constructor.js"(exports, module) {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var DESCRIPTORS = require_descriptors();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayBufferModule = require_array_buffer();
      var anInstance = require_an_instance();
      var createPropertyDescriptor = require_create_property_descriptor();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var isIntegralNumber = require_is_integral_number();
      var toLength = require_to_length();
      var toIndex = require_to_index();
      var toOffset = require_to_offset();
      var toUint8Clamped = require_to_uint8_clamped();
      var toPropertyKey = require_to_property_key();
      var hasOwn = require_has_own_property();
      var classof = require_classof();
      var isObject2 = require_is_object();
      var isSymbol = require_is_symbol();
      var create = require_object_create();
      var isPrototypeOf = require_object_is_prototype_of();
      var setPrototypeOf = require_object_set_prototype_of();
      var getOwnPropertyNames = require_object_get_own_property_names().f;
      var typedArrayFrom = require_typed_array_from();
      var forEach2 = require_array_iteration().forEach;
      var setSpecies = require_set_species();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var definePropertyModule = require_object_define_property();
      var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var InternalStateModule = require_internal_state();
      var inheritIfRequired = require_inherit_if_required();
      var getInternalState = InternalStateModule.get;
      var setInternalState = InternalStateModule.set;
      var enforceInternalState = InternalStateModule.enforce;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var RangeError2 = globalThis2.RangeError;
      var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
      var ArrayBufferPrototype = ArrayBuffer2.prototype;
      var DataView2 = ArrayBufferModule.DataView;
      var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
      var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
      var TypedArray = ArrayBufferViewCore.TypedArray;
      var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
      var isTypedArray2 = ArrayBufferViewCore.isTypedArray;
      var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
      var WRONG_LENGTH = "Wrong length";
      var addGetter = function(it2, key) {
        defineBuiltInAccessor(it2, key, {
          configurable: true,
          get: function() {
            return getInternalState(this)[key];
          }
        });
      };
      var isArrayBuffer2 = function(it2) {
        var klass;
        return isPrototypeOf(ArrayBufferPrototype, it2) || (klass = classof(it2)) === "ArrayBuffer" || klass === "SharedArrayBuffer";
      };
      var isTypedArrayIndex = function(target, key) {
        return isTypedArray2(target) && !isSymbol(key) && key in target && isIntegralNumber(+key) && key >= 0;
      };
      var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
        key = toPropertyKey(key);
        return isTypedArrayIndex(target, key) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
      };
      var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
        key = toPropertyKey(key);
        if (isTypedArrayIndex(target, key) && isObject2(descriptor) && hasOwn(descriptor, "value") && !hasOwn(descriptor, "get") && !hasOwn(descriptor, "set") && !descriptor.configurable && (!hasOwn(descriptor, "writable") || descriptor.writable) && (!hasOwn(descriptor, "enumerable") || descriptor.enumerable)) {
          target[key] = descriptor.value;
          return target;
        }
        return nativeDefineProperty(target, key, descriptor);
      };
      if (DESCRIPTORS) {
        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
          getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
          definePropertyModule.f = wrappedDefineProperty;
          addGetter(TypedArrayPrototype, "buffer");
          addGetter(TypedArrayPrototype, "byteOffset");
          addGetter(TypedArrayPrototype, "byteLength");
          addGetter(TypedArrayPrototype, "length");
        }
        $2({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
          getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
          defineProperty: wrappedDefineProperty
        });
        module.exports = function(TYPE, wrapper, CLAMPED) {
          var BYTES = TYPE.match(/\d+/)[0] / 8;
          var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
          var GETTER = "get" + TYPE;
          var SETTER = "set" + TYPE;
          var NativeTypedArrayConstructor = globalThis2[CONSTRUCTOR_NAME];
          var TypedArrayConstructor = NativeTypedArrayConstructor;
          var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
          var exported = {};
          var getter = function(that, index) {
            var data2 = getInternalState(that);
            return data2.view[GETTER](index * BYTES + data2.byteOffset, true);
          };
          var setter = function(that, index, value) {
            var data2 = getInternalState(that);
            data2.view[SETTER](index * BYTES + data2.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
          };
          var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
              get: function() {
                return getter(this, index);
              },
              set: function(value) {
                return setter(this, index, value);
              },
              enumerable: true
            });
          };
          if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data2, offset, $length) {
              anInstance(that, TypedArrayConstructorPrototype);
              var index = 0;
              var byteOffset = 0;
              var buffer, byteLength, length;
              if (!isObject2(data2)) {
                length = toIndex(data2);
                byteLength = length * BYTES;
                buffer = new ArrayBuffer2(byteLength);
              } else if (isArrayBuffer2(data2)) {
                buffer = data2;
                byteOffset = toOffset(offset, BYTES);
                var $len = data2.byteLength;
                if ($length === void 0) {
                  if ($len % BYTES) throw new RangeError2(WRONG_LENGTH);
                  byteLength = $len - byteOffset;
                  if (byteLength < 0) throw new RangeError2(WRONG_LENGTH);
                } else {
                  byteLength = toLength($length) * BYTES;
                  if (byteLength + byteOffset > $len) throw new RangeError2(WRONG_LENGTH);
                }
                length = byteLength / BYTES;
              } else if (isTypedArray2(data2)) {
                return arrayFromConstructorAndList(TypedArrayConstructor, data2);
              } else {
                return call(typedArrayFrom, TypedArrayConstructor, data2);
              }
              setInternalState(that, {
                buffer,
                byteOffset,
                byteLength,
                length,
                view: new DataView2(buffer)
              });
              while (index < length) addElement(that, index++);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
          } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data2, typedArrayOffset, $length) {
              anInstance(dummy, TypedArrayConstructorPrototype);
              return inheritIfRequired(function() {
                if (!isObject2(data2)) return new NativeTypedArrayConstructor(toIndex(data2));
                if (isArrayBuffer2(data2)) return $length !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data2, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data2);
                if (isTypedArray2(data2)) return arrayFromConstructorAndList(TypedArrayConstructor, data2);
                return call(typedArrayFrom, TypedArrayConstructor, data2);
              }(), dummy, TypedArrayConstructor);
            });
            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach2(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
              if (!(key in TypedArrayConstructor)) {
                createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
              }
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
          }
          if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
          }
          enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;
          if (TYPED_ARRAY_TAG) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
          }
          var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;
          exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
          $2({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
            createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
          }
          if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
            createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
          }
          setSpecies(CONSTRUCTOR_NAME);
        };
      } else module.exports = function() {
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.float32-array.js
  var require_es_typed_array_float32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float32-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float32", function(init) {
        return function Float32Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.float64-array.js
  var require_es_typed_array_float64_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.float64-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Float64", function(init) {
        return function Float64Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int8-array.js
  var require_es_typed_array_int8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int8-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int8", function(init) {
        return function Int8Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int16-array.js
  var require_es_typed_array_int16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int16-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int16", function(init) {
        return function Int16Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.int32-array.js
  var require_es_typed_array_int32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.int32-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Int32", function(init) {
        return function Int32Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-array.js
  var require_es_typed_array_uint8_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init) {
        return function Uint8Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js
  var require_es_typed_array_uint8_clamped_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint8", function(init) {
        return function Uint8ClampedArray2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      }, true);
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint16-array.js
  var require_es_typed_array_uint16_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint16-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint16", function(init) {
        return function Uint16Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.uint32-array.js
  var require_es_typed_array_uint32_array = __commonJS({
    "node_modules/core-js/modules/es.typed-array.uint32-array.js"() {
      "use strict";
      var createTypedArrayConstructor = require_typed_array_constructor();
      createTypedArrayConstructor("Uint32", function(init) {
        return function Uint32Array2(data2, byteOffset, length) {
          return init(this, data2, byteOffset, length);
        };
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.at.js
  var require_es_typed_array_at = __commonJS({
    "node_modules/core-js/modules/es.typed-array.at.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("at", function at2(index) {
        var O2 = aTypedArray(this);
        var len = lengthOfArrayLike(O2);
        var relativeIndex = toIntegerOrInfinity(index);
        var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
        return k < 0 || k >= len ? void 0 : O2[k];
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.copy-within.js
  var require_es_typed_array_copy_within = __commonJS({
    "node_modules/core-js/modules/es.typed-array.copy-within.js"() {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $ArrayCopyWithin = require_array_copy_within();
      var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
        return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.every.js
  var require_es_typed_array_every = __commonJS({
    "node_modules/core-js/modules/es.typed-array.every.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $every = require_array_iteration().every;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("every", function every(callbackfn) {
        return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.fill.js
  var require_es_typed_array_fill = __commonJS({
    "node_modules/core-js/modules/es.typed-array.fill.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $fill = require_array_fill();
      var toBigInt = require_to_big_int();
      var classof = require_classof();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var slice = uncurryThis("".slice);
      var CONVERSION_BUG = fails(function() {
        var count = 0;
        new Int8Array(2).fill({ valueOf: function() {
          return count++;
        } });
        return count !== 1;
      });
      exportTypedArrayMethod("fill", function fill(value) {
        var length = arguments.length;
        aTypedArray(this);
        var actualValue = slice(classof(this), 0, 3) === "Big" ? toBigInt(value) : +value;
        return call($fill, this, actualValue, length > 1 ? arguments[1] : void 0, length > 2 ? arguments[2] : void 0);
      }, CONVERSION_BUG);
    }
  });

  // node_modules/core-js/internals/typed-array-from-same-type-and-list.js
  var require_typed_array_from_same_type_and_list = __commonJS({
    "node_modules/core-js/internals/typed-array-from-same-type-and-list.js"(exports, module) {
      "use strict";
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var getTypedArrayConstructor = require_array_buffer_view_core().getTypedArrayConstructor;
      module.exports = function(instance, list) {
        return arrayFromConstructorAndList(getTypedArrayConstructor(instance), list);
      };
    }
  });

  // node_modules/core-js/modules/es.typed-array.filter.js
  var require_es_typed_array_filter = __commonJS({
    "node_modules/core-js/modules/es.typed-array.filter.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $filter = require_array_iteration().filter;
      var fromSameTypeAndList = require_typed_array_from_same_type_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("filter", function filter2(callbackfn) {
        var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        return fromSameTypeAndList(this, list);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find.js
  var require_es_typed_array_find = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $find = require_array_iteration().find;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("find", function find(predicate) {
        return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-index.js
  var require_es_typed_array_find_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-index.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findIndex = require_array_iteration().findIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findIndex", function findIndex(predicate) {
        return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-last.js
  var require_es_typed_array_find_last = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-last.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findLast = require_array_iteration_from_last().findLast;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findLast", function findLast(predicate) {
        return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.find-last-index.js
  var require_es_typed_array_find_last_index = __commonJS({
    "node_modules/core-js/modules/es.typed-array.find-last-index.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $findLastIndex = require_array_iteration_from_last().findLastIndex;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("findLastIndex", function findLastIndex(predicate) {
        return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.for-each.js
  var require_es_typed_array_for_each = __commonJS({
    "node_modules/core-js/modules/es.typed-array.for-each.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $forEach = require_array_iteration().forEach;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("forEach", function forEach2(callbackfn) {
        $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.from.js
  var require_es_typed_array_from = __commonJS({
    "node_modules/core-js/modules/es.typed-array.from.js"() {
      "use strict";
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var exportTypedArrayStaticMethod = require_array_buffer_view_core().exportTypedArrayStaticMethod;
      var typedArrayFrom = require_typed_array_from();
      exportTypedArrayStaticMethod("from", typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.includes.js
  var require_es_typed_array_includes = __commonJS({
    "node_modules/core-js/modules/es.typed-array.includes.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $includes = require_array_includes().includes;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("includes", function includes(searchElement) {
        return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.index-of.js
  var require_es_typed_array_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.index-of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $indexOf = require_array_includes().indexOf;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
        return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.iterator.js
  var require_es_typed_array_iterator = __commonJS({
    "node_modules/core-js/modules/es.typed-array.iterator.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var fails = require_fails();
      var uncurryThis = require_function_uncurry_this();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var ArrayIterators = require_es_array_iterator();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var Uint8Array2 = globalThis2.Uint8Array;
      var arrayValues = uncurryThis(ArrayIterators.values);
      var arrayKeys = uncurryThis(ArrayIterators.keys);
      var arrayEntries = uncurryThis(ArrayIterators.entries);
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var TypedArrayPrototype = Uint8Array2 && Uint8Array2.prototype;
      var GENERIC = !fails(function() {
        TypedArrayPrototype[ITERATOR].call([1]);
      });
      var ITERATOR_IS_VALUES = !!TypedArrayPrototype && TypedArrayPrototype.values && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values && TypedArrayPrototype.values.name === "values";
      var typedArrayValues = function values() {
        return arrayValues(aTypedArray(this));
      };
      exportTypedArrayMethod("entries", function entries() {
        return arrayEntries(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("keys", function keys() {
        return arrayKeys(aTypedArray(this));
      }, GENERIC);
      exportTypedArrayMethod("values", typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
      exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: "values" });
    }
  });

  // node_modules/core-js/modules/es.typed-array.join.js
  var require_es_typed_array_join = __commonJS({
    "node_modules/core-js/modules/es.typed-array.join.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $join = uncurryThis([].join);
      exportTypedArrayMethod("join", function join(separator) {
        return $join(aTypedArray(this), separator);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.last-index-of.js
  var require_es_typed_array_last_index_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.last-index-of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var apply = require_function_apply();
      var $lastIndexOf = require_array_last_index_of();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
        var length = arguments.length;
        return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.map.js
  var require_es_typed_array_map = __commonJS({
    "node_modules/core-js/modules/es.typed-array.map.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $map = require_array_iteration().map;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("map", function map(mapfn) {
        return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O2, length) {
          return new (getTypedArrayConstructor(O2))(length);
        });
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.of.js
  var require_es_typed_array_of = __commonJS({
    "node_modules/core-js/modules/es.typed-array.of.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require_typed_array_constructors_require_wrappers();
      var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
      var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod;
      exportTypedArrayStaticMethod("of", function of() {
        var index = 0;
        var length = arguments.length;
        var result = new (aTypedArrayConstructor(this))(length);
        while (length > index) result[index] = arguments[index++];
        return result;
      }, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce.js
  var require_es_typed_array_reduce = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduce = require_array_reduce().left;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduce", function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reduce-right.js
  var require_es_typed_array_reduce_right = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reduce-right.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $reduceRight = require_array_reduce().right;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
        var length = arguments.length;
        return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.reverse.js
  var require_es_typed_array_reverse = __commonJS({
    "node_modules/core-js/modules/es.typed-array.reverse.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var floor = Math.floor;
      exportTypedArrayMethod("reverse", function reverse() {
        var that = this;
        var length = aTypedArray(that).length;
        var middle = floor(length / 2);
        var index = 0;
        var value;
        while (index < middle) {
          value = that[index];
          that[index++] = that[--length];
          that[length] = value;
        }
        return that;
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.set.js
  var require_es_typed_array_set = __commonJS({
    "node_modules/core-js/modules/es.typed-array.set.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var call = require_function_call();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var lengthOfArrayLike = require_length_of_array_like();
      var toOffset = require_to_offset();
      var toIndexedObject = require_to_object();
      var fails = require_fails();
      var RangeError2 = globalThis2.RangeError;
      var Int8Array2 = globalThis2.Int8Array;
      var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
      var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function() {
        var array = new Uint8ClampedArray(2);
        call($set, array, { length: 1, 0: 3 }, 1);
        return array[1] !== 3;
      });
      var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function() {
        var array = new Int8Array2(2);
        array.set(1);
        array.set("2", 1);
        return array[0] !== 0 || array[1] !== 2;
      });
      exportTypedArrayMethod("set", function set(arrayLike) {
        aTypedArray(this);
        var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
        var src = toIndexedObject(arrayLike);
        if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
        var length = this.length;
        var len = lengthOfArrayLike(src);
        var index = 0;
        if (len + offset > length) throw new RangeError2("Wrong length");
        while (index < len) this[offset + index] = src[index++];
      }, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);
    }
  });

  // node_modules/core-js/modules/es.typed-array.slice.js
  var require_es_typed_array_slice = __commonJS({
    "node_modules/core-js/modules/es.typed-array.slice.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var fails = require_fails();
      var arraySlice = require_array_slice();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var FORCED = fails(function() {
        new Int8Array(1).slice();
      });
      exportTypedArrayMethod("slice", function slice(start, end) {
        var list = arraySlice(aTypedArray(this), start, end);
        var C2 = getTypedArrayConstructor(this);
        var index = 0;
        var length = list.length;
        var result = new C2(length);
        while (length > index) result[index] = list[index++];
        return result;
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.some.js
  var require_es_typed_array_some = __commonJS({
    "node_modules/core-js/modules/es.typed-array.some.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var $some = require_array_iteration().some;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("some", function some(callbackfn) {
        return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.sort.js
  var require_es_typed_array_sort = __commonJS({
    "node_modules/core-js/modules/es.typed-array.sort.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this_clause();
      var fails = require_fails();
      var aCallable = require_a_callable();
      var internalSort = require_array_sort();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var FF = require_environment_ff_version();
      var IE_OR_EDGE = require_environment_is_ie_or_edge();
      var V8 = require_environment_v8_version();
      var WEBKIT = require_environment_webkit_version();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var Uint16Array2 = globalThis2.Uint16Array;
      var nativeSort = Uint16Array2 && uncurryThis(Uint16Array2.prototype.sort);
      var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function() {
        nativeSort(new Uint16Array2(2), null);
      }) && fails(function() {
        nativeSort(new Uint16Array2(2), {});
      }));
      var STABLE_SORT = !!nativeSort && !fails(function() {
        if (V8) return V8 < 74;
        if (FF) return FF < 67;
        if (IE_OR_EDGE) return true;
        if (WEBKIT) return WEBKIT < 602;
        var array = new Uint16Array2(516);
        var expected = Array(516);
        var index, mod;
        for (index = 0; index < 516; index++) {
          mod = index % 4;
          array[index] = 515 - index;
          expected[index] = index - 2 * mod + 3;
        }
        nativeSort(array, function(a, b) {
          return (a / 4 | 0) - (b / 4 | 0);
        });
        for (index = 0; index < 516; index++) {
          if (array[index] !== expected[index]) return true;
        }
      });
      var getSortCompare = function(comparefn) {
        return function(x2, y) {
          if (comparefn !== void 0) return +comparefn(x2, y) || 0;
          if (y !== y) return -1;
          if (x2 !== x2) return 1;
          if (x2 === 0 && y === 0) return 1 / x2 > 0 && 1 / y < 0 ? 1 : -1;
          return x2 > y;
        };
      };
      exportTypedArrayMethod("sort", function sort(comparefn) {
        if (comparefn !== void 0) aCallable(comparefn);
        if (STABLE_SORT) return nativeSort(this, comparefn);
        return internalSort(aTypedArray(this), getSortCompare(comparefn));
      }, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
    }
  });

  // node_modules/core-js/modules/es.typed-array.subarray.js
  var require_es_typed_array_subarray = __commonJS({
    "node_modules/core-js/modules/es.typed-array.subarray.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var toLength = require_to_length();
      var toAbsoluteIndex = require_to_absolute_index();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      exportTypedArrayMethod("subarray", function subarray(begin, end) {
        var O2 = aTypedArray(this);
        var length = O2.length;
        var beginIndex = toAbsoluteIndex(begin, length);
        var C2 = getTypedArrayConstructor(O2);
        return new C2(
          O2.buffer,
          O2.byteOffset + beginIndex * O2.BYTES_PER_ELEMENT,
          toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
        );
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-locale-string.js
  var require_es_typed_array_to_locale_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-locale-string.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var fails = require_fails();
      var arraySlice = require_array_slice();
      var Int8Array2 = globalThis2.Int8Array;
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var $toLocaleString = [].toLocaleString;
      var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
        $toLocaleString.call(new Int8Array2(1));
      });
      var FORCED = fails(function() {
        return [1, 2].toLocaleString() !== new Int8Array2([1, 2]).toLocaleString();
      }) || !fails(function() {
        Int8Array2.prototype.toLocaleString.call([1, 2]);
      });
      exportTypedArrayMethod("toLocaleString", function toLocaleString() {
        return apply(
          $toLocaleString,
          TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
          arraySlice(arguments)
        );
      }, FORCED);
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-reversed.js
  var require_es_typed_array_to_reversed = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-reversed.js"() {
      "use strict";
      var arrayToReversed = require_array_to_reversed();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      exportTypedArrayMethod("toReversed", function toReversed() {
        return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-sorted.js
  var require_es_typed_array_to_sorted = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-sorted.js"() {
      "use strict";
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var uncurryThis = require_function_uncurry_this();
      var aCallable = require_a_callable();
      var arrayFromConstructorAndList = require_array_from_constructor_and_list();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);
      exportTypedArrayMethod("toSorted", function toSorted(compareFn) {
        if (compareFn !== void 0) aCallable(compareFn);
        var O2 = aTypedArray(this);
        var A2 = arrayFromConstructorAndList(getTypedArrayConstructor(O2), O2);
        return sort(A2, compareFn);
      });
    }
  });

  // node_modules/core-js/modules/es.typed-array.to-string.js
  var require_es_typed_array_to_string = __commonJS({
    "node_modules/core-js/modules/es.typed-array.to-string.js"() {
      "use strict";
      var exportTypedArrayMethod = require_array_buffer_view_core().exportTypedArrayMethod;
      var fails = require_fails();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var Uint8Array2 = globalThis2.Uint8Array;
      var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
      var arrayToString = [].toString;
      var join = uncurryThis([].join);
      if (fails(function() {
        arrayToString.call({});
      })) {
        arrayToString = function toString3() {
          return join(this);
        };
      }
      var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString !== arrayToString;
      exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
    }
  });

  // node_modules/core-js/modules/es.typed-array.with.js
  var require_es_typed_array_with = __commonJS({
    "node_modules/core-js/modules/es.typed-array.with.js"() {
      "use strict";
      var arrayWith = require_array_with();
      var ArrayBufferViewCore = require_array_buffer_view_core();
      var isBigIntArray = require_is_big_int_array();
      var toIntegerOrInfinity = require_to_integer_or_infinity();
      var toBigInt = require_to_big_int();
      var aTypedArray = ArrayBufferViewCore.aTypedArray;
      var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
      var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
      var PROPER_ORDER = !!function() {
        try {
          new Int8Array(1)["with"](2, { valueOf: function() {
            throw 8;
          } });
        } catch (error) {
          return error === 8;
        }
      }();
      exportTypedArrayMethod("with", { "with": function(index, value) {
        var O2 = aTypedArray(this);
        var relativeIndex = toIntegerOrInfinity(index);
        var actualValue = isBigIntArray(O2) ? toBigInt(value) : +value;
        return arrayWith(O2, getTypedArrayConstructor(O2), relativeIndex, actualValue);
      } }["with"], !PROPER_ORDER);
    }
  });

  // node_modules/core-js/modules/es.unescape.js
  var require_es_unescape = __commonJS({
    "node_modules/core-js/modules/es.unescape.js"() {
      "use strict";
      var $2 = require_export();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var stringSlice = uncurryThis("".slice);
      var hex2 = /^[\da-f]{2}$/i;
      var hex4 = /^[\da-f]{4}$/i;
      $2({ global: true }, {
        unescape: function unescape2(string) {
          var str = toString3(string);
          var result = "";
          var length = str.length;
          var index = 0;
          var chr, part;
          while (index < length) {
            chr = charAt(str, index++);
            if (chr === "%") {
              if (charAt(str, index) === "u") {
                part = stringSlice(str, index + 1, index + 5);
                if (exec(hex4, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 5;
                  continue;
                }
              } else {
                part = stringSlice(str, index, index + 2);
                if (exec(hex2, part)) {
                  result += fromCharCode(parseInt(part, 16));
                  index += 2;
                  continue;
                }
              }
            }
            result += chr;
          }
          return result;
        }
      });
    }
  });

  // node_modules/core-js/internals/collection-weak.js
  var require_collection_weak = __commonJS({
    "node_modules/core-js/internals/collection-weak.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIns = require_define_built_ins();
      var getWeakData = require_internal_metadata().getWeakData;
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var isNullOrUndefined = require_is_null_or_undefined();
      var isObject2 = require_is_object();
      var iterate = require_iterate();
      var ArrayIterationModule = require_array_iteration();
      var hasOwn = require_has_own_property();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var internalStateGetterFor = InternalStateModule.getterFor;
      var find = ArrayIterationModule.find;
      var findIndex = ArrayIterationModule.findIndex;
      var splice = uncurryThis([].splice);
      var id = 0;
      var uncaughtFrozenStore = function(state) {
        return state.frozen || (state.frozen = new UncaughtFrozenStore());
      };
      var UncaughtFrozenStore = function() {
        this.entries = [];
      };
      var findUncaughtFrozen = function(store, key) {
        return find(store.entries, function(it2) {
          return it2[0] === key;
        });
      };
      UncaughtFrozenStore.prototype = {
        get: function(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) return entry[1];
        },
        has: function(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function(key, value) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) entry[1] = value;
          else this.entries.push([key, value]);
        },
        "delete": function(key) {
          var index = findIndex(this.entries, function(it2) {
            return it2[0] === key;
          });
          if (~index) splice(this.entries, index, 1);
          return !!~index;
        }
      };
      module.exports = {
        getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
          var Constructor = wrapper(function(that, iterable) {
            anInstance(that, Prototype);
            setInternalState(that, {
              type: CONSTRUCTOR_NAME,
              id: id++,
              frozen: null
            });
            if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
          });
          var Prototype = Constructor.prototype;
          var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
          var define2 = function(that, key, value) {
            var state = getInternalState(that);
            var data2 = getWeakData(anObject(key), true);
            if (data2 === true) uncaughtFrozenStore(state).set(key, value);
            else data2[state.id] = value;
            return that;
          };
          defineBuiltIns(Prototype, {
            // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
            // https://tc39.es/ecma262/#sec-weakset.prototype.delete
            "delete": function(key) {
              var state = getInternalState(this);
              if (!isObject2(key)) return false;
              var data2 = getWeakData(key);
              if (data2 === true) return uncaughtFrozenStore(state)["delete"](key);
              return data2 && hasOwn(data2, state.id) && delete data2[state.id];
            },
            // `{ WeakMap, WeakSet }.prototype.has(key)` methods
            // https://tc39.es/ecma262/#sec-weakmap.prototype.has
            // https://tc39.es/ecma262/#sec-weakset.prototype.has
            has: function has(key) {
              var state = getInternalState(this);
              if (!isObject2(key)) return false;
              var data2 = getWeakData(key);
              if (data2 === true) return uncaughtFrozenStore(state).has(key);
              return data2 && hasOwn(data2, state.id);
            }
          });
          defineBuiltIns(Prototype, IS_MAP ? {
            // `WeakMap.prototype.get(key)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.get
            get: function get(key) {
              var state = getInternalState(this);
              if (isObject2(key)) {
                var data2 = getWeakData(key);
                if (data2 === true) return uncaughtFrozenStore(state).get(key);
                if (data2) return data2[state.id];
              }
            },
            // `WeakMap.prototype.set(key, value)` method
            // https://tc39.es/ecma262/#sec-weakmap.prototype.set
            set: function set(key, value) {
              return define2(this, key, value);
            }
          } : {
            // `WeakSet.prototype.add(value)` method
            // https://tc39.es/ecma262/#sec-weakset.prototype.add
            add: function add(value) {
              return define2(this, value, true);
            }
          });
          return Constructor;
        }
      };
    }
  });

  // node_modules/core-js/modules/es.weak-map.constructor.js
  var require_es_weak_map_constructor = __commonJS({
    "node_modules/core-js/modules/es.weak-map.constructor.js"() {
      "use strict";
      var FREEZING = require_freezing();
      var globalThis2 = require_global_this();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIns = require_define_built_ins();
      var InternalMetadataModule = require_internal_metadata();
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      var isObject2 = require_is_object();
      var enforceInternalState = require_internal_state().enforce;
      var fails = require_fails();
      var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
      var $Object = Object;
      var isArray2 = Array.isArray;
      var isExtensible = $Object.isExtensible;
      var isFrozen = $Object.isFrozen;
      var isSealed = $Object.isSealed;
      var freeze = $Object.freeze;
      var seal = $Object.seal;
      var IS_IE11 = !globalThis2.ActiveXObject && "ActiveXObject" in globalThis2;
      var InternalWeakMap;
      var wrapper = function(init) {
        return function WeakMap2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      };
      var $WeakMap = collection("WeakMap", wrapper, collectionWeak);
      var WeakMapPrototype = $WeakMap.prototype;
      var nativeSet = uncurryThis(WeakMapPrototype.set);
      var hasMSEdgeFreezingBug = function() {
        return FREEZING && fails(function() {
          var frozenArray = freeze([]);
          nativeSet(new $WeakMap(), frozenArray, 1);
          return !isFrozen(frozenArray);
        });
      };
      if (NATIVE_WEAK_MAP) {
        if (IS_IE11) {
          InternalWeakMap = collectionWeak.getConstructor(wrapper, "WeakMap", true);
          InternalMetadataModule.enable();
          nativeDelete = uncurryThis(WeakMapPrototype["delete"]);
          nativeHas = uncurryThis(WeakMapPrototype.has);
          nativeGet = uncurryThis(WeakMapPrototype.get);
          defineBuiltIns(WeakMapPrototype, {
            "delete": function(key) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeDelete(this, key) || state.frozen["delete"](key);
              }
              return nativeDelete(this, key);
            },
            has: function has(key) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas(this, key) || state.frozen.has(key);
              }
              return nativeHas(this, key);
            },
            get: function get(key) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
              }
              return nativeGet(this, key);
            },
            set: function set(key, value) {
              if (isObject2(key) && !isExtensible(key)) {
                var state = enforceInternalState(this);
                if (!state.frozen) state.frozen = new InternalWeakMap();
                nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
              } else nativeSet(this, key, value);
              return this;
            }
          });
        } else if (hasMSEdgeFreezingBug()) {
          defineBuiltIns(WeakMapPrototype, {
            set: function set(key, value) {
              var arrayIntegrityLevel;
              if (isArray2(key)) {
                if (isFrozen(key)) arrayIntegrityLevel = freeze;
                else if (isSealed(key)) arrayIntegrityLevel = seal;
              }
              nativeSet(this, key, value);
              if (arrayIntegrityLevel) arrayIntegrityLevel(key);
              return this;
            }
          });
        }
      }
      var nativeDelete;
      var nativeHas;
      var nativeGet;
    }
  });

  // node_modules/core-js/modules/es.weak-map.js
  var require_es_weak_map = __commonJS({
    "node_modules/core-js/modules/es.weak-map.js"() {
      "use strict";
      require_es_weak_map_constructor();
    }
  });

  // node_modules/core-js/modules/es.weak-set.constructor.js
  var require_es_weak_set_constructor = __commonJS({
    "node_modules/core-js/modules/es.weak-set.constructor.js"() {
      "use strict";
      var collection = require_collection();
      var collectionWeak = require_collection_weak();
      collection("WeakSet", function(init) {
        return function WeakSet2() {
          return init(this, arguments.length ? arguments[0] : void 0);
        };
      }, collectionWeak);
    }
  });

  // node_modules/core-js/modules/es.weak-set.js
  var require_es_weak_set = __commonJS({
    "node_modules/core-js/modules/es.weak-set.js"() {
      "use strict";
      require_es_weak_set_constructor();
    }
  });

  // node_modules/core-js/internals/base64-map.js
  var require_base64_map = __commonJS({
    "node_modules/core-js/internals/base64-map.js"(exports, module) {
      "use strict";
      var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var base64Alphabet = commonAlphabet + "+/";
      var base64UrlAlphabet = commonAlphabet + "-_";
      var inverse = function(characters) {
        var result = {};
        var index = 0;
        for (; index < 64; index++) result[characters.charAt(index)] = index;
        return result;
      };
      module.exports = {
        i2c: base64Alphabet,
        c2i: inverse(base64Alphabet),
        i2cUrl: base64UrlAlphabet,
        c2iUrl: inverse(base64UrlAlphabet)
      };
    }
  });

  // node_modules/core-js/modules/web.atob.js
  var require_web_atob = __commonJS({
    "node_modules/core-js/modules/web.atob.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var toString3 = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var c2i = require_base64_map().c2i;
      var disallowed = /[^\d+/a-z]/i;
      var whitespaces = /[\t\n\f\r ]+/g;
      var finalEq = /[=]{1,2}$/;
      var $atob = getBuiltIn("atob");
      var fromCharCode = String.fromCharCode;
      var charAt = uncurryThis("".charAt);
      var replace = uncurryThis("".replace);
      var exec = uncurryThis(disallowed.exec);
      var BASIC = !!$atob && !fails(function() {
        return $atob("aGk=") !== "hi";
      });
      var NO_SPACES_IGNORE = BASIC && fails(function() {
        return $atob(" ") !== "";
      });
      var NO_ENCODING_CHECK = BASIC && !fails(function() {
        $atob("a");
      });
      var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function() {
        $atob();
      });
      var WRONG_ARITY = BASIC && $atob.length !== 1;
      var FORCED = !BASIC || NO_SPACES_IGNORE || NO_ENCODING_CHECK || NO_ARG_RECEIVING_CHECK || WRONG_ARITY;
      $2({ global: true, bind: true, enumerable: true, forced: FORCED }, {
        atob: function atob2(data2) {
          validateArgumentsLength(arguments.length, 1);
          if (BASIC && !NO_SPACES_IGNORE && !NO_ENCODING_CHECK) return call($atob, globalThis2, data2);
          var string = replace(toString3(data2), whitespaces, "");
          var output = "";
          var position = 0;
          var bc = 0;
          var length, chr, bs2;
          if (string.length % 4 === 0) {
            string = replace(string, finalEq, "");
          }
          length = string.length;
          if (length % 4 === 1 || exec(disallowed, string)) {
            throw new (getBuiltIn("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
          }
          while (position < length) {
            chr = charAt(string, position++);
            bs2 = bc % 4 ? bs2 * 64 + c2i[chr] : c2i[chr];
            if (bc++ % 4) output += fromCharCode(255 & bs2 >> (-2 * bc & 6));
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.btoa.js
  var require_web_btoa = __commonJS({
    "node_modules/core-js/modules/web.btoa.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var call = require_function_call();
      var fails = require_fails();
      var toString3 = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var i2c = require_base64_map().i2c;
      var $btoa = getBuiltIn("btoa");
      var charAt = uncurryThis("".charAt);
      var charCodeAt = uncurryThis("".charCodeAt);
      var BASIC = !!$btoa && !fails(function() {
        return $btoa("hi") !== "aGk=";
      });
      var NO_ARG_RECEIVING_CHECK = BASIC && !fails(function() {
        $btoa();
      });
      var WRONG_ARG_CONVERSION = BASIC && fails(function() {
        return $btoa(null) !== "bnVsbA==";
      });
      var WRONG_ARITY = BASIC && $btoa.length !== 1;
      $2({ global: true, bind: true, enumerable: true, forced: !BASIC || NO_ARG_RECEIVING_CHECK || WRONG_ARG_CONVERSION || WRONG_ARITY }, {
        btoa: function btoa2(data2) {
          validateArgumentsLength(arguments.length, 1);
          if (BASIC) return call($btoa, globalThis2, toString3(data2));
          var string = toString3(data2);
          var output = "";
          var position = 0;
          var map = i2c;
          var block, charCode;
          while (charAt(string, position) || (map = "=", position % 1)) {
            charCode = charCodeAt(string, position += 3 / 4);
            if (charCode > 255) {
              throw new (getBuiltIn("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
            }
            block = block << 8 | charCode;
            output += charAt(map, 63 & block >> 8 - position % 1 * 8);
          }
          return output;
        }
      });
    }
  });

  // node_modules/core-js/internals/dom-iterables.js
  var require_dom_iterables = __commonJS({
    "node_modules/core-js/internals/dom-iterables.js"(exports, module) {
      "use strict";
      module.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
      };
    }
  });

  // node_modules/core-js/internals/dom-token-list-prototype.js
  var require_dom_token_list_prototype = __commonJS({
    "node_modules/core-js/internals/dom-token-list-prototype.js"(exports, module) {
      "use strict";
      var documentCreateElement = require_document_create_element();
      var classList = documentCreateElement("span").classList;
      var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
      module.exports = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
    }
  });

  // node_modules/core-js/modules/web.dom-collections.for-each.js
  var require_web_dom_collections_for_each = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.for-each.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var forEach2 = require_array_for_each();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var handlePrototype = function(CollectionPrototype) {
        if (CollectionPrototype && CollectionPrototype.forEach !== forEach2) try {
          createNonEnumerableProperty(CollectionPrototype, "forEach", forEach2);
        } catch (error) {
          CollectionPrototype.forEach = forEach2;
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        if (DOMIterables[COLLECTION_NAME]) {
          handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype);
        }
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype);
    }
  });

  // node_modules/core-js/modules/web.dom-collections.iterator.js
  var require_web_dom_collections_iterator = __commonJS({
    "node_modules/core-js/modules/web.dom-collections.iterator.js"() {
      "use strict";
      var globalThis2 = require_global_this();
      var DOMIterables = require_dom_iterables();
      var DOMTokenListPrototype = require_dom_token_list_prototype();
      var ArrayIteratorMethods = require_es_array_iterator();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var setToStringTag = require_set_to_string_tag();
      var wellKnownSymbol = require_well_known_symbol();
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayValues = ArrayIteratorMethods.values;
      var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
        if (CollectionPrototype) {
          if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
          }
          setToStringTag(CollectionPrototype, COLLECTION_NAME2, true);
          if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
              createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
            } catch (error) {
              CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
            }
          }
        }
      };
      for (COLLECTION_NAME in DOMIterables) {
        handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
      }
      var COLLECTION_NAME;
      handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    }
  });

  // node_modules/core-js/internals/dom-exception-constants.js
  var require_dom_exception_constants = __commonJS({
    "node_modules/core-js/internals/dom-exception-constants.js"(exports, module) {
      "use strict";
      module.exports = {
        IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
        DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
        HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
        WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
        InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
        NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
        NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
        NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
        NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
        InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
        InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
        SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
        InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
        NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
        InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
        ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
        TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
        SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
        NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
        AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
        URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
        QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
        TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
        InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
        DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
      };
    }
  });

  // node_modules/core-js/modules/web.dom-exception.constructor.js
  var require_web_dom_exception_constructor = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.constructor.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var getBuiltInNodeModule = require_get_built_in_node_module();
      var fails = require_fails();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var anObject = require_an_object();
      var errorToString = require_error_to_string();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_error_stack_clear();
      var InternalStateModule = require_internal_state();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var DATA_CLONE_ERR = "DATA_CLONE_ERR";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION) || function() {
        try {
          var MessageChannel2 = getBuiltIn("MessageChannel") || getBuiltInNodeModule("worker_threads").MessageChannel;
          new MessageChannel2().port1.postMessage(/* @__PURE__ */ new WeakMap());
        } catch (error) {
          if (error.name === DATA_CLONE_ERR && error.code === 25) return error.constructor;
        }
      }();
      var NativeDOMExceptionPrototype = NativeDOMException && NativeDOMException.prototype;
      var ErrorPrototype = Error2.prototype;
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(DOM_EXCEPTION);
      var HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
      var codeFor = function(name) {
        return hasOwn(DOMExceptionConstants, name) && DOMExceptionConstants[name].m ? DOMExceptionConstants[name].c : 0;
      };
      var $DOMException = function DOMException() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var code = codeFor(name);
        setInternalState(this, {
          type: DOM_EXCEPTION,
          name,
          message,
          code
        });
        if (!DESCRIPTORS) {
          this.name = name;
          this.message = message;
          this.code = code;
        }
        if (HAS_STACK) {
          var error = new Error2(message);
          error.name = DOM_EXCEPTION;
          defineProperty(this, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
        }
      };
      var DOMExceptionPrototype = $DOMException.prototype = create(ErrorPrototype);
      var createGetterDescriptor = function(get) {
        return { enumerable: true, configurable: true, get };
      };
      var getterFor = function(key2) {
        return createGetterDescriptor(function() {
          return getInternalState(this)[key2];
        });
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(DOMExceptionPrototype, "code", getterFor("code"));
        defineBuiltInAccessor(DOMExceptionPrototype, "message", getterFor("message"));
        defineBuiltInAccessor(DOMExceptionPrototype, "name", getterFor("name"));
      }
      defineProperty(DOMExceptionPrototype, "constructor", createPropertyDescriptor(1, $DOMException));
      var INCORRECT_CONSTRUCTOR = fails(function() {
        return !(new NativeDOMException() instanceof Error2);
      });
      var INCORRECT_TO_STRING = INCORRECT_CONSTRUCTOR || fails(function() {
        return ErrorPrototype.toString !== errorToString || String(new NativeDOMException(1, 2)) !== "2: 1";
      });
      var INCORRECT_CODE = INCORRECT_CONSTRUCTOR || fails(function() {
        return new NativeDOMException(1, "DataCloneError").code !== 25;
      });
      var MISSED_CONSTANTS = INCORRECT_CONSTRUCTOR || NativeDOMException[DATA_CLONE_ERR] !== 25 || NativeDOMExceptionPrototype[DATA_CLONE_ERR] !== 25;
      var FORCED_CONSTRUCTOR = IS_PURE ? INCORRECT_TO_STRING || INCORRECT_CODE || MISSED_CONSTANTS : INCORRECT_CONSTRUCTOR;
      $2({ global: true, constructor: true, forced: FORCED_CONSTRUCTOR }, {
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (INCORRECT_TO_STRING && (IS_PURE || NativeDOMException === PolyfilledDOMException)) {
        defineBuiltIn(PolyfilledDOMExceptionPrototype, "toString", errorToString);
      }
      if (INCORRECT_CODE && DESCRIPTORS && NativeDOMException === PolyfilledDOMException) {
        defineBuiltInAccessor(PolyfilledDOMExceptionPrototype, "code", createGetterDescriptor(function() {
          return codeFor(anObject(this).name);
        }));
      }
      for (key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
        constant = DOMExceptionConstants[key];
        constantName = constant.s;
        descriptor = createPropertyDescriptor(6, constant.c);
        if (!hasOwn(PolyfilledDOMException, constantName)) {
          defineProperty(PolyfilledDOMException, constantName, descriptor);
        }
        if (!hasOwn(PolyfilledDOMExceptionPrototype, constantName)) {
          defineProperty(PolyfilledDOMExceptionPrototype, constantName, descriptor);
        }
      }
      var constant;
      var constantName;
      var descriptor;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.stack.js
  var require_web_dom_exception_stack = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.stack.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var createPropertyDescriptor = require_create_property_descriptor();
      var defineProperty = require_object_define_property().f;
      var hasOwn = require_has_own_property();
      var anInstance = require_an_instance();
      var inheritIfRequired = require_inherit_if_required();
      var normalizeStringArgument = require_normalize_string_argument();
      var DOMExceptionConstants = require_dom_exception_constants();
      var clearErrorStack = require_error_stack_clear();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var DOM_EXCEPTION = "DOMException";
      var Error2 = getBuiltIn("Error");
      var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
      var $DOMException = function DOMException() {
        anInstance(this, DOMExceptionPrototype);
        var argumentsLength = arguments.length;
        var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
        var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
        var that = new NativeDOMException(message, name);
        var error = new Error2(message);
        error.name = DOM_EXCEPTION;
        defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
        inheritIfRequired(that, this, $DOMException);
        return that;
      };
      var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
      var ERROR_HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
      var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
      var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, DOM_EXCEPTION);
      var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
      var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
      $2({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
        // TODO: fix export logic
        DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
      });
      var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
      var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
      if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
        if (!IS_PURE) {
          defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
        }
        for (key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
          constant = DOMExceptionConstants[key];
          constantName = constant.s;
          if (!hasOwn(PolyfilledDOMException, constantName)) {
            defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));
          }
        }
      }
      var constant;
      var constantName;
      var key;
    }
  });

  // node_modules/core-js/modules/web.dom-exception.to-string-tag.js
  var require_web_dom_exception_to_string_tag = __commonJS({
    "node_modules/core-js/modules/web.dom-exception.to-string-tag.js"() {
      "use strict";
      var getBuiltIn = require_get_built_in();
      var setToStringTag = require_set_to_string_tag();
      var DOM_EXCEPTION = "DOMException";
      setToStringTag(getBuiltIn(DOM_EXCEPTION), DOM_EXCEPTION);
    }
  });

  // node_modules/core-js/modules/web.clear-immediate.js
  var require_web_clear_immediate = __commonJS({
    "node_modules/core-js/modules/web.clear-immediate.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var clearImmediate = require_task().clear;
      $2({ global: true, bind: true, enumerable: true, forced: globalThis2.clearImmediate !== clearImmediate }, {
        clearImmediate
      });
    }
  });

  // node_modules/core-js/internals/schedulers-fix.js
  var require_schedulers_fix = __commonJS({
    "node_modules/core-js/internals/schedulers-fix.js"(exports, module) {
      "use strict";
      var globalThis2 = require_global_this();
      var apply = require_function_apply();
      var isCallable = require_is_callable();
      var ENVIRONMENT = require_environment();
      var USER_AGENT = require_environment_user_agent();
      var arraySlice = require_array_slice();
      var validateArgumentsLength = require_validate_arguments_length();
      var Function2 = globalThis2.Function;
      var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === "BUN" && function() {
        var version2 = globalThis2.Bun.version.split(".");
        return version2.length < 3 || version2[0] === "0" && (version2[1] < 3 || version2[1] === "3" && version2[2] === "0");
      }();
      module.exports = function(scheduler, hasTimeArg) {
        var firstParamIndex = hasTimeArg ? 2 : 1;
        return WRAP ? function(handler, timeout) {
          var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
          var fn2 = isCallable(handler) ? handler : Function2(handler);
          var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
          var callback = boundArgs ? function() {
            apply(fn2, this, params);
          } : fn2;
          return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
        } : scheduler;
      };
    }
  });

  // node_modules/core-js/modules/web.set-immediate.js
  var require_web_set_immediate = __commonJS({
    "node_modules/core-js/modules/web.set-immediate.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var setTask = require_task().set;
      var schedulersFix = require_schedulers_fix();
      var setImmediate2 = globalThis2.setImmediate ? schedulersFix(setTask, false) : setTask;
      $2({ global: true, bind: true, enumerable: true, forced: globalThis2.setImmediate !== setImmediate2 }, {
        setImmediate: setImmediate2
      });
    }
  });

  // node_modules/core-js/modules/web.immediate.js
  var require_web_immediate = __commonJS({
    "node_modules/core-js/modules/web.immediate.js"() {
      "use strict";
      require_web_clear_immediate();
      require_web_set_immediate();
    }
  });

  // node_modules/core-js/modules/web.queue-microtask.js
  var require_web_queue_microtask = __commonJS({
    "node_modules/core-js/modules/web.queue-microtask.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var microtask = require_microtask();
      var aCallable = require_a_callable();
      var validateArgumentsLength = require_validate_arguments_length();
      var fails = require_fails();
      var DESCRIPTORS = require_descriptors();
      var WRONG_ARITY = fails(function() {
        return DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, "queueMicrotask").value.length !== 1;
      });
      $2({ global: true, enumerable: true, dontCallGetSet: true, forced: WRONG_ARITY }, {
        queueMicrotask: function queueMicrotask2(fn2) {
          validateArgumentsLength(arguments.length, 1);
          microtask(aCallable(fn2));
        }
      });
    }
  });

  // node_modules/core-js/modules/web.self.js
  var require_web_self = __commonJS({
    "node_modules/core-js/modules/web.self.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var DESCRIPTORS = require_descriptors();
      var $TypeError = TypeError;
      var defineProperty = Object.defineProperty;
      var INCORRECT_VALUE = globalThis2.self !== globalThis2;
      try {
        if (DESCRIPTORS) {
          descriptor = Object.getOwnPropertyDescriptor(globalThis2, "self");
          if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
            defineBuiltInAccessor(globalThis2, "self", {
              get: function self2() {
                return globalThis2;
              },
              set: function self2(value) {
                if (this !== globalThis2) throw new $TypeError("Illegal invocation");
                defineProperty(globalThis2, "self", {
                  value,
                  writable: true,
                  configurable: true,
                  enumerable: true
                });
              },
              configurable: true,
              enumerable: true
            });
          }
        } else $2({ global: true, simple: true, forced: INCORRECT_VALUE }, {
          self: globalThis2
        });
      } catch (error) {
      }
      var descriptor;
    }
  });

  // node_modules/core-js/modules/web.structured-clone.js
  var require_web_structured_clone = __commonJS({
    "node_modules/core-js/modules/web.structured-clone.js"() {
      "use strict";
      var IS_PURE = require_is_pure();
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var getBuiltIn = require_get_built_in();
      var uncurryThis = require_function_uncurry_this();
      var fails = require_fails();
      var uid = require_uid();
      var isCallable = require_is_callable();
      var isConstructor = require_is_constructor();
      var isNullOrUndefined = require_is_null_or_undefined();
      var isObject2 = require_is_object();
      var isSymbol = require_is_symbol();
      var iterate = require_iterate();
      var anObject = require_an_object();
      var classof = require_classof();
      var hasOwn = require_has_own_property();
      var createProperty = require_create_property();
      var createNonEnumerableProperty = require_create_non_enumerable_property();
      var lengthOfArrayLike = require_length_of_array_like();
      var validateArgumentsLength = require_validate_arguments_length();
      var getRegExpFlags = require_regexp_get_flags();
      var MapHelpers = require_map_helpers();
      var SetHelpers = require_set_helpers();
      var setIterate = require_set_iterate();
      var detachTransferable = require_detach_transferable();
      var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
      var PROPER_STRUCTURED_CLONE_TRANSFER = require_structured_clone_proper_transfer();
      var Object2 = globalThis2.Object;
      var Array2 = globalThis2.Array;
      var Date2 = globalThis2.Date;
      var Error2 = globalThis2.Error;
      var TypeError2 = globalThis2.TypeError;
      var PerformanceMark = globalThis2.PerformanceMark;
      var DOMException = getBuiltIn("DOMException");
      var Map2 = MapHelpers.Map;
      var mapHas = MapHelpers.has;
      var mapGet = MapHelpers.get;
      var mapSet = MapHelpers.set;
      var Set2 = SetHelpers.Set;
      var setAdd = SetHelpers.add;
      var setHas = SetHelpers.has;
      var objectKeys = getBuiltIn("Object", "keys");
      var push = uncurryThis([].push);
      var thisBooleanValue = uncurryThis(true.valueOf);
      var thisNumberValue = uncurryThis(1 .valueOf);
      var thisStringValue = uncurryThis("".valueOf);
      var thisTimeValue = uncurryThis(Date2.prototype.getTime);
      var PERFORMANCE_MARK = uid("structuredClone");
      var DATA_CLONE_ERROR = "DataCloneError";
      var TRANSFERRING = "Transferring";
      var checkBasicSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var set1 = new globalThis2.Set([7]);
          var set2 = structuredCloneImplementation(set1);
          var number = structuredCloneImplementation(Object2(7));
          return set2 === set1 || !set2.has(7) || !isObject2(number) || +number !== 7;
        }) && structuredCloneImplementation;
      };
      var checkErrorsCloning = function(structuredCloneImplementation, $Error) {
        return !fails(function() {
          var error = new $Error();
          var test2 = structuredCloneImplementation({ a: error, b: error });
          return !(test2 && test2.a === test2.b && test2.a instanceof $Error && test2.a.stack === error.stack);
        });
      };
      var checkNewErrorsCloningSemantic = function(structuredCloneImplementation) {
        return !fails(function() {
          var test2 = structuredCloneImplementation(new globalThis2.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));
          return test2.name !== "AggregateError" || test2.errors[0] !== 1 || test2.message !== PERFORMANCE_MARK || test2.cause !== 3;
        });
      };
      var nativeStructuredClone = globalThis2.structuredClone;
      var FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error2) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);
      var structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function(value) {
        return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;
      });
      var nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;
      var throwUncloneable = function(type) {
        throw new DOMException("Uncloneable type: " + type, DATA_CLONE_ERROR);
      };
      var throwUnpolyfillable = function(type, action) {
        throw new DOMException((action || "Cloning") + " of " + type + " cannot be properly polyfilled in this engine", DATA_CLONE_ERROR);
      };
      var tryNativeRestrictedStructuredClone = function(value, type) {
        if (!nativeRestrictedStructuredClone) throwUnpolyfillable(type);
        return nativeRestrictedStructuredClone(value);
      };
      var createDataTransfer = function() {
        var dataTransfer;
        try {
          dataTransfer = new globalThis2.DataTransfer();
        } catch (error) {
          try {
            dataTransfer = new globalThis2.ClipboardEvent("").clipboardData;
          } catch (error2) {
          }
        }
        return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;
      };
      var cloneBuffer = function(value, map, $type) {
        if (mapHas(map, value)) return mapGet(map, value);
        var type = $type || classof(value);
        var clone, length, options, source, target, i;
        if (type === "SharedArrayBuffer") {
          if (nativeRestrictedStructuredClone) clone = nativeRestrictedStructuredClone(value);
          else clone = value;
        } else {
          var DataView2 = globalThis2.DataView;
          if (!DataView2 && !isCallable(value.slice)) throwUnpolyfillable("ArrayBuffer");
          try {
            if (isCallable(value.slice) && !value.resizable) {
              clone = value.slice(0);
            } else {
              length = value.byteLength;
              options = "maxByteLength" in value ? { maxByteLength: value.maxByteLength } : void 0;
              clone = new ArrayBuffer(length, options);
              source = new DataView2(value);
              target = new DataView2(clone);
              for (i = 0; i < length; i++) {
                target.setUint8(i, source.getUint8(i));
              }
            }
          } catch (error) {
            throw new DOMException("ArrayBuffer is detached", DATA_CLONE_ERROR);
          }
        }
        mapSet(map, value, clone);
        return clone;
      };
      var cloneView = function(value, type, offset, length, map) {
        var C2 = globalThis2[type];
        if (!isObject2(C2)) throwUnpolyfillable(type);
        return new C2(cloneBuffer(value.buffer, map), offset, length);
      };
      var structuredCloneInternal = function(value, map) {
        if (isSymbol(value)) throwUncloneable("Symbol");
        if (!isObject2(value)) return value;
        if (map) {
          if (mapHas(map, value)) return mapGet(map, value);
        } else map = new Map2();
        var type = classof(value);
        var C2, name, cloned, dataTransfer, i, length, keys, key;
        switch (type) {
          case "Array":
            cloned = Array2(lengthOfArrayLike(value));
            break;
          case "Object":
            cloned = {};
            break;
          case "Map":
            cloned = new Map2();
            break;
          case "Set":
            cloned = new Set2();
            break;
          case "RegExp":
            cloned = new RegExp(value.source, getRegExpFlags(value));
            break;
          case "Error":
            name = value.name;
            switch (name) {
              case "AggregateError":
                cloned = new (getBuiltIn(name))([]);
                break;
              case "EvalError":
              case "RangeError":
              case "ReferenceError":
              case "SuppressedError":
              case "SyntaxError":
              case "TypeError":
              case "URIError":
                cloned = new (getBuiltIn(name))();
                break;
              case "CompileError":
              case "LinkError":
              case "RuntimeError":
                cloned = new (getBuiltIn("WebAssembly", name))();
                break;
              default:
                cloned = new Error2();
            }
            break;
          case "DOMException":
            cloned = new DOMException(value.message, value.name);
            break;
          case "ArrayBuffer":
          case "SharedArrayBuffer":
            cloned = cloneBuffer(value, map, type);
            break;
          case "DataView":
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float16Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array":
            length = type === "DataView" ? value.byteLength : value.length;
            cloned = cloneView(value, type, value.byteOffset, length, map);
            break;
          case "DOMQuad":
            try {
              cloned = new DOMQuad(
                structuredCloneInternal(value.p1, map),
                structuredCloneInternal(value.p2, map),
                structuredCloneInternal(value.p3, map),
                structuredCloneInternal(value.p4, map)
              );
            } catch (error) {
              cloned = tryNativeRestrictedStructuredClone(value, type);
            }
            break;
          case "File":
            if (nativeRestrictedStructuredClone) try {
              cloned = nativeRestrictedStructuredClone(value);
              if (classof(cloned) !== type) cloned = void 0;
            } catch (error) {
            }
            if (!cloned) try {
              cloned = new File([value], value.name, value);
            } catch (error) {
            }
            if (!cloned) throwUnpolyfillable(type);
            break;
          case "FileList":
            dataTransfer = createDataTransfer();
            if (dataTransfer) {
              for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {
                dataTransfer.items.add(structuredCloneInternal(value[i], map));
              }
              cloned = dataTransfer.files;
            } else cloned = tryNativeRestrictedStructuredClone(value, type);
            break;
          case "ImageData":
            try {
              cloned = new ImageData(
                structuredCloneInternal(value.data, map),
                value.width,
                value.height,
                { colorSpace: value.colorSpace }
              );
            } catch (error) {
              cloned = tryNativeRestrictedStructuredClone(value, type);
            }
            break;
          default:
            if (nativeRestrictedStructuredClone) {
              cloned = nativeRestrictedStructuredClone(value);
            } else switch (type) {
              case "BigInt":
                cloned = Object2(value.valueOf());
                break;
              case "Boolean":
                cloned = Object2(thisBooleanValue(value));
                break;
              case "Number":
                cloned = Object2(thisNumberValue(value));
                break;
              case "String":
                cloned = Object2(thisStringValue(value));
                break;
              case "Date":
                cloned = new Date2(thisTimeValue(value));
                break;
              case "Blob":
                try {
                  cloned = value.slice(0, value.size, value.type);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMPoint":
              case "DOMPointReadOnly":
                C2 = globalThis2[type];
                try {
                  cloned = C2.fromPoint ? C2.fromPoint(value) : new C2(value.x, value.y, value.z, value.w);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMRect":
              case "DOMRectReadOnly":
                C2 = globalThis2[type];
                try {
                  cloned = C2.fromRect ? C2.fromRect(value) : new C2(value.x, value.y, value.width, value.height);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "DOMMatrix":
              case "DOMMatrixReadOnly":
                C2 = globalThis2[type];
                try {
                  cloned = C2.fromMatrix ? C2.fromMatrix(value) : new C2(value);
                } catch (error) {
                  throwUnpolyfillable(type);
                }
                break;
              case "AudioData":
              case "VideoFrame":
                if (!isCallable(value.clone)) throwUnpolyfillable(type);
                try {
                  cloned = value.clone();
                } catch (error) {
                  throwUncloneable(type);
                }
                break;
              case "CropTarget":
              case "CryptoKey":
              case "FileSystemDirectoryHandle":
              case "FileSystemFileHandle":
              case "FileSystemHandle":
              case "GPUCompilationInfo":
              case "GPUCompilationMessage":
              case "ImageBitmap":
              case "RTCCertificate":
              case "WebAssembly.Module":
                throwUnpolyfillable(type);
              // break omitted
              default:
                throwUncloneable(type);
            }
        }
        mapSet(map, value, cloned);
        switch (type) {
          case "Array":
          case "Object":
            keys = objectKeys(value);
            for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {
              key = keys[i];
              createProperty(cloned, key, structuredCloneInternal(value[key], map));
            }
            break;
          case "Map":
            value.forEach(function(v, k) {
              mapSet(cloned, structuredCloneInternal(k, map), structuredCloneInternal(v, map));
            });
            break;
          case "Set":
            value.forEach(function(v) {
              setAdd(cloned, structuredCloneInternal(v, map));
            });
            break;
          case "Error":
            createNonEnumerableProperty(cloned, "message", structuredCloneInternal(value.message, map));
            if (hasOwn(value, "cause")) {
              createNonEnumerableProperty(cloned, "cause", structuredCloneInternal(value.cause, map));
            }
            if (name === "AggregateError") {
              cloned.errors = structuredCloneInternal(value.errors, map);
            } else if (name === "SuppressedError") {
              cloned.error = structuredCloneInternal(value.error, map);
              cloned.suppressed = structuredCloneInternal(value.suppressed, map);
            }
          // break omitted
          case "DOMException":
            if (ERROR_STACK_INSTALLABLE) {
              createNonEnumerableProperty(cloned, "stack", structuredCloneInternal(value.stack, map));
            }
        }
        return cloned;
      };
      var tryToTransfer = function(rawTransfer, map) {
        if (!isObject2(rawTransfer)) throw new TypeError2("Transfer option cannot be converted to a sequence");
        var transfer = [];
        iterate(rawTransfer, function(value2) {
          push(transfer, anObject(value2));
        });
        var i = 0;
        var length = lengthOfArrayLike(transfer);
        var buffers = new Set2();
        var value, type, C2, transferred, canvas, context;
        while (i < length) {
          value = transfer[i++];
          type = classof(value);
          if (type === "ArrayBuffer" ? setHas(buffers, value) : mapHas(map, value)) {
            throw new DOMException("Duplicate transferable", DATA_CLONE_ERROR);
          }
          if (type === "ArrayBuffer") {
            setAdd(buffers, value);
            continue;
          }
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            transferred = nativeStructuredClone(value, { transfer: [value] });
          } else switch (type) {
            case "ImageBitmap":
              C2 = globalThis2.OffscreenCanvas;
              if (!isConstructor(C2)) throwUnpolyfillable(type, TRANSFERRING);
              try {
                canvas = new C2(value.width, value.height);
                context = canvas.getContext("bitmaprenderer");
                context.transferFromImageBitmap(value);
                transferred = canvas.transferToImageBitmap();
              } catch (error) {
              }
              break;
            case "AudioData":
            case "VideoFrame":
              if (!isCallable(value.clone) || !isCallable(value.close)) throwUnpolyfillable(type, TRANSFERRING);
              try {
                transferred = value.clone();
                value.close();
              } catch (error) {
              }
              break;
            case "MediaSourceHandle":
            case "MessagePort":
            case "MIDIAccess":
            case "OffscreenCanvas":
            case "ReadableStream":
            case "RTCDataChannel":
            case "TransformStream":
            case "WebTransportReceiveStream":
            case "WebTransportSendStream":
            case "WritableStream":
              throwUnpolyfillable(type, TRANSFERRING);
          }
          if (transferred === void 0) throw new DOMException("This object cannot be transferred: " + type, DATA_CLONE_ERROR);
          mapSet(map, value, transferred);
        }
        return buffers;
      };
      var detachBuffers = function(buffers) {
        setIterate(buffers, function(buffer) {
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            nativeRestrictedStructuredClone(buffer, { transfer: [buffer] });
          } else if (isCallable(buffer.transfer)) {
            buffer.transfer();
          } else if (detachTransferable) {
            detachTransferable(buffer);
          } else {
            throwUnpolyfillable("ArrayBuffer", TRANSFERRING);
          }
        });
      };
      $2({ global: true, enumerable: true, sham: !PROPER_STRUCTURED_CLONE_TRANSFER, forced: FORCED_REPLACEMENT }, {
        structuredClone: function structuredClone2(value) {
          var options = validateArgumentsLength(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject(arguments[1]) : void 0;
          var transfer = options ? options.transfer : void 0;
          var map, buffers;
          if (transfer !== void 0) {
            map = new Map2();
            buffers = tryToTransfer(transfer, map);
          }
          var clone = structuredCloneInternal(value, map);
          if (buffers) detachBuffers(buffers);
          return clone;
        }
      });
    }
  });

  // node_modules/core-js/modules/web.set-interval.js
  var require_web_set_interval = __commonJS({
    "node_modules/core-js/modules/web.set-interval.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var schedulersFix = require_schedulers_fix();
      var setInterval = schedulersFix(globalThis2.setInterval, true);
      $2({ global: true, bind: true, forced: globalThis2.setInterval !== setInterval }, {
        setInterval
      });
    }
  });

  // node_modules/core-js/modules/web.set-timeout.js
  var require_web_set_timeout = __commonJS({
    "node_modules/core-js/modules/web.set-timeout.js"() {
      "use strict";
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var schedulersFix = require_schedulers_fix();
      var setTimeout2 = schedulersFix(globalThis2.setTimeout, true);
      $2({ global: true, bind: true, forced: globalThis2.setTimeout !== setTimeout2 }, {
        setTimeout: setTimeout2
      });
    }
  });

  // node_modules/core-js/modules/web.timers.js
  var require_web_timers = __commonJS({
    "node_modules/core-js/modules/web.timers.js"() {
      "use strict";
      require_web_set_interval();
      require_web_set_timeout();
    }
  });

  // node_modules/core-js/internals/url-constructor-detection.js
  var require_url_constructor_detection = __commonJS({
    "node_modules/core-js/internals/url-constructor-detection.js"(exports, module) {
      "use strict";
      var fails = require_fails();
      var wellKnownSymbol = require_well_known_symbol();
      var DESCRIPTORS = require_descriptors();
      var IS_PURE = require_is_pure();
      var ITERATOR = wellKnownSymbol("iterator");
      module.exports = !fails(function() {
        var url = new URL("b?a=1&b=2&c=3", "https://a");
        var params = url.searchParams;
        var params2 = new URLSearchParams("a=1&a=2&b=3");
        var result = "";
        url.pathname = "c%20d";
        params.forEach(function(value, key) {
          params["delete"]("b");
          result += key + value;
        });
        params2["delete"]("a", 2);
        params2["delete"]("b", void 0);
        return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "https://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("https://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("https://x", void 0).host !== "x";
      });
    }
  });

  // node_modules/core-js/internals/string-punycode-to-ascii.js
  var require_string_punycode_to_ascii = __commonJS({
    "node_modules/core-js/internals/string-punycode-to-ascii.js"(exports, module) {
      "use strict";
      var uncurryThis = require_function_uncurry_this();
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexNonASCII = /[^\0-\u007E]/;
      var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
      var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
      var baseMinusTMin = base - tMin;
      var $RangeError = RangeError;
      var exec = uncurryThis(regexSeparators.exec);
      var floor = Math.floor;
      var fromCharCode = String.fromCharCode;
      var charCodeAt = uncurryThis("".charCodeAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var split = uncurryThis("".split);
      var toLowerCase = uncurryThis("".toLowerCase);
      var ucs2decode = function(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = charCodeAt(string, counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = charCodeAt(string, counter++);
            if ((extra & 64512) === 56320) {
              push(output, ((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              push(output, value);
              counter--;
            }
          } else {
            push(output, value);
          }
        }
        return output;
      };
      var digitToBasic = function(digit) {
        return digit + 22 + 75 * (digit < 26);
      };
      var adapt = function(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        while (delta > baseMinusTMin * tMax >> 1) {
          delta = floor(delta / baseMinusTMin);
          k += base;
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var encode4 = function(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var i, currentValue;
        for (i = 0; i < input.length; i++) {
          currentValue = input[i];
          if (currentValue < 128) {
            push(output, fromCharCode(currentValue));
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          push(output, delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            throw new $RangeError(OVERFLOW_ERROR);
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (i = 0; i < input.length; i++) {
            currentValue = input[i];
            if (currentValue < n && ++delta > maxInt) {
              throw new $RangeError(OVERFLOW_ERROR);
            }
            if (currentValue === n) {
              var q2 = delta;
              var k = base;
              while (true) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q2 < t) break;
                var qMinusT = q2 - t;
                var baseMinusT = base - t;
                push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                q2 = floor(qMinusT / baseMinusT);
                k += base;
              }
              push(output, fromCharCode(digitToBasic(q2)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
              delta = 0;
              handledCPCount++;
            }
          }
          delta++;
          n++;
        }
        return join(output, "");
      };
      module.exports = function(input) {
        var encoded = [];
        var labels = split(replace(toLowerCase(input), regexSeparators, "."), ".");
        var i, label;
        for (i = 0; i < labels.length; i++) {
          label = labels[i];
          push(encoded, exec(regexNonASCII, label) ? "xn--" + encode4(label) : label);
        }
        return join(encoded, ".");
      };
    }
  });

  // node_modules/core-js/modules/web.url-search-params.constructor.js
  var require_web_url_search_params_constructor = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.constructor.js"(exports, module) {
      "use strict";
      require_es_array_iterator();
      require_es_string_from_code_point();
      var $2 = require_export();
      var globalThis2 = require_global_this();
      var safeGetBuiltIn = require_safe_get_built_in();
      var getBuiltIn = require_get_built_in();
      var call = require_function_call();
      var uncurryThis = require_function_uncurry_this();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var defineBuiltIns = require_define_built_ins();
      var setToStringTag = require_set_to_string_tag();
      var createIteratorConstructor = require_iterator_create_constructor();
      var InternalStateModule = require_internal_state();
      var anInstance = require_an_instance();
      var isCallable = require_is_callable();
      var hasOwn = require_has_own_property();
      var bind2 = require_function_bind_context();
      var classof = require_classof();
      var anObject = require_an_object();
      var isObject2 = require_is_object();
      var $toString = require_to_string();
      var create = require_object_create();
      var createPropertyDescriptor = require_create_property_descriptor();
      var getIterator = require_get_iterator();
      var getIteratorMethod = require_get_iterator_method();
      var createIterResultObject = require_create_iter_result_object();
      var validateArgumentsLength = require_validate_arguments_length();
      var wellKnownSymbol = require_well_known_symbol();
      var arraySort = require_array_sort();
      var ITERATOR = wellKnownSymbol("iterator");
      var URL_SEARCH_PARAMS = "URLSearchParams";
      var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
      var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
      var nativeFetch = safeGetBuiltIn("fetch");
      var NativeRequest = safeGetBuiltIn("Request");
      var Headers = safeGetBuiltIn("Headers");
      var RequestPrototype = NativeRequest && NativeRequest.prototype;
      var HeadersPrototype = Headers && Headers.prototype;
      var TypeError2 = globalThis2.TypeError;
      var encodeURIComponent2 = globalThis2.encodeURIComponent;
      var fromCharCode = String.fromCharCode;
      var fromCodePoint = getBuiltIn("String", "fromCodePoint");
      var $parseInt = parseInt;
      var charAt = uncurryThis("".charAt);
      var join = uncurryThis([].join);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var splice = uncurryThis([].splice);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var exec = uncurryThis(/./.exec);
      var plus = /\+/g;
      var FALLBACK_REPLACER = "\uFFFD";
      var VALID_HEX = /^[0-9a-f]+$/i;
      var parseHexOctet = function(string, start) {
        var substr = stringSlice(string, start, start + 2);
        if (!exec(VALID_HEX, substr)) return NaN;
        return $parseInt(substr, 16);
      };
      var getLeadingOnes = function(octet) {
        var count = 0;
        for (var mask = 128; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
          count++;
        }
        return count;
      };
      var utf8Decode = function(octets) {
        var codePoint = null;
        switch (octets.length) {
          case 1:
            codePoint = octets[0];
            break;
          case 2:
            codePoint = (octets[0] & 31) << 6 | octets[1] & 63;
            break;
          case 3:
            codePoint = (octets[0] & 15) << 12 | (octets[1] & 63) << 6 | octets[2] & 63;
            break;
          case 4:
            codePoint = (octets[0] & 7) << 18 | (octets[1] & 63) << 12 | (octets[2] & 63) << 6 | octets[3] & 63;
            break;
        }
        return codePoint > 1114111 ? null : codePoint;
      };
      var decode2 = function(input) {
        input = replace(input, plus, " ");
        var length = input.length;
        var result = "";
        var i = 0;
        while (i < length) {
          var decodedChar = charAt(input, i);
          if (decodedChar === "%") {
            if (charAt(input, i + 1) === "%" || i + 3 > length) {
              result += "%";
              i++;
              continue;
            }
            var octet = parseHexOctet(input, i + 1);
            if (octet !== octet) {
              result += decodedChar;
              i++;
              continue;
            }
            i += 2;
            var byteSequenceLength = getLeadingOnes(octet);
            if (byteSequenceLength === 0) {
              decodedChar = fromCharCode(octet);
            } else {
              if (byteSequenceLength === 1 || byteSequenceLength > 4) {
                result += FALLBACK_REPLACER;
                i++;
                continue;
              }
              var octets = [octet];
              var sequenceIndex = 1;
              while (sequenceIndex < byteSequenceLength) {
                i++;
                if (i + 3 > length || charAt(input, i) !== "%") break;
                var nextByte = parseHexOctet(input, i + 1);
                if (nextByte !== nextByte) {
                  i += 3;
                  break;
                }
                if (nextByte > 191 || nextByte < 128) break;
                push(octets, nextByte);
                i += 2;
                sequenceIndex++;
              }
              if (octets.length !== byteSequenceLength) {
                result += FALLBACK_REPLACER;
                continue;
              }
              var codePoint = utf8Decode(octets);
              if (codePoint === null) {
                result += FALLBACK_REPLACER;
              } else {
                decodedChar = fromCodePoint(codePoint);
              }
            }
          }
          result += decodedChar;
          i++;
        }
        return result;
      };
      var find = /[!'()~]|%20/g;
      var replacements = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+"
      };
      var replacer = function(match) {
        return replacements[match];
      };
      var serialize = function(it2) {
        return replace(encodeURIComponent2(it2), find, replacer);
      };
      var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
        setInternalState(this, {
          type: URL_SEARCH_PARAMS_ITERATOR,
          target: getInternalParamsState(params).entries,
          index: 0,
          kind
        });
      }, URL_SEARCH_PARAMS, function next() {
        var state = getInternalIteratorState(this);
        var target = state.target;
        var index = state.index++;
        if (!target || index >= target.length) {
          state.target = null;
          return createIterResultObject(void 0, true);
        }
        var entry = target[index];
        switch (state.kind) {
          case "keys":
            return createIterResultObject(entry.key, false);
          case "values":
            return createIterResultObject(entry.value, false);
        }
        return createIterResultObject([entry.key, entry.value], false);
      }, true);
      var URLSearchParamsState = function(init) {
        this.entries = [];
        this.url = null;
        if (init !== void 0) {
          if (isObject2(init)) this.parseObject(init);
          else this.parseQuery(typeof init == "string" ? charAt(init, 0) === "?" ? stringSlice(init, 1) : init : $toString(init));
        }
      };
      URLSearchParamsState.prototype = {
        type: URL_SEARCH_PARAMS,
        bindURL: function(url) {
          this.url = url;
          this.update();
        },
        parseObject: function(object) {
          var entries = this.entries;
          var iteratorMethod = getIteratorMethod(object);
          var iterator2, next, step, entryIterator, entryNext, first, second;
          if (iteratorMethod) {
            iterator2 = getIterator(object, iteratorMethod);
            next = iterator2.next;
            while (!(step = call(next, iterator2)).done) {
              entryIterator = getIterator(anObject(step.value));
              entryNext = entryIterator.next;
              if ((first = call(entryNext, entryIterator)).done || (second = call(entryNext, entryIterator)).done || !call(entryNext, entryIterator).done) throw new TypeError2("Expected sequence with length 2");
              push(entries, { key: $toString(first.value), value: $toString(second.value) });
            }
          } else for (var key in object) if (hasOwn(object, key)) {
            push(entries, { key, value: $toString(object[key]) });
          }
        },
        parseQuery: function(query) {
          if (query) {
            var entries = this.entries;
            var attributes = split(query, "&");
            var index = 0;
            var attribute, entry;
            while (index < attributes.length) {
              attribute = attributes[index++];
              if (attribute.length) {
                entry = split(attribute, "=");
                push(entries, {
                  key: decode2(shift(entry)),
                  value: decode2(join(entry, "="))
                });
              }
            }
          }
        },
        serialize: function() {
          var entries = this.entries;
          var result = [];
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            push(result, serialize(entry.key) + "=" + serialize(entry.value));
          }
          return join(result, "&");
        },
        update: function() {
          this.entries.length = 0;
          this.parseQuery(this.url.query);
        },
        updateURL: function() {
          if (this.url) this.url.update();
        }
      };
      var URLSearchParamsConstructor = function URLSearchParams2() {
        anInstance(this, URLSearchParamsPrototype);
        var init = arguments.length > 0 ? arguments[0] : void 0;
        var state = setInternalState(this, new URLSearchParamsState(init));
        if (!DESCRIPTORS) this.size = state.entries.length;
      };
      var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
      defineBuiltIns(URLSearchParamsPrototype, {
        // `URLSearchParams.prototype.append` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-append
        append: function append2(name, value) {
          var state = getInternalParamsState(this);
          validateArgumentsLength(arguments.length, 2);
          push(state.entries, { key: $toString(name), value: $toString(value) });
          if (!DESCRIPTORS) this.length++;
          state.updateURL();
        },
        // `URLSearchParams.prototype.delete` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
        "delete": function(name) {
          var state = getInternalParamsState(this);
          var length = validateArgumentsLength(arguments.length, 1);
          var entries = state.entries;
          var key = $toString(name);
          var $value = length < 2 ? void 0 : arguments[1];
          var value = $value === void 0 ? $value : $toString($value);
          var index = 0;
          while (index < entries.length) {
            var entry = entries[index];
            if (entry.key === key && (value === void 0 || entry.value === value)) {
              splice(entries, index, 1);
              if (value !== void 0) break;
            } else index++;
          }
          if (!DESCRIPTORS) this.size = entries.length;
          state.updateURL();
        },
        // `URLSearchParams.prototype.get` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-get
        get: function get(name) {
          var entries = getInternalParamsState(this).entries;
          validateArgumentsLength(arguments.length, 1);
          var key = $toString(name);
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key) return entries[index].value;
          }
          return null;
        },
        // `URLSearchParams.prototype.getAll` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
        getAll: function getAll(name) {
          var entries = getInternalParamsState(this).entries;
          validateArgumentsLength(arguments.length, 1);
          var key = $toString(name);
          var result = [];
          var index = 0;
          for (; index < entries.length; index++) {
            if (entries[index].key === key) push(result, entries[index].value);
          }
          return result;
        },
        // `URLSearchParams.prototype.has` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-has
        has: function has(name) {
          var entries = getInternalParamsState(this).entries;
          var length = validateArgumentsLength(arguments.length, 1);
          var key = $toString(name);
          var $value = length < 2 ? void 0 : arguments[1];
          var value = $value === void 0 ? $value : $toString($value);
          var index = 0;
          while (index < entries.length) {
            var entry = entries[index++];
            if (entry.key === key && (value === void 0 || entry.value === value)) return true;
          }
          return false;
        },
        // `URLSearchParams.prototype.set` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-set
        set: function set(name, value) {
          var state = getInternalParamsState(this);
          validateArgumentsLength(arguments.length, 1);
          var entries = state.entries;
          var found = false;
          var key = $toString(name);
          var val = $toString(value);
          var index = 0;
          var entry;
          for (; index < entries.length; index++) {
            entry = entries[index];
            if (entry.key === key) {
              if (found) splice(entries, index--, 1);
              else {
                found = true;
                entry.value = val;
              }
            }
          }
          if (!found) push(entries, { key, value: val });
          if (!DESCRIPTORS) this.size = entries.length;
          state.updateURL();
        },
        // `URLSearchParams.prototype.sort` method
        // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
        sort: function sort() {
          var state = getInternalParamsState(this);
          arraySort(state.entries, function(a, b) {
            return a.key > b.key ? 1 : -1;
          });
          state.updateURL();
        },
        // `URLSearchParams.prototype.forEach` method
        forEach: function forEach2(callback) {
          var entries = getInternalParamsState(this).entries;
          var boundFunction = bind2(callback, arguments.length > 1 ? arguments[1] : void 0);
          var index = 0;
          var entry;
          while (index < entries.length) {
            entry = entries[index++];
            boundFunction(entry.value, entry.key, this);
          }
        },
        // `URLSearchParams.prototype.keys` method
        keys: function keys() {
          return new URLSearchParamsIterator(this, "keys");
        },
        // `URLSearchParams.prototype.values` method
        values: function values() {
          return new URLSearchParamsIterator(this, "values");
        },
        // `URLSearchParams.prototype.entries` method
        entries: function entries() {
          return new URLSearchParamsIterator(this, "entries");
        }
      }, { enumerable: true });
      defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
      defineBuiltIn(URLSearchParamsPrototype, "toString", function toString3() {
        return getInternalParamsState(this).serialize();
      }, { enumerable: true });
      if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
        get: function size() {
          return getInternalParamsState(this).entries.length;
        },
        configurable: true,
        enumerable: true
      });
      setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
      $2({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
        URLSearchParams: URLSearchParamsConstructor
      });
      if (!USE_NATIVE_URL && isCallable(Headers)) {
        headersHas = uncurryThis(HeadersPrototype.has);
        headersSet = uncurryThis(HeadersPrototype.set);
        wrapRequestOptions = function(init) {
          if (isObject2(init)) {
            var body = init.body;
            var headers;
            if (classof(body) === URL_SEARCH_PARAMS) {
              headers = init.headers ? new Headers(init.headers) : new Headers();
              if (!headersHas(headers, "content-type")) {
                headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
              return create(init, {
                body: createPropertyDescriptor(0, $toString(body)),
                headers: createPropertyDescriptor(0, headers)
              });
            }
          }
          return init;
        };
        if (isCallable(nativeFetch)) {
          $2({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
            fetch: function fetch2(input) {
              return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
            }
          });
        }
        if (isCallable(NativeRequest)) {
          RequestConstructor = function Request2(input) {
            anInstance(this, RequestPrototype);
            return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
          };
          RequestPrototype.constructor = RequestConstructor;
          RequestConstructor.prototype = RequestPrototype;
          $2({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
            Request: RequestConstructor
          });
        }
      }
      var headersHas;
      var headersSet;
      var wrapRequestOptions;
      var RequestConstructor;
      module.exports = {
        URLSearchParams: URLSearchParamsConstructor,
        getState: getInternalParamsState
      };
    }
  });

  // node_modules/core-js/modules/web.url.constructor.js
  var require_web_url_constructor = __commonJS({
    "node_modules/core-js/modules/web.url.constructor.js"() {
      "use strict";
      require_es_string_iterator();
      var $2 = require_export();
      var DESCRIPTORS = require_descriptors();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var globalThis2 = require_global_this();
      var bind2 = require_function_bind_context();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltIn = require_define_built_in();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var anInstance = require_an_instance();
      var hasOwn = require_has_own_property();
      var assign = require_object_assign();
      var arrayFrom = require_array_from();
      var arraySlice = require_array_slice();
      var codeAt = require_string_multibyte().codeAt;
      var toASCII = require_string_punycode_to_ascii();
      var $toString = require_to_string();
      var setToStringTag = require_set_to_string_tag();
      var validateArgumentsLength = require_validate_arguments_length();
      var URLSearchParamsModule = require_web_url_search_params_constructor();
      var InternalStateModule = require_internal_state();
      var setInternalState = InternalStateModule.set;
      var getInternalURLState = InternalStateModule.getterFor("URL");
      var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
      var getInternalSearchParamsState = URLSearchParamsModule.getState;
      var NativeURL = globalThis2.URL;
      var TypeError2 = globalThis2.TypeError;
      var parseInt2 = globalThis2.parseInt;
      var floor = Math.floor;
      var pow = Math.pow;
      var charAt = uncurryThis("".charAt);
      var exec = uncurryThis(/./.exec);
      var join = uncurryThis([].join);
      var numberToString = uncurryThis(1 .toString);
      var pop = uncurryThis([].pop);
      var push = uncurryThis([].push);
      var replace = uncurryThis("".replace);
      var shift = uncurryThis([].shift);
      var split = uncurryThis("".split);
      var stringSlice = uncurryThis("".slice);
      var toLowerCase = uncurryThis("".toLowerCase);
      var unshift = uncurryThis([].unshift);
      var INVALID_AUTHORITY = "Invalid authority";
      var INVALID_SCHEME = "Invalid scheme";
      var INVALID_HOST = "Invalid host";
      var INVALID_PORT = "Invalid port";
      var ALPHA = /[a-z]/i;
      var ALPHANUMERIC = /[\d+-.a-z]/i;
      var DIGIT = /\d/;
      var HEX_START = /^0x/i;
      var OCT = /^[0-7]+$/;
      var DEC = /^\d+$/;
      var HEX = /^[\da-f]+$/i;
      var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
      var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
      var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
      var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
      var TAB_AND_NEW_LINE = /[\t\n\r]/g;
      var EOF;
      var parseIPv4 = function(input) {
        var parts = split(input, ".");
        var partsLength, numbers, index, part, radix, number, ipv4;
        if (parts.length && parts[parts.length - 1] === "") {
          parts.length--;
        }
        partsLength = parts.length;
        if (partsLength > 4) return input;
        numbers = [];
        for (index = 0; index < partsLength; index++) {
          part = parts[index];
          if (part === "") return input;
          radix = 10;
          if (part.length > 1 && charAt(part, 0) === "0") {
            radix = exec(HEX_START, part) ? 16 : 8;
            part = stringSlice(part, radix === 8 ? 1 : 2);
          }
          if (part === "") {
            number = 0;
          } else {
            if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
            number = parseInt2(part, radix);
          }
          push(numbers, number);
        }
        for (index = 0; index < partsLength; index++) {
          number = numbers[index];
          if (index === partsLength - 1) {
            if (number >= pow(256, 5 - partsLength)) return null;
          } else if (number > 255) return null;
        }
        ipv4 = pop(numbers);
        for (index = 0; index < numbers.length; index++) {
          ipv4 += numbers[index] * pow(256, 3 - index);
        }
        return ipv4;
      };
      var parseIPv6 = function(input) {
        var address = [0, 0, 0, 0, 0, 0, 0, 0];
        var pieceIndex = 0;
        var compress = null;
        var pointer = 0;
        var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
        var chr = function() {
          return charAt(input, pointer);
        };
        if (chr() === ":") {
          if (charAt(input, 1) !== ":") return;
          pointer += 2;
          pieceIndex++;
          compress = pieceIndex;
        }
        while (chr()) {
          if (pieceIndex === 8) return;
          if (chr() === ":") {
            if (compress !== null) return;
            pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
          }
          value = length = 0;
          while (length < 4 && exec(HEX, chr())) {
            value = value * 16 + parseInt2(chr(), 16);
            pointer++;
            length++;
          }
          if (chr() === ".") {
            if (length === 0) return;
            pointer -= length;
            if (pieceIndex > 6) return;
            numbersSeen = 0;
            while (chr()) {
              ipv4Piece = null;
              if (numbersSeen > 0) {
                if (chr() === "." && numbersSeen < 4) pointer++;
                else return;
              }
              if (!exec(DIGIT, chr())) return;
              while (exec(DIGIT, chr())) {
                number = parseInt2(chr(), 10);
                if (ipv4Piece === null) ipv4Piece = number;
                else if (ipv4Piece === 0) return;
                else ipv4Piece = ipv4Piece * 10 + number;
                if (ipv4Piece > 255) return;
                pointer++;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              numbersSeen++;
              if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
            }
            if (numbersSeen !== 4) return;
            break;
          } else if (chr() === ":") {
            pointer++;
            if (!chr()) return;
          } else if (chr()) return;
          address[pieceIndex++] = value;
        }
        if (compress !== null) {
          swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            swap = address[pieceIndex];
            address[pieceIndex--] = address[compress + swaps - 1];
            address[compress + --swaps] = swap;
          }
        } else if (pieceIndex !== 8) return;
        return address;
      };
      var findLongestZeroSequence = function(ipv6) {
        var maxIndex = null;
        var maxLength = 1;
        var currStart = null;
        var currLength = 0;
        var index = 0;
        for (; index < 8; index++) {
          if (ipv6[index] !== 0) {
            if (currLength > maxLength) {
              maxIndex = currStart;
              maxLength = currLength;
            }
            currStart = null;
            currLength = 0;
          } else {
            if (currStart === null) currStart = index;
            ++currLength;
          }
        }
        return currLength > maxLength ? currStart : maxIndex;
      };
      var serializeHost = function(host) {
        var result, index, compress, ignore0;
        if (typeof host == "number") {
          result = [];
          for (index = 0; index < 4; index++) {
            unshift(result, host % 256);
            host = floor(host / 256);
          }
          return join(result, ".");
        }
        if (typeof host == "object") {
          result = "";
          compress = findLongestZeroSequence(host);
          for (index = 0; index < 8; index++) {
            if (ignore0 && host[index] === 0) continue;
            if (ignore0) ignore0 = false;
            if (compress === index) {
              result += index ? ":" : "::";
              ignore0 = true;
            } else {
              result += numberToString(host[index], 16);
              if (index < 7) result += ":";
            }
          }
          return "[" + result + "]";
        }
        return host;
      };
      var C0ControlPercentEncodeSet = {};
      var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
        " ": 1,
        '"': 1,
        "<": 1,
        ">": 1,
        "`": 1
      });
      var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
        "#": 1,
        "?": 1,
        "{": 1,
        "}": 1
      });
      var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
        "/": 1,
        ":": 1,
        ";": 1,
        "=": 1,
        "@": 1,
        "[": 1,
        "\\": 1,
        "]": 1,
        "^": 1,
        "|": 1
      });
      var percentEncode = function(chr, set) {
        var code = codeAt(chr, 0);
        return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
      };
      var specialSchemes = {
        ftp: 21,
        file: null,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var isWindowsDriveLetter = function(string, normalized) {
        var second;
        return string.length === 2 && exec(ALPHA, charAt(string, 0)) && ((second = charAt(string, 1)) === ":" || !normalized && second === "|");
      };
      var startsWithWindowsDriveLetter = function(string) {
        var third;
        return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (string.length === 2 || ((third = charAt(string, 2)) === "/" || third === "\\" || third === "?" || third === "#"));
      };
      var isSingleDot = function(segment) {
        return segment === "." || toLowerCase(segment) === "%2e";
      };
      var isDoubleDot = function(segment) {
        segment = toLowerCase(segment);
        return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
      };
      var SCHEME_START = {};
      var SCHEME = {};
      var NO_SCHEME = {};
      var SPECIAL_RELATIVE_OR_AUTHORITY = {};
      var PATH_OR_AUTHORITY = {};
      var RELATIVE = {};
      var RELATIVE_SLASH = {};
      var SPECIAL_AUTHORITY_SLASHES = {};
      var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
      var AUTHORITY = {};
      var HOST = {};
      var HOSTNAME = {};
      var PORT = {};
      var FILE = {};
      var FILE_SLASH = {};
      var FILE_HOST = {};
      var PATH_START = {};
      var PATH = {};
      var CANNOT_BE_A_BASE_URL_PATH = {};
      var QUERY = {};
      var FRAGMENT = {};
      var URLState = function(url, isBase, base) {
        var urlString = $toString(url);
        var baseState, failure, searchParams;
        if (isBase) {
          failure = this.parse(urlString);
          if (failure) throw new TypeError2(failure);
          this.searchParams = null;
        } else {
          if (base !== void 0) baseState = new URLState(base, true);
          failure = this.parse(urlString, null, baseState);
          if (failure) throw new TypeError2(failure);
          searchParams = getInternalSearchParamsState(new URLSearchParams2());
          searchParams.bindURL(this);
          this.searchParams = searchParams;
        }
      };
      URLState.prototype = {
        type: "URL",
        // https://url.spec.whatwg.org/#url-parsing
        // eslint-disable-next-line max-statements -- TODO
        parse: function(input, stateOverride, base) {
          var url = this;
          var state = stateOverride || SCHEME_START;
          var pointer = 0;
          var buffer = "";
          var seenAt = false;
          var seenBracket = false;
          var seenPasswordToken = false;
          var codePoints, chr, bufferCodePoints, failure;
          input = $toString(input);
          if (!stateOverride) {
            url.scheme = "";
            url.username = "";
            url.password = "";
            url.host = null;
            url.port = null;
            url.path = [];
            url.query = null;
            url.fragment = null;
            url.cannotBeABaseURL = false;
            input = replace(input, LEADING_C0_CONTROL_OR_SPACE, "");
            input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, "$1");
          }
          input = replace(input, TAB_AND_NEW_LINE, "");
          codePoints = arrayFrom(input);
          while (pointer <= codePoints.length) {
            chr = codePoints[pointer];
            switch (state) {
              case SCHEME_START:
                if (chr && exec(ALPHA, chr)) {
                  buffer += toLowerCase(chr);
                  state = SCHEME;
                } else if (!stateOverride) {
                  state = NO_SCHEME;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case SCHEME:
                if (chr && (exec(ALPHANUMERIC, chr) || chr === "+" || chr === "-" || chr === ".")) {
                  buffer += toLowerCase(chr);
                } else if (chr === ":") {
                  if (stateOverride && (url.isSpecial() !== hasOwn(specialSchemes, buffer) || buffer === "file" && (url.includesCredentials() || url.port !== null) || url.scheme === "file" && !url.host)) return;
                  url.scheme = buffer;
                  if (stateOverride) {
                    if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
                    return;
                  }
                  buffer = "";
                  if (url.scheme === "file") {
                    state = FILE;
                  } else if (url.isSpecial() && base && base.scheme === url.scheme) {
                    state = SPECIAL_RELATIVE_OR_AUTHORITY;
                  } else if (url.isSpecial()) {
                    state = SPECIAL_AUTHORITY_SLASHES;
                  } else if (codePoints[pointer + 1] === "/") {
                    state = PATH_OR_AUTHORITY;
                    pointer++;
                  } else {
                    url.cannotBeABaseURL = true;
                    push(url.path, "");
                    state = CANNOT_BE_A_BASE_URL_PATH;
                  }
                } else if (!stateOverride) {
                  buffer = "";
                  state = NO_SCHEME;
                  pointer = 0;
                  continue;
                } else return INVALID_SCHEME;
                break;
              case NO_SCHEME:
                if (!base || base.cannotBeABaseURL && chr !== "#") return INVALID_SCHEME;
                if (base.cannotBeABaseURL && chr === "#") {
                  url.scheme = base.scheme;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  url.cannotBeABaseURL = true;
                  state = FRAGMENT;
                  break;
                }
                state = base.scheme === "file" ? FILE : RELATIVE;
                continue;
              case SPECIAL_RELATIVE_OR_AUTHORITY:
                if (chr === "/" && codePoints[pointer + 1] === "/") {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  pointer++;
                } else {
                  state = RELATIVE;
                  continue;
                }
                break;
              case PATH_OR_AUTHORITY:
                if (chr === "/") {
                  state = AUTHORITY;
                  break;
                } else {
                  state = PATH;
                  continue;
                }
              case RELATIVE:
                url.scheme = base.scheme;
                if (chr === EOF) {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                } else if (chr === "/" || chr === "\\" && url.isSpecial()) {
                  state = RELATIVE_SLASH;
                } else if (chr === "?") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = "";
                  state = QUERY;
                } else if (chr === "#") {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.query = base.query;
                  url.fragment = "";
                  state = FRAGMENT;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  url.path = arraySlice(base.path);
                  url.path.length--;
                  state = PATH;
                  continue;
                }
                break;
              case RELATIVE_SLASH:
                if (url.isSpecial() && (chr === "/" || chr === "\\")) {
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                } else if (chr === "/") {
                  state = AUTHORITY;
                } else {
                  url.username = base.username;
                  url.password = base.password;
                  url.host = base.host;
                  url.port = base.port;
                  state = PATH;
                  continue;
                }
                break;
              case SPECIAL_AUTHORITY_SLASHES:
                state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                if (chr !== "/" || charAt(buffer, pointer + 1) !== "/") continue;
                pointer++;
                break;
              case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                if (chr !== "/" && chr !== "\\") {
                  state = AUTHORITY;
                  continue;
                }
                break;
              case AUTHORITY:
                if (chr === "@") {
                  if (seenAt) buffer = "%40" + buffer;
                  seenAt = true;
                  bufferCodePoints = arrayFrom(buffer);
                  for (var i = 0; i < bufferCodePoints.length; i++) {
                    var codePoint = bufferCodePoints[i];
                    if (codePoint === ":" && !seenPasswordToken) {
                      seenPasswordToken = true;
                      continue;
                    }
                    var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                    if (seenPasswordToken) url.password += encodedCodePoints;
                    else url.username += encodedCodePoints;
                  }
                  buffer = "";
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                  if (seenAt && buffer === "") return INVALID_AUTHORITY;
                  pointer -= arrayFrom(buffer).length + 1;
                  buffer = "";
                  state = HOST;
                } else buffer += chr;
                break;
              case HOST:
              case HOSTNAME:
                if (stateOverride && url.scheme === "file") {
                  state = FILE_HOST;
                  continue;
                } else if (chr === ":" && !seenBracket) {
                  if (buffer === "") return INVALID_HOST;
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  buffer = "";
                  state = PORT;
                  if (stateOverride === HOSTNAME) return;
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial()) {
                  if (url.isSpecial() && buffer === "") return INVALID_HOST;
                  if (stateOverride && buffer === "" && (url.includesCredentials() || url.port !== null)) return;
                  failure = url.parseHost(buffer);
                  if (failure) return failure;
                  buffer = "";
                  state = PATH_START;
                  if (stateOverride) return;
                  continue;
                } else {
                  if (chr === "[") seenBracket = true;
                  else if (chr === "]") seenBracket = false;
                  buffer += chr;
                }
                break;
              case PORT:
                if (exec(DIGIT, chr)) {
                  buffer += chr;
                } else if (chr === EOF || chr === "/" || chr === "?" || chr === "#" || chr === "\\" && url.isSpecial() || stateOverride) {
                  if (buffer !== "") {
                    var port = parseInt2(buffer, 10);
                    if (port > 65535) return INVALID_PORT;
                    url.port = url.isSpecial() && port === specialSchemes[url.scheme] ? null : port;
                    buffer = "";
                  }
                  if (stateOverride) return;
                  state = PATH_START;
                  continue;
                } else return INVALID_PORT;
                break;
              case FILE:
                url.scheme = "file";
                if (chr === "/" || chr === "\\") state = FILE_SLASH;
                else if (base && base.scheme === "file") {
                  switch (chr) {
                    case EOF:
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.query = base.query;
                      break;
                    case "?":
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.query = "";
                      state = QUERY;
                      break;
                    case "#":
                      url.host = base.host;
                      url.path = arraySlice(base.path);
                      url.query = base.query;
                      url.fragment = "";
                      state = FRAGMENT;
                      break;
                    default:
                      if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                        url.host = base.host;
                        url.path = arraySlice(base.path);
                        url.shortenPath();
                      }
                      state = PATH;
                      continue;
                  }
                } else {
                  state = PATH;
                  continue;
                }
                break;
              case FILE_SLASH:
                if (chr === "/" || chr === "\\") {
                  state = FILE_HOST;
                  break;
                }
                if (base && base.scheme === "file" && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ""))) {
                  if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
                  else url.host = base.host;
                }
                state = PATH;
                continue;
              case FILE_HOST:
                if (chr === EOF || chr === "/" || chr === "\\" || chr === "?" || chr === "#") {
                  if (!stateOverride && isWindowsDriveLetter(buffer)) {
                    state = PATH;
                  } else if (buffer === "") {
                    url.host = "";
                    if (stateOverride) return;
                    state = PATH_START;
                  } else {
                    failure = url.parseHost(buffer);
                    if (failure) return failure;
                    if (url.host === "localhost") url.host = "";
                    if (stateOverride) return;
                    buffer = "";
                    state = PATH_START;
                  }
                  continue;
                } else buffer += chr;
                break;
              case PATH_START:
                if (url.isSpecial()) {
                  state = PATH;
                  if (chr !== "/" && chr !== "\\") continue;
                } else if (!stateOverride && chr === "?") {
                  url.query = "";
                  state = QUERY;
                } else if (!stateOverride && chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr !== EOF) {
                  state = PATH;
                  if (chr !== "/") continue;
                }
                break;
              case PATH:
                if (chr === EOF || chr === "/" || chr === "\\" && url.isSpecial() || !stateOverride && (chr === "?" || chr === "#")) {
                  if (isDoubleDot(buffer)) {
                    url.shortenPath();
                    if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else if (isSingleDot(buffer)) {
                    if (chr !== "/" && !(chr === "\\" && url.isSpecial())) {
                      push(url.path, "");
                    }
                  } else {
                    if (url.scheme === "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                      if (url.host) url.host = "";
                      buffer = charAt(buffer, 0) + ":";
                    }
                    push(url.path, buffer);
                  }
                  buffer = "";
                  if (url.scheme === "file" && (chr === EOF || chr === "?" || chr === "#")) {
                    while (url.path.length > 1 && url.path[0] === "") {
                      shift(url.path);
                    }
                  }
                  if (chr === "?") {
                    url.query = "";
                    state = QUERY;
                  } else if (chr === "#") {
                    url.fragment = "";
                    state = FRAGMENT;
                  }
                } else {
                  buffer += percentEncode(chr, pathPercentEncodeSet);
                }
                break;
              case CANNOT_BE_A_BASE_URL_PATH:
                if (chr === "?") {
                  url.query = "";
                  state = QUERY;
                } else if (chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr !== EOF) {
                  url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case QUERY:
                if (!stateOverride && chr === "#") {
                  url.fragment = "";
                  state = FRAGMENT;
                } else if (chr !== EOF) {
                  if (chr === "'" && url.isSpecial()) url.query += "%27";
                  else if (chr === "#") url.query += "%23";
                  else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
                }
                break;
              case FRAGMENT:
                if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
                break;
            }
            pointer++;
          }
        },
        // https://url.spec.whatwg.org/#host-parsing
        parseHost: function(input) {
          var result, codePoints, index;
          if (charAt(input, 0) === "[") {
            if (charAt(input, input.length - 1) !== "]") return INVALID_HOST;
            result = parseIPv6(stringSlice(input, 1, -1));
            if (!result) return INVALID_HOST;
            this.host = result;
          } else if (!this.isSpecial()) {
            if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
            result = "";
            codePoints = arrayFrom(input);
            for (index = 0; index < codePoints.length; index++) {
              result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
            }
            this.host = result;
          } else {
            input = toASCII(input);
            if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
            result = parseIPv4(input);
            if (result === null) return INVALID_HOST;
            this.host = result;
          }
        },
        // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
        cannotHaveUsernamePasswordPort: function() {
          return !this.host || this.cannotBeABaseURL || this.scheme === "file";
        },
        // https://url.spec.whatwg.org/#include-credentials
        includesCredentials: function() {
          return this.username !== "" || this.password !== "";
        },
        // https://url.spec.whatwg.org/#is-special
        isSpecial: function() {
          return hasOwn(specialSchemes, this.scheme);
        },
        // https://url.spec.whatwg.org/#shorten-a-urls-path
        shortenPath: function() {
          var path = this.path;
          var pathSize = path.length;
          if (pathSize && (this.scheme !== "file" || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
            path.length--;
          }
        },
        // https://url.spec.whatwg.org/#concept-url-serializer
        serialize: function() {
          var url = this;
          var scheme = url.scheme;
          var username = url.username;
          var password = url.password;
          var host = url.host;
          var port = url.port;
          var path = url.path;
          var query = url.query;
          var fragment = url.fragment;
          var output = scheme + ":";
          if (host !== null) {
            output += "//";
            if (url.includesCredentials()) {
              output += username + (password ? ":" + password : "") + "@";
            }
            output += serializeHost(host);
            if (port !== null) output += ":" + port;
          } else if (scheme === "file") output += "//";
          output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
          if (query !== null) output += "?" + query;
          if (fragment !== null) output += "#" + fragment;
          return output;
        },
        // https://url.spec.whatwg.org/#dom-url-href
        setHref: function(href) {
          var failure = this.parse(href);
          if (failure) throw new TypeError2(failure);
          this.searchParams.update();
        },
        // https://url.spec.whatwg.org/#dom-url-origin
        getOrigin: function() {
          var scheme = this.scheme;
          var port = this.port;
          if (scheme === "blob") try {
            return new URLConstructor(scheme.path[0]).origin;
          } catch (error) {
            return "null";
          }
          if (scheme === "file" || !this.isSpecial()) return "null";
          return scheme + "://" + serializeHost(this.host) + (port !== null ? ":" + port : "");
        },
        // https://url.spec.whatwg.org/#dom-url-protocol
        getProtocol: function() {
          return this.scheme + ":";
        },
        setProtocol: function(protocol) {
          this.parse($toString(protocol) + ":", SCHEME_START);
        },
        // https://url.spec.whatwg.org/#dom-url-username
        getUsername: function() {
          return this.username;
        },
        setUsername: function(username) {
          var codePoints = arrayFrom($toString(username));
          if (this.cannotHaveUsernamePasswordPort()) return;
          this.username = "";
          for (var i = 0; i < codePoints.length; i++) {
            this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
          }
        },
        // https://url.spec.whatwg.org/#dom-url-password
        getPassword: function() {
          return this.password;
        },
        setPassword: function(password) {
          var codePoints = arrayFrom($toString(password));
          if (this.cannotHaveUsernamePasswordPort()) return;
          this.password = "";
          for (var i = 0; i < codePoints.length; i++) {
            this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
          }
        },
        // https://url.spec.whatwg.org/#dom-url-host
        getHost: function() {
          var host = this.host;
          var port = this.port;
          return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
        },
        setHost: function(host) {
          if (this.cannotBeABaseURL) return;
          this.parse(host, HOST);
        },
        // https://url.spec.whatwg.org/#dom-url-hostname
        getHostname: function() {
          var host = this.host;
          return host === null ? "" : serializeHost(host);
        },
        setHostname: function(hostname) {
          if (this.cannotBeABaseURL) return;
          this.parse(hostname, HOSTNAME);
        },
        // https://url.spec.whatwg.org/#dom-url-port
        getPort: function() {
          var port = this.port;
          return port === null ? "" : $toString(port);
        },
        setPort: function(port) {
          if (this.cannotHaveUsernamePasswordPort()) return;
          port = $toString(port);
          if (port === "") this.port = null;
          else this.parse(port, PORT);
        },
        // https://url.spec.whatwg.org/#dom-url-pathname
        getPathname: function() {
          var path = this.path;
          return this.cannotBeABaseURL ? path[0] : path.length ? "/" + join(path, "/") : "";
        },
        setPathname: function(pathname) {
          if (this.cannotBeABaseURL) return;
          this.path = [];
          this.parse(pathname, PATH_START);
        },
        // https://url.spec.whatwg.org/#dom-url-search
        getSearch: function() {
          var query = this.query;
          return query ? "?" + query : "";
        },
        setSearch: function(search) {
          search = $toString(search);
          if (search === "") {
            this.query = null;
          } else {
            if (charAt(search, 0) === "?") search = stringSlice(search, 1);
            this.query = "";
            this.parse(search, QUERY);
          }
          this.searchParams.update();
        },
        // https://url.spec.whatwg.org/#dom-url-searchparams
        getSearchParams: function() {
          return this.searchParams.facade;
        },
        // https://url.spec.whatwg.org/#dom-url-hash
        getHash: function() {
          var fragment = this.fragment;
          return fragment ? "#" + fragment : "";
        },
        setHash: function(hash) {
          hash = $toString(hash);
          if (hash === "") {
            this.fragment = null;
            return;
          }
          if (charAt(hash, 0) === "#") hash = stringSlice(hash, 1);
          this.fragment = "";
          this.parse(hash, FRAGMENT);
        },
        update: function() {
          this.query = this.searchParams.serialize() || null;
        }
      };
      var URLConstructor = function URL2(url) {
        var that = anInstance(this, URLPrototype);
        var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : void 0;
        var state = setInternalState(that, new URLState(url, false, base));
        if (!DESCRIPTORS) {
          that.href = state.serialize();
          that.origin = state.getOrigin();
          that.protocol = state.getProtocol();
          that.username = state.getUsername();
          that.password = state.getPassword();
          that.host = state.getHost();
          that.hostname = state.getHostname();
          that.port = state.getPort();
          that.pathname = state.getPathname();
          that.search = state.getSearch();
          that.searchParams = state.getSearchParams();
          that.hash = state.getHash();
        }
      };
      var URLPrototype = URLConstructor.prototype;
      var accessorDescriptor = function(getter, setter) {
        return {
          get: function() {
            return getInternalURLState(this)[getter]();
          },
          set: setter && function(value) {
            return getInternalURLState(this)[setter](value);
          },
          configurable: true,
          enumerable: true
        };
      };
      if (DESCRIPTORS) {
        defineBuiltInAccessor(URLPrototype, "href", accessorDescriptor("serialize", "setHref"));
        defineBuiltInAccessor(URLPrototype, "origin", accessorDescriptor("getOrigin"));
        defineBuiltInAccessor(URLPrototype, "protocol", accessorDescriptor("getProtocol", "setProtocol"));
        defineBuiltInAccessor(URLPrototype, "username", accessorDescriptor("getUsername", "setUsername"));
        defineBuiltInAccessor(URLPrototype, "password", accessorDescriptor("getPassword", "setPassword"));
        defineBuiltInAccessor(URLPrototype, "host", accessorDescriptor("getHost", "setHost"));
        defineBuiltInAccessor(URLPrototype, "hostname", accessorDescriptor("getHostname", "setHostname"));
        defineBuiltInAccessor(URLPrototype, "port", accessorDescriptor("getPort", "setPort"));
        defineBuiltInAccessor(URLPrototype, "pathname", accessorDescriptor("getPathname", "setPathname"));
        defineBuiltInAccessor(URLPrototype, "search", accessorDescriptor("getSearch", "setSearch"));
        defineBuiltInAccessor(URLPrototype, "searchParams", accessorDescriptor("getSearchParams"));
        defineBuiltInAccessor(URLPrototype, "hash", accessorDescriptor("getHash", "setHash"));
      }
      defineBuiltIn(URLPrototype, "toJSON", function toJSON2() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      defineBuiltIn(URLPrototype, "toString", function toString3() {
        return getInternalURLState(this).serialize();
      }, { enumerable: true });
      if (NativeURL) {
        nativeCreateObjectURL = NativeURL.createObjectURL;
        nativeRevokeObjectURL = NativeURL.revokeObjectURL;
        if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, "createObjectURL", bind2(nativeCreateObjectURL, NativeURL));
        if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, "revokeObjectURL", bind2(nativeRevokeObjectURL, NativeURL));
      }
      var nativeCreateObjectURL;
      var nativeRevokeObjectURL;
      setToStringTag(URLConstructor, "URL");
      $2({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
        URL: URLConstructor
      });
    }
  });

  // node_modules/core-js/modules/web.url.js
  var require_web_url = __commonJS({
    "node_modules/core-js/modules/web.url.js"() {
      "use strict";
      require_web_url_constructor();
    }
  });

  // node_modules/core-js/modules/web.url.can-parse.js
  var require_web_url_can_parse = __commonJS({
    "node_modules/core-js/modules/web.url.can-parse.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var fails = require_fails();
      var validateArgumentsLength = require_validate_arguments_length();
      var toString3 = require_to_string();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var URL2 = getBuiltIn("URL");
      var THROWS_WITHOUT_ARGUMENTS = USE_NATIVE_URL && fails(function() {
        URL2.canParse();
      });
      var WRONG_ARITY = fails(function() {
        return URL2.canParse.length !== 1;
      });
      $2({ target: "URL", stat: true, forced: !THROWS_WITHOUT_ARGUMENTS || WRONG_ARITY }, {
        canParse: function canParse(url) {
          var length = validateArgumentsLength(arguments.length, 1);
          var urlString = toString3(url);
          var base = length < 2 || arguments[1] === void 0 ? void 0 : toString3(arguments[1]);
          try {
            return !!new URL2(urlString, base);
          } catch (error) {
            return false;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url.parse.js
  var require_web_url_parse = __commonJS({
    "node_modules/core-js/modules/web.url.parse.js"() {
      "use strict";
      var $2 = require_export();
      var getBuiltIn = require_get_built_in();
      var validateArgumentsLength = require_validate_arguments_length();
      var toString3 = require_to_string();
      var USE_NATIVE_URL = require_url_constructor_detection();
      var URL2 = getBuiltIn("URL");
      $2({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, {
        parse: function parse(url) {
          var length = validateArgumentsLength(arguments.length, 1);
          var urlString = toString3(url);
          var base = length < 2 || arguments[1] === void 0 ? void 0 : toString3(arguments[1]);
          try {
            return new URL2(urlString, base);
          } catch (error) {
            return null;
          }
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url.to-json.js
  var require_web_url_to_json = __commonJS({
    "node_modules/core-js/modules/web.url.to-json.js"() {
      "use strict";
      var $2 = require_export();
      var call = require_function_call();
      $2({ target: "URL", proto: true, enumerable: true }, {
        toJSON: function toJSON2() {
          return call(URL.prototype.toString, this);
        }
      });
    }
  });

  // node_modules/core-js/modules/web.url-search-params.js
  var require_web_url_search_params = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.js"() {
      "use strict";
      require_web_url_search_params_constructor();
    }
  });

  // node_modules/core-js/modules/web.url-search-params.delete.js
  var require_web_url_search_params_delete = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.delete.js"() {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var $URLSearchParams = URLSearchParams;
      var URLSearchParamsPrototype = $URLSearchParams.prototype;
      var append2 = uncurryThis(URLSearchParamsPrototype.append);
      var $delete = uncurryThis(URLSearchParamsPrototype["delete"]);
      var forEach2 = uncurryThis(URLSearchParamsPrototype.forEach);
      var push = uncurryThis([].push);
      var params = new $URLSearchParams("a=1&a=2&b=3");
      params["delete"]("a", 1);
      params["delete"]("b", void 0);
      if (params + "" !== "a=2") {
        defineBuiltIn(URLSearchParamsPrototype, "delete", function(name) {
          var length = arguments.length;
          var $value = length < 2 ? void 0 : arguments[1];
          if (length && $value === void 0) return $delete(this, name);
          var entries = [];
          forEach2(this, function(v, k) {
            push(entries, { key: k, value: v });
          });
          validateArgumentsLength(length, 1);
          var key = toString3(name);
          var value = toString3($value);
          var index = 0;
          var dindex = 0;
          var found = false;
          var entriesLength = entries.length;
          var entry;
          while (index < entriesLength) {
            entry = entries[index++];
            if (found || entry.key === key) {
              found = true;
              $delete(this, entry.key);
            } else dindex++;
          }
          while (dindex < entriesLength) {
            entry = entries[dindex++];
            if (!(entry.key === key && entry.value === value)) append2(this, entry.key, entry.value);
          }
        }, { enumerable: true, unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/web.url-search-params.has.js
  var require_web_url_search_params_has = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.has.js"() {
      "use strict";
      var defineBuiltIn = require_define_built_in();
      var uncurryThis = require_function_uncurry_this();
      var toString3 = require_to_string();
      var validateArgumentsLength = require_validate_arguments_length();
      var $URLSearchParams = URLSearchParams;
      var URLSearchParamsPrototype = $URLSearchParams.prototype;
      var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
      var $has = uncurryThis(URLSearchParamsPrototype.has);
      var params = new $URLSearchParams("a=1");
      if (params.has("a", 2) || !params.has("a", void 0)) {
        defineBuiltIn(URLSearchParamsPrototype, "has", function has(name) {
          var length = arguments.length;
          var $value = length < 2 ? void 0 : arguments[1];
          if (length && $value === void 0) return $has(this, name);
          var values = getAll(this, name);
          validateArgumentsLength(length, 1);
          var value = toString3($value);
          var index = 0;
          while (index < values.length) {
            if (values[index++] === value) return true;
          }
          return false;
        }, { enumerable: true, unsafe: true });
      }
    }
  });

  // node_modules/core-js/modules/web.url-search-params.size.js
  var require_web_url_search_params_size = __commonJS({
    "node_modules/core-js/modules/web.url-search-params.size.js"() {
      "use strict";
      var DESCRIPTORS = require_descriptors();
      var uncurryThis = require_function_uncurry_this();
      var defineBuiltInAccessor = require_define_built_in_accessor();
      var URLSearchParamsPrototype = URLSearchParams.prototype;
      var forEach2 = uncurryThis(URLSearchParamsPrototype.forEach);
      if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
        defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
          get: function size() {
            var count = 0;
            forEach2(this, function() {
              count++;
            });
            return count;
          },
          configurable: true,
          enumerable: true
        });
      }
    }
  });

  // node_modules/core-js/stable/index.js
  var require_stable = __commonJS({
    "node_modules/core-js/stable/index.js"(exports, module) {
      "use strict";
      require_es_symbol();
      require_es_symbol_description();
      require_es_symbol_async_iterator();
      require_es_symbol_has_instance();
      require_es_symbol_is_concat_spreadable();
      require_es_symbol_iterator();
      require_es_symbol_match();
      require_es_symbol_match_all();
      require_es_symbol_replace();
      require_es_symbol_search();
      require_es_symbol_species();
      require_es_symbol_split();
      require_es_symbol_to_primitive();
      require_es_symbol_to_string_tag();
      require_es_symbol_unscopables();
      require_es_error_cause();
      require_es_error_to_string();
      require_es_aggregate_error();
      require_es_aggregate_error_cause();
      require_es_array_at();
      require_es_array_concat();
      require_es_array_copy_within();
      require_es_array_every();
      require_es_array_fill();
      require_es_array_filter();
      require_es_array_find();
      require_es_array_find_index();
      require_es_array_find_last();
      require_es_array_find_last_index();
      require_es_array_flat();
      require_es_array_flat_map();
      require_es_array_for_each();
      require_es_array_from();
      require_es_array_includes();
      require_es_array_index_of();
      require_es_array_is_array();
      require_es_array_iterator();
      require_es_array_join();
      require_es_array_last_index_of();
      require_es_array_map();
      require_es_array_of();
      require_es_array_push();
      require_es_array_reduce();
      require_es_array_reduce_right();
      require_es_array_reverse();
      require_es_array_slice();
      require_es_array_some();
      require_es_array_sort();
      require_es_array_species();
      require_es_array_splice();
      require_es_array_to_reversed();
      require_es_array_to_sorted();
      require_es_array_to_spliced();
      require_es_array_unscopables_flat();
      require_es_array_unscopables_flat_map();
      require_es_array_unshift();
      require_es_array_with();
      require_es_array_buffer_constructor();
      require_es_array_buffer_is_view();
      require_es_array_buffer_slice();
      require_es_data_view();
      require_es_data_view_get_float16();
      require_es_data_view_set_float16();
      require_es_array_buffer_detached();
      require_es_array_buffer_transfer();
      require_es_array_buffer_transfer_to_fixed_length();
      require_es_date_get_year();
      require_es_date_now();
      require_es_date_set_year();
      require_es_date_to_gmt_string();
      require_es_date_to_iso_string();
      require_es_date_to_json();
      require_es_date_to_primitive();
      require_es_date_to_string();
      require_es_escape();
      require_es_function_bind();
      require_es_function_has_instance();
      require_es_function_name();
      require_es_global_this();
      require_es_iterator_constructor();
      require_es_iterator_drop();
      require_es_iterator_every();
      require_es_iterator_filter();
      require_es_iterator_find();
      require_es_iterator_flat_map();
      require_es_iterator_for_each();
      require_es_iterator_from();
      require_es_iterator_map();
      require_es_iterator_reduce();
      require_es_iterator_some();
      require_es_iterator_take();
      require_es_iterator_to_array();
      require_es_json_stringify();
      require_es_json_to_string_tag();
      require_es_map();
      require_es_map_group_by();
      require_es_math_acosh();
      require_es_math_asinh();
      require_es_math_atanh();
      require_es_math_cbrt();
      require_es_math_clz32();
      require_es_math_cosh();
      require_es_math_expm1();
      require_es_math_fround();
      require_es_math_f16round();
      require_es_math_hypot();
      require_es_math_imul();
      require_es_math_log10();
      require_es_math_log1p();
      require_es_math_log2();
      require_es_math_sign();
      require_es_math_sinh();
      require_es_math_tanh();
      require_es_math_to_string_tag();
      require_es_math_trunc();
      require_es_number_constructor();
      require_es_number_epsilon();
      require_es_number_is_finite();
      require_es_number_is_integer();
      require_es_number_is_nan();
      require_es_number_is_safe_integer();
      require_es_number_max_safe_integer();
      require_es_number_min_safe_integer();
      require_es_number_parse_float();
      require_es_number_parse_int();
      require_es_number_to_exponential();
      require_es_number_to_fixed();
      require_es_number_to_precision();
      require_es_object_assign();
      require_es_object_create();
      require_es_object_define_getter();
      require_es_object_define_properties();
      require_es_object_define_property();
      require_es_object_define_setter();
      require_es_object_entries();
      require_es_object_freeze();
      require_es_object_from_entries();
      require_es_object_get_own_property_descriptor();
      require_es_object_get_own_property_descriptors();
      require_es_object_get_own_property_names();
      require_es_object_get_prototype_of();
      require_es_object_group_by();
      require_es_object_has_own();
      require_es_object_is();
      require_es_object_is_extensible();
      require_es_object_is_frozen();
      require_es_object_is_sealed();
      require_es_object_keys();
      require_es_object_lookup_getter();
      require_es_object_lookup_setter();
      require_es_object_prevent_extensions();
      require_es_object_proto();
      require_es_object_seal();
      require_es_object_set_prototype_of();
      require_es_object_to_string();
      require_es_object_values();
      require_es_parse_float();
      require_es_parse_int();
      require_es_promise();
      require_es_promise_all_settled();
      require_es_promise_any();
      require_es_promise_finally();
      require_es_promise_try();
      require_es_promise_with_resolvers();
      require_es_reflect_apply();
      require_es_reflect_construct();
      require_es_reflect_define_property();
      require_es_reflect_delete_property();
      require_es_reflect_get();
      require_es_reflect_get_own_property_descriptor();
      require_es_reflect_get_prototype_of();
      require_es_reflect_has();
      require_es_reflect_is_extensible();
      require_es_reflect_own_keys();
      require_es_reflect_prevent_extensions();
      require_es_reflect_set();
      require_es_reflect_set_prototype_of();
      require_es_reflect_to_string_tag();
      require_es_regexp_constructor();
      require_es_regexp_escape();
      require_es_regexp_dot_all();
      require_es_regexp_exec();
      require_es_regexp_flags();
      require_es_regexp_sticky();
      require_es_regexp_test();
      require_es_regexp_to_string();
      require_es_set();
      require_es_set_difference_v2();
      require_es_set_intersection_v2();
      require_es_set_is_disjoint_from_v2();
      require_es_set_is_subset_of_v2();
      require_es_set_is_superset_of_v2();
      require_es_set_symmetric_difference_v2();
      require_es_set_union_v2();
      require_es_string_at_alternative();
      require_es_string_code_point_at();
      require_es_string_ends_with();
      require_es_string_from_code_point();
      require_es_string_includes();
      require_es_string_is_well_formed();
      require_es_string_iterator();
      require_es_string_match();
      require_es_string_match_all();
      require_es_string_pad_end();
      require_es_string_pad_start();
      require_es_string_raw();
      require_es_string_repeat();
      require_es_string_replace();
      require_es_string_replace_all();
      require_es_string_search();
      require_es_string_split();
      require_es_string_starts_with();
      require_es_string_substr();
      require_es_string_to_well_formed();
      require_es_string_trim();
      require_es_string_trim_end();
      require_es_string_trim_start();
      require_es_string_anchor();
      require_es_string_big();
      require_es_string_blink();
      require_es_string_bold();
      require_es_string_fixed();
      require_es_string_fontcolor();
      require_es_string_fontsize();
      require_es_string_italics();
      require_es_string_link();
      require_es_string_small();
      require_es_string_strike();
      require_es_string_sub();
      require_es_string_sup();
      require_es_typed_array_float32_array();
      require_es_typed_array_float64_array();
      require_es_typed_array_int8_array();
      require_es_typed_array_int16_array();
      require_es_typed_array_int32_array();
      require_es_typed_array_uint8_array();
      require_es_typed_array_uint8_clamped_array();
      require_es_typed_array_uint16_array();
      require_es_typed_array_uint32_array();
      require_es_typed_array_at();
      require_es_typed_array_copy_within();
      require_es_typed_array_every();
      require_es_typed_array_fill();
      require_es_typed_array_filter();
      require_es_typed_array_find();
      require_es_typed_array_find_index();
      require_es_typed_array_find_last();
      require_es_typed_array_find_last_index();
      require_es_typed_array_for_each();
      require_es_typed_array_from();
      require_es_typed_array_includes();
      require_es_typed_array_index_of();
      require_es_typed_array_iterator();
      require_es_typed_array_join();
      require_es_typed_array_last_index_of();
      require_es_typed_array_map();
      require_es_typed_array_of();
      require_es_typed_array_reduce();
      require_es_typed_array_reduce_right();
      require_es_typed_array_reverse();
      require_es_typed_array_set();
      require_es_typed_array_slice();
      require_es_typed_array_some();
      require_es_typed_array_sort();
      require_es_typed_array_subarray();
      require_es_typed_array_to_locale_string();
      require_es_typed_array_to_reversed();
      require_es_typed_array_to_sorted();
      require_es_typed_array_to_string();
      require_es_typed_array_with();
      require_es_unescape();
      require_es_weak_map();
      require_es_weak_set();
      require_web_atob();
      require_web_btoa();
      require_web_dom_collections_for_each();
      require_web_dom_collections_iterator();
      require_web_dom_exception_constructor();
      require_web_dom_exception_stack();
      require_web_dom_exception_to_string_tag();
      require_web_immediate();
      require_web_queue_microtask();
      require_web_self();
      require_web_structured_clone();
      require_web_timers();
      require_web_url();
      require_web_url_can_parse();
      require_web_url_parse();
      require_web_url_to_json();
      require_web_url_search_params();
      require_web_url_search_params_delete();
      require_web_url_search_params_has();
      require_web_url_search_params_size();
      module.exports = require_path();
    }
  });

  // node_modules/regenerator-runtime/runtime.js
  var require_runtime = __commonJS({
    "node_modules/regenerator-runtime/runtime.js"(exports, module) {
      var runtime = function(exports2) {
        "use strict";
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var defineProperty = Object.defineProperty || function(obj, key, desc) {
          obj[key] = desc.value;
        };
        var undefined2;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define2(obj, key, value) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
          return obj[key];
        }
        try {
          define2({}, "");
        } catch (err) {
          define2 = function(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
          return generator;
        }
        exports2.wrap = wrap;
        function tryCatch(fn2, obj, arg) {
          try {
            return { type: "normal", arg: fn2.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        define2(IteratorPrototype, iteratorSymbol, function() {
          return this;
        });
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = GeneratorFunctionPrototype;
        defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
        defineProperty(
          GeneratorFunctionPrototype,
          "constructor",
          { value: GeneratorFunction, configurable: true }
        );
        GeneratorFunction.displayName = define2(
          GeneratorFunctionPrototype,
          toStringTagSymbol,
          "GeneratorFunction"
        );
        function defineIteratorMethods(prototype3) {
          ["next", "throw", "return"].forEach(function(method) {
            define2(prototype3, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports2.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports2.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define2(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports2.awrap = function(arg) {
          return { __await: arg };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(
              callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg
            ) : callInvokeWithMethodAndArg();
          }
          defineProperty(this, "_invoke", { value: enqueue });
        }
        defineIteratorMethods(AsyncIterator.prototype);
        define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
          return this;
        });
        exports2.AsyncIterator = AsyncIterator;
        exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0) PromiseImpl = Promise;
          var iter = new AsyncIterator(
            wrap(innerFn, outerFn, self2, tryLocsList),
            PromiseImpl
          );
          return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return {
                  value: record.arg,
                  done: context.done
                };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var methodName = context.method;
          var method = delegate.iterator[methodName];
          if (method === undefined2) {
            context.delegate = null;
            if (methodName === "throw" && delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            if (methodName !== "return") {
              context.method = "throw";
              context.arg = new TypeError(
                "The iterator does not provide a '" + methodName + "' method"
              );
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info2 = record.arg;
          if (!info2) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info2.done) {
            context[delegate.resultName] = info2.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined2;
            }
          } else {
            return info2;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define2(Gp, toStringTagSymbol, "Generator");
        define2(Gp, iteratorSymbol, function() {
          return this;
        });
        define2(Gp, "toString", function() {
          return "[object Generator]";
        });
        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports2.keys = function(val) {
          var object = Object(val);
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key2 = keys.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable != null) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next2.value = iterable[i];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined2;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          throw new TypeError(typeof iterable + " is not iterable");
        }
        exports2.values = values;
        function doneResult() {
          return { value: undefined2, done: true };
        }
        Context.prototype = {
          constructor: Context,
          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            this.sent = this._sent = undefined2;
            this.done = false;
            this.delegate = null;
            this.method = "next";
            this.arg = undefined2;
            this.tryEntries.forEach(resetTryEntry);
            if (!skipTempReset) {
              for (var name in this) {
                if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                  this[name] = undefined2;
                }
              }
            }
          },
          stop: function() {
            this.done = true;
            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }
            return this.rval;
          },
          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }
            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;
              if (caught) {
                context.method = "next";
                context.arg = undefined2;
              }
              return !!caught;
            }
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;
              if (entry.tryLoc === "root") {
                return handle("end");
              }
              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");
                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },
          abrupt: function(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }
            if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
              finallyEntry = null;
            }
            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;
            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }
            return this.complete(record);
          },
          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }
            if (record.type === "break" || record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }
            return ContinueSentinel;
          },
          finish: function(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },
          "catch": function(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName,
              nextLoc
            };
            if (this.method === "next") {
              this.arg = undefined2;
            }
            return ContinueSentinel;
          }
        };
        return exports2;
      }(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        typeof module === "object" ? module.exports : {}
      );
      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        if (typeof globalThis === "object") {
          globalThis.regeneratorRuntime = runtime;
        } else {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  function bind(fn2, thisArg) {
    return function wrap() {
      return fn2.apply(thisArg, arguments);
    };
  }
  var init_bind = __esm({
    "node_modules/axios/lib/helpers/bind.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/utils.js
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  function forEach(obj, fn2, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l = obj.length; i < l; i++) {
        fn2.call(null, obj[i], i, obj);
      }
    } else {
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
  }
  var toString, getPrototypeOf, iterator, toStringTag, kindOf, kindOfTest, typeOfTest, isArray, isUndefined, isArrayBuffer, isString, isFunction, isNumber, isObject, isBoolean, isPlainObject, isDate, isFile, isBlob, isFileList, isStream, isFormData, isURLSearchParams, isReadableStream, isRequest, isResponse, isHeaders, trim, _global, isContextDefined, extend, stripBOM, inherits, toFlatObject, endsWith, toArray, isTypedArray, forEachEntry, matchAll, isHTMLForm, toCamelCase, hasOwnProperty, isRegExp, reduceDescriptors, freezeMethods, toObjectSet, noop, toFiniteNumber, toJSONObject, isAsyncFn, isThenable, _setImmediate, asap, isIterable, utils_default;
  var init_utils = __esm({
    "node_modules/axios/lib/utils.js"() {
      "use strict";
      init_bind();
      ({ toString } = Object.prototype);
      ({ getPrototypeOf } = Object);
      ({ iterator, toStringTag } = Symbol);
      kindOf = /* @__PURE__ */ ((cache) => (thing) => {
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      })(/* @__PURE__ */ Object.create(null));
      kindOfTest = (type) => {
        type = type.toLowerCase();
        return (thing) => kindOf(thing) === type;
      };
      typeOfTest = (type) => (thing) => typeof thing === type;
      ({ isArray } = Array);
      isUndefined = typeOfTest("undefined");
      isArrayBuffer = kindOfTest("ArrayBuffer");
      isString = typeOfTest("string");
      isFunction = typeOfTest("function");
      isNumber = typeOfTest("number");
      isObject = (thing) => thing !== null && typeof thing === "object";
      isBoolean = (thing) => thing === true || thing === false;
      isPlainObject = (val) => {
        if (kindOf(val) !== "object") {
          return false;
        }
        const prototype3 = getPrototypeOf(val);
        return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
      };
      isDate = kindOfTest("Date");
      isFile = kindOfTest("File");
      isBlob = kindOfTest("Blob");
      isFileList = kindOfTest("FileList");
      isStream = (val) => isObject(val) && isFunction(val.pipe);
      isFormData = (thing) => {
        let kind;
        return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
        kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
      };
      isURLSearchParams = kindOfTest("URLSearchParams");
      [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
      trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      _global = (() => {
        if (typeof globalThis !== "undefined") return globalThis;
        return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      })();
      isContextDefined = (context) => !isUndefined(context) && context !== _global;
      extend = (a, b, thisArg, { allOwnKeys } = {}) => {
        forEach(b, (val, key) => {
          if (thisArg && isFunction(val)) {
            a[key] = bind(val, thisArg);
          } else {
            a[key] = val;
          }
        }, { allOwnKeys });
        return a;
      };
      stripBOM = (content) => {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      };
      inherits = (constructor, superConstructor, props, descriptors2) => {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
        constructor.prototype.constructor = constructor;
        Object.defineProperty(constructor, "super", {
          value: superConstructor.prototype
        });
        props && Object.assign(constructor.prototype, props);
      };
      toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
        let props;
        let i;
        let prop;
        const merged = {};
        destObj = destObj || {};
        if (sourceObj == null) return destObj;
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i = props.length;
          while (i-- > 0) {
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      };
      endsWith = (str, searchString, position) => {
        str = String(str);
        if (position === void 0 || position > str.length) {
          position = str.length;
        }
        position -= searchString.length;
        const lastIndex = str.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      };
      toArray = (thing) => {
        if (!thing) return null;
        if (isArray(thing)) return thing;
        let i = thing.length;
        if (!isNumber(i)) return null;
        const arr = new Array(i);
        while (i-- > 0) {
          arr[i] = thing[i];
        }
        return arr;
      };
      isTypedArray = /* @__PURE__ */ ((TypedArray) => {
        return (thing) => {
          return TypedArray && thing instanceof TypedArray;
        };
      })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
      forEachEntry = (obj, fn2) => {
        const generator = obj && obj[iterator];
        const _iterator = generator.call(obj);
        let result;
        while ((result = _iterator.next()) && !result.done) {
          const pair = result.value;
          fn2.call(obj, pair[0], pair[1]);
        }
      };
      matchAll = (regExp, str) => {
        let matches;
        const arr = [];
        while ((matches = regExp.exec(str)) !== null) {
          arr.push(matches);
        }
        return arr;
      };
      isHTMLForm = kindOfTest("HTMLFormElement");
      toCamelCase = (str) => {
        return str.toLowerCase().replace(
          /[-_\s]([a-z\d])(\w*)/g,
          function replacer(m, p1, p2) {
            return p1.toUpperCase() + p2;
          }
        );
      };
      hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
      isRegExp = kindOfTest("RegExp");
      reduceDescriptors = (obj, reducer) => {
        const descriptors2 = Object.getOwnPropertyDescriptors(obj);
        const reducedDescriptors = {};
        forEach(descriptors2, (descriptor, name) => {
          let ret;
          if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
          }
        });
        Object.defineProperties(obj, reducedDescriptors);
      };
      freezeMethods = (obj) => {
        reduceDescriptors(obj, (descriptor, name) => {
          if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
            return false;
          }
          const value = obj[name];
          if (!isFunction(value)) return;
          descriptor.enumerable = false;
          if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
          }
          if (!descriptor.set) {
            descriptor.set = () => {
              throw Error("Can not rewrite read-only method '" + name + "'");
            };
          }
        });
      };
      toObjectSet = (arrayOrString, delimiter) => {
        const obj = {};
        const define2 = (arr) => {
          arr.forEach((value) => {
            obj[value] = true;
          });
        };
        isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
        return obj;
      };
      noop = () => {
      };
      toFiniteNumber = (value, defaultValue) => {
        return value != null && Number.isFinite(value = +value) ? value : defaultValue;
      };
      toJSONObject = (obj) => {
        const stack = new Array(10);
        const visit = (source, i) => {
          if (isObject(source)) {
            if (stack.indexOf(source) >= 0) {
              return;
            }
            if (!("toJSON" in source)) {
              stack[i] = source;
              const target = isArray(source) ? [] : {};
              forEach(source, (value, key) => {
                const reducedValue = visit(value, i + 1);
                !isUndefined(reducedValue) && (target[key] = reducedValue);
              });
              stack[i] = void 0;
              return target;
            }
          }
          return source;
        };
        return visit(obj, 0);
      };
      isAsyncFn = kindOfTest("AsyncFunction");
      isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
      _setImmediate = ((setImmediateSupported, postMessageSupported) => {
        if (setImmediateSupported) {
          return setImmediate;
        }
        return postMessageSupported ? ((token, callbacks) => {
          _global.addEventListener("message", ({ source, data: data2 }) => {
            if (source === _global && data2 === token) {
              callbacks.length && callbacks.shift()();
            }
          }, false);
          return (cb) => {
            callbacks.push(cb);
            _global.postMessage(token, "*");
          };
        })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
      })(
        typeof setImmediate === "function",
        isFunction(_global.postMessage)
      );
      asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
      isIterable = (thing) => thing != null && isFunction(thing[iterator]);
      utils_default = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isBoolean,
        isObject,
        isPlainObject,
        isReadableStream,
        isRequest,
        isResponse,
        isHeaders,
        isUndefined,
        isDate,
        isFile,
        isBlob,
        isRegExp,
        isFunction,
        isStream,
        isURLSearchParams,
        isTypedArray,
        isFileList,
        forEach,
        merge,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf,
        kindOfTest,
        endsWith,
        toArray,
        forEachEntry,
        matchAll,
        isHTMLForm,
        hasOwnProperty,
        hasOwnProp: hasOwnProperty,
        // an alias to avoid ESLint no-prototype-builtins detection
        reduceDescriptors,
        freezeMethods,
        toObjectSet,
        toCamelCase,
        noop,
        toFiniteNumber,
        findKey,
        global: _global,
        isContextDefined,
        isSpecCompliantForm,
        toJSONObject,
        isAsyncFn,
        isThenable,
        setImmediate: _setImmediate,
        asap,
        isIterable
      };
    }
  });

  // node_modules/axios/lib/core/AxiosError.js
  function AxiosError(message, code, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config2 && (this.config = config2);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  var prototype, descriptors, AxiosError_default;
  var init_AxiosError = __esm({
    "node_modules/axios/lib/core/AxiosError.js"() {
      "use strict";
      init_utils();
      utils_default.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils_default.toJSONObject(this.config),
            code: this.code,
            status: this.status
          };
        }
      });
      prototype = AxiosError.prototype;
      descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED",
        "ERR_NOT_SUPPORT",
        "ERR_INVALID_URL"
        // eslint-disable-next-line func-names
      ].forEach((code) => {
        descriptors[code] = { value: code };
      });
      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype, "isAxiosError", { value: true });
      AxiosError.from = (error, code, config2, request, response, customProps) => {
        const axiosError = Object.create(prototype);
        utils_default.toFlatObject(error, axiosError, function filter2(obj) {
          return obj !== Error.prototype;
        }, (prop) => {
          return prop !== "isAxiosError";
        });
        AxiosError.call(axiosError, error.message, code, config2, request, response);
        axiosError.cause = error;
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      AxiosError_default = AxiosError;
    }
  });

  // node_modules/axios/lib/helpers/null.js
  var null_default;
  var init_null = __esm({
    "node_modules/axios/lib/helpers/null.js"() {
      null_default = null;
    }
  });

  // node_modules/axios/lib/helpers/toFormData.js
  function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
  }
  function removeBrackets(key) {
    return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      token = removeBrackets(token);
      return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
  }
  function toFormData(obj, formData, options) {
    if (!utils_default.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (null_default || FormData)();
    options = utils_default.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils_default.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null) return "";
      if (utils_default.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils_default.isBlob(value)) {
        throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
      }
      if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils_default.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils_default.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils_default.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils_default.forEach(value, function each(el, key) {
        const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils_default.isString(key) ? key.trim() : key,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils_default.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  var predicates, toFormData_default;
  var init_toFormData = __esm({
    "node_modules/axios/lib/helpers/toFormData.js"() {
      "use strict";
      init_utils();
      init_AxiosError();
      init_null();
      predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
        return /^is[A-Z]/.test(prop);
      });
      toFormData_default = toFormData;
    }
  });

  // node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  function encode(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData_default(params, this, options);
  }
  var prototype2, AxiosURLSearchParams_default;
  var init_AxiosURLSearchParams = __esm({
    "node_modules/axios/lib/helpers/AxiosURLSearchParams.js"() {
      "use strict";
      init_toFormData();
      prototype2 = AxiosURLSearchParams.prototype;
      prototype2.append = function append(name, value) {
        this._pairs.push([name, value]);
      };
      prototype2.toString = function toString2(encoder) {
        const _encode2 = encoder ? function(value) {
          return encoder.call(this, value, encode);
        } : encode;
        return this._pairs.map(function each(pair) {
          return _encode2(pair[0]) + "=" + _encode2(pair[1]);
        }, "").join("&");
      };
      AxiosURLSearchParams_default = AxiosURLSearchParams;
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options) {
    if (!params) {
      return url;
    }
    const _encode2 = options && options.encode || encode2;
    if (utils_default.isFunction(options)) {
      options = {
        serialize: options
      };
    }
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode2);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }
  var init_buildURL = __esm({
    "node_modules/axios/lib/helpers/buildURL.js"() {
      "use strict";
      init_utils();
      init_AxiosURLSearchParams();
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var InterceptorManager, InterceptorManager_default;
  var init_InterceptorManager = __esm({
    "node_modules/axios/lib/core/InterceptorManager.js"() {
      "use strict";
      init_utils();
      InterceptorManager = class {
        constructor() {
          this.handlers = [];
        }
        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        use(fulfilled, rejected, options) {
          this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
          });
          return this.handlers.length - 1;
        }
        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         *
         * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
         */
        eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        }
        /**
         * Clear all interceptors from the stack
         *
         * @returns {void}
         */
        clear() {
          if (this.handlers) {
            this.handlers = [];
          }
        }
        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         *
         * @returns {void}
         */
        forEach(fn2) {
          utils_default.forEach(this.handlers, function forEachHandler(h2) {
            if (h2 !== null) {
              fn2(h2);
            }
          });
        }
      };
      InterceptorManager_default = InterceptorManager;
    }
  });

  // node_modules/axios/lib/defaults/transitional.js
  var transitional_default;
  var init_transitional = __esm({
    "node_modules/axios/lib/defaults/transitional.js"() {
      "use strict";
      transitional_default = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
    }
  });

  // node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
  var URLSearchParams_default;
  var init_URLSearchParams = __esm({
    "node_modules/axios/lib/platform/browser/classes/URLSearchParams.js"() {
      "use strict";
      init_AxiosURLSearchParams();
      URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;
    }
  });

  // node_modules/axios/lib/platform/browser/classes/FormData.js
  var FormData_default;
  var init_FormData = __esm({
    "node_modules/axios/lib/platform/browser/classes/FormData.js"() {
      "use strict";
      FormData_default = typeof FormData !== "undefined" ? FormData : null;
    }
  });

  // node_modules/axios/lib/platform/browser/classes/Blob.js
  var Blob_default;
  var init_Blob = __esm({
    "node_modules/axios/lib/platform/browser/classes/Blob.js"() {
      "use strict";
      Blob_default = typeof Blob !== "undefined" ? Blob : null;
    }
  });

  // node_modules/axios/lib/platform/browser/index.js
  var browser_default;
  var init_browser = __esm({
    "node_modules/axios/lib/platform/browser/index.js"() {
      init_URLSearchParams();
      init_FormData();
      init_Blob();
      browser_default = {
        isBrowser: true,
        classes: {
          URLSearchParams: URLSearchParams_default,
          FormData: FormData_default,
          Blob: Blob_default
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      };
    }
  });

  // node_modules/axios/lib/platform/common/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    hasBrowserEnv: () => hasBrowserEnv,
    hasStandardBrowserEnv: () => hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
    navigator: () => _navigator,
    origin: () => origin
  });
  var hasBrowserEnv, _navigator, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, origin;
  var init_utils2 = __esm({
    "node_modules/axios/lib/platform/common/utils.js"() {
      hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
      _navigator = typeof navigator === "object" && navigator || void 0;
      hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
      hasStandardBrowserWebWorkerEnv = (() => {
        return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
      })();
      origin = hasBrowserEnv && window.location.href || "http://localhost";
    }
  });

  // node_modules/axios/lib/platform/index.js
  var platform_default;
  var init_platform = __esm({
    "node_modules/axios/lib/platform/index.js"() {
      init_browser();
      init_utils2();
      platform_default = {
        ...utils_exports,
        ...browser_default
      };
    }
  });

  // node_modules/axios/lib/helpers/toURLEncodedForm.js
  function toURLEncodedForm(data2, options) {
    return toFormData_default(data2, new platform_default.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform_default.isNode && utils_default.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  var init_toURLEncodedForm = __esm({
    "node_modules/axios/lib/helpers/toURLEncodedForm.js"() {
      "use strict";
      init_utils();
      init_toFormData();
      init_platform();
    }
  });

  // node_modules/axios/lib/helpers/formDataToJSON.js
  function parsePropPath(name) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      if (name === "__proto__") return true;
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils_default.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils_default.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils_default.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path, value, target[name], index);
      if (result && utils_default.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
      const obj = {};
      utils_default.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  var formDataToJSON_default;
  var init_formDataToJSON = __esm({
    "node_modules/axios/lib/helpers/formDataToJSON.js"() {
      "use strict";
      init_utils();
      formDataToJSON_default = formDataToJSON;
    }
  });

  // node_modules/axios/lib/defaults/index.js
  function stringifySafely(rawValue, parser, encoder) {
    if (utils_default.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils_default.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults, defaults_default;
  var init_defaults = __esm({
    "node_modules/axios/lib/defaults/index.js"() {
      "use strict";
      init_utils();
      init_AxiosError();
      init_transitional();
      init_toFormData();
      init_toURLEncodedForm();
      init_platform();
      init_formDataToJSON();
      defaults = {
        transitional: transitional_default,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [function transformRequest(data2, headers) {
          const contentType = headers.getContentType() || "";
          const hasJSONContentType = contentType.indexOf("application/json") > -1;
          const isObjectPayload = utils_default.isObject(data2);
          if (isObjectPayload && utils_default.isHTMLForm(data2)) {
            data2 = new FormData(data2);
          }
          const isFormData2 = utils_default.isFormData(data2);
          if (isFormData2) {
            return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data2)) : data2;
          }
          if (utils_default.isArrayBuffer(data2) || utils_default.isBuffer(data2) || utils_default.isStream(data2) || utils_default.isFile(data2) || utils_default.isBlob(data2) || utils_default.isReadableStream(data2)) {
            return data2;
          }
          if (utils_default.isArrayBufferView(data2)) {
            return data2.buffer;
          }
          if (utils_default.isURLSearchParams(data2)) {
            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
            return data2.toString();
          }
          let isFileList2;
          if (isObjectPayload) {
            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
              return toURLEncodedForm(data2, this.formSerializer).toString();
            }
            if ((isFileList2 = utils_default.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
              const _FormData = this.env && this.env.FormData;
              return toFormData_default(
                isFileList2 ? { "files[]": data2 } : data2,
                _FormData && new _FormData(),
                this.formSerializer
              );
            }
          }
          if (isObjectPayload || hasJSONContentType) {
            headers.setContentType("application/json", false);
            return stringifySafely(data2);
          }
          return data2;
        }],
        transformResponse: [function transformResponse(data2) {
          const transitional2 = this.transitional || defaults.transitional;
          const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
          const JSONRequested = this.responseType === "json";
          if (utils_default.isResponse(data2) || utils_default.isReadableStream(data2)) {
            return data2;
          }
          if (data2 && utils_default.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
            const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
            const strictJSONParsing = !silentJSONParsing && JSONRequested;
            try {
              return JSON.parse(data2);
            } catch (e) {
              if (strictJSONParsing) {
                if (e.name === "SyntaxError") {
                  throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e;
              }
            }
          }
          return data2;
        }],
        /**
         * A timeout in milliseconds to abort a request. If set to 0 (default) a
         * timeout is not created.
         */
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: platform_default.classes.FormData,
          Blob: platform_default.classes.Blob
        },
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
      utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
        defaults.headers[method] = {};
      });
      defaults_default = defaults;
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var ignoreDuplicateOf, parseHeaders_default;
  var init_parseHeaders = __esm({
    "node_modules/axios/lib/helpers/parseHeaders.js"() {
      "use strict";
      init_utils();
      ignoreDuplicateOf = utils_default.toObjectSet([
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ]);
      parseHeaders_default = (rawHeaders) => {
        const parsed = {};
        let key;
        let val;
        let i;
        rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
          i = line.indexOf(":");
          key = line.substring(0, i).trim().toLowerCase();
          val = line.substring(i + 1).trim();
          if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
          }
          if (key === "set-cookie") {
            if (parsed[key]) {
              parsed[key].push(val);
            } else {
              parsed[key] = [val];
            }
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/core/AxiosHeaders.js
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils_default.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils_default.isString(value)) return;
    if (utils_default.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils_default.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils_default.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var $internals, isValidHeaderName, AxiosHeaders, AxiosHeaders_default;
  var init_AxiosHeaders = __esm({
    "node_modules/axios/lib/core/AxiosHeaders.js"() {
      "use strict";
      init_utils();
      init_parseHeaders();
      $internals = Symbol("internals");
      isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
      AxiosHeaders = class {
        constructor(headers) {
          headers && this.set(headers);
        }
        set(header, valueOrRewrite, rewrite) {
          const self2 = this;
          function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) {
              throw new Error("header name must be a non-empty string");
            }
            const key = utils_default.findKey(self2, lHeader);
            if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
              self2[key || _header] = normalizeValue(_value);
            }
          }
          const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
          if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
            setHeaders(header, valueOrRewrite);
          } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
            setHeaders(parseHeaders_default(header), valueOrRewrite);
          } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
            let obj = {}, dest, key;
            for (const entry of header) {
              if (!utils_default.isArray(entry)) {
                throw TypeError("Object iterator must return a key-value pair");
              }
              obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
            }
            setHeaders(obj, valueOrRewrite);
          } else {
            header != null && setHeader(valueOrRewrite, header, rewrite);
          }
          return this;
        }
        get(header, parser) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils_default.findKey(this, header);
            if (key) {
              const value = this[key];
              if (!parser) {
                return value;
              }
              if (parser === true) {
                return parseTokens(value);
              }
              if (utils_default.isFunction(parser)) {
                return parser.call(this, value, key);
              }
              if (utils_default.isRegExp(parser)) {
                return parser.exec(value);
              }
              throw new TypeError("parser must be boolean|regexp|function");
            }
          }
        }
        has(header, matcher) {
          header = normalizeHeader(header);
          if (header) {
            const key = utils_default.findKey(this, header);
            return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
          }
          return false;
        }
        delete(header, matcher) {
          const self2 = this;
          let deleted = false;
          function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
              const key = utils_default.findKey(self2, _header);
              if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                delete self2[key];
                deleted = true;
              }
            }
          }
          if (utils_default.isArray(header)) {
            header.forEach(deleteHeader);
          } else {
            deleteHeader(header);
          }
          return deleted;
        }
        clear(matcher) {
          const keys = Object.keys(this);
          let i = keys.length;
          let deleted = false;
          while (i--) {
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
              delete this[key];
              deleted = true;
            }
          }
          return deleted;
        }
        normalize(format) {
          const self2 = this;
          const headers = {};
          utils_default.forEach(this, (value, header) => {
            const key = utils_default.findKey(headers, header);
            if (key) {
              self2[key] = normalizeValue(value);
              delete self2[header];
              return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) {
              delete self2[header];
            }
            self2[normalized] = normalizeValue(value);
            headers[normalized] = true;
          });
          return this;
        }
        concat(...targets) {
          return this.constructor.concat(this, ...targets);
        }
        toJSON(asStrings) {
          const obj = /* @__PURE__ */ Object.create(null);
          utils_default.forEach(this, (value, header) => {
            value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
          });
          return obj;
        }
        [Symbol.iterator]() {
          return Object.entries(this.toJSON())[Symbol.iterator]();
        }
        toString() {
          return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
        }
        getSetCookie() {
          return this.get("set-cookie") || [];
        }
        get [Symbol.toStringTag]() {
          return "AxiosHeaders";
        }
        static from(thing) {
          return thing instanceof this ? thing : new this(thing);
        }
        static concat(first, ...targets) {
          const computed = new this(first);
          targets.forEach((target) => computed.set(target));
          return computed;
        }
        static accessor(header) {
          const internals = this[$internals] = this[$internals] = {
            accessors: {}
          };
          const accessors = internals.accessors;
          const prototype3 = this.prototype;
          function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
              buildAccessors(prototype3, _header);
              accessors[lHeader] = true;
            }
          }
          utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
          return this;
        }
      };
      AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
      utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
        let mapped = key[0].toUpperCase() + key.slice(1);
        return {
          get: () => value,
          set(headerValue) {
            this[mapped] = headerValue;
          }
        };
      });
      utils_default.freezeMethods(AxiosHeaders);
      AxiosHeaders_default = AxiosHeaders;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  function transformData(fns, response) {
    const config2 = this || defaults_default;
    const context = response || config2;
    const headers = AxiosHeaders_default.from(context.headers);
    let data2 = context.data;
    utils_default.forEach(fns, function transform(fn2) {
      data2 = fn2.call(config2, data2, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data2;
  }
  var init_transformData = __esm({
    "node_modules/axios/lib/core/transformData.js"() {
      "use strict";
      init_utils();
      init_defaults();
      init_AxiosHeaders();
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  var init_isCancel = __esm({
    "node_modules/axios/lib/cancel/isCancel.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/cancel/CanceledError.js
  function CanceledError(message, config2, request) {
    AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  var CanceledError_default;
  var init_CanceledError = __esm({
    "node_modules/axios/lib/cancel/CanceledError.js"() {
      "use strict";
      init_AxiosError();
      init_utils();
      utils_default.inherits(CanceledError, AxiosError_default, {
        __CANCEL__: true
      });
      CanceledError_default = CanceledError;
    }
  });

  // node_modules/axios/lib/core/settle.js
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError_default(
        "Request failed with status code " + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  var init_settle = __esm({
    "node_modules/axios/lib/core/settle.js"() {
      "use strict";
      init_AxiosError();
    }
  });

  // node_modules/axios/lib/helpers/parseProtocol.js
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }
  var init_parseProtocol = __esm({
    "node_modules/axios/lib/helpers/parseProtocol.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/helpers/speedometer.js
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  var speedometer_default;
  var init_speedometer = __esm({
    "node_modules/axios/lib/helpers/speedometer.js"() {
      "use strict";
      speedometer_default = speedometer;
    }
  });

  // node_modules/axios/lib/helpers/throttle.js
  function throttle(fn2, freq) {
    let timestamp = 0;
    let threshold = 1e3 / freq;
    let lastArgs;
    let timer;
    const invoke = (args, now = Date.now()) => {
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn2.apply(null, args);
    };
    const throttled = (...args) => {
      const now = Date.now();
      const passed = now - timestamp;
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    const flush = () => lastArgs && invoke(lastArgs);
    return [throttled, flush];
  }
  var throttle_default;
  var init_throttle = __esm({
    "node_modules/axios/lib/helpers/throttle.js"() {
      throttle_default = throttle;
    }
  });

  // node_modules/axios/lib/helpers/progressEventReducer.js
  var progressEventReducer, progressEventDecorator, asyncDecorator;
  var init_progressEventReducer = __esm({
    "node_modules/axios/lib/helpers/progressEventReducer.js"() {
      init_speedometer();
      init_throttle();
      init_utils();
      progressEventReducer = (listener, isDownloadStream, freq = 3) => {
        let bytesNotified = 0;
        const _speedometer = speedometer_default(50, 250);
        return throttle_default((e) => {
          const loaded = e.loaded;
          const total = e.lengthComputable ? e.total : void 0;
          const progressBytes = loaded - bytesNotified;
          const rate = _speedometer(progressBytes);
          const inRange = loaded <= total;
          bytesNotified = loaded;
          const data2 = {
            loaded,
            total,
            progress: total ? loaded / total : void 0,
            bytes: progressBytes,
            rate: rate ? rate : void 0,
            estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
            event: e,
            lengthComputable: total != null,
            [isDownloadStream ? "download" : "upload"]: true
          };
          listener(data2);
        }, freq);
      };
      progressEventDecorator = (total, throttled) => {
        const lengthComputable = total != null;
        return [(loaded) => throttled[0]({
          lengthComputable,
          total,
          loaded
        }), throttled[1]];
      };
      asyncDecorator = (fn2) => (...args) => utils_default.asap(() => fn2(...args));
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var isURLSameOrigin_default;
  var init_isURLSameOrigin = __esm({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"() {
      init_platform();
      isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
        url = new URL(url, platform_default.origin);
        return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
      })(
        new URL(platform_default.origin),
        platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
      ) : () => true;
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var cookies_default;
  var init_cookies = __esm({
    "node_modules/axios/lib/helpers/cookies.js"() {
      init_utils();
      init_platform();
      cookies_default = platform_default.hasStandardBrowserEnv ? (
        // Standard browser envs support document.cookie
        {
          write(name, value, expires, path, domain, secure) {
            const cookie = [name + "=" + encodeURIComponent(value)];
            utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
            utils_default.isString(path) && cookie.push("path=" + path);
            utils_default.isString(domain) && cookie.push("domain=" + domain);
            secure === true && cookie.push("secure");
            document.cookie = cookie.join("; ");
          },
          read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        }
      ) : (
        // Non-standard browser env (web workers, react-native) lack needed support.
        {
          write() {
          },
          read() {
            return null;
          },
          remove() {
          }
        }
      );
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }
  var init_isAbsoluteURL = __esm({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  var init_combineURLs = __esm({
    "node_modules/axios/lib/helpers/combineURLs.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    let isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  var init_buildFullPath = __esm({
    "node_modules/axios/lib/core/buildFullPath.js"() {
      "use strict";
      init_isAbsoluteURL();
      init_combineURLs();
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, prop, caseless) {
      if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
        return utils_default.merge.call({ caseless }, target, source);
      } else if (utils_default.isPlainObject(source)) {
        return utils_default.merge({}, source);
      } else if (utils_default.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(a, b, prop, caseless);
      } else if (!utils_default.isUndefined(a)) {
        return getMergedValue(void 0, a, prop, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils_default.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils_default.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }
  var headersToObject;
  var init_mergeConfig = __esm({
    "node_modules/axios/lib/core/mergeConfig.js"() {
      "use strict";
      init_utils();
      init_AxiosHeaders();
      headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
    }
  });

  // node_modules/axios/lib/helpers/resolveConfig.js
  var resolveConfig_default;
  var init_resolveConfig = __esm({
    "node_modules/axios/lib/helpers/resolveConfig.js"() {
      init_platform();
      init_utils();
      init_isURLSameOrigin();
      init_cookies();
      init_buildFullPath();
      init_mergeConfig();
      init_AxiosHeaders();
      init_buildURL();
      resolveConfig_default = (config2) => {
        const newConfig = mergeConfig({}, config2);
        let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
        newConfig.headers = headers = AxiosHeaders_default.from(headers);
        newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
        if (auth) {
          headers.set(
            "Authorization",
            "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
          );
        }
        let contentType;
        if (utils_default.isFormData(data2)) {
          if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
            headers.setContentType(void 0);
          } else if ((contentType = headers.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        if (platform_default.hasStandardBrowserEnv) {
          withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
            const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
            if (xsrfValue) {
              headers.set(xsrfHeaderName, xsrfValue);
            }
          }
        }
        return newConfig;
      };
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var isXHRAdapterSupported, xhr_default;
  var init_xhr = __esm({
    "node_modules/axios/lib/adapters/xhr.js"() {
      init_utils();
      init_settle();
      init_transitional();
      init_AxiosError();
      init_CanceledError();
      init_parseProtocol();
      init_platform();
      init_AxiosHeaders();
      init_progressEventReducer();
      init_resolveConfig();
      isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
      xhr_default = isXHRAdapterSupported && function(config2) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          const _config = resolveConfig_default(config2);
          let requestData = _config.data;
          const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
          let { responseType, onUploadProgress, onDownloadProgress } = _config;
          let onCanceled;
          let uploadThrottled, downloadThrottled;
          let flushUpload, flushDownload;
          function done() {
            flushUpload && flushUpload();
            flushDownload && flushDownload();
            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
            _config.signal && _config.signal.removeEventListener("abort", onCanceled);
          }
          let request = new XMLHttpRequest();
          request.open(_config.method.toUpperCase(), _config.url, true);
          request.timeout = _config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            const responseHeaders = AxiosHeaders_default.from(
              "getAllResponseHeaders" in request && request.getAllResponseHeaders()
            );
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config2,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional2 = _config.transitional || transitional_default;
            if (_config.timeoutErrorMessage) {
              timeoutErrorMessage = _config.timeoutErrorMessage;
            }
            reject(new AxiosError_default(
              timeoutErrorMessage,
              transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
              config2,
              request
            ));
            request = null;
          };
          requestData === void 0 && requestHeaders.setContentType(null);
          if ("setRequestHeader" in request) {
            utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
              request.setRequestHeader(key, val);
            });
          }
          if (!utils_default.isUndefined(_config.withCredentials)) {
            request.withCredentials = !!_config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = _config.responseType;
          }
          if (onDownloadProgress) {
            [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
            request.addEventListener("progress", downloadThrottled);
          }
          if (onUploadProgress && request.upload) {
            [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
            request.upload.addEventListener("progress", uploadThrottled);
            request.upload.addEventListener("loadend", flushUpload);
          }
          if (_config.cancelToken || _config.signal) {
            onCanceled = (cancel) => {
              if (!request) {
                return;
              }
              reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
              request.abort();
              request = null;
            };
            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
            if (_config.signal) {
              _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
            }
          }
          const protocol = parseProtocol(_config.url);
          if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
            reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
            return;
          }
          request.send(requestData || null);
        });
      };
    }
  });

  // node_modules/axios/lib/helpers/composeSignals.js
  var composeSignals, composeSignals_default;
  var init_composeSignals = __esm({
    "node_modules/axios/lib/helpers/composeSignals.js"() {
      init_CanceledError();
      init_AxiosError();
      init_utils();
      composeSignals = (signals, timeout) => {
        const { length } = signals = signals ? signals.filter(Boolean) : [];
        if (timeout || length) {
          let controller = new AbortController();
          let aborted;
          const onabort = function(reason) {
            if (!aborted) {
              aborted = true;
              unsubscribe();
              const err = reason instanceof Error ? reason : this.reason;
              controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
            }
          };
          let timer = timeout && setTimeout(() => {
            timer = null;
            onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
          }, timeout);
          const unsubscribe = () => {
            if (signals) {
              timer && clearTimeout(timer);
              timer = null;
              signals.forEach((signal2) => {
                signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
              });
              signals = null;
            }
          };
          signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
          const { signal } = controller;
          signal.unsubscribe = () => utils_default.asap(unsubscribe);
          return signal;
        }
      };
      composeSignals_default = composeSignals;
    }
  });

  // node_modules/axios/lib/helpers/trackStream.js
  var streamChunk, readBytes, readStream, trackStream;
  var init_trackStream = __esm({
    "node_modules/axios/lib/helpers/trackStream.js"() {
      streamChunk = function* (chunk, chunkSize) {
        let len = chunk.byteLength;
        if (!chunkSize || len < chunkSize) {
          yield chunk;
          return;
        }
        let pos = 0;
        let end;
        while (pos < len) {
          end = pos + chunkSize;
          yield chunk.slice(pos, end);
          pos = end;
        }
      };
      readBytes = async function* (iterable, chunkSize) {
        for await (const chunk of readStream(iterable)) {
          yield* streamChunk(chunk, chunkSize);
        }
      };
      readStream = async function* (stream) {
        if (stream[Symbol.asyncIterator]) {
          yield* stream;
          return;
        }
        const reader = stream.getReader();
        try {
          for (; ; ) {
            const { done, value } = await reader.read();
            if (done) {
              break;
            }
            yield value;
          }
        } finally {
          await reader.cancel();
        }
      };
      trackStream = (stream, chunkSize, onProgress, onFinish) => {
        const iterator2 = readBytes(stream, chunkSize);
        let bytes = 0;
        let done;
        let _onFinish = (e) => {
          if (!done) {
            done = true;
            onFinish && onFinish(e);
          }
        };
        return new ReadableStream({
          async pull(controller) {
            try {
              const { done: done2, value } = await iterator2.next();
              if (done2) {
                _onFinish();
                controller.close();
                return;
              }
              let len = value.byteLength;
              if (onProgress) {
                let loadedBytes = bytes += len;
                onProgress(loadedBytes);
              }
              controller.enqueue(new Uint8Array(value));
            } catch (err) {
              _onFinish(err);
              throw err;
            }
          },
          cancel(reason) {
            _onFinish(reason);
            return iterator2.return();
          }
        }, {
          highWaterMark: 2
        });
      };
    }
  });

  // node_modules/axios/lib/adapters/fetch.js
  var isFetchSupported, isReadableStreamSupported, encodeText, test, supportsRequestStream, DEFAULT_CHUNK_SIZE, supportsResponseStream, resolvers, getBodyLength, resolveBodyLength, fetch_default;
  var init_fetch = __esm({
    "node_modules/axios/lib/adapters/fetch.js"() {
      init_platform();
      init_utils();
      init_AxiosError();
      init_composeSignals();
      init_trackStream();
      init_AxiosHeaders();
      init_progressEventReducer();
      init_resolveConfig();
      init_settle();
      isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
      isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
      encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
      test = (fn2, ...args) => {
        try {
          return !!fn2(...args);
        } catch (e) {
          return false;
        }
      };
      supportsRequestStream = isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform_default.origin, {
          body: new ReadableStream(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      DEFAULT_CHUNK_SIZE = 64 * 1024;
      supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
      resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && ((res) => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_2, config2) => {
            throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
          });
        });
      })(new Response());
      getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils_default.isBlob(body)) {
          return body.size;
        }
        if (utils_default.isSpecCompliantForm(body)) {
          const _request = new Request(platform_default.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils_default.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils_default.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      resolveBodyLength = async (headers, body) => {
        const length = utils_default.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      fetch_default = isFetchSupported && (async (config2) => {
        let {
          url,
          method,
          data: data2,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig_default(config2);
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data2)) !== 0) {
            let _request = new Request(url, {
              method: "POST",
              body: data2,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils_default.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils_default.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = "credentials" in Request.prototype;
          request = new Request(url, {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data2,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          });
          let response = await fetch(request);
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders_default.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config2,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError_default.from(err, err && err.code, config2, request);
        }
      });
    }
  });

  // node_modules/axios/lib/adapters/adapters.js
  var knownAdapters, renderReason, isResolvedHandle, adapters_default;
  var init_adapters = __esm({
    "node_modules/axios/lib/adapters/adapters.js"() {
      init_utils();
      init_null();
      init_xhr();
      init_fetch();
      init_AxiosError();
      knownAdapters = {
        http: null_default,
        xhr: xhr_default,
        fetch: fetch_default
      };
      utils_default.forEach(knownAdapters, (fn2, value) => {
        if (fn2) {
          try {
            Object.defineProperty(fn2, "name", { value });
          } catch (e) {
          }
          Object.defineProperty(fn2, "adapterName", { value });
        }
      });
      renderReason = (reason) => `- ${reason}`;
      isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
      adapters_default = {
        getAdapter: (adapters) => {
          adapters = utils_default.isArray(adapters) ? adapters : [adapters];
          const { length } = adapters;
          let nameOrAdapter;
          let adapter;
          const rejectedReasons = {};
          for (let i = 0; i < length; i++) {
            nameOrAdapter = adapters[i];
            let id;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
              adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
              if (adapter === void 0) {
                throw new AxiosError_default(`Unknown adapter '${id}'`);
              }
            }
            if (adapter) {
              break;
            }
            rejectedReasons[id || "#" + i] = adapter;
          }
          if (!adapter) {
            const reasons = Object.entries(rejectedReasons).map(
              ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
            );
            let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError_default(
              `There is no suitable adapter to dispatch the request ` + s,
              "ERR_NOT_SUPPORT"
            );
          }
          return adapter;
        },
        adapters: knownAdapters
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError_default(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders_default.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  var init_dispatchRequest = __esm({
    "node_modules/axios/lib/core/dispatchRequest.js"() {
      "use strict";
      init_transformData();
      init_isCancel();
      init_defaults();
      init_CanceledError();
      init_AxiosHeaders();
      init_adapters();
    }
  });

  // node_modules/axios/lib/env/data.js
  var VERSION;
  var init_data = __esm({
    "node_modules/axios/lib/env/data.js"() {
      VERSION = "1.9.0";
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === void 0 || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
      }
    }
  }
  var validators, deprecatedWarnings, validator_default;
  var init_validator = __esm({
    "node_modules/axios/lib/helpers/validator.js"() {
      "use strict";
      init_data();
      init_AxiosError();
      validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
        };
      });
      deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version2, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return (value, opt, opts) => {
          if (validator === false) {
            throw new AxiosError_default(
              formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
              AxiosError_default.ERR_DEPRECATED
            );
          }
          if (version2 && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version2 + " and will be removed in the near future"
              )
            );
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      validators.spelling = function spelling(correctSpelling) {
        return (value, opt) => {
          console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
          return true;
        };
      };
      validator_default = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var validators2, Axios, Axios_default;
  var init_Axios = __esm({
    "node_modules/axios/lib/core/Axios.js"() {
      "use strict";
      init_utils();
      init_buildURL();
      init_InterceptorManager();
      init_dispatchRequest();
      init_mergeConfig();
      init_buildFullPath();
      init_validator();
      init_AxiosHeaders();
      validators2 = validator_default.validators;
      Axios = class {
        constructor(instanceConfig) {
          this.defaults = instanceConfig || {};
          this.interceptors = {
            request: new InterceptorManager_default(),
            response: new InterceptorManager_default()
          };
        }
        /**
         * Dispatch a request
         *
         * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
         * @param {?Object} config
         *
         * @returns {Promise} The Promise to be fulfilled
         */
        async request(configOrUrl, config2) {
          try {
            return await this._request(configOrUrl, config2);
          } catch (err) {
            if (err instanceof Error) {
              let dummy = {};
              Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
              const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
              try {
                if (!err.stack) {
                  err.stack = stack;
                } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                  err.stack += "\n" + stack;
                }
              } catch (e) {
              }
            }
            throw err;
          }
        }
        _request(configOrUrl, config2) {
          if (typeof configOrUrl === "string") {
            config2 = config2 || {};
            config2.url = configOrUrl;
          } else {
            config2 = configOrUrl || {};
          }
          config2 = mergeConfig(this.defaults, config2);
          const { transitional: transitional2, paramsSerializer, headers } = config2;
          if (transitional2 !== void 0) {
            validator_default.assertOptions(transitional2, {
              silentJSONParsing: validators2.transitional(validators2.boolean),
              forcedJSONParsing: validators2.transitional(validators2.boolean),
              clarifyTimeoutError: validators2.transitional(validators2.boolean)
            }, false);
          }
          if (paramsSerializer != null) {
            if (utils_default.isFunction(paramsSerializer)) {
              config2.paramsSerializer = {
                serialize: paramsSerializer
              };
            } else {
              validator_default.assertOptions(paramsSerializer, {
                encode: validators2.function,
                serialize: validators2.function
              }, true);
            }
          }
          if (config2.allowAbsoluteUrls !== void 0) {
          } else if (this.defaults.allowAbsoluteUrls !== void 0) {
            config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
          } else {
            config2.allowAbsoluteUrls = true;
          }
          validator_default.assertOptions(config2, {
            baseUrl: validators2.spelling("baseURL"),
            withXsrfToken: validators2.spelling("withXSRFToken")
          }, true);
          config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
          let contextHeaders = headers && utils_default.merge(
            headers.common,
            headers[config2.method]
          );
          headers && utils_default.forEach(
            ["delete", "get", "head", "post", "put", "patch", "common"],
            (method) => {
              delete headers[method];
            }
          );
          config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
          const requestInterceptorChain = [];
          let synchronousRequestInterceptors = true;
          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
              return;
            }
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
          });
          const responseInterceptorChain = [];
          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
          });
          let promise;
          let i = 0;
          let len;
          if (!synchronousRequestInterceptors) {
            const chain = [dispatchRequest.bind(this), void 0];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config2);
            while (i < len) {
              promise = promise.then(chain[i++], chain[i++]);
            }
            return promise;
          }
          len = requestInterceptorChain.length;
          let newConfig = config2;
          i = 0;
          while (i < len) {
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
              newConfig = onFulfilled(newConfig);
            } catch (error) {
              onRejected.call(this, error);
              break;
            }
          }
          try {
            promise = dispatchRequest.call(this, newConfig);
          } catch (error) {
            return Promise.reject(error);
          }
          i = 0;
          len = responseInterceptorChain.length;
          while (i < len) {
            promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
          }
          return promise;
        }
        getUri(config2) {
          config2 = mergeConfig(this.defaults, config2);
          const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
          return buildURL(fullPath, config2.params, config2.paramsSerializer);
        }
      };
      utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            url,
            data: (config2 || {}).data
          }));
        };
      });
      utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data2, config2) {
            return this.request(mergeConfig(config2 || {}, {
              method,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data: data2
            }));
          };
        }
        Axios.prototype[method] = generateHTTPMethod();
        Axios.prototype[method + "Form"] = generateHTTPMethod(true);
      });
      Axios_default = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var CancelToken, CancelToken_default;
  var init_CancelToken = __esm({
    "node_modules/axios/lib/cancel/CancelToken.js"() {
      "use strict";
      init_CanceledError();
      CancelToken = class _CancelToken {
        constructor(executor) {
          if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
          }
          let resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });
          const token = this;
          this.promise.then((cancel) => {
            if (!token._listeners) return;
            let i = token._listeners.length;
            while (i-- > 0) {
              token._listeners[i](cancel);
            }
            token._listeners = null;
          });
          this.promise.then = (onfulfilled) => {
            let _resolve;
            const promise = new Promise((resolve) => {
              token.subscribe(resolve);
              _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
              token.unsubscribe(_resolve);
            };
            return promise;
          };
          executor(function cancel(message, config2, request) {
            if (token.reason) {
              return;
            }
            token.reason = new CanceledError_default(message, config2, request);
            resolvePromise(token.reason);
          });
        }
        /**
         * Throws a `CanceledError` if cancellation has been requested.
         */
        throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        }
        /**
         * Subscribe to the cancel signal
         */
        subscribe(listener) {
          if (this.reason) {
            listener(this.reason);
            return;
          }
          if (this._listeners) {
            this._listeners.push(listener);
          } else {
            this._listeners = [listener];
          }
        }
        /**
         * Unsubscribe from the cancel signal
         */
        unsubscribe(listener) {
          if (!this._listeners) {
            return;
          }
          const index = this._listeners.indexOf(listener);
          if (index !== -1) {
            this._listeners.splice(index, 1);
          }
        }
        toAbortSignal() {
          const controller = new AbortController();
          const abort = (err) => {
            controller.abort(err);
          };
          this.subscribe(abort);
          controller.signal.unsubscribe = () => this.unsubscribe(abort);
          return controller.signal;
        }
        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        static source() {
          let cancel;
          const token = new _CancelToken(function executor(c) {
            cancel = c;
          });
          return {
            token,
            cancel
          };
        }
      };
      CancelToken_default = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  var init_spread = __esm({
    "node_modules/axios/lib/helpers/spread.js"() {
      "use strict";
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
  }
  var init_isAxiosError = __esm({
    "node_modules/axios/lib/helpers/isAxiosError.js"() {
      "use strict";
      init_utils();
    }
  });

  // node_modules/axios/lib/helpers/HttpStatusCode.js
  var HttpStatusCode, HttpStatusCode_default;
  var init_HttpStatusCode = __esm({
    "node_modules/axios/lib/helpers/HttpStatusCode.js"() {
      HttpStatusCode = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
      Object.entries(HttpStatusCode).forEach(([key, value]) => {
        HttpStatusCode[value] = key;
      });
      HttpStatusCode_default = HttpStatusCode;
    }
  });

  // node_modules/axios/lib/axios.js
  function createInstance(defaultConfig) {
    const context = new Axios_default(defaultConfig);
    const instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
    utils_default.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios, axios_default;
  var init_axios = __esm({
    "node_modules/axios/lib/axios.js"() {
      "use strict";
      init_utils();
      init_bind();
      init_Axios();
      init_mergeConfig();
      init_defaults();
      init_formDataToJSON();
      init_CanceledError();
      init_CancelToken();
      init_isCancel();
      init_data();
      init_toFormData();
      init_AxiosError();
      init_spread();
      init_isAxiosError();
      init_AxiosHeaders();
      init_adapters();
      init_HttpStatusCode();
      axios = createInstance(defaults_default);
      axios.Axios = Axios_default;
      axios.CanceledError = CanceledError_default;
      axios.CancelToken = CancelToken_default;
      axios.isCancel = isCancel;
      axios.VERSION = VERSION;
      axios.toFormData = toFormData_default;
      axios.AxiosError = AxiosError_default;
      axios.Cancel = axios.CanceledError;
      axios.all = function all(promises) {
        return Promise.all(promises);
      };
      axios.spread = spread;
      axios.isAxiosError = isAxiosError;
      axios.mergeConfig = mergeConfig;
      axios.AxiosHeaders = AxiosHeaders_default;
      axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
      axios.getAdapter = adapters_default.getAdapter;
      axios.HttpStatusCode = HttpStatusCode_default;
      axios.default = axios;
      axios_default = axios;
    }
  });

  // node_modules/axios/index.js
  var Axios2, AxiosError2, CanceledError2, isCancel2, CancelToken2, VERSION2, all2, Cancel, isAxiosError2, spread2, toFormData2, AxiosHeaders2, HttpStatusCode2, formToJSON, getAdapter, mergeConfig2;
  var init_axios2 = __esm({
    "node_modules/axios/index.js"() {
      init_axios();
      ({
        Axios: Axios2,
        AxiosError: AxiosError2,
        CanceledError: CanceledError2,
        isCancel: isCancel2,
        CancelToken: CancelToken2,
        VERSION: VERSION2,
        all: all2,
        Cancel,
        isAxiosError: isAxiosError2,
        spread: spread2,
        toFormData: toFormData2,
        AxiosHeaders: AxiosHeaders2,
        HttpStatusCode: HttpStatusCode2,
        formToJSON,
        getAdapter,
        mergeConfig: mergeConfig2
      } = axios_default);
    }
  });

  // public/js/alert.js
  var hideAlert, showAlert;
  var init_alert = __esm({
    "public/js/alert.js"() {
      hideAlert = () => {
        const el = document.querySelector(".alert");
        if (el) el.parentElement.removeChild(el);
      };
      showAlert = (type, msg) => {
        hideAlert();
        const markup = `<div class="alert alert--${type}">${msg}</div>`;
        document.querySelector("body").insertAdjacentHTML("afterbegin", markup);
        window.setTimeout(hideAlert, 5e3);
      };
    }
  });

  // public/js/login.js
  var login, logout;
  var init_login = __esm({
    "public/js/login.js"() {
      init_axios2();
      init_alert();
      login = async (email, password) => {
        try {
          const res = await axios_default({
            method: "POST",
            url: "/api/v1/users/login",
            data: {
              email,
              password
            }
          });
          if (res.data.status === "success") {
            showAlert("success", "Logged in successfully!");
            window.setTimeout(() => {
              location.assign("/");
            }, 1e3);
          }
        } catch (err) {
          showAlert("error", err.response.data.message);
        }
      };
      logout = async () => {
        try {
          const res = await axios_default.get("/api/v1/users/logout");
          if (res.data.status === "success") location.reload(true);
        } catch (err) {
          showAlert("error", "Error logging out! try again");
        }
      };
    }
  });

  // public/js/signup.js
  var signup, startCountdownRedirect;
  var init_signup = __esm({
    "public/js/signup.js"() {
      init_axios2();
      init_alert();
      signup = async (data2) => {
        try {
          const res = await axios_default({
            method: "POST",
            url: "/api/v1/users/signup",
            data: data2
          });
          if (res.data.status === "success") {
            showAlert("success", "Sign up successfully!");
            window.setTimeout(() => {
              location.assign("/check-email");
            }, 1e3);
          }
        } catch (err) {
          showAlert("error", err.response.data.message);
        }
      };
      startCountdownRedirect = (page, seconds) => {
        const timerEl = document.getElementById("countdown-number");
        const timer = window.setInterval(() => {
          seconds--;
          timerEl.textContent = `${seconds} seconds`;
          if (seconds === 0) {
            clearInterval(timer);
            location.assign(page);
          }
        }, 1e3);
      };
    }
  });

  // public/js/updateSettings.js
  var updateSettings;
  var init_updateSettings = __esm({
    "public/js/updateSettings.js"() {
      init_axios2();
      init_alert();
      updateSettings = async (data2, type) => {
        try {
          const urlParam = type === "password" ? "updateMyPassword" : "updateMe";
          const res = await axios_default({
            method: "PATCH",
            url: `/api/v1/users/${urlParam}`,
            data: data2
          });
          if (res.data.status === "success") {
            showAlert("success", `${type.toUpperCase()} updated successfully!`);
          }
        } catch (err) {
          showAlert("error", err.response.data.message);
        }
      };
    }
  });

  // public/js/stripe.js
  var bookTour;
  var init_stripe = __esm({
    "public/js/stripe.js"() {
      init_axios2();
      init_alert();
      bookTour = async (tourId, bookingDate) => {
        const stripe = Stripe(
          "pk_test_51RSyLcH7UHaPkmrdaiQtYJdB2ozzOOXA5B6uhrXT9i8rt3wdt09wZtPij8sO4J1MiDGUXOqQFYlbi9c9rLqfEs8p00jst2nCYp"
        );
        try {
          const session = await axios_default(
            `/api/v1/bookings/checkout-session/${tourId}/${bookingDate}`
          );
          await stripe.redirectToCheckout({
            sessionId: session.data.session.id
          });
        } catch (err) {
          showAlert("error", err.message);
        }
      };
    }
  });

  // public/js/booking.js
  function selectBookingDate() {
    const dateButtons = document.querySelectorAll(".date-button-js");
    const bookBtn = document.getElementById("book-tour");
    if (!bookBtn) return;
    dateButtons.forEach((date) => {
      date.addEventListener("click", (e) => {
        const { startDate } = e.target.dataset;
        if (startDate) {
          bookBtn.dataset.bookingDate = startDate;
          dateButtons.forEach((b) => b.classList.remove("selected-date"));
          date.classList.add("selected-date");
        }
      });
    });
  }
  var init_booking = __esm({
    "public/js/booking.js"() {
    }
  });

  // public/js/review.js
  var addReview;
  var init_review = __esm({
    "public/js/review.js"() {
      init_axios2();
      init_alert();
      addReview = async (data2) => {
        try {
          const res = await axios_default({
            method: "POST",
            url: "/api/v1/reviews",
            data: data2
          });
          if (res.data.status === "success") {
            showAlert("success", "Review has been added successfully!");
            window.setTimeout(() => {
              location.reload();
            }, 1e3);
          }
        } catch (err) {
          showAlert("error", err.response.data.message);
        }
      };
    }
  });

  // node_modules/@maptiler/sdk/dist/maptiler-sdk.css
  var init_maptiler_sdk = __esm({
    "node_modules/@maptiler/sdk/dist/maptiler-sdk.css"() {
    }
  });

  // node_modules/maplibre-gl/dist/maplibre-gl.js
  var require_maplibre_gl = __commonJS({
    "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
      })(exports, function() {
        "use strict";
        var maplibregl = {};
        var modules = {};
        function define2(moduleName, _dependencies, moduleFactory) {
          modules[moduleName] = moduleFactory;
          if (moduleName !== "index") {
            return;
          }
          var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
          var sharedModule = {};
          modules.shared(sharedModule);
          modules.index(maplibregl, sharedModule);
          if (typeof window !== "undefined") {
            maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
          }
          return maplibregl;
        }
        ;
        define2("shared", ["exports"], function(t) {
          "use strict";
          function e(t2, e2, r2, n2) {
            return new (r2 || (r2 = Promise))(function(i2, s2) {
              function a2(t3) {
                try {
                  l2(n2.next(t3));
                } catch (t4) {
                  s2(t4);
                }
              }
              function o2(t3) {
                try {
                  l2(n2.throw(t3));
                } catch (t4) {
                  s2(t4);
                }
              }
              function l2(t3) {
                var e3;
                t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
                  t4(e3);
                })).then(a2, o2);
              }
              l2((n2 = n2.apply(t2, e2 || [])).next());
            });
          }
          function r(t2) {
            return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
          }
          var n, i;
          function s() {
            if (i) return n;
            function t2(t3, e2) {
              this.x = t3, this.y = e2;
            }
            return i = 1, n = t2, t2.prototype = { clone: function() {
              return new t2(this.x, this.y);
            }, add: function(t3) {
              return this.clone()._add(t3);
            }, sub: function(t3) {
              return this.clone()._sub(t3);
            }, multByPoint: function(t3) {
              return this.clone()._multByPoint(t3);
            }, divByPoint: function(t3) {
              return this.clone()._divByPoint(t3);
            }, mult: function(t3) {
              return this.clone()._mult(t3);
            }, div: function(t3) {
              return this.clone()._div(t3);
            }, rotate: function(t3) {
              return this.clone()._rotate(t3);
            }, rotateAround: function(t3, e2) {
              return this.clone()._rotateAround(t3, e2);
            }, matMult: function(t3) {
              return this.clone()._matMult(t3);
            }, unit: function() {
              return this.clone()._unit();
            }, perp: function() {
              return this.clone()._perp();
            }, round: function() {
              return this.clone()._round();
            }, mag: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            }, equals: function(t3) {
              return this.x === t3.x && this.y === t3.y;
            }, dist: function(t3) {
              return Math.sqrt(this.distSqr(t3));
            }, distSqr: function(t3) {
              var e2 = t3.x - this.x, r2 = t3.y - this.y;
              return e2 * e2 + r2 * r2;
            }, angle: function() {
              return Math.atan2(this.y, this.x);
            }, angleTo: function(t3) {
              return Math.atan2(this.y - t3.y, this.x - t3.x);
            }, angleWith: function(t3) {
              return this.angleWithSep(t3.x, t3.y);
            }, angleWithSep: function(t3, e2) {
              return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
            }, _matMult: function(t3) {
              var e2 = t3[2] * this.x + t3[3] * this.y;
              return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
            }, _add: function(t3) {
              return this.x += t3.x, this.y += t3.y, this;
            }, _sub: function(t3) {
              return this.x -= t3.x, this.y -= t3.y, this;
            }, _mult: function(t3) {
              return this.x *= t3, this.y *= t3, this;
            }, _div: function(t3) {
              return this.x /= t3, this.y /= t3, this;
            }, _multByPoint: function(t3) {
              return this.x *= t3.x, this.y *= t3.y, this;
            }, _divByPoint: function(t3) {
              return this.x /= t3.x, this.y /= t3.y, this;
            }, _unit: function() {
              return this._div(this.mag()), this;
            }, _perp: function() {
              var t3 = this.y;
              return this.y = this.x, this.x = -t3, this;
            }, _rotate: function(t3) {
              var e2 = Math.cos(t3), r2 = Math.sin(t3), n2 = r2 * this.x + e2 * this.y;
              return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
            }, _rotateAround: function(t3, e2) {
              var r2 = Math.cos(t3), n2 = Math.sin(t3), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
              return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
            }, _round: function() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            } }, t2.convert = function(e2) {
              return e2 instanceof t2 ? e2 : Array.isArray(e2) ? new t2(e2[0], e2[1]) : e2;
            }, n;
          }
          "function" == typeof SuppressedError && SuppressedError;
          var a, o, l = r(s()), u = function() {
            if (o) return a;
            function t2(t3, e2, r2, n2) {
              this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
            }
            return o = 1, a = t2, t2.prototype = { sampleCurveX: function(t3) {
              return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
            }, sampleCurveY: function(t3) {
              return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
            }, sampleCurveDerivativeX: function(t3) {
              return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
            }, solveCurveX: function(t3, e2) {
              if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
              if (t3 > 1) return 1;
              for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
                var i2 = this.sampleCurveX(r2) - t3;
                if (Math.abs(i2) < e2) return r2;
                var s2 = this.sampleCurveDerivativeX(r2);
                if (Math.abs(s2) < 1e-6) break;
                r2 -= i2 / s2;
              }
              var a2 = 0, o2 = 1;
              for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++) t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
              return r2;
            }, solve: function(t3, e2) {
              return this.sampleCurveY(this.solveCurveX(t3, e2));
            } }, a;
          }(), c = r(u);
          let h2, p;
          function f() {
            return null == h2 && (h2 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), h2;
          }
          function d() {
            if (null == p && (p = false, f())) {
              const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
              if (e2) {
                for (let r3 = 0; r3 < t2 * t2; r3++) {
                  const n2 = 4 * r3;
                  e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
                }
                const r2 = e2.getImageData(0, 0, t2, t2).data;
                for (let e3 = 0; e3 < t2 * t2 * 4; e3++) if (e3 % 4 != 3 && r2[e3] !== e3) {
                  p = true;
                  break;
                }
              }
            }
            return p || false;
          }
          var y = 1e-6, m = "undefined" != typeof Float32Array ? Float32Array : Array;
          function g2() {
            var t2 = new m(9);
            return m != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
          }
          function x2(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function v() {
            var t2 = new m(3);
            return m != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
          }
          function b(t2) {
            return Math.hypot(t2[0], t2[1], t2[2]);
          }
          function w(t2, e2, r2) {
            var n2 = new m(3);
            return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = 0, e2 = arguments.length; e2--; ) t2 += arguments[e2] * arguments[e2];
            return Math.sqrt(t2);
          });
          var _2, A2 = b;
          function S2(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
          }
          function k() {
            var t2 = new m(4);
            return m != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
          }
          function M2() {
            var t2 = new m(2);
            return m != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
          }
          function I2(t2, e2) {
            var r2 = new m(2);
            return r2[0] = t2, r2[1] = e2, r2;
          }
          v(), _2 = new m(4), m != Float32Array && (_2[0] = 0, _2[1] = 0, _2[2] = 0, _2[3] = 0), v(), w(1, 0, 0), w(0, 1, 0), k(), k(), g2(), M2();
          const z = 8192;
          function P(t2, e2, r2) {
            return e2 * (z / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
          }
          function C2(t2, e2) {
            return (t2 % e2 + e2) % e2;
          }
          function B2(t2, e2, r2) {
            return t2 * (1 - r2) + e2 * r2;
          }
          function V2(t2) {
            if (t2 <= 0) return 0;
            if (t2 >= 1) return 1;
            const e2 = t2 * t2, r2 = e2 * t2;
            return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
          }
          function E2(t2, e2, r2, n2) {
            const i2 = new c(t2, e2, r2, n2);
            return (t3) => i2.solve(t3);
          }
          const T = E2(0.25, 0.1, 0.25, 1);
          function F2(t2, e2, r2) {
            return Math.min(r2, Math.max(e2, t2));
          }
          function $2(t2, e2, r2) {
            const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r2 : i2;
          }
          function L2(t2, ...e2) {
            for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
            return t2;
          }
          let O2 = 1;
          function D2(t2, e2, r2) {
            const n2 = {};
            for (const r3 in t2) n2[r3] = e2.call(this, t2[r3], r3, t2);
            return n2;
          }
          function j(t2, e2, r2) {
            const n2 = {};
            for (const r3 in t2) e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
            return n2;
          }
          function R(t2) {
            return Array.isArray(t2) ? t2.map(R) : "object" == typeof t2 && t2 ? D2(t2, R) : t2;
          }
          const N2 = {};
          function U(t2) {
            N2[t2] || ("undefined" != typeof console && console.warn(t2), N2[t2] = true);
          }
          function q2(t2, e2, r2) {
            return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
          }
          function G2(t2) {
            return "undefined" != typeof WorkerGlobalScope && void 0 !== t2 && t2 instanceof WorkerGlobalScope;
          }
          let Z2 = null;
          function K2(t2) {
            return "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap;
          }
          const X2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          function H2(t2, r2, n2, i2, s2) {
            return e(this, void 0, void 0, function* () {
              if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
              const e2 = new VideoFrame(t2, { timestamp: 0 });
              try {
                const a2 = null == e2 ? void 0 : e2.format;
                if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB")) throw new Error(`Unrecognized format ${a2}`);
                const o2 = a2.startsWith("BGR"), l2 = new Uint8ClampedArray(i2 * s2 * 4);
                if (yield e2.copyTo(l2, function(t3, e3, r3, n3, i3) {
                  const s3 = 4 * Math.max(1, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l3 = Math.max(0, e3), u2 = Math.max(0, r3);
                  return { rect: { x: l3, y: u2, width: Math.min(t3.width, e3 + n3) - l3, height: Math.min(t3.height, r3 + i3) - u2 }, layout: [{ offset: a3, stride: o3 }] };
                }(t2, r2, n2, i2, s2)), o2) for (let t3 = 0; t3 < l2.length; t3 += 4) {
                  const e3 = l2[t3];
                  l2[t3] = l2[t3 + 2], l2[t3 + 2] = e3;
                }
                return l2;
              } finally {
                e2.close();
              }
            });
          }
          let Y2, J2;
          function W2(t2, e2, r2, n2) {
            return t2.addEventListener(e2, r2, n2), { unsubscribe: () => {
              t2.removeEventListener(e2, r2, n2);
            } };
          }
          function Q2(t2) {
            return t2 * Math.PI / 180;
          }
          function tt(t2) {
            return t2 / Math.PI * 180;
          }
          const et = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, rt = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, nt = "AbortError";
          function it2() {
            return new Error(nt);
          }
          const st2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
          function at2(t2) {
            return st2.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
          }
          const ot2 = "global-dispatcher";
          class lt2 extends Error {
            constructor(t2, e2, r2, n2) {
              super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
            }
          }
          const ut = () => G2(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, ct2 = function(t2, r2) {
            if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
              const e2 = at2(t2.url);
              if (e2) return e2(t2, r2);
              if (G2(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: ot2 }, r2);
            }
            if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(ut()) && !/^\w+:/.test(n2))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t3, r3) {
                return e(this, void 0, void 0, function* () {
                  const e2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: ut(), signal: r3.signal });
                  let n3, i2;
                  "json" !== t3.type || e2.headers.has("Accept") || e2.headers.set("Accept", "application/json");
                  try {
                    n3 = yield fetch(e2);
                  } catch (e3) {
                    throw new lt2(0, e3.message, t3.url, new Blob());
                  }
                  if (!n3.ok) {
                    const e3 = yield n3.blob();
                    throw new lt2(n3.status, n3.statusText, t3.url, e3);
                  }
                  i2 = "arrayBuffer" === t3.type || "image" === t3.type ? n3.arrayBuffer() : "json" === t3.type ? n3.json() : n3.text();
                  const s2 = yield i2;
                  if (r3.signal.aborted) throw it2();
                  return { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
                });
              }(t2, r2);
              if (G2(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: ot2 }, r2);
            }
            var n2;
            return function(t3, e2) {
              return new Promise((r3, n3) => {
                var i2;
                const s2 = new XMLHttpRequest();
                s2.open(t3.method || "GET", t3.url, true), "arrayBuffer" !== t3.type && "image" !== t3.type || (s2.responseType = "arraybuffer");
                for (const e3 in t3.headers) s2.setRequestHeader(e3, t3.headers[e3]);
                "json" === t3.type && (s2.responseType = "text", (null === (i2 = t3.headers) || void 0 === i2 ? void 0 : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = "include" === t3.credentials, s2.onerror = () => {
                  n3(new Error(s2.statusText));
                }, s2.onload = () => {
                  if (!e2.signal.aborted) if ((s2.status >= 200 && s2.status < 300 || 0 === s2.status) && null !== s2.response) {
                    let e3 = s2.response;
                    if ("json" === t3.type) try {
                      e3 = JSON.parse(s2.response);
                    } catch (t4) {
                      return void n3(t4);
                    }
                    r3({ data: e3, cacheControl: s2.getResponseHeader("Cache-Control"), expires: s2.getResponseHeader("Expires") });
                  } else {
                    const e3 = new Blob([s2.response], { type: s2.getResponseHeader("Content-Type") });
                    n3(new lt2(s2.status, s2.statusText, t3.url, e3));
                  }
                }, e2.signal.addEventListener("abort", () => {
                  s2.abort(), n3(it2());
                }), s2.send(t3.body);
              });
            }(t2, r2);
          };
          function ht2(t2) {
            if (!t2 || t2.indexOf("://") <= 0 || 0 === t2.indexOf("data:image/") || 0 === t2.indexOf("blob:")) return true;
            const e2 = new URL(t2), r2 = window.location;
            return e2.protocol === r2.protocol && e2.host === r2.host;
          }
          function pt2(t2, e2, r2) {
            r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
          }
          function ft2(t2, e2, r2) {
            if (r2 && r2[t2]) {
              const n2 = r2[t2].indexOf(e2);
              -1 !== n2 && r2[t2].splice(n2, 1);
            }
          }
          class dt2 {
            constructor(t2, e2 = {}) {
              L2(this, e2), this.type = t2;
            }
          }
          class yt2 extends dt2 {
            constructor(t2, e2 = {}) {
              super("error", L2({ error: t2 }, e2));
            }
          }
          class mt2 {
            on(t2, e2) {
              return this._listeners = this._listeners || {}, pt2(t2, e2, this._listeners), { unsubscribe: () => {
                this.off(t2, e2);
              } };
            }
            off(t2, e2) {
              return ft2(t2, e2, this._listeners), ft2(t2, e2, this._oneTimeListeners), this;
            }
            once(t2, e2) {
              return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, pt2(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
            }
            fire(t2, e2) {
              "string" == typeof t2 && (t2 = new dt2(t2, e2 || {}));
              const r2 = t2.type;
              if (this.listens(r2)) {
                t2.target = this;
                const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
                for (const r3 of e3) r3.call(this, t2);
                const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
                for (const e4 of n2) ft2(r2, e4, this._oneTimeListeners), e4.call(this, t2);
                const i2 = this._eventedParent;
                i2 && (L2(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
              } else t2 instanceof yt2 && console.error(t2.error);
              return this;
            }
            listens(t2) {
              return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
            }
            setEventedParent(t2, e2) {
              return this._eventedParent = t2, this._eventedParentData = e2, this;
            }
          }
          var gt2 = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, state: { type: "state", default: {} }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "numberArray", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-altitude": { type: "numberArray", default: 45, minimum: 0, maximum: 90, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "colorArray", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "colorArray", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-method": { type: "enum", values: { standard: {}, basic: {}, combined: {}, igor: {}, multidirectional: {} }, default: "standard", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          const xt2 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
          function vt(t2, e2) {
            const r2 = {};
            for (const e3 in t2) "ref" !== e3 && (r2[e3] = t2[e3]);
            return xt2.forEach((t3) => {
              t3 in e2 && (r2[t3] = e2[t3]);
            }), r2;
          }
          function bt2(t2, e2) {
            if (Array.isArray(t2)) {
              if (!Array.isArray(e2) || t2.length !== e2.length) return false;
              for (let r2 = 0; r2 < t2.length; r2++) if (!bt2(t2[r2], e2[r2])) return false;
              return true;
            }
            if ("object" == typeof t2 && null !== t2 && null !== e2) {
              if ("object" != typeof e2) return false;
              if (Object.keys(t2).length !== Object.keys(e2).length) return false;
              for (const r2 in t2) if (!bt2(t2[r2], e2[r2])) return false;
              return true;
            }
            return t2 === e2;
          }
          function wt2(t2, e2) {
            t2.push(e2);
          }
          function _t2(t2, e2, r2) {
            wt2(r2, { command: "addSource", args: [t2, e2[t2]] });
          }
          function At2(t2, e2, r2) {
            wt2(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
          }
          function St2(t2, e2, r2, n2) {
            At2(t2, r2, n2), _t2(t2, e2, r2);
          }
          function kt2(t2, e2, r2) {
            let n2;
            for (n2 in t2[r2]) if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && "data" !== n2 && !bt2(t2[r2][n2], e2[r2][n2])) return false;
            for (n2 in e2[r2]) if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && "data" !== n2 && !bt2(t2[r2][n2], e2[r2][n2])) return false;
            return true;
          }
          function Mt2(t2, e2, r2, n2, i2, s2) {
            t2 = t2 || {}, e2 = e2 || {};
            for (const a2 in t2) Object.prototype.hasOwnProperty.call(t2, a2) && (bt2(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
            for (const a2 in e2) Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (bt2(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
          }
          function It2(t2) {
            return t2.id;
          }
          function zt2(t2, e2) {
            return t2[e2.id] = e2, t2;
          }
          class Pt {
            constructor(t2, e2, r2, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
            }
          }
          function Ct2(t2, ...e2) {
            for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
            return t2;
          }
          class Bt2 extends Error {
            constructor(t2, e2) {
              super(e2), this.message = e2, this.key = t2;
            }
          }
          class Vt2 {
            constructor(t2, e2 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r2] of e2) this.bindings[t3] = r2;
            }
            concat(t2) {
              return new Vt2(this, t2);
            }
            get(t2) {
              if (this.bindings[t2]) return this.bindings[t2];
              if (this.parent) return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          const Et2 = { kind: "null" }, Tt2 = { kind: "number" }, Ft2 = { kind: "string" }, $t = { kind: "boolean" }, Lt2 = { kind: "color" }, Ot2 = { kind: "projectionDefinition" }, Dt2 = { kind: "object" }, jt = { kind: "value" }, Rt2 = { kind: "collator" }, Nt2 = { kind: "formatted" }, Ut2 = { kind: "padding" }, qt2 = { kind: "colorArray" }, Gt2 = { kind: "numberArray" }, Zt2 = { kind: "resolvedImage" }, Kt2 = { kind: "variableAnchorOffsetCollection" };
          function Xt2(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function Ht2(t2) {
            if ("array" === t2.kind) {
              const e2 = Ht2(t2.itemType);
              return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
            }
            return t2.kind;
          }
          const Yt2 = [Et2, Tt2, Ft2, $t, Lt2, Ot2, Nt2, Dt2, Xt2(jt), Ut2, Gt2, qt2, Zt2, Kt2];
          function Jt2(t2, e2) {
            if ("error" === e2.kind) return null;
            if ("array" === t2.kind) {
              if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Jt2(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N)) return null;
            } else {
              if (t2.kind === e2.kind) return null;
              if ("value" === t2.kind) {
                for (const t3 of Yt2) if (!Jt2(t3, e2)) return null;
              }
            }
            return `Expected ${Ht2(t2)} but found ${Ht2(e2)} instead.`;
          }
          function Wt2(t2, e2) {
            return e2.some((e3) => e3.kind === t2.kind);
          }
          function Qt2(t2, e2) {
            return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
          }
          function te2(t2, e2) {
            return "array" === t2.kind && "array" === e2.kind ? t2.itemType.kind === e2.itemType.kind && "number" == typeof t2.N : t2.kind === e2.kind;
          }
          const ee2 = 0.96422, re2 = 0.82521, ne2 = 4 / 29, ie2 = 6 / 29, se2 = 3 * ie2 * ie2, ae = ie2 * ie2 * ie2, oe2 = Math.PI / 180, le2 = 180 / Math.PI;
          function ue2(t2) {
            return (t2 %= 360) < 0 && (t2 += 360), t2;
          }
          function ce2([t2, e2, r2, n2]) {
            let i2, s2;
            const a2 = pe2((0.2225045 * (t2 = he2(t2)) + 0.7168786 * (e2 = he2(e2)) + 0.0606169 * (r2 = he2(r2))) / 1);
            t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = pe2((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / ee2), s2 = pe2((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / re2));
            const o2 = 116 * a2 - 16;
            return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
          }
          function he2(t2) {
            return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function pe2(t2) {
            return t2 > ae ? Math.pow(t2, 1 / 3) : t2 / se2 + ne2;
          }
          function fe2([t2, e2, r2, n2]) {
            let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
            return i2 = 1 * ye2(i2), s2 = ee2 * ye2(s2), a2 = re2 * ye2(a2), [de2(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2), de2(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2), de2(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2), n2];
          }
          function de2(t2) {
            return (t2 = t2 <= 304e-5 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
          }
          function ye2(t2) {
            return t2 > ie2 ? t2 * t2 * t2 : se2 * (t2 - ne2);
          }
          const me2 = Object.hasOwn || function(t2, e2) {
            return Object.prototype.hasOwnProperty.call(t2, e2);
          };
          function ge2(t2, e2) {
            return me2(t2, e2) ? t2[e2] : void 0;
          }
          function xe2(t2) {
            return parseInt(t2.padEnd(2, t2), 16) / 255;
          }
          function ve2(t2, e2) {
            return be(e2 ? t2 / 100 : t2, 0, 1);
          }
          function be(t2, e2, r2) {
            return Math.min(Math.max(e2, t2), r2);
          }
          function we2(t2) {
            return !t2.some(Number.isNaN);
          }
          const _e2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
          function Ae2(t2, e2, r2) {
            return t2 + r2 * (e2 - t2);
          }
          function Se(t2, e2, r2) {
            return t2.map((t3, n2) => Ae2(t3, e2[n2], r2));
          }
          class ke2 {
            constructor(t2, e2, r2, n2 = 1, i2 = true) {
              this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
            }
            static parse(t2) {
              if (t2 instanceof ke2) return t2;
              if ("string" != typeof t2) return;
              const e2 = function(t3) {
                if ("transparent" === (t3 = t3.toLowerCase().trim())) return [0, 0, 0, 0];
                const e3 = ge2(_e2, t3);
                if (e3) {
                  const [t4, r3, n2] = e3;
                  return [t4 / 255, r3 / 255, n2 / 255, 1];
                }
                if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
                  const e4 = t3.length < 6 ? 1 : 2;
                  let r3 = 1;
                  return [xe2(t3.slice(r3, r3 += e4)), xe2(t3.slice(r3, r3 += e4)), xe2(t3.slice(r3, r3 += e4)), xe2(t3.slice(r3, r3 + e4) || "ff")];
                }
                if (t3.startsWith("rgb")) {
                  const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                  if (e4) {
                    const [t4, r3, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2] = e4, f2 = [i2 || " ", o2 || " ", c2].join("");
                    if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
                      const t5 = [n2, a2, u2].join(""), e5 = "%%%" === t5 ? 100 : "" === t5 ? 255 : 0;
                      if (e5) {
                        const t6 = [be(+r3 / e5, 0, 1), be(+s2 / e5, 0, 1), be(+l2 / e5, 0, 1), h3 ? ve2(+h3, p2) : 1];
                        if (we2(t6)) return t6;
                      }
                    }
                    return;
                  }
                }
                const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (r2) {
                  const [t4, e4, n2, i2, s2, a2, o2, l2, u2] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
                  if ("  " === c2 || "  /" === c2 || ",," === c2 || ",,," === c2) {
                    const t5 = [+e4, be(+i2, 0, 100), be(+a2, 0, 100), l2 ? ve2(+l2, u2) : 1];
                    if (we2(t5)) return function([t6, e5, r3, n3]) {
                      function i3(n4) {
                        const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                        return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                      }
                      return t6 = ue2(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                    }(t5);
                  }
                }
              }(t2);
              return e2 ? new ke2(...e2, false) : void 0;
            }
            get rgb() {
              const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
              return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
            }
            get hcl() {
              return this.overwriteGetter("hcl", function(t2) {
                const [e2, r2, n2, i2] = ce2(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
                return [Math.round(1e4 * s2) ? ue2(Math.atan2(n2, r2) * le2) : NaN, s2, e2, i2];
              }(this.rgb));
            }
            get lab() {
              return this.overwriteGetter("lab", ce2(this.rgb));
            }
            overwriteGetter(t2, e2) {
              return Object.defineProperty(this, t2, { value: e2 }), e2;
            }
            toString() {
              const [t2, e2, r2, n2] = this.rgb;
              return `rgba(${[t2, e2, r2].map((t3) => Math.round(255 * t3)).join(",")},${n2})`;
            }
            static interpolate(t2, e2, r2, n2 = "rgb") {
              switch (n2) {
                case "rgb": {
                  const [n3, i2, s2, a2] = Se(t2.rgb, e2.rgb, r2);
                  return new ke2(n3, i2, s2, a2, false);
                }
                case "hcl": {
                  const [n3, i2, s2, a2] = t2.hcl, [o2, l2, u2, c2] = e2.hcl;
                  let h3, p2;
                  if (isNaN(n3) || isNaN(o2)) isNaN(n3) ? isNaN(o2) ? h3 = NaN : (h3 = o2, 1 !== s2 && 0 !== s2 || (p2 = l2)) : (h3 = n3, 1 !== u2 && 0 !== u2 || (p2 = i2));
                  else {
                    let t3 = o2 - n3;
                    o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h3 = n3 + r2 * t3;
                  }
                  const [f2, d2, y2, m2] = function([t3, e3, r3, n4]) {
                    return t3 = isNaN(t3) ? 0 : t3 * oe2, fe2([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
                  }([h3, null != p2 ? p2 : Ae2(i2, l2, r2), Ae2(s2, u2, r2), Ae2(a2, c2, r2)]);
                  return new ke2(f2, d2, y2, m2, false);
                }
                case "lab": {
                  const [n3, i2, s2, a2] = fe2(Se(t2.lab, e2.lab, r2));
                  return new ke2(n3, i2, s2, a2, false);
                }
              }
            }
          }
          ke2.black = new ke2(0, 0, 0, 1), ke2.white = new ke2(1, 1, 1, 1), ke2.transparent = new ke2(0, 0, 0, 0), ke2.red = new ke2(1, 0, 0, 1);
          class Me2 {
            constructor(t2, e2, r2) {
              this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e2) {
              return this.collator.compare(t2, e2);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          const Ie = ["bottom", "center", "top"];
          class ze2 {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2, this.verticalAlign = s2;
            }
          }
          class Pe2 {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new Pe2([new ze2(t2, null, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
            }
            static factory(t2) {
              return t2 instanceof Pe2 ? t2 : Pe2.fromString(t2);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
            }
          }
          class Ce2 {
            constructor(t2) {
              this.values = t2.slice();
            }
            static parse(t2) {
              if (t2 instanceof Ce2) return t2;
              if ("number" == typeof t2) return new Ce2([t2, t2, t2, t2]);
              if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
                for (const e2 of t2) if ("number" != typeof e2) return;
                switch (t2.length) {
                  case 1:
                    t2 = [t2[0], t2[0], t2[0], t2[0]];
                    break;
                  case 2:
                    t2 = [t2[0], t2[1], t2[0], t2[1]];
                    break;
                  case 3:
                    t2 = [t2[0], t2[1], t2[2], t2[1]];
                }
                return new Ce2(t2);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
            static interpolate(t2, e2, r2) {
              return new Ce2(Se(t2.values, e2.values, r2));
            }
          }
          class Be2 {
            constructor(t2) {
              this.values = t2.slice();
            }
            static parse(t2) {
              if (t2 instanceof Be2) return t2;
              if ("number" == typeof t2) return new Be2([t2]);
              if (Array.isArray(t2)) {
                for (const e2 of t2) if ("number" != typeof e2) return;
                return new Be2(t2);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
            static interpolate(t2, e2, r2) {
              return new Be2(Se(t2.values, e2.values, r2));
            }
          }
          class Ve2 {
            constructor(t2) {
              this.values = t2.slice();
            }
            static parse(t2) {
              if (t2 instanceof Ve2) return t2;
              if ("string" == typeof t2) {
                const e3 = ke2.parse(t2);
                if (!e3) return;
                return new Ve2([e3]);
              }
              if (!Array.isArray(t2)) return;
              const e2 = [];
              for (const r2 of t2) {
                if ("string" != typeof r2) return;
                const t3 = ke2.parse(r2);
                if (!t3) return;
                e2.push(t3);
              }
              return new Ve2(e2);
            }
            toString() {
              return JSON.stringify(this.values);
            }
            static interpolate(t2, e2, r2, n2 = "rgb") {
              const i2 = [];
              if (t2.values.length != e2.values.length) throw new Error(`colorArray: Arrays have mismatched length (${t2.values.length} vs. ${e2.values.length}), cannot interpolate.`);
              for (let s2 = 0; s2 < t2.values.length; s2++) i2.push(ke2.interpolate(t2.values[s2], e2.values[s2], r2, n2));
              return new Ve2(i2);
            }
          }
          class Ee2 extends Error {
            constructor(t2) {
              super(t2), this.name = "RuntimeError";
            }
            toJSON() {
              return this.message;
            }
          }
          const Te2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
          class Fe2 {
            constructor(t2) {
              this.values = t2.slice();
            }
            static parse(t2) {
              if (t2 instanceof Fe2) return t2;
              if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
                for (let e2 = 0; e2 < t2.length; e2 += 2) {
                  const r2 = t2[e2], n2 = t2[e2 + 1];
                  if ("string" != typeof r2 || !Te2.has(r2)) return;
                  if (!Array.isArray(n2) || 2 !== n2.length || "number" != typeof n2[0] || "number" != typeof n2[1]) return;
                }
                return new Fe2(t2);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
            static interpolate(t2, e2, r2) {
              const n2 = t2.values, i2 = e2.values;
              if (n2.length !== i2.length) throw new Ee2(`Cannot interpolate values of different length. from: ${t2.toString()}, to: ${e2.toString()}`);
              const s2 = [];
              for (let t3 = 0; t3 < n2.length; t3 += 2) {
                if (n2[t3] !== i2[t3]) throw new Ee2(`Cannot interpolate values containing mismatched anchors. from[${t3}]: ${n2[t3]}, to[${t3}]: ${i2[t3]}`);
                s2.push(n2[t3]);
                const [e3, a2] = n2[t3 + 1], [o2, l2] = i2[t3 + 1];
                s2.push([Ae2(e3, o2, r2), Ae2(a2, l2, r2)]);
              }
              return new Fe2(s2);
            }
          }
          class $e2 {
            constructor(t2) {
              this.name = t2.name, this.available = t2.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t2) {
              return t2 ? new $e2({ name: t2, available: false }) : null;
            }
          }
          class Le2 {
            constructor(t2, e2, r2) {
              this.from = t2, this.to = e2, this.transition = r2;
            }
            static interpolate(t2, e2, r2) {
              return new Le2(t2, e2, r2);
            }
            static parse(t2) {
              return t2 instanceof Le2 ? t2 : Array.isArray(t2) && 3 === t2.length && "string" == typeof t2[0] && "string" == typeof t2[1] && "number" == typeof t2[2] ? new Le2(t2[0], t2[1], t2[2]) : "object" == typeof t2 && "string" == typeof t2.from && "string" == typeof t2.to && "number" == typeof t2.transition ? new Le2(t2.from, t2.to, t2.transition) : "string" == typeof t2 ? new Le2(t2, t2, 1) : void 0;
            }
          }
          function Oe2(t2, e2, r2, n2) {
            return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function De(t2) {
            if (null === t2 || "string" == typeof t2 || "boolean" == typeof t2 || "number" == typeof t2 || t2 instanceof Le2 || t2 instanceof ke2 || t2 instanceof Me2 || t2 instanceof Pe2 || t2 instanceof Ce2 || t2 instanceof Be2 || t2 instanceof Ve2 || t2 instanceof Fe2 || t2 instanceof $e2) return true;
            if (Array.isArray(t2)) {
              for (const e2 of t2) if (!De(e2)) return false;
              return true;
            }
            if ("object" == typeof t2) {
              for (const e2 in t2) if (!De(t2[e2])) return false;
              return true;
            }
            return false;
          }
          function je2(t2) {
            if (null === t2) return Et2;
            if ("string" == typeof t2) return Ft2;
            if ("boolean" == typeof t2) return $t;
            if ("number" == typeof t2) return Tt2;
            if (t2 instanceof ke2) return Lt2;
            if (t2 instanceof Le2) return Ot2;
            if (t2 instanceof Me2) return Rt2;
            if (t2 instanceof Pe2) return Nt2;
            if (t2 instanceof Ce2) return Ut2;
            if (t2 instanceof Be2) return Gt2;
            if (t2 instanceof Ve2) return qt2;
            if (t2 instanceof Fe2) return Kt2;
            if (t2 instanceof $e2) return Zt2;
            if (Array.isArray(t2)) {
              const e2 = t2.length;
              let r2;
              for (const e3 of t2) {
                const t3 = je2(e3);
                if (r2) {
                  if (r2 === t3) continue;
                  r2 = jt;
                  break;
                }
                r2 = t3;
              }
              return Xt2(r2 || jt, e2);
            }
            return Dt2;
          }
          function Re2(t2) {
            const e2 = typeof t2;
            return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof ke2 || t2 instanceof Le2 || t2 instanceof Pe2 || t2 instanceof Ce2 || t2 instanceof Be2 || t2 instanceof Ve2 || t2 instanceof Fe2 || t2 instanceof $e2 ? t2.toString() : JSON.stringify(t2);
          }
          class Ne2 {
            constructor(t2, e2) {
              this.type = t2, this.value = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!De(t2[1])) return e2.error("invalid value");
              const r2 = t2[1];
              let n2 = je2(r2);
              const i2 = e2.expectedType;
              return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new Ne2(n2, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          const Ue2 = { string: Ft2, number: Tt2, boolean: $t, object: Dt2 };
          class qe {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              let r2, n2 = 1;
              const i2 = t2[0];
              if ("array" === i2) {
                let i3, s3;
                if (t2.length > 2) {
                  const r3 = t2[1];
                  if ("string" != typeof r3 || !(r3 in Ue2) || "object" === r3) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = Ue2[r3], n2++;
                } else i3 = jt;
                if (t2.length > 3) {
                  if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                  s3 = t2[2], n2++;
                }
                r2 = Xt2(i3, s3);
              } else {
                if (!Ue2[i2]) throw new Error(`Types doesn't contain name = ${i2}`);
                r2 = Ue2[i2];
              }
              const s2 = [];
              for (; n2 < t2.length; n2++) {
                const r3 = e2.parse(t2[n2], n2, jt);
                if (!r3) return null;
                s2.push(r3);
              }
              return new qe(r2, s2);
            }
            evaluate(t2) {
              for (let e2 = 0; e2 < this.args.length; e2++) {
                const r2 = this.args[e2].evaluate(t2);
                if (!Jt2(this.type, je2(r2))) return r2;
                if (e2 === this.args.length - 1) throw new Ee2(`Expected value to be of type ${Ht2(this.type)}, but found ${Ht2(je2(r2))} instead.`);
              }
              throw new Error();
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
          }
          const Ge2 = { "to-boolean": $t, "to-color": Lt2, "to-number": Tt2, "to-string": Ft2 };
          class Ze2 {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              const r2 = t2[0];
              if (!Ge2[r2]) throw new Error(`Can't parse ${r2} as it is not part of the known types`);
              if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length) return e2.error("Expected one argument.");
              const n2 = Ge2[r2], i2 = [];
              for (let r3 = 1; r3 < t2.length; r3++) {
                const n3 = e2.parse(t2[r3], r3, jt);
                if (!n3) return null;
                i2.push(n3);
              }
              return new Ze2(n2, i2);
            }
            evaluate(t2) {
              switch (this.type.kind) {
                case "boolean":
                  return Boolean(this.args[0].evaluate(t2));
                case "color": {
                  let e2, r2;
                  for (const n2 of this.args) {
                    if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof ke2) return e2;
                    if ("string" == typeof e2) {
                      const r3 = t2.parseColor(e2);
                      if (r3) return r3;
                    } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rgba value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Oe2(e2[0], e2[1], e2[2], e2[3]), !r2)) return new ke2(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                  }
                  throw new Ee2(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
                }
                case "padding": {
                  let e2;
                  for (const r2 of this.args) {
                    e2 = r2.evaluate(t2);
                    const n2 = Ce2.parse(e2);
                    if (n2) return n2;
                  }
                  throw new Ee2(`Could not parse padding from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
                }
                case "numberArray": {
                  let e2;
                  for (const r2 of this.args) {
                    e2 = r2.evaluate(t2);
                    const n2 = Be2.parse(e2);
                    if (n2) return n2;
                  }
                  throw new Ee2(`Could not parse numberArray from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
                }
                case "colorArray": {
                  let e2;
                  for (const r2 of this.args) {
                    e2 = r2.evaluate(t2);
                    const n2 = Ve2.parse(e2);
                    if (n2) return n2;
                  }
                  throw new Ee2(`Could not parse colorArray from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
                }
                case "variableAnchorOffsetCollection": {
                  let e2;
                  for (const r2 of this.args) {
                    e2 = r2.evaluate(t2);
                    const n2 = Fe2.parse(e2);
                    if (n2) return n2;
                  }
                  throw new Ee2(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e2 ? e2 : JSON.stringify(e2)}'`);
                }
                case "number": {
                  let e2 = null;
                  for (const r2 of this.args) {
                    if (e2 = r2.evaluate(t2), null === e2) return 0;
                    const n2 = Number(e2);
                    if (!isNaN(n2)) return n2;
                  }
                  throw new Ee2(`Could not convert ${JSON.stringify(e2)} to number.`);
                }
                case "formatted":
                  return Pe2.fromString(Re2(this.args[0].evaluate(t2)));
                case "resolvedImage":
                  return $e2.fromString(Re2(this.args[0].evaluate(t2)));
                case "projectionDefinition":
                  return this.args[0].evaluate(t2);
                default:
                  return Re2(this.args[0].evaluate(t2));
              }
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
          }
          const Ke2 = ["Unknown", "Point", "LineString", "Polygon"];
          class Xe2 {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? Ke2[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t2) {
              let e2 = this._parseColorCache.get(t2);
              return e2 || (e2 = ke2.parse(t2), this._parseColorCache.set(t2, e2)), e2;
            }
          }
          class He2 {
            constructor(t2, e2, r2 = [], n2, i2 = new Vt2(), s2 = []) {
              this.registry = t2, this.path = r2, this.key = r2.map((t3) => `[${t3}]`).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
            }
            parse(t2, e2, r2, n2, i2 = {}) {
              return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            _parse(t2, e2) {
              function r2(t3, e3, r3) {
                return "assert" === r3 ? new qe(e3, [t3]) : "coerce" === r3 ? new Ze2(e3, [t3]) : t3;
              }
              if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (0 === t2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = t2[0];
                if ("string" != typeof n2) return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i2 = this.registry[n2];
                if (i2) {
                  let n3 = i2.parse(t2, this);
                  if (!n3) return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, i3 = n3.type;
                    if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind) {
                      if ("projectionDefinition" === t3.kind && ["string", "array"].includes(i3.kind) || ["color", "formatted", "resolvedImage"].includes(t3.kind) && ["value", "string"].includes(i3.kind) || ["padding", "numberArray"].includes(t3.kind) && ["value", "number", "array"].includes(i3.kind) || "colorArray" === t3.kind && ["value", "string", "array"].includes(i3.kind) || "variableAnchorOffsetCollection" === t3.kind && ["value", "array"].includes(i3.kind)) n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                      else if (this.checkSubtype(t3, i3)) return null;
                    } else n3 = r2(n3, t3, e2.typeAnnotation || "assert");
                  }
                  if (!(n3 instanceof Ne2) && "resolvedImage" !== n3.type.kind && this._isConstant(n3)) {
                    const t3 = new Xe2();
                    try {
                      n3 = new Ne2(n3.type, n3.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return n3;
                }
                return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e2, r2) {
              const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
              return new He2(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
            }
            error(t2, ...e2) {
              const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new Bt2(r2, t2));
            }
            checkSubtype(t2, e2) {
              const r2 = Jt2(t2, e2);
              return r2 && this.error(r2), r2;
            }
          }
          class Ye2 {
            constructor(t2, e2) {
              this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e2 of this.bindings) t2(e2[1]);
              t2(this.result);
            }
            static parse(t2, e2) {
              if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r2 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if ("string" != typeof i2) return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const s2 = e2.parse(t2[n3 + 1], n3 + 1);
                if (!s2) return null;
                r2.push([i2, s2]);
              }
              const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
              return n2 ? new Ye2(r2, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
          }
          class Je2 {
            constructor(t2, e2) {
              this.type = e2.type, this.name = t2, this.boundExpression = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length || "string" != typeof t2[1]) return e2.error("'var' expression requires exactly one string literal argument.");
              const r2 = t2[1];
              return e2.scope.has(r2) ? new Je2(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
          }
          class We2 {
            constructor(t2, e2, r2) {
              this.type = t2, this.index = e2, this.input = r2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, Tt2), n2 = e2.parse(t2[2], 2, Xt2(e2.expectedType || jt));
              return r2 && n2 ? new We2(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e2 < 0) throw new Ee2(`Array index out of bounds: ${e2} < 0.`);
              if (e2 >= r2.length) throw new Ee2(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
              if (e2 !== Math.floor(e2)) throw new Ee2(`Array index must be an integer, but found ${e2} instead.`);
              return r2[e2];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class Qe2 {
            constructor(t2, e2) {
              this.type = $t, this.needle = t2, this.haystack = e2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, jt), n2 = e2.parse(t2[2], 2, jt);
              return r2 && n2 ? Wt2(r2.type, [$t, Ft2, Tt2, Et2, jt]) ? new Qe2(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(r2.type)} instead`) : null;
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!r2) return false;
              if (!Qt2(e2, ["boolean", "string", "number", "null"])) throw new Ee2(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(je2(e2))} instead.`);
              if (!Qt2(r2, ["string", "array"])) throw new Ee2(`Expected second argument to be of type array or string, but found ${Ht2(je2(r2))} instead.`);
              return r2.indexOf(e2) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
          }
          class tr2 {
            constructor(t2, e2, r2) {
              this.type = Tt2, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, jt), n2 = e2.parse(t2[2], 2, jt);
              if (!r2 || !n2) return null;
              if (!Wt2(r2.type, [$t, Ft2, Tt2, Et2, jt])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, Tt2);
                return i2 ? new tr2(r2, n2, i2) : null;
              }
              return new tr2(r2, n2);
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!Qt2(e2, ["boolean", "string", "number", "null"])) throw new Ee2(`Expected first argument to be of type boolean, string, number or null, but found ${Ht2(je2(e2))} instead.`);
              let n2;
              if (this.fromIndex && (n2 = this.fromIndex.evaluate(t2)), Qt2(r2, ["string"])) {
                const t3 = r2.indexOf(e2, n2);
                return -1 === t3 ? -1 : [...r2.slice(0, t3)].length;
              }
              if (Qt2(r2, ["array"])) return r2.indexOf(e2, n2);
              throw new Ee2(`Expected second argument to be of type array or string, but found ${Ht2(je2(r2))} instead.`);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
          }
          class er2 {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
            }
            static parse(t2, e2) {
              if (t2.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1) return e2.error("Expected an even number of arguments.");
              let r2, n2;
              e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
              const i2 = {}, s2 = [];
              for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
                let o3 = t2[a3];
                const l2 = t2[a3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e2.concat(a3);
                if (0 === o3.length) return u2.error("Expected at least one branch label.");
                for (const t3 of o3) {
                  if ("number" != typeof t3 && "string" != typeof t3) return u2.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t3 && Math.floor(t3) !== t3) return u2.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u2.checkSubtype(r2, je2(t3))) return null;
                  } else r2 = je2(t3);
                  if (void 0 !== i2[String(t3)]) return u2.error("Branch labels must be unique.");
                  i2[String(t3)] = s2.length;
                }
                const c2 = e2.parse(l2, a3, n2);
                if (!c2) return null;
                n2 = n2 || c2.type, s2.push(c2);
              }
              const a2 = e2.parse(t2[1], 1, jt);
              if (!a2) return null;
              const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
              return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new er2(r2, n2, a2, i2, s2, o2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              return (je2(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class rr2 {
            constructor(t2, e2, r2) {
              this.type = t2, this.branches = e2, this.otherwise = r2;
            }
            static parse(t2, e2) {
              if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
              let r2;
              e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const s2 = e2.parse(t2[i3], i3, $t);
                if (!s2) return null;
                const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
                if (!a2) return null;
                n2.push([s2, a2]), r2 = r2 || a2.type;
              }
              const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
              if (!i2) return null;
              if (!r2) throw new Error("Can't infer output type");
              return new rr2(r2, n2, i2);
            }
            evaluate(t2) {
              for (const [e2, r2] of this.branches) if (e2.evaluate(t2)) return r2.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e2, r2] of this.branches) t2(e2), t2(r2);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class nr {
            constructor(t2, e2, r2, n2) {
              this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, jt), n2 = e2.parse(t2[2], 2, Tt2);
              if (!r2 || !n2) return null;
              if (!Wt2(r2.type, [Xt2(jt), Ft2, jt])) return e2.error(`Expected first argument to be of type array or string, but found ${Ht2(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, Tt2);
                return i2 ? new nr(r2.type, r2, n2, i2) : null;
              }
              return new nr(r2.type, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
              let n2;
              if (this.endIndex && (n2 = this.endIndex.evaluate(t2)), Qt2(e2, ["string"])) return [...e2].slice(r2, n2).join("");
              if (Qt2(e2, ["array"])) return e2.slice(r2, n2);
              throw new Ee2(`Expected first argument to be of type array or string, but found ${Ht2(je2(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
          }
          function ir(t2, e2) {
            const r2 = t2.length - 1;
            let n2, i2, s2 = 0, a2 = r2, o2 = 0;
            for (; s2 <= a2; ) if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
              if (o2 === r2 || e2 < i2) return o2;
              s2 = o2 + 1;
            } else {
              if (!(n2 > e2)) throw new Ee2("Input is not a number.");
              a2 = o2 - 1;
            }
            return 0;
          }
          class sr {
            constructor(t2, e2, r2) {
              this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of r2) this.labels.push(t3), this.outputs.push(e3);
            }
            static parse(t2, e2) {
              if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
              const r2 = e2.parse(t2[1], 1, Tt2);
              if (!r2) return null;
              const n2 = [];
              let i2 = null;
              e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
              for (let r3 = 1; r3 < t2.length; r3 += 2) {
                const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
                if ("number" != typeof s2) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n2.length && n2[n2.length - 1][0] >= s2) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e2.parse(a2, l2, i2);
                if (!u2) return null;
                i2 = i2 || u2.type, n2.push([s2, u2]);
              }
              return new sr(i2, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length) return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0]) return r2[0].evaluate(t2);
              const i2 = e2.length;
              return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[ir(e2, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs) t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
          }
          function ar(t2) {
            return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
          }
          var or, lr, ur2 = function() {
            if (lr) return or;
            function t2(t3, e2, r2, n2) {
              this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
            }
            return lr = 1, or = t2, t2.prototype = { sampleCurveX: function(t3) {
              return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
            }, sampleCurveY: function(t3) {
              return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
            }, sampleCurveDerivativeX: function(t3) {
              return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
            }, solveCurveX: function(t3, e2) {
              if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
              if (t3 > 1) return 1;
              for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
                var i2 = this.sampleCurveX(r2) - t3;
                if (Math.abs(i2) < e2) return r2;
                var s2 = this.sampleCurveDerivativeX(r2);
                if (Math.abs(s2) < 1e-6) break;
                r2 -= i2 / s2;
              }
              var a2 = 0, o2 = 1;
              for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++) t3 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
              return r2;
            }, solve: function(t3, e2) {
              return this.sampleCurveY(this.solveCurveX(t3, e2));
            } }, or;
          }(), cr2 = ar(ur2);
          class hr2 {
            constructor(t2, e2, r2, n2, i2) {
              this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of i2) this.labels.push(t3), this.outputs.push(e3);
            }
            static interpolationFactor(t2, e2, r2, n2) {
              let i2 = 0;
              if ("exponential" === t2.name) i2 = pr2(e2, t2.base, r2, n2);
              else if ("linear" === t2.name) i2 = pr2(e2, 1, r2, n2);
              else if ("cubic-bezier" === t2.name) {
                const s2 = t2.controlPoints;
                i2 = new cr2(s2[0], s2[1], s2[2], s2[3]).solve(pr2(e2, 1, r2, n2));
              }
              return i2;
            }
            static parse(t2, e2) {
              let [r2, n2, i2, ...s2] = t2;
              if (!Array.isArray(n2) || 0 === n2.length) return e2.error("Expected an interpolation type expression.", 1);
              if ("linear" === n2[0]) n2 = { name: "linear" };
              else if ("exponential" === n2[0]) {
                const t3 = n2[1];
                if ("number" != typeof t3) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if ("cubic-bezier" !== n2[0]) return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
              if (i2 = e2.parse(i2, 2, Tt2), !i2) return null;
              const a2 = [];
              let o2 = null;
              "interpolate-hcl" !== r2 && "interpolate-lab" !== r2 || e2.expectedType == qt2 ? e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType) : o2 = Lt2;
              for (let t3 = 0; t3 < s2.length; t3 += 2) {
                const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if ("number" != typeof r3) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (a2.length && a2[a2.length - 1][0] >= r3) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u2 = e2.parse(n3, l2, o2);
                if (!u2) return null;
                o2 = o2 || u2.type, a2.push([r3, u2]);
              }
              return te2(o2, Tt2) || te2(o2, Ot2) || te2(o2, Lt2) || te2(o2, Ut2) || te2(o2, Gt2) || te2(o2, qt2) || te2(o2, Kt2) || te2(o2, Xt2(Tt2)) ? new hr2(o2, r2, n2, i2, a2) : e2.error(`Type ${Ht2(o2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length) return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0]) return r2[0].evaluate(t2);
              const i2 = e2.length;
              if (n2 >= e2[i2 - 1]) return r2[i2 - 1].evaluate(t2);
              const s2 = ir(e2, n2), a2 = hr2.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
              switch (this.operator) {
                case "interpolate":
                  switch (this.type.kind) {
                    case "number":
                      return Ae2(o2, l2, a2);
                    case "color":
                      return ke2.interpolate(o2, l2, a2);
                    case "padding":
                      return Ce2.interpolate(o2, l2, a2);
                    case "colorArray":
                      return Ve2.interpolate(o2, l2, a2);
                    case "numberArray":
                      return Be2.interpolate(o2, l2, a2);
                    case "variableAnchorOffsetCollection":
                      return Fe2.interpolate(o2, l2, a2);
                    case "array":
                      return Se(o2, l2, a2);
                    case "projectionDefinition":
                      return Le2.interpolate(o2, l2, a2);
                  }
                case "interpolate-hcl":
                  switch (this.type.kind) {
                    case "color":
                      return ke2.interpolate(o2, l2, a2, "hcl");
                    case "colorArray":
                      return Ve2.interpolate(o2, l2, a2, "hcl");
                  }
                case "interpolate-lab":
                  switch (this.type.kind) {
                    case "color":
                      return ke2.interpolate(o2, l2, a2, "lab");
                    case "colorArray":
                      return Ve2.interpolate(o2, l2, a2, "lab");
                  }
              }
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs) t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
          }
          function pr2(t2, e2, r2, n2) {
            const i2 = n2 - r2, s2 = t2 - r2;
            return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
          }
          const fr2 = { color: ke2.interpolate, number: Ae2, padding: Ce2.interpolate, numberArray: Be2.interpolate, colorArray: Ve2.interpolate, variableAnchorOffsetCollection: Fe2.interpolate, array: Se };
          class dr2 {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              let r2 = null;
              const n2 = e2.expectedType;
              n2 && "value" !== n2.kind && (r2 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t3) return null;
                r2 = r2 || t3.type, i2.push(t3);
              }
              if (!r2) throw new Error("No output type");
              const s2 = n2 && i2.some((t3) => Jt2(n2, t3.type));
              return new dr2(s2 ? jt : r2, i2);
            }
            evaluate(t2) {
              let e2, r2 = null, n2 = 0;
              for (const i2 of this.args) if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof $e2 && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2) break;
              return r2;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
          }
          function yr2(t2, e2) {
            return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
          }
          function mr2(t2, e2, r2, n2) {
            return 0 === n2.compare(e2, r2);
          }
          function gr2(t2, e2, r2) {
            const n2 = "==" !== t2 && "!=" !== t2;
            return class i2 {
              constructor(t3, e3, r3) {
                this.type = $t, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
              }
              static parse(t3, e3) {
                if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
                const r3 = t3[0];
                let s2 = e3.parse(t3[1], 1, jt);
                if (!s2) return null;
                if (!yr2(r3, s2.type)) return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Ht2(s2.type)}'.`);
                let a2 = e3.parse(t3[2], 2, jt);
                if (!a2) return null;
                if (!yr2(r3, a2.type)) return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Ht2(a2.type)}'.`);
                if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error(`Cannot compare types '${Ht2(s2.type)}' and '${Ht2(a2.type)}'.`);
                n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new qe(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new qe(s2.type, [a2])));
                let o2 = null;
                if (4 === t3.length) {
                  if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                  if (o2 = e3.parse(t3[3], 3, Rt2), !o2) return null;
                }
                return new i2(s2, a2, o2);
              }
              evaluate(i3) {
                const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e3 = je2(s2), r3 = je2(a2);
                  if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind) throw new Ee2(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = je2(s2), r3 = je2(a2);
                  if ("string" !== t3.kind || "string" !== r3.kind) return e2(i3, s2, a2);
                }
                return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
            };
          }
          const xr2 = gr2("==", function(t2, e2, r2) {
            return e2 === r2;
          }, mr2), vr2 = gr2("!=", function(t2, e2, r2) {
            return e2 !== r2;
          }, function(t2, e2, r2, n2) {
            return !mr2(0, e2, r2, n2);
          }), br2 = gr2("<", function(t2, e2, r2) {
            return e2 < r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) < 0;
          }), wr2 = gr2(">", function(t2, e2, r2) {
            return e2 > r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) > 0;
          }), _r2 = gr2("<=", function(t2, e2, r2) {
            return e2 <= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) <= 0;
          }), Ar2 = gr2(">=", function(t2, e2, r2) {
            return e2 >= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) >= 0;
          });
          class Sr2 {
            constructor(t2, e2, r2) {
              this.type = Rt2, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error("Expected one argument.");
              const r2 = t2[1];
              if ("object" != typeof r2 || Array.isArray(r2)) return e2.error("Collator options argument must be an object.");
              const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, $t);
              if (!n2) return null;
              const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, $t);
              if (!i2) return null;
              let s2 = null;
              return r2.locale && (s2 = e2.parse(r2.locale, 1, Ft2), !s2) ? null : new Sr2(n2, i2, s2);
            }
            evaluate(t2) {
              return new Me2(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
          }
          class kr2 {
            constructor(t2, e2, r2, n2, i2) {
              this.type = Ft2, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, Tt2);
              if (!r2) return null;
              const n2 = t2[2];
              if ("object" != typeof n2 || Array.isArray(n2)) return e2.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e2.parse(n2.locale, 1, Ft2), !i2)) return null;
              let s2 = null;
              if (n2.currency && (s2 = e2.parse(n2.currency, 1, Ft2), !s2)) return null;
              let a2 = null;
              if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, Tt2), !a2)) return null;
              let o2 = null;
              return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, Tt2), !o2) ? null : new kr2(r2, i2, s2, a2, o2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
          }
          class Mr2 {
            constructor(t2) {
              this.type = Nt2, this.sections = t2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              const r2 = t2[1];
              if (!Array.isArray(r2) && "object" == typeof r2) return e2.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
                const s2 = t2[r3];
                if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                  i2 = false;
                  let t3 = null;
                  if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, Tt2), !t3)) return null;
                  let r4 = null;
                  if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, Xt2(Ft2)), !r4)) return null;
                  let a2 = null;
                  if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, Lt2), !a2)) return null;
                  let o2 = null;
                  if (s2["vertical-align"]) {
                    if ("string" == typeof s2["vertical-align"] && !Ie.includes(s2["vertical-align"])) return e2.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s2["vertical-align"]}' instead.`);
                    if (o2 = e2.parse(s2["vertical-align"], 1, Ft2), !o2) return null;
                  }
                  const l2 = n2[n2.length - 1];
                  l2.scale = t3, l2.font = r4, l2.textColor = a2, l2.verticalAlign = o2;
                } else {
                  const s3 = e2.parse(t2[r3], 1, jt);
                  if (!s3) return null;
                  const a2 = s3.type.kind;
                  if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null, verticalAlign: null });
                }
              }
              return new Mr2(n2);
            }
            evaluate(t2) {
              return new Pe2(this.sections.map((e2) => {
                const r2 = e2.content.evaluate(t2);
                return je2(r2) === Zt2 ? new ze2("", r2, null, null, null, e2.verticalAlign ? e2.verticalAlign.evaluate(t2) : null) : new ze2(Re2(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null, e2.verticalAlign ? e2.verticalAlign.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e2 of this.sections) t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor), e2.verticalAlign && t2(e2.verticalAlign);
            }
            outputDefined() {
              return false;
            }
          }
          class Ir2 {
            constructor(t2) {
              this.type = Zt2, this.input = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, Ft2);
              return r2 ? new Ir2(r2) : e2.error("No image name provided.");
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = $e2.fromString(e2);
              return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class zr2 {
            constructor(t2) {
              this.type = Tt2, this.input = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1);
              return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${Ht2(r2.type)} instead.`) : new zr2(r2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              if ("string" == typeof e2) return [...e2].length;
              if (Array.isArray(e2)) return e2.length;
              throw new Ee2(`Expected value to be of type string or array, but found ${Ht2(je2(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          const Pr = 8192;
          function Cr2(t2, e2) {
            const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r2 * i2 * Pr), Math.round(n2 * i2 * Pr)];
          }
          function Br2(t2, e2) {
            const r2 = Math.pow(2, e2.z);
            return [(i2 = (t2[0] / Pr + e2.x) / r2, 360 * i2 - 180), (n2 = (t2[1] / Pr + e2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
            var n2, i2;
          }
          function Vr2(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function Er2(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function Tr2(t2, e2, r2) {
            const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
            return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
          }
          function Fr(t2, e2, r2, n2) {
            return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] && !(!Rr(t2, e2, r2, n2) || !Rr(r2, n2, t2, e2));
            var i2, s2;
          }
          function $r(t2, e2, r2) {
            for (const n2 of r2) for (let r3 = 0; r3 < n2.length - 1; ++r3) if (Fr(t2, e2, n2[r3], n2[r3 + 1])) return true;
            return false;
          }
          function Lr2(t2, e2, r2 = false) {
            let n2 = false;
            for (const o2 of e2) for (let e3 = 0; e3 < o2.length - 1; e3++) {
              if (Tr2(t2, o2[e3], o2[e3 + 1])) return r2;
              (s2 = o2[e3])[1] > (i2 = t2)[1] != (a2 = o2[e3 + 1])[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
            }
            var i2, s2, a2;
            return n2;
          }
          function Or(t2, e2) {
            for (const r2 of e2) if (Lr2(t2, r2)) return true;
            return false;
          }
          function Dr2(t2, e2) {
            for (const r2 of t2) if (!Lr2(r2, e2)) return false;
            for (let r2 = 0; r2 < t2.length - 1; ++r2) if ($r(t2[r2], t2[r2 + 1], e2)) return false;
            return true;
          }
          function jr2(t2, e2) {
            for (const r2 of e2) if (Dr2(t2, r2)) return true;
            return false;
          }
          function Rr(t2, e2, r2, n2) {
            const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
            return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
          }
          function Nr(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const a2 = Cr2(t2[i2][n3], r2);
                Vr2(e2, a2), s2.push(a2);
              }
              n2.push(s2);
            }
            return n2;
          }
          function Ur2(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = Nr(t2[i2], e2, r2);
              n2.push(s2);
            }
            return n2;
          }
          function qr2(t2, e2, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              const e3 = 0.5 * n2;
              let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
              0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
            }
            Vr2(e2, t2);
          }
          function Gr2(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * Pr, s2 = [n2.x * Pr, n2.y * Pr], a2 = [];
            for (const n3 of t2) for (const t3 of n3) {
              const n4 = [t3.x + s2[0], t3.y + s2[1]];
              qr2(n4, e2, r2, i2), a2.push(n4);
            }
            return a2;
          }
          function Zr2(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * Pr, s2 = [n2.x * Pr, n2.y * Pr], a2 = [];
            for (const r3 of t2) {
              const t3 = [];
              for (const n3 of r3) {
                const r4 = [n3.x + s2[0], n3.y + s2[1]];
                Vr2(e2, r4), t3.push(r4);
              }
              a2.push(t3);
            }
            if (e2[2] - e2[0] <= i2 / 2) {
              (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t3 of a2) for (const n3 of t3) qr2(n3, e2, r2, i2);
            }
            var o2;
            return a2;
          }
          class Kr2 {
            constructor(t2, e2) {
              this.type = $t, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (De(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type) {
                  const t3 = [];
                  for (const r2 of e3.features) {
                    const { type: e4, coordinates: n2 } = r2.geometry;
                    "Polygon" === e4 && t3.push(n2), "MultiPolygon" === e4 && t3.push(...n2);
                  }
                  if (t3.length) return new Kr2(e3, { type: "MultiPolygon", coordinates: t3 });
                } else if ("Feature" === e3.type) {
                  const t3 = e3.geometry.type;
                  if ("Polygon" === t3 || "MultiPolygon" === t3) return new Kr2(e3, e3.geometry);
                } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new Kr2(e3, e3);
              }
              return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (null != t2.geometry() && null != t2.canonicalID()) {
                if ("Point" === t2.geometryType()) return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e2.type) {
                    const s2 = Nr(e2.coordinates, n2, i2), a2 = Gr2(t3.geometry(), r2, n2, i2);
                    if (!Er2(r2, n2)) return false;
                    for (const t4 of a2) if (!Lr2(t4, s2)) return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s2 = Ur2(e2.coordinates, n2, i2), a2 = Gr2(t3.geometry(), r2, n2, i2);
                    if (!Er2(r2, n2)) return false;
                    for (const t4 of a2) if (!Or(t4, s2)) return false;
                  }
                  return true;
                }(t2, this.geometries);
                if ("LineString" === t2.geometryType()) return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e2.type) {
                    const s2 = Nr(e2.coordinates, n2, i2), a2 = Zr2(t3.geometry(), r2, n2, i2);
                    if (!Er2(r2, n2)) return false;
                    for (const t4 of a2) if (!Dr2(t4, s2)) return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s2 = Ur2(e2.coordinates, n2, i2), a2 = Zr2(t3.geometry(), r2, n2, i2);
                    if (!Er2(r2, n2)) return false;
                    for (const t4 of a2) if (!jr2(t4, s2)) return false;
                  }
                  return true;
                }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          let Xr2 = class {
            constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this._up(this.length++);
            }
            pop() {
              if (0 === this.length) return;
              const t2 = this.data[0], e2 = this.data.pop();
              return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r2 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r2(n2, s2) >= 0) break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1);
                const s2 = n3 + 1;
                if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
                e2[t2] = e2[n3], t2 = n3;
              }
              e2[t2] = i2;
            }
          };
          function Hr2(t2, e2, r2 = 0, n2 = t2.length - 1, i2 = Jr2) {
            for (; n2 > r2; ) {
              if (n2 - r2 > 600) {
                const s3 = n2 - r2 + 1, a3 = e2 - r2 + 1, o3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * o3 / 3), u2 = 0.5 * Math.sqrt(o3 * l2 * (s3 - l2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
                Hr2(t2, e2, Math.max(r2, Math.floor(e2 - a3 * l2 / s3 + u2)), Math.min(n2, Math.floor(e2 + (s3 - a3) * l2 / s3 + u2)), i2);
              }
              const s2 = t2[e2];
              let a2 = r2, o2 = n2;
              for (Yr2(t2, r2, e2), i2(t2[n2], s2) > 0 && Yr2(t2, r2, n2); a2 < o2; ) {
                for (Yr2(t2, a2, o2), a2++, o2--; i2(t2[a2], s2) < 0; ) a2++;
                for (; i2(t2[o2], s2) > 0; ) o2--;
              }
              0 === i2(t2[r2], s2) ? Yr2(t2, r2, o2) : (o2++, Yr2(t2, o2, n2)), o2 <= e2 && (r2 = o2 + 1), e2 <= o2 && (n2 = o2 - 1);
            }
          }
          function Yr2(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function Jr2(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function Wr2(t2, e2) {
            if (t2.length <= 1) return [t2];
            const r2 = [];
            let n2, i2;
            for (const e3 of t2) {
              const t3 = tn2(e3);
              0 !== t3 && (e3.area = Math.abs(t3), void 0 === i2 && (i2 = t3 < 0), i2 === t3 < 0 ? (n2 && r2.push(n2), n2 = [e3]) : n2.push(e3));
            }
            if (n2 && r2.push(n2), e2 > 1) for (let t3 = 0; t3 < r2.length; t3++) r2[t3].length <= e2 || (Hr2(r2[t3], e2, 1, r2[t3].length - 1, Qr2), r2[t3] = r2[t3].slice(0, e2));
            return r2;
          }
          function Qr2(t2, e2) {
            return e2.area - t2.area;
          }
          function tn2(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++) r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          const en2 = 1 / 298.257223563, rn2 = en2 * (2 - en2), nn2 = Math.PI / 180;
          class sn2 {
            constructor(t2) {
              const e2 = 6378.137 * nn2 * 1e3, r2 = Math.cos(t2 * nn2), n2 = 1 / (1 - rn2 * (1 - r2 * r2)), i2 = Math.sqrt(n2);
              this.kx = e2 * i2 * r2, this.ky = e2 * i2 * n2 * (1 - rn2);
            }
            distance(t2, e2) {
              const r2 = this.wrap(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
              return Math.sqrt(r2 * r2 + n2 * n2);
            }
            pointOnLine(t2, e2) {
              let r2, n2, i2, s2, a2 = 1 / 0;
              for (let o2 = 0; o2 < t2.length - 1; o2++) {
                let l2 = t2[o2][0], u2 = t2[o2][1], c2 = this.wrap(t2[o2 + 1][0] - l2) * this.kx, h3 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
                0 === c2 && 0 === h3 || (p2 = (this.wrap(e2[0] - l2) * this.kx * c2 + (e2[1] - u2) * this.ky * h3) / (c2 * c2 + h3 * h3), p2 > 1 ? (l2 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u2 += h3 / this.ky * p2)), c2 = this.wrap(e2[0] - l2) * this.kx, h3 = (e2[1] - u2) * this.ky;
                const f2 = c2 * c2 + h3 * h3;
                f2 < a2 && (a2 = f2, r2 = l2, n2 = u2, i2 = o2, s2 = p2);
              }
              return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
            }
            wrap(t2) {
              for (; t2 < -180; ) t2 += 360;
              for (; t2 > 180; ) t2 -= 360;
              return t2;
            }
          }
          function an2(t2, e2) {
            return e2[0] - t2[0];
          }
          function on2(t2) {
            return t2[1] - t2[0] + 1;
          }
          function ln2(t2, e2) {
            return t2[1] >= t2[0] && t2[1] < e2;
          }
          function un2(t2, e2) {
            if (t2[0] > t2[1]) return [null, null];
            const r2 = on2(t2);
            if (e2) {
              if (2 === r2) return [t2, null];
              const e3 = Math.floor(r2 / 2);
              return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
            }
            if (1 === r2) return [t2, null];
            const n2 = Math.floor(r2 / 2) - 1;
            return [[t2[0], t2[0] + n2], [t2[0] + n2 + 1, t2[1]]];
          }
          function cn2(t2, e2) {
            if (!ln2(e2, t2.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let n2 = e2[0]; n2 <= e2[1]; ++n2) Vr2(r2, t2[n2]);
            return r2;
          }
          function hn2(t2) {
            const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (const r2 of t2) for (const t3 of r2) Vr2(e2, t3);
            return e2;
          }
          function pn2(t2) {
            return t2[0] !== -1 / 0 && t2[1] !== -1 / 0 && t2[2] !== 1 / 0 && t2[3] !== 1 / 0;
          }
          function fn2(t2, e2, r2) {
            if (!pn2(t2) || !pn2(e2)) return NaN;
            let n2 = 0, i2 = 0;
            return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
          }
          function dn2(t2, e2, r2) {
            const n2 = r2.pointOnLine(e2, t2);
            return r2.distance(t2, n2.point);
          }
          function yn2(t2, e2, r2, n2, i2) {
            const s2 = Math.min(dn2(t2, [r2, n2], i2), dn2(e2, [r2, n2], i2)), a2 = Math.min(dn2(r2, [t2, e2], i2), dn2(n2, [t2, e2], i2));
            return Math.min(s2, a2);
          }
          function mn2(t2, e2, r2, n2, i2) {
            if (!ln2(e2, t2.length) || !ln2(n2, r2.length)) return 1 / 0;
            let s2 = 1 / 0;
            for (let a2 = e2[0]; a2 < e2[1]; ++a2) {
              const e3 = t2[a2], o2 = t2[a2 + 1];
              for (let t3 = n2[0]; t3 < n2[1]; ++t3) {
                const n3 = r2[t3], a3 = r2[t3 + 1];
                if (Fr(e3, o2, n3, a3)) return 0;
                s2 = Math.min(s2, yn2(e3, o2, n3, a3, i2));
              }
            }
            return s2;
          }
          function gn(t2, e2, r2, n2, i2) {
            if (!ln2(e2, t2.length) || !ln2(n2, r2.length)) return NaN;
            let s2 = 1 / 0;
            for (let a2 = e2[0]; a2 <= e2[1]; ++a2) for (let e3 = n2[0]; e3 <= n2[1]; ++e3) if (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])), 0 === s2) return s2;
            return s2;
          }
          function xn2(t2, e2, r2) {
            if (Lr2(t2, e2, true)) return 0;
            let n2 = 1 / 0;
            for (const i2 of e2) {
              const e3 = i2[0], s2 = i2[i2.length - 1];
              if (e3 !== s2 && (n2 = Math.min(n2, dn2(t2, [s2, e3], r2)), 0 === n2)) return n2;
              const a2 = r2.pointOnLine(i2, t2);
              if (n2 = Math.min(n2, r2.distance(t2, a2.point)), 0 === n2) return n2;
            }
            return n2;
          }
          function vn(t2, e2, r2, n2) {
            if (!ln2(e2, t2.length)) return NaN;
            for (let n3 = e2[0]; n3 <= e2[1]; ++n3) if (Lr2(t2[n3], r2, true)) return 0;
            let i2 = 1 / 0;
            for (let s2 = e2[0]; s2 < e2[1]; ++s2) {
              const e3 = t2[s2], a2 = t2[s2 + 1];
              for (const t3 of r2) for (let r3 = 0, s3 = t3.length, o2 = s3 - 1; r3 < s3; o2 = r3++) {
                const s4 = t3[o2], l2 = t3[r3];
                if (Fr(e3, a2, s4, l2)) return 0;
                i2 = Math.min(i2, yn2(e3, a2, s4, l2, n2));
              }
            }
            return i2;
          }
          function bn(t2, e2) {
            for (const r2 of t2) for (const t3 of r2) if (Lr2(t3, e2, true)) return true;
            return false;
          }
          function wn(t2, e2, r2, n2 = 1 / 0) {
            const i2 = hn2(t2), s2 = hn2(e2);
            if (n2 !== 1 / 0 && fn2(i2, s2, r2) >= n2) return n2;
            if (Er2(i2, s2)) {
              if (bn(t2, e2)) return 0;
            } else if (bn(e2, t2)) return 0;
            let a2 = 1 / 0;
            for (const n3 of t2) for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++) {
              const i4 = n3[s3], o2 = n3[t3];
              for (const t4 of e2) for (let e3 = 0, n4 = t4.length, s4 = n4 - 1; e3 < n4; s4 = e3++) {
                const n5 = t4[s4], l2 = t4[e3];
                if (Fr(i4, o2, n5, l2)) return 0;
                a2 = Math.min(a2, yn2(i4, o2, n5, l2, r2));
              }
            }
            return a2;
          }
          function _n2(t2, e2, r2, n2, i2, s2) {
            if (!s2) return;
            const a2 = fn2(cn2(n2, s2), i2, r2);
            a2 < e2 && t2.push([a2, s2, [0, 0]]);
          }
          function An2(t2, e2, r2, n2, i2, s2, a2) {
            if (!s2 || !a2) return;
            const o2 = fn2(cn2(n2, s2), cn2(i2, a2), r2);
            o2 < e2 && t2.push([o2, s2, a2]);
          }
          function Sn(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
            if (0 === s2) return s2;
            const a2 = new Xr2([[0, [0, t2.length - 1], [0, 0]]], an2), o2 = hn2(r2);
            for (; a2.length > 0; ) {
              const i3 = a2.pop();
              if (i3[0] >= s2) continue;
              const l2 = i3[1], u2 = e2 ? 50 : 100;
              if (on2(l2) <= u2) {
                if (!ln2(l2, t2.length)) return NaN;
                if (e2) {
                  const e3 = vn(t2, l2, r2, n2);
                  if (isNaN(e3) || 0 === e3) return e3;
                  s2 = Math.min(s2, e3);
                } else for (let e3 = l2[0]; e3 <= l2[1]; ++e3) {
                  const i4 = xn2(t2[e3], r2, n2);
                  if (s2 = Math.min(s2, i4), 0 === s2) return 0;
                }
              } else {
                const r3 = un2(l2, e2);
                _n2(a2, s2, n2, t2, o2, r3[0]), _n2(a2, s2, n2, t2, o2, r3[1]);
              }
            }
            return s2;
          }
          function kn(t2, e2, r2, n2, i2, s2 = 1 / 0) {
            let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
            if (0 === a2) return a2;
            const o2 = new Xr2([[0, [0, t2.length - 1], [0, r2.length - 1]]], an2);
            for (; o2.length > 0; ) {
              const s3 = o2.pop();
              if (s3[0] >= a2) continue;
              const l2 = s3[1], u2 = s3[2], c2 = e2 ? 50 : 100, h3 = n2 ? 50 : 100;
              if (on2(l2) <= c2 && on2(u2) <= h3) {
                if (!ln2(l2, t2.length) && ln2(u2, r2.length)) return NaN;
                let s4;
                if (e2 && n2) s4 = mn2(t2, l2, r2, u2, i2), a2 = Math.min(a2, s4);
                else if (e2 && !n2) {
                  const e3 = t2.slice(l2[0], l2[1] + 1);
                  for (let t3 = u2[0]; t3 <= u2[1]; ++t3) if (s4 = dn2(r2[t3], e3, i2), a2 = Math.min(a2, s4), 0 === a2) return a2;
                } else if (!e2 && n2) {
                  const e3 = r2.slice(u2[0], u2[1] + 1);
                  for (let r3 = l2[0]; r3 <= l2[1]; ++r3) if (s4 = dn2(t2[r3], e3, i2), a2 = Math.min(a2, s4), 0 === a2) return a2;
                } else s4 = gn(t2, l2, r2, u2, i2), a2 = Math.min(a2, s4);
              } else {
                const s4 = un2(l2, e2), c3 = un2(u2, n2);
                An2(o2, a2, i2, t2, r2, s4[0], c3[0]), An2(o2, a2, i2, t2, r2, s4[0], c3[1]), An2(o2, a2, i2, t2, r2, s4[1], c3[0]), An2(o2, a2, i2, t2, r2, s4[1], c3[1]);
              }
            }
            return a2;
          }
          function Mn2(t2) {
            return "MultiPolygon" === t2.type ? t2.coordinates.map((t3) => ({ type: "Polygon", coordinates: t3 })) : "MultiLineString" === t2.type ? t2.coordinates.map((t3) => ({ type: "LineString", coordinates: t3 })) : "MultiPoint" === t2.type ? t2.coordinates.map((t3) => ({ type: "Point", coordinates: t3 })) : [t2];
          }
          class In2 {
            constructor(t2, e2) {
              this.type = Tt2, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`'distance' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (De(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type) return new In2(e3, e3.features.map((t3) => Mn2(t3.geometry)).flat());
                if ("Feature" === e3.type) return new In2(e3, Mn2(e3.geometry));
                if ("type" in e3 && "coordinates" in e3) return new In2(e3, Mn2(e3));
              }
              return e2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (null != t2.geometry() && null != t2.canonicalID()) {
                if ("Point" === t2.geometryType()) return function(t3, e2) {
                  const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Br2([e3.x, e3.y], t3.canonical));
                  if (0 === r2.length) return NaN;
                  const i2 = new sn2(n2[0][1]);
                  let s2 = 1 / 0;
                  for (const t4 of e2) {
                    switch (t4.type) {
                      case "Point":
                        s2 = Math.min(s2, kn(n2, false, [t4.coordinates], false, i2, s2));
                        break;
                      case "LineString":
                        s2 = Math.min(s2, kn(n2, false, t4.coordinates, true, i2, s2));
                        break;
                      case "Polygon":
                        s2 = Math.min(s2, Sn(n2, false, t4.coordinates, i2, s2));
                    }
                    if (0 === s2) return s2;
                  }
                  return s2;
                }(t2, this.geometries);
                if ("LineString" === t2.geometryType()) return function(t3, e2) {
                  const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Br2([e3.x, e3.y], t3.canonical));
                  if (0 === r2.length) return NaN;
                  const i2 = new sn2(n2[0][1]);
                  let s2 = 1 / 0;
                  for (const t4 of e2) {
                    switch (t4.type) {
                      case "Point":
                        s2 = Math.min(s2, kn(n2, true, [t4.coordinates], false, i2, s2));
                        break;
                      case "LineString":
                        s2 = Math.min(s2, kn(n2, true, t4.coordinates, true, i2, s2));
                        break;
                      case "Polygon":
                        s2 = Math.min(s2, Sn(n2, true, t4.coordinates, i2, s2));
                    }
                    if (0 === s2) return s2;
                  }
                  return s2;
                }(t2, this.geometries);
                if ("Polygon" === t2.geometryType()) return function(t3, e2) {
                  const r2 = t3.geometry();
                  if (0 === r2.length || 0 === r2[0].length) return NaN;
                  const n2 = Wr2(r2, 0).map((e3) => e3.map((e4) => e4.map((e5) => Br2([e5.x, e5.y], t3.canonical)))), i2 = new sn2(n2[0][0][0][1]);
                  let s2 = 1 / 0;
                  for (const t4 of e2) for (const e3 of n2) {
                    switch (t4.type) {
                      case "Point":
                        s2 = Math.min(s2, Sn([t4.coordinates], false, e3, i2, s2));
                        break;
                      case "LineString":
                        s2 = Math.min(s2, Sn(t4.coordinates, true, e3, i2, s2));
                        break;
                      case "Polygon":
                        s2 = Math.min(s2, wn(e3, t4.coordinates, i2, s2));
                    }
                    if (0 === s2) return s2;
                  }
                  return s2;
                }(t2, this.geometries);
              }
              return NaN;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          class zn2 {
            constructor(t2) {
              this.type = jt, this.key = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = t2[1];
              return null == r2 ? e2.error("Global state property must be defined.") : "string" != typeof r2 ? e2.error(`Global state property must be string, but found ${typeof t2[1]} instead.`) : new zn2(r2);
            }
            evaluate(t2) {
              var e2;
              const r2 = null === (e2 = t2.globals) || void 0 === e2 ? void 0 : e2.globalState;
              return r2 && 0 !== Object.keys(r2).length ? ge2(r2, this.key) : null;
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
          }
          const Pn2 = { "==": xr2, "!=": vr2, ">": wr2, "<": br2, ">=": Ar2, "<=": _r2, array: qe, at: We2, boolean: qe, case: rr2, coalesce: dr2, collator: Sr2, format: Mr2, image: Ir2, in: Qe2, "index-of": tr2, interpolate: hr2, "interpolate-hcl": hr2, "interpolate-lab": hr2, length: zr2, let: Ye2, literal: Ne2, match: er2, number: qe, "number-format": kr2, object: qe, slice: nr, step: sr, string: qe, "to-boolean": Ze2, "to-color": Ze2, "to-number": Ze2, "to-string": Ze2, var: Je2, within: Kr2, distance: In2, "global-state": zn2 };
          class Cn2 {
            constructor(t2, e2, r2, n2) {
              this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
            }
            evaluate(t2) {
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            static parse(t2, e2) {
              const r2 = t2[0], n2 = Cn2.definitions[r2];
              if (!n2) return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
              let o2 = null;
              for (const [n3, s3] of a2) {
                o2 = new He2(e2.registry, Fn2, e2.path, null, e2.scope);
                const a3 = [];
                let l2 = false;
                for (let e3 = 1; e3 < t2.length; e3++) {
                  const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
                  if (!s4) {
                    l2 = true;
                    break;
                  }
                  a3.push(s4);
                }
                if (!l2) if (Array.isArray(n3) && n3.length !== a3.length) o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
                else {
                  for (let t3 = 0; t3 < a3.length; t3++) {
                    const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                    o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                  }
                  if (0 === o2.errors.length) return new Cn2(r2, i2, s3, a3);
                }
              }
              if (1 === a2.length) e2.errors.push(...o2.errors);
              else {
                const r3 = (a2.length ? a2 : s2).map(([t3]) => {
                  return e3 = t3, Array.isArray(e3) ? `(${e3.map(Ht2).join(", ")})` : `(${Ht2(e3.type)}...)`;
                  var e3;
                }).join(" | "), n3 = [];
                for (let r4 = 1; r4 < t2.length; r4++) {
                  const i3 = e2.parse(t2[r4], 1 + n3.length);
                  if (!i3) return null;
                  n3.push(Ht2(i3.type));
                }
                e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e2) {
              Cn2.definitions = e2;
              for (const r2 in e2) t2[r2] = Cn2;
            }
          }
          function Bn2(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, a2 = Oe2(e2, r2, n2, s2);
            if (a2) throw new Ee2(a2);
            return new ke2(e2 / 255, r2 / 255, n2 / 255, s2, false);
          }
          function Vn2(t2, e2) {
            return t2 in e2;
          }
          function En2(t2, e2) {
            const r2 = e2[t2];
            return void 0 === r2 ? null : r2;
          }
          function Tn2(t2) {
            return { type: t2 };
          }
          function Fn2(t2) {
            if (t2 instanceof Je2) return Fn2(t2.boundExpression);
            if (t2 instanceof Cn2 && "error" === t2.name) return false;
            if (t2 instanceof Sr2) return false;
            if (t2 instanceof Kr2) return false;
            if (t2 instanceof In2) return false;
            if (t2 instanceof zn2) return false;
            const e2 = t2 instanceof Ze2 || t2 instanceof qe;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 = e2 ? r2 && Fn2(t3) : r2 && t3 instanceof Ne2;
            }), !!r2 && $n2(t2) && On2(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
          }
          function $n2(t2) {
            if (t2 instanceof Cn2) {
              if ("get" === t2.name && 1 === t2.args.length) return false;
              if ("feature-state" === t2.name) return false;
              if ("has" === t2.name && 1 === t2.args.length) return false;
              if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name) return false;
              if (/^filter-/.test(t2.name)) return false;
            }
            if (t2 instanceof Kr2) return false;
            if (t2 instanceof In2) return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !$n2(t3) && (e2 = false);
            }), e2;
          }
          function Ln2(t2) {
            if (t2 instanceof Cn2 && "feature-state" === t2.name) return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !Ln2(t3) && (e2 = false);
            }), e2;
          }
          function On2(t2, e2) {
            if (t2 instanceof Cn2 && e2.indexOf(t2.name) >= 0) return false;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 && !On2(t3, e2) && (r2 = false);
            }), r2;
          }
          function Dn2(t2) {
            return { result: "success", value: t2 };
          }
          function jn(t2) {
            return { result: "error", value: t2 };
          }
          function Rn2(t2) {
            return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
          }
          function Nn2(t2) {
            return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
          }
          function Un2(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function qn2(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
          }
          function Gn2(t2) {
            return "object" == typeof t2 && null !== t2 && !Array.isArray(t2) && je2(t2) === Dt2;
          }
          function Zn2(t2) {
            return t2;
          }
          function Kn2(t2, e2) {
            const r2 = t2.stops && "object" == typeof t2.stops[0][0], n2 = r2 || !(r2 || void 0 !== t2.property), i2 = t2.type || (Un2(e2) ? "exponential" : "interval"), s2 = function(t3) {
              switch (t3.type) {
                case "color":
                  return ke2.parse;
                case "padding":
                  return Ce2.parse;
                case "numberArray":
                  return Be2.parse;
                case "colorArray":
                  return Ve2.parse;
                default:
                  return null;
              }
            }(e2);
            if (s2 && ((t2 = Ct2({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], s2(t3[1])])), t2.default = s2(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== (a2 = t2.colorSpace) && "hcl" !== a2 && "lab" !== a2) throw new Error(`Unknown color space: "${t2.colorSpace}"`);
            var a2;
            const o2 = function(t3) {
              switch (t3) {
                case "exponential":
                  return Jn2;
                case "interval":
                  return Yn2;
                case "categorical":
                  return Hn2;
                case "identity":
                  return Wn2;
                default:
                  throw new Error(`Unknown function type "${t3}"`);
              }
            }(i2);
            let l2, u2;
            if ("categorical" === i2) {
              l2 = /* @__PURE__ */ Object.create(null);
              for (const e3 of t2.stops) l2[e3[0]] = e3[1];
              u2 = typeof t2.stops[0][0];
            }
            if (r2) {
              const r3 = {}, n3 = [];
              for (let e3 = 0; e3 < t2.stops.length; e3++) {
                const i4 = t2.stops[e3], s4 = i4[0].zoom;
                void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3) i3.push([r3[t3].zoom, Kn2(r3[t3], e2)]);
              const s3 = { name: "linear" };
              return { kind: "composite", interpolationType: s3, interpolationFactor: hr2.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Jn2({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
            }
            if (n2) {
              const r3 = "exponential" === i2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: hr2.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l2, u2) };
            }
            return { kind: "source", evaluate(r3, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return void 0 === i3 ? Xn2(t2.default, e2.default) : o2(t2, e2, i3, l2, u2);
            } };
          }
          function Xn2(t2, e2, r2) {
            return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
          }
          function Hn2(t2, e2, r2, n2, i2) {
            return Xn2(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
          }
          function Yn2(t2, e2, r2) {
            if ("number" !== qn2(r2)) return Xn2(t2.default, e2.default);
            const n2 = t2.stops.length;
            if (1 === n2) return t2.stops[0][1];
            if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0]) return t2.stops[n2 - 1][1];
            const i2 = ir(t2.stops.map((t3) => t3[0]), r2);
            return t2.stops[i2][1];
          }
          function Jn2(t2, e2, r2) {
            const n2 = void 0 !== t2.base ? t2.base : 1;
            if ("number" !== qn2(r2)) return Xn2(t2.default, e2.default);
            const i2 = t2.stops.length;
            if (1 === i2) return t2.stops[0][1];
            if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0]) return t2.stops[i2 - 1][1];
            const s2 = ir(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
              const i3 = n3 - r3, s3 = t3 - r3;
              return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
            }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1], u2 = fr2[e2.type] || Zn2;
            return "function" == typeof o2.evaluate ? { evaluate(...e3) {
              const r3 = o2.evaluate.apply(void 0, e3), n3 = l2.evaluate.apply(void 0, e3);
              if (void 0 !== r3 && void 0 !== n3) return u2(r3, n3, a2, t2.colorSpace);
            } } : u2(o2, l2, a2, t2.colorSpace);
          }
          function Wn2(t2, e2, r2) {
            switch (e2.type) {
              case "color":
                r2 = ke2.parse(r2);
                break;
              case "formatted":
                r2 = Pe2.fromString(r2.toString());
                break;
              case "resolvedImage":
                r2 = $e2.fromString(r2.toString());
                break;
              case "padding":
                r2 = Ce2.parse(r2);
                break;
              case "colorArray":
                r2 = Ve2.parse(r2);
                break;
              case "numberArray":
                r2 = Be2.parse(r2);
                break;
              default:
                qn2(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0);
            }
            return Xn2(r2, t2.default, e2.default);
          }
          Cn2.register(Pn2, { error: [{ kind: "error" }, [Ft2], (t2, [e2]) => {
            throw new Ee2(e2.evaluate(t2));
          }], typeof: [Ft2, [jt], (t2, [e2]) => Ht2(je2(e2.evaluate(t2)))], "to-rgba": [Xt2(Tt2, 4), [Lt2], (t2, [e2]) => {
            const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
            return [255 * r2, 255 * n2, 255 * i2, s2];
          }], rgb: [Lt2, [Tt2, Tt2, Tt2], Bn2], rgba: [Lt2, [Tt2, Tt2, Tt2, Tt2], Bn2], has: { type: $t, overloads: [[[Ft2], (t2, [e2]) => Vn2(e2.evaluate(t2), t2.properties())], [[Ft2, Dt2], (t2, [e2, r2]) => Vn2(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: jt, overloads: [[[Ft2], (t2, [e2]) => En2(e2.evaluate(t2), t2.properties())], [[Ft2, Dt2], (t2, [e2, r2]) => En2(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [jt, [Ft2], (t2, [e2]) => En2(e2.evaluate(t2), t2.featureState || {})], properties: [Dt2, [], (t2) => t2.properties()], "geometry-type": [Ft2, [], (t2) => t2.geometryType()], id: [jt, [], (t2) => t2.id()], zoom: [Tt2, [], (t2) => t2.globals.zoom], "heatmap-density": [Tt2, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [Tt2, [], (t2) => t2.globals.lineProgress || 0], accumulated: [jt, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [Tt2, Tn2(Tt2), (t2, e2) => {
            let r2 = 0;
            for (const n2 of e2) r2 += n2.evaluate(t2);
            return r2;
          }], "*": [Tt2, Tn2(Tt2), (t2, e2) => {
            let r2 = 1;
            for (const n2 of e2) r2 *= n2.evaluate(t2);
            return r2;
          }], "-": { type: Tt2, overloads: [[[Tt2, Tt2], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[Tt2], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [Tt2, [Tt2, Tt2], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [Tt2, [Tt2, Tt2], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [Tt2, [], () => Math.LN2], pi: [Tt2, [], () => Math.PI], e: [Tt2, [], () => Math.E], "^": [Tt2, [Tt2, Tt2], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [Tt2, [Tt2], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [Tt2, [Tt2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [Tt2, [Tt2], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [Tt2, [Tt2], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [Tt2, [Tt2], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [Tt2, [Tt2], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [Tt2, [Tt2], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [Tt2, [Tt2], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [Tt2, [Tt2], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [Tt2, [Tt2], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [Tt2, Tn2(Tt2), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [Tt2, Tn2(Tt2), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [Tt2, [Tt2], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [Tt2, [Tt2], (t2, [e2]) => {
            const r2 = e2.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [Tt2, [Tt2], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [Tt2, [Tt2], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [$t, [Ft2, jt], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [$t, [jt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [$t, [Ft2], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [$t, [Ft2, jt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [$t, [jt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }], "filter->": [$t, [Ft2, jt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [$t, [jt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }], "filter-<=": [$t, [Ft2, jt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [$t, [jt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }], "filter->=": [$t, [Ft2, jt], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [$t, [jt], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }], "filter-has": [$t, [jt], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [$t, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [$t, [Xt2(Ft2)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [$t, [Xt2(jt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [$t, [Ft2, Xt2(jt)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [$t, [Ft2, Xt2(jt)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
            for (; r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e3[i2] === t3) return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: $t, overloads: [[[$t, $t], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Tn2($t), (t2, e2) => {
            for (const r2 of e2) if (!r2.evaluate(t2)) return false;
            return true;
          }]] }, any: { type: $t, overloads: [[[$t, $t], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Tn2($t), (t2, e2) => {
            for (const r2 of e2) if (r2.evaluate(t2)) return true;
            return false;
          }]] }, "!": [$t, [$t], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [$t, [Ft2], (t2, [e2]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2.evaluate(t2));
          }], upcase: [Ft2, [Ft2], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [Ft2, [Ft2], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [Ft2, Tn2(jt), (t2, e2) => e2.map((e3) => Re2(e3.evaluate(t2))).join("")], "resolved-locale": [Ft2, [Rt2], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
          class Qn2 {
            constructor(t2, e2) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new Xe2(), this._defaultValue = e2 ? function(t3) {
                if ("color" === t3.type && Gn2(t3.default)) return new ke2(0, 0, 0, 0);
                switch (t3.type) {
                  case "color":
                    return ke2.parse(t3.default) || null;
                  case "padding":
                    return Ce2.parse(t3.default) || null;
                  case "numberArray":
                    return Be2.parse(t3.default) || null;
                  case "colorArray":
                    return Ve2.parse(t3.default) || null;
                  case "variableAnchorOffsetCollection":
                    return Fe2.parse(t3.default) || null;
                  case "projectionDefinition":
                    return Le2.parse(t3.default) || null;
                  default:
                    return void 0 === t3.default ? null : t3.default;
                }
              }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues)) throw new Ee2(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
              }
            }
          }
          function ti2(t2) {
            return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Pn2;
          }
          function ei2(t2, e2) {
            const r2 = new He2(Pn2, Fn2, [], e2 ? function(t3) {
              const e3 = { color: Lt2, string: Ft2, number: Tt2, enum: Ft2, boolean: $t, formatted: Nt2, padding: Ut2, numberArray: Gt2, colorArray: qt2, projectionDefinition: Ot2, resolvedImage: Zt2, variableAnchorOffsetCollection: Kt2 };
              return "array" === t3.type ? Xt2(e3[t3.value] || jt, t3.length) : e3[t3.type];
            }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
            return n2 ? Dn2(new Qn2(n2, e2)) : jn(r2.errors);
          }
          class ri2 {
            constructor(t2, e2) {
              this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !Ln2(e2.expression);
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
          }
          class ni2 {
            constructor(t2, e2, r2, n2) {
              this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !Ln2(e2.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
            interpolationFactor(t2, e2, r2) {
              return this.interpolationType ? hr2.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
            }
          }
          function ii2(t2, e2) {
            const r2 = ei2(t2, e2);
            if ("error" === r2.result) return r2;
            const n2 = r2.value.expression, i2 = $n2(n2);
            if (!i2 && !Rn2(e2)) return jn([new Bt2("", "data expressions not supported")]);
            const s2 = On2(n2, ["zoom"]);
            if (!s2 && !Nn2(e2)) return jn([new Bt2("", "zoom expressions not supported")]);
            const a2 = ai2(n2);
            return a2 || s2 ? a2 instanceof Bt2 ? jn([a2]) : a2 instanceof hr2 && !Un2(e2) ? jn([new Bt2("", '"interpolate" expressions cannot be used with this property')]) : Dn2(a2 ? new ni2(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof hr2 ? a2.interpolation : void 0) : new ri2(i2 ? "constant" : "source", r2.value)) : jn([new Bt2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class si2 {
            constructor(t2, e2) {
              this._parameters = t2, this._specification = e2, Ct2(this, Kn2(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new si2(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function ai2(t2) {
            let e2 = null;
            if (t2 instanceof Ye2) e2 = ai2(t2.result);
            else if (t2 instanceof dr2) {
              for (const r2 of t2.args) if (e2 = ai2(r2), e2) break;
            } else (t2 instanceof sr || t2 instanceof hr2) && t2.input instanceof Cn2 && "zoom" === t2.input.name && (e2 = t2);
            return e2 instanceof Bt2 || t2.eachChild((t3) => {
              const r2 = ai2(t3);
              r2 instanceof Bt2 ? e2 = r2 : !e2 && r2 ? e2 = new Bt2("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new Bt2("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e2;
          }
          function oi2(t2) {
            if (true === t2 || false === t2) return true;
            if (!Array.isArray(t2) || 0 === t2.length) return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
              case "in":
                return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e2 of t2.slice(1)) if (!oi2(e2) && "boolean" != typeof e2) return false;
                return true;
              default:
                return true;
            }
          }
          const li2 = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function ui2(t2) {
            if (null == t2) return { filter: () => true, needGeometry: false };
            oi2(t2) || (t2 = pi2(t2));
            const e2 = ei2(t2, li2);
            if ("error" === e2.result) throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
            return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: hi2(t2) };
          }
          function ci2(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function hi2(t2) {
            if (!Array.isArray(t2)) return false;
            if ("within" === t2[0] || "distance" === t2[0]) return true;
            for (let e2 = 1; e2 < t2.length; e2++) if (hi2(t2[e2])) return true;
            return false;
          }
          function pi2(t2) {
            if (!t2) return true;
            const e2 = t2[0];
            return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? fi2(t2[1], t2[2], "==") : "!=" === e2 ? mi2(fi2(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? fi2(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(pi2))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(pi2)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(pi2).map(mi2)) : "in" === e2 ? di2(t2[1], t2.slice(2)) : "!in" === e2 ? mi2(di2(t2[1], t2.slice(2))) : "has" === e2 ? yi2(t2[1]) : "!has" !== e2 || mi2(yi2(t2[1]));
            var r2;
          }
          function fi2(t2, e2, r2) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r2}`, e2];
              case "$id":
                return [`filter-id-${r2}`, e2];
              default:
                return [`filter-${r2}`, t2, e2];
            }
          }
          function di2(t2, e2) {
            if (0 === e2.length) return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(ci2)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function yi2(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function mi2(t2) {
            return ["!", t2];
          }
          function gi2(t2) {
            const e2 = typeof t2;
            if ("number" === e2 || "boolean" === e2 || "string" === e2 || null == t2) return JSON.stringify(t2);
            if (Array.isArray(t2)) {
              let e3 = "[";
              for (const r3 of t2) e3 += `${gi2(r3)},`;
              return `${e3}]`;
            }
            const r2 = Object.keys(t2).sort();
            let n2 = "{";
            for (let e3 = 0; e3 < r2.length; e3++) n2 += `${JSON.stringify(r2[e3])}:${gi2(t2[r2[e3]])},`;
            return `${n2}}`;
          }
          function xi2(t2) {
            let e2 = "";
            for (const r2 of xt2) e2 += `/${gi2(t2[r2])}`;
            return e2;
          }
          function vi2(t2) {
            const e2 = t2.value;
            return e2 ? [new Pt(t2.key, e2, "constants have been deprecated as of v8")] : [];
          }
          function bi2(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function wi2(t2) {
            if (Array.isArray(t2)) return t2.map(wi2);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e2 = {};
              for (const r2 in t2) e2[r2] = wi2(t2[r2]);
              return e2;
            }
            return bi2(t2);
          }
          function _i2(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
            let l2 = [];
            const u2 = qn2(r2);
            if ("object" !== u2) return [new Pt(e2, r2, `object expected, ${u2} found`)];
            for (const t3 in r2) {
              const u3 = t3.split(".")[0], c2 = ge2(n2, u3) || n2["*"];
              let h3;
              if (ge2(i2, u3)) h3 = i2[u3];
              else if (ge2(n2, u3)) h3 = o2;
              else if (i2["*"]) h3 = i2["*"];
              else {
                if (!n2["*"]) {
                  l2.push(new Pt(e2, r2[t3], `unknown property "${t3}"`));
                  continue;
                }
                h3 = o2;
              }
              l2 = l2.concat(h3({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: c2, style: s2, styleSpec: a2, object: r2, objectKey: t3, validateSpec: o2 }, r2));
            }
            for (const t3 in n2) i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && l2.push(new Pt(e2, r2, `missing required property "${t3}"`));
            return l2;
          }
          function Ai2(t2) {
            const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || t2.validateSpec;
            if ("array" !== qn2(e2)) return [new Pt(s2, e2, `array expected, ${qn2(e2)} found`)];
            if (r2.length && e2.length !== r2.length) return [new Pt(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
            if (r2["min-length"] && e2.length < r2["min-length"]) return [new Pt(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
            let o2 = { type: r2.value, values: r2.values };
            i2.$version < 7 && (o2.function = r2.function), "object" === qn2(r2.value) && (o2 = r2.value);
            let l2 = [];
            for (let r3 = 0; r3 < e2.length; r3++) l2 = l2.concat(a2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t2.validateSpec, style: n2, styleSpec: i2, key: `${s2}[${r3}]` }));
            return l2;
          }
          function Si2(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
            let i2 = qn2(r2);
            return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new Pt(e2, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new Pt(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new Pt(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
          }
          function ki2(t2) {
            const e2 = t2.valueSpec, r2 = bi2(t2.value.type);
            let n2, i2, s2, a2 = {};
            const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === qn2(t2.value.stops) && "array" === qn2(t2.value.stops[0]) && "object" === qn2(t2.value.stops[0][0]), c2 = _i2({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, validateSpec: t2.validateSpec, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if ("identity" === r2) return [new Pt(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let e3 = [];
              const n3 = t3.value;
              return e3 = e3.concat(Ai2({ key: t3.key, value: n3, valueSpec: t3.valueSpec, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h3 })), "array" === qn2(n3) && 0 === n3.length && e3.push(new Pt(t3.key, n3, "array must have at least one stop")), e3;
            }, default: function(t3) {
              return t3.validateSpec({ key: t3.key, value: t3.value, valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec });
            } } });
            return "identity" === r2 && o2 && c2.push(new Pt(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new Pt(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Un2(t2.valueSpec) && c2.push(new Pt(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !Rn2(t2.valueSpec) ? c2.push(new Pt(t2.key, t2.value, "property functions not supported")) : o2 && !Nn2(t2.valueSpec) && c2.push(new Pt(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new Pt(t2.key, t2.value, '"property" property is required')), c2;
            function h3(t3) {
              let r3 = [];
              const n3 = t3.value, o3 = t3.key;
              if ("array" !== qn2(n3)) return [new Pt(o3, n3, `array expected, ${qn2(n3)} found`)];
              if (2 !== n3.length) return [new Pt(o3, n3, `array length 2 expected, length ${n3.length} found`)];
              if (u2) {
                if ("object" !== qn2(n3[0])) return [new Pt(o3, n3, `object expected, ${qn2(n3[0])} found`)];
                if (void 0 === n3[0].zoom) return [new Pt(o3, n3, "object stop key must have zoom")];
                if (void 0 === n3[0].value) return [new Pt(o3, n3, "object stop key must have value")];
                if (s2 && s2 > bi2(n3[0].zoom)) return [new Pt(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
                bi2(n3[0].zoom) !== s2 && (s2 = bi2(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat(_i2({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Si2, value: p2 } }));
              } else r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }, n3));
              return ti2(wi2(n3[1])) ? r3.concat([new Pt(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t3.validateSpec({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function p2(t3, s3) {
              const o3 = qn2(t3.value), l3 = bi2(t3.value), u3 = null !== t3.value ? t3.value : s3;
              if (n2) {
                if (o3 !== n2) return [new Pt(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
              } else n2 = o3;
              if ("number" !== o3 && "string" !== o3 && "boolean" !== o3) return [new Pt(t3.key, u3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== o3 && "categorical" !== r2) {
                let n3 = `number expected, ${o3} found`;
                return Rn2(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Pt(t3.key, u3, n3)];
              }
              return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l3 < i2 ? [new Pt(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new Pt(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new Pt(t3.key, u3, `integer expected, found ${l3}`)];
            }
          }
          function Mi2(t2) {
            const e2 = ("property" === t2.expressionContext ? ii2 : ei2)(wi2(t2.value), t2.valueSpec);
            if ("error" === e2.result) return e2.value.map((e3) => new Pt(`${t2.key}${e3.key}`, t2.value, e3.message));
            const r2 = e2.value.expression || e2.value._styleExpression.expression;
            if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined()) return [new Pt(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t2.expressionContext && "layout" === t2.propertyType && !Ln2(r2)) return [new Pt(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t2.expressionContext && !Ln2(r2)) return [new Pt(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
            if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
              if (!On2(r2, ["zoom", "feature-state"])) return [new Pt(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t2.expressionContext && !$n2(r2)) return [new Pt(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function Ii2(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = qn2(r2);
            return "string" !== n2 ? [new Pt(e2, r2, `color expected, ${n2} found`)] : ke2.parse(String(r2)) ? [] : [new Pt(e2, r2, `color expected, "${r2}" found`)];
          }
          function zi2(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
            return Array.isArray(n2.values) ? -1 === n2.values.indexOf(bi2(r2)) && i2.push(new Pt(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(bi2(r2)) && i2.push(new Pt(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
          }
          function Pi2(t2) {
            return oi2(wi2(t2.value)) ? Mi2(Ct2({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Ci2(t2);
          }
          function Ci2(t2) {
            const e2 = t2.value, r2 = t2.key;
            if ("array" !== qn2(e2)) return [new Pt(r2, e2, `array expected, ${qn2(e2)} found`)];
            const n2 = t2.styleSpec;
            let i2, s2 = [];
            if (e2.length < 1) return [new Pt(r2, e2, "filter array must have at least 1 element")];
            switch (s2 = s2.concat(zi2({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), bi2(e2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e2.length >= 2 && "$type" === bi2(e2[1]) && s2.push(new Pt(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
              case "==":
              case "!=":
                3 !== e2.length && s2.push(new Pt(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e2.length >= 2 && (i2 = qn2(e2[1]), "string" !== i2 && s2.push(new Pt(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
                for (let a2 = 2; a2 < e2.length; a2++) i2 = qn2(e2[a2]), "$type" === bi2(e2[1]) ? s2 = s2.concat(zi2({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new Pt(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n3 = 1; n3 < e2.length; n3++) s2 = s2.concat(Ci2({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                i2 = qn2(e2[1]), 2 !== e2.length ? s2.push(new Pt(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new Pt(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
            }
            return s2;
          }
          function Bi2(t2, e2) {
            const r2 = t2.key, n2 = t2.validateSpec, i2 = t2.style, s2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, l2 = s2[`${e2}_${t2.layerType}`];
            if (!l2) return [];
            const u2 = o2.match(/^(.*)-transition$/);
            if ("paint" === e2 && u2 && l2[u2[1]] && l2[u2[1]].transition) return n2({ key: r2, value: a2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
            const c2 = t2.valueSpec || l2[o2];
            if (!c2) return [new Pt(r2, a2, `unknown property "${o2}"`)];
            let h3;
            if ("string" === qn2(a2) && Rn2(c2) && !c2.tokens && (h3 = /^{([^}]+)}$/.exec(a2))) return [new Pt(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h3[1])} }\`.`)];
            const p2 = [];
            return "symbol" === t2.layerType && ("text-field" === o2 && i2 && !i2.glyphs && p2.push(new Pt(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Gn2(wi2(a2)) && "identity" === bi2(a2.type) && p2.push(new Pt(r2, a2, '"text-font" does not support identity functions'))), p2.concat(n2({ key: t2.key, value: a2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
          }
          function Vi2(t2) {
            return Bi2(t2, "paint");
          }
          function Ei2(t2) {
            return Bi2(t2, "layout");
          }
          function Ti2(t2) {
            let e2 = [];
            const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
            if ("object" !== qn2(r2)) return [new Pt(n2, r2, `object expected, ${qn2(r2)} found`)];
            r2.type || r2.ref || e2.push(new Pt(n2, r2, 'either "type" or "ref" is required'));
            let a2 = bi2(r2.type);
            const o2 = bi2(r2.ref);
            if (r2.id) {
              const s3 = bi2(r2.id);
              for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
                const t3 = i2.layers[a3];
                bi2(t3.id) === s3 && e2.push(new Pt(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in r2) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in r2 && e2.push(new Pt(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
              }), i2.layers.forEach((e3) => {
                bi2(e3.id) === o2 && (t3 = e3);
              }), t3 ? t3.ref ? e2.push(new Pt(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = bi2(t3.type) : e2.push(new Pt(n2, r2.ref, `ref layer "${o2}" not found`));
            } else if ("background" !== a2) if (r2.source) {
              const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && bi2(t3.type);
              t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new Pt(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster-dem" !== s3 && "hillshade" === a2 ? e2.push(new Pt(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : "raster" === s3 && "raster" !== a2 ? e2.push(new Pt(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e2.push(new Pt(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && t3.lineMetrics || e2.push(new Pt(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new Pt(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new Pt(n2, r2.source, `source "${r2.source}" not found`));
            } else e2.push(new Pt(n2, r2, 'missing required property "source"'));
            return e2 = e2.concat(_i2({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, objectElementValidators: { "*": () => [], type: () => t2.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, object: r2, objectKey: "type" }), filter: Pi2, layout: (t3) => _i2({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Ei2(Ct2({ layerType: a2 }, t4)) } }), paint: (t3) => _i2({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Vi2(Ct2({ layerType: a2 }, t4)) } }) } })), e2;
          }
          function Fi2(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = qn2(e2);
            return "string" !== n2 ? [new Pt(r2, e2, `string expected, ${n2} found`)] : [];
          }
          const $i2 = { promoteId: function({ key: t2, value: e2 }) {
            if ("string" === qn2(e2)) return Fi2({ key: t2, value: e2 });
            {
              const r2 = [];
              for (const n2 in e2) r2.push(...Fi2({ key: `${t2}.${n2}`, value: e2[n2] }));
              return r2;
            }
          } };
          function Li2(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style, s2 = t2.validateSpec;
            if (!e2.type) return [new Pt(r2, e2, '"type" is required')];
            const a2 = bi2(e2.type);
            let o2;
            switch (a2) {
              case "vector":
              case "raster":
                return o2 = _i2({ key: r2, value: e2, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: $i2, validateSpec: s2 }), o2;
              case "raster-dem":
                return o2 = function(t3) {
                  var e3;
                  const r3 = null !== (e3 = t3.sourceName) && void 0 !== e3 ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
                  let o3 = [];
                  const l2 = qn2(n3);
                  if (void 0 === n3) return o3;
                  if ("object" !== l2) return o3.push(new Pt("source_raster_dem", n3, `object expected, ${l2} found`)), o3;
                  const u2 = "custom" === bi2(n3.encoding), c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h3 = t3.value.encoding ? `"${t3.value.encoding}"` : "Default";
                  for (const e4 in n3) !u2 && c2.includes(e4) ? o3.push(new Pt(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h3} encoding found`)) : s3[e4] ? o3 = o3.concat(t3.validateSpec({ key: e4, value: n3[e4], valueSpec: s3[e4], validateSpec: t3.validateSpec, style: a3, styleSpec: i3 })) : o3.push(new Pt(e4, n3[e4], `unknown property "${e4}"`));
                  return o3;
                }({ sourceName: r2, value: e2, style: t2.style, styleSpec: n2, validateSpec: s2 }), o2;
              case "geojson":
                if (o2 = _i2({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: $i2 }), e2.cluster) for (const t3 in e2.clusterProperties) {
                  const [n3, i3] = e2.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                  o2.push(...Mi2({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), o2.push(...Mi2({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
                }
                return o2;
              case "video":
                return _i2({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
              case "image":
                return _i2({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
              case "canvas":
                return [new Pt(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return zi2({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
            }
          }
          function Oi2(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
            let s2 = [];
            const a2 = qn2(e2);
            if (void 0 === e2) return s2;
            if ("object" !== a2) return s2 = s2.concat([new Pt("light", e2, `object expected, ${a2} found`)]), s2;
            for (const a3 in e2) {
              const o2 = a3.match(/^(.*)-transition$/);
              s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: r2.transition, validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new Pt(a3, e2[a3], `unknown property "${a3}"`)]);
            }
            return s2;
          }
          function Di2(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.sky, i2 = t2.style, s2 = qn2(e2);
            if (void 0 === e2) return [];
            if ("object" !== s2) return [new Pt("sky", e2, `object expected, ${s2} found`)];
            let a2 = [];
            for (const s3 in e2) a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Pt(s3, e2[s3], `unknown property "${s3}"`)]);
            return a2;
          }
          function ji2(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style;
            let s2 = [];
            const a2 = qn2(e2);
            if (void 0 === e2) return s2;
            if ("object" !== a2) return s2 = s2.concat([new Pt("terrain", e2, `object expected, ${a2} found`)]), s2;
            for (const a3 in e2) s2 = s2.concat(n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new Pt(a3, e2[a3], `unknown property "${a3}"`)]);
            return s2;
          }
          function Ri2(t2) {
            let e2 = [];
            const r2 = t2.value, n2 = t2.key;
            if (Array.isArray(r2)) {
              const i2 = [], s2 = [];
              for (const a2 in r2) r2[a2].id && i2.includes(r2[a2].id) && e2.push(new Pt(n2, r2, `all the sprites' ids must be unique, but ${r2[a2].id} is duplicated`)), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new Pt(n2, r2, `all the sprites' URLs must be unique, but ${r2[a2].url} is duplicated`)), s2.push(r2[a2].url), e2 = e2.concat(_i2({ key: `${n2}[${a2}]`, value: r2[a2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t2.validateSpec }));
              return e2;
            }
            return Fi2({ key: n2, value: r2 });
          }
          function Ni2(t2) {
            return e2 = t2.value, Boolean(e2) && e2.constructor === Object ? [] : [new Pt(t2.key, t2.value, `object expected, ${qn2(t2.value)} found`)];
            var e2;
          }
          const Ui2 = { "*": () => [], array: Ai2, boolean: function(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = qn2(e2);
            return "boolean" !== n2 ? [new Pt(r2, e2, `boolean expected, ${n2} found`)] : [];
          }, number: Si2, color: Ii2, constants: vi2, enum: zi2, filter: Pi2, function: ki2, layer: Ti2, object: _i2, source: Li2, light: Oi2, sky: Di2, terrain: ji2, projection: function(t2) {
            const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.projection, i2 = t2.style, s2 = qn2(e2);
            if (void 0 === e2) return [];
            if ("object" !== s2) return [new Pt("projection", e2, `object expected, ${s2} found`)];
            let a2 = [];
            for (const s3 in e2) a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new Pt(s3, e2[s3], `unknown property "${s3}"`)]);
            return a2;
          }, projectionDefinition: function(t2) {
            const e2 = t2.key;
            let r2 = t2.value;
            r2 = r2 instanceof String ? r2.valueOf() : r2;
            const n2 = qn2(r2);
            return "array" !== n2 || function(t3) {
              return Array.isArray(t3) && 3 === t3.length && "string" == typeof t3[0] && "string" == typeof t3[1] && "number" == typeof t3[2];
            }(r2) || function(t3) {
              return !!["interpolate", "step", "literal"].includes(t3[0]);
            }(r2) ? ["array", "string"].includes(n2) ? [] : [new Pt(e2, r2, `projection expected, invalid type "${n2}" found`)] : [new Pt(e2, r2, `projection expected, invalid array ${JSON.stringify(r2)} found`)];
          }, string: Fi2, formatted: function(t2) {
            return 0 === Fi2(t2).length ? [] : Mi2(t2);
          }, resolvedImage: function(t2) {
            return 0 === Fi2(t2).length ? [] : Mi2(t2);
          }, padding: function(t2) {
            const e2 = t2.key, r2 = t2.value;
            if ("array" === qn2(r2)) {
              if (r2.length < 1 || r2.length > 4) return [new Pt(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
              const n2 = { type: "number" };
              let i2 = [];
              for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
              return i2;
            }
            return Si2({ key: e2, value: r2, valueSpec: {} });
          }, numberArray: function(t2) {
            const e2 = t2.key, r2 = t2.value;
            if ("array" === qn2(r2)) {
              const n2 = { type: "number" };
              if (r2.length < 1) return [new Pt(e2, r2, "array length at least 1 expected, length 0 found")];
              let i2 = [];
              for (let s2 = 0; s2 < r2.length; s2++) i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
              return i2;
            }
            return Si2({ key: e2, value: r2, valueSpec: {} });
          }, colorArray: function(t2) {
            const e2 = t2.key, r2 = t2.value;
            if ("array" === qn2(r2)) {
              if (r2.length < 1) return [new Pt(e2, r2, "array length at least 1 expected, length 0 found")];
              let t3 = [];
              for (let n2 = 0; n2 < r2.length; n2++) t3 = t3.concat(Ii2({ key: `${e2}[${n2}]`, value: r2[n2] }));
              return t3;
            }
            return Ii2({ key: e2, value: r2 });
          }, variableAnchorOffsetCollection: function(t2) {
            const e2 = t2.key, r2 = t2.value, n2 = qn2(r2), i2 = t2.styleSpec;
            if ("array" !== n2 || r2.length < 1 || r2.length % 2 != 0) return [new Pt(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let s2 = [];
            for (let n3 = 0; n3 < r2.length; n3 += 2) s2 = s2.concat(zi2({ key: `${e2}[${n3}]`, value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(Ai2({ key: `${e2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t2.validateSpec, style: t2.style, styleSpec: i2 }));
            return s2;
          }, sprite: Ri2, state: Ni2 };
          function qi2(t2) {
            const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
            return t2.validateSpec = qi2, r2.expression && Gn2(bi2(e2)) ? ki2(t2) : r2.expression && ti2(wi2(e2)) ? Mi2(t2) : r2.type && Ui2[r2.type] ? Ui2[r2.type](t2) : _i2(Ct2({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
          }
          function Gi2(t2) {
            const e2 = t2.value, r2 = t2.key, n2 = Fi2(t2);
            return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
          }
          function Zi2(t2, e2 = gt2) {
            let r2 = [];
            return r2 = r2.concat(qi2({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, validateSpec: qi2, objectElementValidators: { glyphs: Gi2, "*": () => [] } })), t2.constants && (r2 = r2.concat(vi2({ key: "constants", value: t2.constants }))), Xi2(r2);
          }
          function Ki2(t2) {
            return function(e2) {
              return t2({ ...e2, validateSpec: qi2 });
            };
          }
          function Xi2(t2) {
            return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
          }
          function Hi2(t2) {
            return function(...e2) {
              return Xi2(t2.apply(this, e2));
            };
          }
          Zi2.source = Hi2(Ki2(Li2)), Zi2.sprite = Hi2(Ki2(Ri2)), Zi2.glyphs = Hi2(Ki2(Gi2)), Zi2.light = Hi2(Ki2(Oi2)), Zi2.sky = Hi2(Ki2(Di2)), Zi2.terrain = Hi2(Ki2(ji2)), Zi2.state = Hi2(Ki2(Ni2)), Zi2.layer = Hi2(Ki2(Ti2)), Zi2.filter = Hi2(Ki2(Pi2)), Zi2.paintProperty = Hi2(Ki2(Vi2)), Zi2.layoutProperty = Hi2(Ki2(Ei2));
          const Yi2 = Zi2, Ji2 = Yi2.light, Wi2 = Yi2.sky, Qi2 = Yi2.paintProperty, ts2 = Yi2.layoutProperty;
          function es2(t2, e2) {
            let r2 = false;
            if (e2 && e2.length) for (const n2 of e2) t2.fire(new yt2(new Error(n2.message))), r2 = true;
            return r2;
          }
          class rs2 {
            constructor(t2, e2, r2) {
              const n2 = this.cells = [];
              if (t2 instanceof ArrayBuffer) {
                this.arrayBuffer = t2;
                const i3 = new Int32Array(this.arrayBuffer);
                t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
                for (let t3 = 0; t3 < this.d * this.d; t3++) {
                  const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                  n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
                }
                const s2 = i3[3 + n2.length + 1];
                this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
              } else {
                this.d = e2 + 2 * r2;
                for (let t3 = 0; t3 < this.d * this.d; t3++) n2.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
              const i2 = r2 / e2 * t2;
              this.min = -i2, this.max = t2 + i2;
            }
            insert(t2, e2, r2, n2, i2) {
              this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
            }
            _insertReadonly() {
              throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t2, e2, r2, n2, i2, s2) {
              this.cells[i2].push(s2);
            }
            query(t2, e2, r2, n2, i2) {
              const s2 = this.min, a2 = this.max;
              if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
              {
                const s3 = [];
                return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
              }
            }
            _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this.cells[i2];
              if (null !== l2) {
                const i3 = this.keys, u2 = this.bboxes;
                for (let c2 = 0; c2 < l2.length; c2++) {
                  const h3 = l2[c2];
                  if (void 0 === a2[h3]) {
                    const l3 = 4 * h3;
                    (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (a2[h3] = true, s2.push(i3[h3])) : a2[h3] = false;
                  }
                }
              }
            }
            _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h3 = this._convertToCellCoord(n2);
              for (let p2 = l2; p2 <= c2; p2++) for (let l3 = u2; l3 <= h3; l3++) {
                const u3 = this.d * l3 + p2;
                if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2)) return;
              }
            }
            _convertFromCellCoord(t2) {
              return (t2 - this.padding) / this.scale;
            }
            _convertToCellCoord(t2) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
            }
            toArrayBuffer() {
              if (this.arrayBuffer) return this.arrayBuffer;
              const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
              let r2 = 0;
              for (let t3 = 0; t3 < this.cells.length; t3++) r2 += this.cells[t3].length;
              const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
              n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
              let i2 = e2;
              for (let e3 = 0; e3 < t2.length; e3++) {
                const r3 = t2[e3];
                n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
              }
              return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
            }
            static serialize(t2, e2) {
              const r2 = t2.toArrayBuffer();
              return e2 && e2.push(r2), { buffer: r2 };
            }
            static deserialize(t2) {
              return new rs2(t2.buffer);
            }
          }
          const ns2 = {};
          function is2(t2, e2, r2 = {}) {
            if (ns2[t2]) throw new Error(`${t2} is already registered.`);
            Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), ns2[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
          }
          is2("Object", Object), is2("TransferableGridIndex", rs2), is2("Color", ke2), is2("Error", Error), is2("AJAXError", lt2), is2("ResolvedImage", $e2), is2("StylePropertyFunction", si2), is2("StyleExpression", Qn2, { omit: ["_evaluator"] }), is2("ZoomDependentExpression", ni2), is2("ZoomConstantExpression", ri2), is2("CompoundExpression", Cn2, { omit: ["_evaluate"] });
          for (const t2 in Pn2) Pn2[t2]._classRegistryKey || is2(`Expression_${t2}`, Pn2[t2]);
          function ss2(t2) {
            return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
          }
          function as2(t2) {
            return t2.$name || t2.constructor._classRegistryKey;
          }
          function os2(t2) {
            return !function(t3) {
              if (null === t3 || "object" != typeof t3) return false;
              const e2 = as2(t3);
              return !(!e2 || "Object" === e2);
            }(t2) && (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || ss2(t2) || K2(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData);
          }
          function ls2(t2, e2) {
            if (os2(t2)) return (ss2(t2) || K2(t2)) && e2 && e2.push(t2), ArrayBuffer.isView(t2) && e2 && e2.push(t2.buffer), t2 instanceof ImageData && e2 && e2.push(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const r3 = [];
              for (const n3 of t2) r3.push(ls2(n3, e2));
              return r3;
            }
            if ("object" != typeof t2) throw new Error("can't serialize object of type " + typeof t2);
            const r2 = as2(t2);
            if (!r2) throw new Error(`can't serialize object of unregistered class ${t2.constructor.name}`);
            if (!ns2[r2]) throw new Error(`${r2} is not registered.`);
            const { klass: n2 } = ns2[r2], i2 = n2.serialize ? n2.serialize(t2, e2) : {};
            if (n2.serialize) {
              if (e2 && i2 === e2[e2.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (const n3 in t2) {
                if (!t2.hasOwnProperty(n3)) continue;
                if (ns2[r2].omit.indexOf(n3) >= 0) continue;
                const s2 = t2[n3];
                i2[n3] = ns2[r2].shallow.indexOf(n3) >= 0 ? s2 : ls2(s2, e2);
              }
              t2 instanceof Error && (i2.message = t2.message);
            }
            if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== r2 && (i2.$name = r2), i2;
          }
          function us2(t2) {
            if (os2(t2)) return t2;
            if (Array.isArray(t2)) return t2.map(us2);
            if ("object" != typeof t2) throw new Error("can't deserialize object of type " + typeof t2);
            const e2 = as2(t2) || "Object";
            if (!ns2[e2]) throw new Error(`can't deserialize unregistered class ${e2}`);
            const { klass: r2 } = ns2[e2];
            if (!r2) throw new Error(`can't deserialize unregistered class ${e2}`);
            if (r2.deserialize) return r2.deserialize(t2);
            const n2 = Object.create(r2.prototype);
            for (const r3 of Object.keys(t2)) {
              if ("$name" === r3) continue;
              const i2 = t2[r3];
              n2[r3] = ns2[e2].shallow.indexOf(r3) >= 0 ? i2 : us2(i2);
            }
            return n2;
          }
          class cs2 {
            constructor() {
              this.first = true;
            }
            update(t2, e2) {
              const r2 = Math.floor(t2);
              return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
            }
          }
          const hs2 = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
          function ps2(t2) {
            for (const e2 of t2) if (xs2(e2.charCodeAt(0))) return true;
            return false;
          }
          function fs2(t2) {
            for (const e2 of t2) if (!ms2(e2.charCodeAt(0))) return false;
            return true;
          }
          function ds2(t2) {
            const e2 = t2.map((t3) => {
              try {
                return new RegExp(`\\p{sc=${t3}}`, "u").source;
              } catch (t4) {
                return null;
              }
            }).filter((t3) => t3);
            return new RegExp(e2.join("|"), "u");
          }
          const ys2 = ds2(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
          function ms2(t2) {
            return !ys2.test(String.fromCodePoint(t2));
          }
          const gs2 = ds2(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
          function xs2(t2) {
            return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(hs2["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || hs2["CJK Compatibility"](t2) || hs2["CJK Strokes"](t2) || !(!hs2["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || hs2["Enclosed CJK Letters and Months"](t2) || hs2["Ideographic Description Characters"](t2) || hs2.Kanbun(t2) || hs2.Katakana(t2) && 12540 !== t2 || !(!hs2["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!hs2["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || hs2["Vertical Forms"](t2) || hs2["Yijing Hexagram Symbols"](t2) || /\p{sc=Cans}/u.test(String.fromCodePoint(t2)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t2)) || gs2.test(String.fromCodePoint(t2)))));
          }
          function vs2(t2) {
            return !(xs2(t2) || function(t3) {
              return !!(hs2["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || hs2["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || hs2["Letterlike Symbols"](t3) || hs2["Number Forms"](t3) || hs2["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || hs2["Control Pictures"](t3) && 9251 !== t3 || hs2["Optical Character Recognition"](t3) || hs2["Enclosed Alphanumerics"](t3) || hs2["Geometric Shapes"](t3) || hs2["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || hs2["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || hs2["CJK Symbols and Punctuation"](t3) || hs2.Katakana(t3) || hs2["Private Use Area"](t3) || hs2["CJK Compatibility Forms"](t3) || hs2["Small Form Variants"](t3) || hs2["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
            }(t2));
          }
          const bs2 = ds2(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
          function ws2(t2) {
            return bs2.test(String.fromCodePoint(t2));
          }
          function _s2(t2, e2) {
            return !(!e2 && ws2(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || hs2.Khmer(t2));
          }
          function As2(t2) {
            for (const e2 of t2) if (ws2(e2.charCodeAt(0))) return true;
            return false;
          }
          const Ss2 = new class {
            constructor() {
              this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
              };
            }
            setState(t2) {
              this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
            }
            getState() {
              return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
            }
            setMethods(t2) {
              if (Ss2.isParsed()) throw new Error("RTL text plugin already registered.");
              this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText, this.loadScriptResolve();
            }
            isParsed() {
              return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
            }
            getRTLTextPluginStatus() {
              return this.pluginStatus;
            }
            syncState(t2, r2) {
              return e(this, void 0, void 0, function* () {
                if (this.isParsed()) return this.getState();
                if ("loading" !== t2.pluginStatus) return this.setState(t2), t2;
                const e2 = t2.pluginURL, n2 = new Promise((t3) => {
                  this.loadScriptResolve = t3;
                });
                r2(e2);
                const i2 = new Promise((t3) => setTimeout(() => t3(), this.TIMEOUT));
                if (yield Promise.race([n2, i2]), this.isParsed()) {
                  const t3 = { pluginStatus: "loaded", pluginURL: e2 };
                  return this.setState(t3), t3;
                }
                throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${e2}`);
              });
            }
          }();
          class ks2 {
            constructor(t2, e2) {
              this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new cs2(), this.transition = {});
            }
            isSupportedScript(t2) {
              return function(t3, e2) {
                for (const r2 of t3) if (!_s2(r2.charCodeAt(0), e2)) return false;
                return true;
              }(t2, "loaded" === Ss2.getRTLTextPluginStatus());
            }
            crossFadingFactor() {
              return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
              return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
            }
          }
          class Ms2 {
            constructor(t2, e2) {
              this.property = t2, this.value = e2, this.expression = function(t3, e3) {
                if (Gn2(t3)) return new si2(t3, e3);
                if (ti2(t3)) {
                  const r2 = ii2(t3, e3);
                  if ("error" === r2.result) throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return r2.value;
                }
                {
                  let r2 = t3;
                  return "color" === e3.type && "string" == typeof t3 ? r2 = ke2.parse(t3) : "padding" !== e3.type || "number" != typeof t3 && !Array.isArray(t3) ? "numberArray" !== e3.type || "number" != typeof t3 && !Array.isArray(t3) ? "colorArray" !== e3.type || "string" != typeof t3 && !Array.isArray(t3) ? "variableAnchorOffsetCollection" === e3.type && Array.isArray(t3) ? r2 = Fe2.parse(t3) : "projectionDefinition" === e3.type && "string" == typeof t3 && (r2 = Le2.parse(t3)) : r2 = Ve2.parse(t3) : r2 = Be2.parse(t3) : r2 = Ce2.parse(t3), { kind: "constant", evaluate: () => r2 };
                }
              }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t2, e2, r2) {
              return this.property.possiblyEvaluate(this, t2, e2, r2);
            }
          }
          class Is2 {
            constructor(t2) {
              this.property = t2, this.value = new Ms2(t2, void 0);
            }
            transitioned(t2, e2) {
              return new Ps2(this.property, this.value, e2, L2({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new Ps2(this.property, this.value, null, {}, 0);
            }
          }
          class zs2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
            }
            getValue(t2) {
              return R(this._values[t2].value.value);
            }
            setValue(t2, e2) {
              Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Is2(this._values[t2].property)), this._values[t2].value = new Ms2(this._values[t2].property, null === e2 ? void 0 : R(e2));
            }
            getTransition(t2) {
              return R(this._values[t2].transition);
            }
            setTransition(t2, e2) {
              Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Is2(this._values[t2].property)), this._values[t2].transition = R(e2) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
                const n2 = this.getTransition(e2);
                void 0 !== n2 && (t2[`${e2}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e2) {
              const r2 = new Cs2(this._properties);
              for (const n2 of Object.keys(this._values)) r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
              return r2;
            }
            untransitioned() {
              const t2 = new Cs2(this._properties);
              for (const e2 of Object.keys(this._values)) t2._values[e2] = this._values[e2].untransitioned();
              return t2;
            }
          }
          class Ps2 {
            constructor(t2, e2, r2, n2, i2) {
              this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
              if (s2) {
                if (n2 > this.end) return this.prior = null, i2;
                if (this.value.isDataDriven()) return this.prior = null, i2;
                if (n2 < this.begin) return s2.possiblyEvaluate(t2, e2, r2);
                {
                  const a2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, V2(a2));
                }
              }
              return i2;
            }
          }
          class Cs2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new Es2(this._properties);
              for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values)) if (this._values[t2].prior) return true;
              return false;
            }
          }
          class Bs2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
            }
            hasValue(t2) {
              return void 0 !== this._values[t2].value;
            }
            getValue(t2) {
              return R(this._values[t2].value);
            }
            setValue(t2, e2) {
              this._values[t2] = new Ms2(this._values[t2].property, null === e2 ? void 0 : R(e2));
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
              }
              return t2;
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new Es2(this._properties);
              for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
          }
          class Vs2 {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = e2, this.parameters = r2;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t2) {
              return "constant" === this.value.kind ? this.value.value : t2;
            }
            evaluate(t2, e2, r2, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
            }
          }
          class Es2 {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class Ts2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              if (t2.isDataDriven()) throw new Error("Value should not be data driven");
              return t2.expression.evaluate(e2);
            }
            interpolate(t2, e2, r2) {
              const n2 = fr2[this.specification.type];
              return n2 ? n2(t2, e2, r2) : t2;
            }
          }
          class Fs2 {
            constructor(t2, e2) {
              this.specification = t2, this.overrides = e2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return new Vs2(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
            }
            interpolate(t2, e2, r2) {
              if ("constant" !== t2.value.kind || "constant" !== e2.value.kind) return t2;
              if (void 0 === t2.value.value || void 0 === e2.value.value) return new Vs2(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = fr2[this.specification.type];
              if (n2) {
                const i2 = n2(t2.value.value, e2.value.value, r2);
                return new Vs2(this, { kind: "constant", value: i2 }, t2.parameters);
              }
              return t2;
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
            }
          }
          class $s2 extends Fs2 {
            possiblyEvaluate(t2, e2, r2, n2) {
              if (void 0 === t2.value) return new Vs2(this, { kind: "constant", value: void 0 }, e2);
              if ("constant" === t2.expression.kind) {
                const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
                return new Vs2(this, { kind: "constant", value: a2 }, e2);
              }
              if ("camera" === t2.expression.kind) {
                const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
                return new Vs2(this, { kind: "constant", value: r3 }, e2);
              }
              return new Vs2(this, t2.expression, e2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              if ("source" === t2.kind) {
                const a2 = t2.evaluate(e2, r2, n2, i2, s2);
                return this._calculate(a2, a2, a2, e2);
              }
              return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
            }
            _calculate(t2, e2, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class Ls2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              if (void 0 !== t2.value) {
                if ("constant" === t2.expression.kind) {
                  const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                  return this._calculate(i2, i2, i2, e2);
                }
                return this._calculate(t2.expression.evaluate(new ks2(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new ks2(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new ks2(Math.floor(e2.zoom + 1), e2)), e2);
              }
            }
            _calculate(t2, e2, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class Os2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return !!t2.expression.evaluate(e2, null, {}, r2, n2);
            }
            interpolate() {
              return false;
            }
          }
          class Ds2 {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e2 in t2) {
                const r2 = t2[e2];
                r2.specification.overridable && this.overridableProperties.push(e2);
                const n2 = this.defaultPropertyValues[e2] = new Ms2(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new Is2(r2);
                this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
              }
            }
          }
          is2("DataDrivenProperty", Fs2), is2("DataConstantProperty", Ts2), is2("CrossFadedDataDrivenProperty", $s2), is2("CrossFadedProperty", Ls2), is2("ColorRampProperty", Os2);
          const js2 = "-transition";
          class Rs2 extends mt2 {
            constructor(t2, e2) {
              if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Bs2(e2.layout)), e2.paint)) {
                this._transitionablePaint = new zs2(e2.paint);
                for (const e3 in t2.paint) this.setPaintProperty(e3, t2.paint[e3], { validate: false });
                for (const e3 in t2.layout) this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Es2(e2.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t2) {
              return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e2, r2 = {}) {
              null != e2 && this._validate(ts2, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
            }
            getPaintProperty(t2) {
              return t2.endsWith(js2) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e2, r2 = {}) {
              if (null != e2 && this._validate(Qi2, `layers.${this.id}.paint.${t2}`, t2, e2, r2)) return false;
              if (t2.endsWith(js2)) return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || void 0), false;
              {
                const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
                this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
                const a2 = this._transitionablePaint._values[t2].value;
                return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
              }
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e2) {
              t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
            }
            serialize() {
              const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), j(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
            }
            _validate(t2, e2, r2, n2, i2 = {}) {
              return (!i2 || false !== i2.validate) && es2(this, t2.call(Yi2, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: gt2, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e2 = this.paint.get(t2);
                if (e2 instanceof Vs2 && Rn2(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
              }
              return false;
            }
          }
          const Ns2 = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class Us2 {
            constructor(t2, e2) {
              this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class qs2 {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e2) {
              return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e2 = Object.create(this.prototype);
              return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e2 = this.uint8;
                this._refreshViews(), e2 && this.uint8.set(e2);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function Gs2(t2, e2 = 1) {
            let r2 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = Ns2[t3.type].BYTES_PER_ELEMENT, s2 = r2 = Zs(r2, Math.max(e2, i2)), a2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
            }), size: Zs(r2, Math.max(n2, e2)), alignment: e2 };
          }
          function Zs(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          class Ks2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
            }
          }
          Ks2.prototype.bytesPerElement = 4, is2("StructArrayLayout2i4", Ks2);
          class Xs extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          Xs.prototype.bytesPerElement = 6, is2("StructArrayLayout3i6", Xs);
          class Hs2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
            }
          }
          Hs2.prototype.bytesPerElement = 8, is2("StructArrayLayout4i8", Hs2);
          class Ys extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          Ys.prototype.bytesPerElement = 12, is2("StructArrayLayout2i4i12", Ys);
          class Js extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 4 * t2, l2 = 8 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
            }
          }
          Js.prototype.bytesPerElement = 8, is2("StructArrayLayout2i4ub8", Js);
          class Ws extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
            }
          }
          Ws.prototype.bytesPerElement = 8, is2("StructArrayLayout2f8", Ws);
          class Qs extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = this.length;
              return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
              const h3 = 10 * t2;
              return this.uint16[h3 + 0] = e2, this.uint16[h3 + 1] = r2, this.uint16[h3 + 2] = n2, this.uint16[h3 + 3] = i2, this.uint16[h3 + 4] = s2, this.uint16[h3 + 5] = a2, this.uint16[h3 + 6] = o2, this.uint16[h3 + 7] = l2, this.uint16[h3 + 8] = u2, this.uint16[h3 + 9] = c2, t2;
            }
          }
          Qs.prototype.bytesPerElement = 20, is2("StructArrayLayout10ui20", Qs);
          class ta2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2) {
              const f2 = 12 * t2;
              return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h3, this.int16[f2 + 11] = p2, t2;
            }
          }
          ta2.prototype.bytesPerElement = 24, is2("StructArrayLayout4i4ui4i24", ta2);
          class ea2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          ea2.prototype.bytesPerElement = 12, is2("StructArrayLayout3f12", ea2);
          class ra2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint32[1 * t2 + 0] = e2, t2;
            }
          }
          ra2.prototype.bytesPerElement = 4, is2("StructArrayLayout1ul4", ra2);
          class na2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = this.length;
              return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = 10 * t2, h3 = 5 * t2;
              return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h3 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
            }
          }
          na2.prototype.bytesPerElement = 20, is2("StructArrayLayout6i1ul2ui20", na2);
          class ia2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
            }
          }
          ia2.prototype.bytesPerElement = 12, is2("StructArrayLayout2i2i2i12", ia2);
          class sa2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const a2 = 4 * t2, o2 = 8 * t2;
              return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
            }
          }
          sa2.prototype.bytesPerElement = 16, is2("StructArrayLayout2f1f2i16", sa2);
          class aa2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = 16 * t2, l2 = 4 * t2, u2 = 8 * t2;
              return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.int16[u2 + 6] = s2, this.int16[u2 + 7] = a2, t2;
            }
          }
          aa2.prototype.bytesPerElement = 16, is2("StructArrayLayout2ub2f2i16", aa2);
          class oa2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
            }
          }
          oa2.prototype.bytesPerElement = 6, is2("StructArrayLayout3ui6", oa2);
          class la2 extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2) {
              const g3 = this.length;
              return this.resize(g3 + 1), this.emplace(g3, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2, g3) {
              const x3 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
              return this.int16[x3 + 0] = e2, this.int16[x3 + 1] = r2, this.uint16[x3 + 2] = n2, this.uint16[x3 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x3 + 10] = l2, this.uint16[x3 + 11] = u2, this.uint16[x3 + 12] = c2, this.float32[v2 + 7] = h3, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x3 + 22] = g3, t2;
            }
          }
          la2.prototype.bytesPerElement = 48, is2("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", la2);
          class ua extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2, g3, x3, v2, b2, w2, _3, A3, S3, k2, M3, I3) {
              const z2 = this.length;
              return this.resize(z2 + 1), this.emplace(z2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2, g3, x3, v2, b2, w2, _3, A3, S3, k2, M3, I3);
            }
            emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2, g3, x3, v2, b2, w2, _3, A3, S3, k2, M3, I3, z2) {
              const P2 = 32 * t2, C3 = 16 * t2;
              return this.int16[P2 + 0] = e2, this.int16[P2 + 1] = r2, this.int16[P2 + 2] = n2, this.int16[P2 + 3] = i2, this.int16[P2 + 4] = s2, this.int16[P2 + 5] = a2, this.int16[P2 + 6] = o2, this.int16[P2 + 7] = l2, this.uint16[P2 + 8] = u2, this.uint16[P2 + 9] = c2, this.uint16[P2 + 10] = h3, this.uint16[P2 + 11] = p2, this.uint16[P2 + 12] = f2, this.uint16[P2 + 13] = d2, this.uint16[P2 + 14] = y2, this.uint16[P2 + 15] = m2, this.uint16[P2 + 16] = g3, this.uint16[P2 + 17] = x3, this.uint16[P2 + 18] = v2, this.uint16[P2 + 19] = b2, this.uint16[P2 + 20] = w2, this.uint16[P2 + 21] = _3, this.uint16[P2 + 22] = A3, this.uint32[C3 + 12] = S3, this.float32[C3 + 13] = k2, this.float32[C3 + 14] = M3, this.uint16[P2 + 30] = I3, this.uint16[P2 + 31] = z2, t2;
            }
          }
          ua.prototype.bytesPerElement = 64, is2("StructArrayLayout8i15ui1ul2f2ui64", ua);
          class ca extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.float32[1 * t2 + 0] = e2, t2;
            }
          }
          ca.prototype.bytesPerElement = 4, is2("StructArrayLayout1f4", ca);
          class ha extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          ha.prototype.bytesPerElement = 12, is2("StructArrayLayout1ui2f12", ha);
          class pa extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 4 * t2;
              return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
            }
          }
          pa.prototype.bytesPerElement = 8, is2("StructArrayLayout1ul2ui8", pa);
          class fa extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
            }
          }
          fa.prototype.bytesPerElement = 4, is2("StructArrayLayout2ui4", fa);
          class da extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint16[1 * t2 + 0] = e2, t2;
            }
          }
          da.prototype.bytesPerElement = 2, is2("StructArrayLayout1ui2", da);
          class ya extends qs2 {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
            }
          }
          ya.prototype.bytesPerElement = 16, is2("StructArrayLayout4f16", ya);
          class ma extends Us2 {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
              return new l(this.anchorPointX, this.anchorPointY);
            }
          }
          ma.prototype.size = 20;
          class ga extends na2 {
            get(t2) {
              return new ma(this, t2);
            }
          }
          is2("CollisionBoxArray", ga);
          class xa extends Us2 {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 37] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 38] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 10] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 22];
            }
          }
          xa.prototype.size = 48;
          class va extends la2 {
            get(t2) {
              return new xa(this, t2);
            }
          }
          is2("PlacedSymbolArray", va);
          class ba extends Us2 {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 12] = t2;
            }
            get textBoxScale() {
              return this._structArray.float32[this._pos4 + 13];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textAnchorOffsetStartIndex() {
              return this._structArray.uint16[this._pos2 + 30];
            }
            get textAnchorOffsetEndIndex() {
              return this._structArray.uint16[this._pos2 + 31];
            }
          }
          ba.prototype.size = 64;
          class wa extends ua {
            get(t2) {
              return new ba(this, t2);
            }
          }
          is2("SymbolInstanceArray", wa);
          class _a2 extends ca {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          is2("GlyphOffsetArray", _a2);
          class Aa extends Xs {
            getx(t2) {
              return this.int16[3 * t2 + 0];
            }
            gety(t2) {
              return this.int16[3 * t2 + 1];
            }
            gettileUnitDistanceFromAnchor(t2) {
              return this.int16[3 * t2 + 2];
            }
          }
          is2("SymbolLineVertexArray", Aa);
          class Sa2 extends Us2 {
            get textAnchor() {
              return this._structArray.uint16[this._pos2 + 0];
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 2];
            }
          }
          Sa2.prototype.size = 12;
          class ka extends ha {
            get(t2) {
              return new Sa2(this, t2);
            }
          }
          is2("TextAnchorOffsetArray", ka);
          class Ma extends Us2 {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
          }
          Ma.prototype.size = 8;
          class Ia extends pa {
            get(t2) {
              return new Ma(this, t2);
            }
          }
          is2("FeatureIndexArray", Ia);
          class za2 extends Ks2 {
          }
          class Pa extends Ks2 {
          }
          class Ca extends Ks2 {
          }
          class Ba2 extends Ys {
          }
          class Va2 extends Js {
          }
          class Ea extends Ws {
          }
          class Ta extends Qs {
          }
          class Fa extends ta2 {
          }
          class $a extends ea2 {
          }
          class La extends ra2 {
          }
          class Oa2 extends ia2 {
          }
          class Da extends aa2 {
          }
          class ja extends oa2 {
          }
          class Ra extends fa {
          }
          const Na = Gs2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ua2 } = Na;
          class qa2 {
            constructor(t2 = []) {
              this._forceNewSegmentOnNextPrepare = false, this.segments = t2;
            }
            prepareSegment(t2, e2, r2, n2) {
              const i2 = this.segments[this.segments.length - 1];
              return t2 > qa2.MAX_VERTEX_ARRAY_LENGTH && U(`Max vertices per segment is ${qa2.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${qa2.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i2 || i2.vertexLength + t2 > qa2.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2 ? this.createNewSegment(e2, r2, n2) : i2;
            }
            createNewSegment(t2, e2, r2) {
              const n2 = { vertexOffset: t2.length, primitiveOffset: e2.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
              return void 0 !== r2 && (n2.sortKey = r2), this._forceNewSegmentOnNextPrepare = false, this.segments.push(n2), n2;
            }
            getOrCreateLatestSegment(t2, e2, r2) {
              return this.prepareSegment(0, t2, e2, r2);
            }
            forceNewSegmentOnNextPrepare() {
              this._forceNewSegmentOnNextPrepare = true;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments) for (const e2 in t2.vaos) t2.vaos[e2].destroy();
            }
            static simpleSegment(t2, e2, r2, n2) {
              return new qa2([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          function Ga2(t2, e2) {
            return 256 * (t2 = F2(Math.floor(t2), 0, 255)) + F2(Math.floor(e2), 0, 255);
          }
          qa2.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, is2("SegmentVector", qa2);
          const Za2 = Gs2([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
          var Ka2, Xa2, Ha2, Ya2 = { exports: {} }, Ja = { exports: {} }, Wa2 = { exports: {} }, Qa2 = function() {
            if (Ha2) return Ya2.exports;
            Ha2 = 1;
            var t2 = (Ka2 || (Ka2 = 1, Ja.exports = function(t3, e3) {
              var r2, n2, i2, s2, a2, o2, l2, u2;
              for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e3, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; ) l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
              switch (l2 = 0, r2) {
                case 3:
                  l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
                case 2:
                  l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
                case 1:
                  i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
              }
              return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
            }), Ja.exports), e2 = (Xa2 || (Xa2 = 1, Wa2.exports = function(t3, e3) {
              for (var r2, n2 = t3.length, i2 = e3 ^ n2, s2 = 0; n2 >= 4; ) r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
              switch (n2) {
                case 3:
                  i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
                case 2:
                  i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
                case 1:
                  i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
              }
              return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
            }), Wa2.exports);
            return Ya2.exports = t2, Ya2.exports.murmur3 = t2, Ya2.exports.murmur2 = e2, Ya2.exports;
          }(), to2 = r(Qa2);
          class eo2 {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t2, e2, r2, n2) {
              this.ids.push(ro2(t2)), this.positions.push(e2, r2, n2);
            }
            getPositions(t2) {
              if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
              const e2 = ro2(t2);
              let r2 = 0, n2 = this.ids.length - 1;
              for (; r2 < n2; ) {
                const t3 = r2 + n2 >> 1;
                this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
              }
              const i2 = [];
              for (; this.ids[r2] === e2; ) i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
              return i2;
            }
            static serialize(t2, e2) {
              const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return no2(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
            }
            static deserialize(t2) {
              const e2 = new eo2();
              return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
            }
          }
          function ro2(t2) {
            const e2 = +t2;
            return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : to2(String(t2));
          }
          function no2(t2, e2, r2, n2) {
            for (; r2 < n2; ) {
              const i2 = t2[r2 + n2 >> 1];
              let s2 = r2 - 1, a2 = n2 + 1;
              for (; ; ) {
                do {
                  s2++;
                } while (t2[s2] < i2);
                do {
                  a2--;
                } while (t2[a2] > i2);
                if (s2 >= a2) break;
                io2(t2, s2, a2), io2(e2, 3 * s2, 3 * a2), io2(e2, 3 * s2 + 1, 3 * a2 + 1), io2(e2, 3 * s2 + 2, 3 * a2 + 2);
              }
              a2 - r2 < n2 - a2 ? (no2(t2, e2, r2, a2), r2 = a2 + 1) : (no2(t2, e2, a2 + 1, n2), n2 = a2);
            }
          }
          function io2(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          is2("FeaturePositionMap", eo2);
          class so2 {
            constructor(t2, e2) {
              this.gl = t2.gl, this.location = e2;
            }
          }
          class ao2 extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
            }
          }
          class oo2 extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
            }
          }
          class lo2 extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = ke2.transparent;
            }
            set(t2) {
              t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
            }
          }
          const uo2 = new Float32Array(16);
          function co2(t2) {
            return [Ga2(255 * t2.r, 255 * t2.g), Ga2(255 * t2.b, 255 * t2.a)];
          }
          class ho2 {
            constructor(t2, e2, r2) {
              this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
            }
            setUniform(t2, e2, r2) {
              t2.set(r2.constantOr(this.value));
            }
            getBinding(t2, e2, r2) {
              return "color" === this.type ? new lo2(t2, e2) : new ao2(t2, e2);
            }
          }
          class po2 {
            constructor(t2, e2) {
              this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t2, e2) {
              this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
            }
            setUniform(t2, e2, r2, n2) {
              const i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
              i2 && t2.set(i2);
            }
            getBinding(t2, e2, r2) {
              return "u_pattern" === r2.substr(0, 9) ? new oo2(t2, e2) : new ao2(t2, e2);
            }
          }
          class fo2 {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2, n2, i2) {
              const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new ks2(0), e2, {}, n2, [], i2);
              this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
            }
            updatePaintArray(t2, e2, r2, n2) {
              const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
              this._setPaintValue(t2, e2, i2);
            }
            _setPaintValue(t2, e2, r2) {
              if ("color" === this.type) {
                const n2 = co2(r2);
                for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, n2[0], n2[1]);
              } else {
                for (let n2 = t2; n2 < e2; n2++) this.paintVertexArray.emplace(n2, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class yo2 {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r2, n2, i2) {
              const s2 = this.expression.evaluate(new ks2(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new ks2(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
            }
            updatePaintArray(t2, e2, r2, n2) {
              const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
              this._setPaintValue(t2, e2, i2, s2);
            }
            _setPaintValue(t2, e2, r2, n2) {
              if ("color" === this.type) {
                const i2 = co2(r2), s2 = co2(n2);
                for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
              } else {
                for (let i2 = t2; i2 < e2; i2++) this.paintVertexArray.emplace(i2, r2, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e2) {
              const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = F2(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
              t2.set(n2);
            }
            getBinding(t2, e2, r2) {
              return new ao2(t2, e2);
            }
          }
          class mo2 {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
            }
            populatePaintArray(t2, e2, r2) {
              const n2 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
            }
            updatePaintArray(t2, e2, r2, n2, i2) {
              this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
            }
            _setPaintValues(t2, e2, r2, n2) {
              if (!n2 || !r2) return;
              const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
              if (o2 && l2 && u2) for (let r3 = t2; r3 < e2; r3++) this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
            }
            upload(t2) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, Za2.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, Za2.members, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class go2 {
            constructor(t2, e2, r2) {
              this.binders = {}, this._buffers = [];
              const n2 = [];
              for (const i2 in t2.paint._values) {
                if (!r2(i2)) continue;
                const s2 = t2.paint.get(i2);
                if (!(s2 instanceof Vs2 && Rn2(s2.property.specification))) continue;
                const a2 = vo2(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h3 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
                if ("constant" === o2.kind) this.binders[i2] = h3 ? new po2(o2.value, a2) : new ho2(o2.value, a2, l2), n2.push(`/u_${i2}`);
                else if ("source" === o2.kind || h3) {
                  const r3 = bo2(i2, l2, "source");
                  this.binders[i2] = h3 ? new mo2(o2, l2, u2, e2, r3, t2.id) : new fo2(o2, a2, l2, r3), n2.push(`/a_${i2}`);
                } else {
                  const t3 = bo2(i2, l2, "composite");
                  this.binders[i2] = new yo2(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
                }
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof fo2 || e2 instanceof yo2 ? e2.maxValue : 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2) {
              for (const s2 in this.binders) {
                const a2 = this.binders[s2];
                (a2 instanceof fo2 || a2 instanceof yo2 || a2 instanceof mo2) && a2.populatePaintArray(t2, e2, r2, n2, i2);
              }
            }
            setConstantPatternPositions(t2, e2) {
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                n2 instanceof po2 && n2.setConstantPatternPositions(t2, e2);
              }
            }
            updatePaintArrays(t2, e2, r2, n2, i2) {
              let s2 = false;
              for (const a2 in t2) {
                const o2 = e2.getPositions(a2);
                for (const e3 of o2) {
                  const o3 = r2.feature(e3.index);
                  for (const r3 in this.binders) {
                    const l2 = this.binders[r3];
                    if ((l2 instanceof fo2 || l2 instanceof yo2 || l2 instanceof mo2) && true === l2.expression.isStateDependent) {
                      const u2 = n2.paint.get(r3);
                      l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                    }
                  }
                }
              }
              return s2;
            }
            defines() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof ho2 || r2 instanceof po2) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof fo2 || r2 instanceof yo2) for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++) t2.push(r2.paintVertexAttributes[e3].name);
                else if (r2 instanceof mo2) for (let e3 = 0; e3 < Za2.members.length; e3++) t2.push(Za2.members[e3].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof ho2 || r2 instanceof po2 || r2 instanceof yo2) for (const e3 of r2.uniformNames) t2.push(e3);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2, e2) {
              const r2 = [];
              for (const n2 in this.binders) {
                const i2 = this.binders[n2];
                if (i2 instanceof ho2 || i2 instanceof po2 || i2 instanceof yo2) {
                  for (const s2 of i2.uniformNames) if (e2[s2]) {
                    const a2 = i2.getBinding(t2, e2[s2], s2);
                    r2.push({ name: s2, property: n2, binding: a2 });
                  }
                }
              }
              return r2;
            }
            setUniforms(t2, e2, r2, n2) {
              for (const { name: t3, property: i2, binding: s2 } of e2) this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
            }
            updatePaintBuffers(t2) {
              this._buffers = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (t2 && r2 instanceof mo2) {
                  const e3 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                  e3 && this._buffers.push(e3);
                } else (r2 instanceof fo2 || r2 instanceof yo2) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
              }
            }
            upload(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof fo2 || r2 instanceof yo2 || r2 instanceof mo2) && r2.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof fo2 || e2 instanceof yo2 || e2 instanceof mo2) && e2.destroy();
              }
            }
          }
          class xo2 {
            constructor(t2, e2, r2 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2) this.programConfigurations[n2.id] = new go2(n2, e2, r2);
              this.needsUpload = false, this._featureMap = new eo2(), this._bufferOffset = 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2) {
              for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
              void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e2, r2, n2) {
              for (const i2 of r2) this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations) this.programConfigurations[t2].destroy();
            }
          }
          function vo2(t2, e2) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
          }
          function bo2(t2, e2, r2) {
            const n2 = { color: { source: Ws, composite: ya }, number: { source: ca, composite: Ws } }, i2 = function(t3) {
              return { "line-pattern": { source: Ta, composite: Ta }, "fill-pattern": { source: Ta, composite: Ta }, "fill-extrusion-pattern": { source: Ta, composite: Ta } }[t3];
            }(t2);
            return i2 && i2[r2] || n2[e2][r2];
          }
          is2("ConstantBinder", ho2), is2("CrossFadedConstantBinder", po2), is2("SourceExpressionBinder", fo2), is2("CrossFadedCompositeBinder", mo2), is2("CompositeExpressionBinder", yo2), is2("ProgramConfiguration", go2, { omit: ["_buffers"] }), is2("ProgramConfigurationSet", xo2);
          const wo2 = Math.pow(2, 14) - 1, _o2 = -wo2 - 1;
          function Ao2(t2) {
            const e2 = z / t2.extent, r2 = t2.loadGeometry();
            for (let t3 = 0; t3 < r2.length; t3++) {
              const n2 = r2[t3];
              for (let t4 = 0; t4 < n2.length; t4++) {
                const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
                r3.x = F2(i2, _o2, wo2), r3.y = F2(s2, _o2, wo2), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && U("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r2;
          }
          function So2(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ao2(t2) : [] };
          }
          const ko2 = -32768;
          function Mo2(t2, e2, r2, n2, i2) {
            t2.emplaceBack(ko2 + 8 * e2 + n2, ko2 + 8 * r2 + i2);
          }
          class Io2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Pa(), this.indexArray = new ja(), this.segments = new qa2(), this.programConfigurations = new xo2(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              const n2 = this.layers[0], i2 = [];
              let s2 = null, a2 = false, o2 = "heatmap" === n2.type;
              if ("circle" === n2.type) {
                const t3 = n2;
                s2 = t3.layout.get("circle-sort-key"), a2 = !s2.isConstant(), o2 = o2 || "map" === t3.paint.get("circle-pitch-alignment");
              }
              const l2 = o2 ? e2.subdivisionGranularity.circle : 1;
              for (const { feature: e3, id: n3, index: o3, sourceLayerIndex: l3 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = So2(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new ks2(this.zoom), u2, r2)) continue;
                const c2 = a2 ? s2.evaluate(u2, {}, r2) : void 0, h3 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u2.geometry : Ao2(e3), patterns: {}, sortKey: c2 };
                i2.push(h3);
              }
              a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of i2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o3 = t2[s3].feature;
                this.addFeature(n3, i3, s3, r2, l2), e2.featureIndex.insert(o3, i3, s3, a3, this.index);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ua2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r2, n2, i2 = 1) {
              let s2;
              switch (i2) {
                case 1:
                  s2 = [0, 7];
                  break;
                case 3:
                  s2 = [0, 2, 5, 7];
                  break;
                case 5:
                  s2 = [0, 1, 3, 4, 6, 7];
                  break;
                case 7:
                  s2 = [0, 1, 2, 3, 4, 5, 6, 7];
                  break;
                default:
                  throw new Error(`Invalid circle bucket granularity: ${i2}; valid values are 1, 3, 5, 7.`);
              }
              const a2 = s2.length;
              for (const r3 of e2) for (const e3 of r3) {
                const r4 = e3.x, n3 = e3.y;
                if (r4 < 0 || r4 >= z || n3 < 0 || n3 >= z) continue;
                const i3 = this.segments.prepareSegment(a2 * a2, this.layoutVertexArray, this.indexArray, t2.sortKey), o2 = i3.vertexLength;
                for (let t3 = 0; t3 < a2; t3++) for (let e4 = 0; e4 < a2; e4++) Mo2(this.layoutVertexArray, r4, n3, s2[e4], s2[t3]);
                for (let t3 = 0; t3 < a2 - 1; t3++) for (let e4 = 0; e4 < a2 - 1; e4++) {
                  const r5 = o2 + t3 * a2 + e4, n4 = o2 + (t3 + 1) * a2 + e4;
                  this.indexArray.emplaceBack(r5, n4 + 1, r5 + 1), this.indexArray.emplaceBack(r5, n4, n4 + 1);
                }
                i3.vertexLength += a2 * a2, i3.primitiveLength += (a2 - 1) * (a2 - 1) * 2;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
            }
          }
          function zo2(t2, e2) {
            for (let r2 = 0; r2 < t2.length; r2++) if (Lo2(e2, t2[r2])) return true;
            for (let r2 = 0; r2 < e2.length; r2++) if (Lo2(t2, e2[r2])) return true;
            return !!Vo2(t2, e2);
          }
          function Po2(t2, e2, r2) {
            return !!Lo2(t2, e2) || !!To2(e2, t2, r2);
          }
          function Co2(t2, e2) {
            if (1 === t2.length) return $o2(e2, t2[0]);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const n2 = e2[r2];
              for (let e3 = 0; e3 < n2.length; e3++) if (Lo2(t2, n2[e3])) return true;
            }
            for (let r2 = 0; r2 < t2.length; r2++) if ($o2(e2, t2[r2])) return true;
            for (let r2 = 0; r2 < e2.length; r2++) if (Vo2(t2, e2[r2])) return true;
            return false;
          }
          function Bo2(t2, e2, r2) {
            if (t2.length > 1) {
              if (Vo2(t2, e2)) return true;
              for (let n2 = 0; n2 < e2.length; n2++) if (To2(e2[n2], t2, r2)) return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++) if (To2(t2[n2], e2, r2)) return true;
            return false;
          }
          function Vo2(t2, e2) {
            if (0 === t2.length || 0 === e2.length) return false;
            for (let r2 = 0; r2 < t2.length - 1; r2++) {
              const n2 = t2[r2], i2 = t2[r2 + 1];
              for (let t3 = 0; t3 < e2.length - 1; t3++) if (Eo2(n2, i2, e2[t3], e2[t3 + 1])) return true;
            }
            return false;
          }
          function Eo2(t2, e2, r2, n2) {
            return q2(t2, r2, n2) !== q2(e2, r2, n2) && q2(t2, e2, r2) !== q2(t2, e2, n2);
          }
          function To2(t2, e2, r2) {
            const n2 = r2 * r2;
            if (1 === e2.length) return t2.distSqr(e2[0]) < n2;
            for (let r3 = 1; r3 < e2.length; r3++) if (Fo2(t2, e2[r3 - 1], e2[r3]) < n2) return true;
            return false;
          }
          function Fo2(t2, e2, r2) {
            const n2 = e2.distSqr(r2);
            if (0 === n2) return t2.distSqr(e2);
            const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
          }
          function $o2(t2, e2) {
            for (let r2 = 0; r2 < t2.length; r2++) if (Lo2(t2[r2], e2)) return true;
            return false;
          }
          function Lo2(t2, e2) {
            let r2 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const s2 = t2[n2], a2 = t2[i2];
              s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
            }
            return r2;
          }
          function Oo2(t2, e2, r2) {
            const n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y) return false;
            const s2 = q2(t2, e2, r2[0]);
            return s2 !== q2(t2, e2, r2[1]) || s2 !== q2(t2, e2, r2[2]) || s2 !== q2(t2, e2, r2[3]);
          }
          function Do2(t2, e2, r2) {
            const n2 = e2.paint.get(t2).value;
            return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function jo2(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function Ro2(t2, e2, r2, n2, i2) {
            if (!e2[0] && !e2[1]) return t2;
            const s2 = l.convert(e2)._mult(i2);
            "viewport" === r2 && s2._rotate(-n2);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3++) a2.push(t2[e3].sub(s2));
            return a2;
          }
          let No2, Uo2;
          is2("CircleBucket", Io2, { omit: ["layers"] });
          var qo2 = { get paint() {
            return Uo2 = Uo2 || new Ds2({ "circle-radius": new Fs2(gt2.paint_circle["circle-radius"]), "circle-color": new Fs2(gt2.paint_circle["circle-color"]), "circle-blur": new Fs2(gt2.paint_circle["circle-blur"]), "circle-opacity": new Fs2(gt2.paint_circle["circle-opacity"]), "circle-translate": new Ts2(gt2.paint_circle["circle-translate"]), "circle-translate-anchor": new Ts2(gt2.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ts2(gt2.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ts2(gt2.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Fs2(gt2.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Fs2(gt2.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Fs2(gt2.paint_circle["circle-stroke-opacity"]) });
          }, get layout() {
            return No2 = No2 || new Ds2({ "circle-sort-key": new Fs2(gt2.layout_circle["circle-sort-key"]) });
          } };
          class Go2 extends Rs2 {
            constructor(t2) {
              super(t2, qo2);
            }
            createBucket(t2) {
              return new Io2(t2);
            }
            queryRadius(t2) {
              const e2 = t2;
              return Do2("circle-radius", this, e2) + Do2("circle-stroke-width", this, e2) + jo2(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, unwrappedTileID: a2, getElevation: o2 }) {
              const l2 = Ro2(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i2.bearingInRadians, s2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = "map" === this.paint.get("circle-pitch-alignment"), h3 = c2 ? l2 : function(t3, e3, r3, n3) {
                return t3.map((t4) => Zo2(t4, e3, r3, n3));
              }(l2, i2, a2, o2), p2 = c2 ? u2 * s2 : u2;
              for (const t3 of n2) for (const e3 of t3) {
                const t4 = c2 ? e3 : Zo2(e3, i2, a2, o2);
                let r3 = p2;
                const n3 = i2.projectTileCoordinates(e3.x, e3.y, a2, o2).signedDistanceFromCamera;
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n3 / i2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= i2.cameraToCenterDistance / n3), Po2(h3, t4, r3)) return true;
              }
              return false;
            }
          }
          function Zo2(t2, e2, r2, n2) {
            const i2 = e2.projectTileCoordinates(t2.x, t2.y, r2, n2).point;
            return new l((0.5 * i2.x + 0.5) * e2.width, (0.5 * -i2.y + 0.5) * e2.height);
          }
          class Ko2 extends Io2 {
          }
          let Xo2;
          is2("HeatmapBucket", Ko2, { omit: ["layers"] });
          var Ho2 = { get paint() {
            return Xo2 = Xo2 || new Ds2({ "heatmap-radius": new Fs2(gt2.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Fs2(gt2.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ts2(gt2.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Os2(gt2.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ts2(gt2.paint_heatmap["heatmap-opacity"]) });
          } };
          function Yo2(t2, { width: e2, height: r2 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e2 * r2 * n2) throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
            } else i2 = new Uint8Array(e2 * r2 * n2);
            return t2.width = e2, t2.height = r2, t2.data = i2, t2;
          }
          function Jo2(t2, { width: e2, height: r2 }, n2) {
            if (e2 === t2.width && r2 === t2.height) return;
            const i2 = Yo2({}, { width: e2, height: r2 }, n2);
            Wo2(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
          }
          function Wo2(t2, e2, r2, n2, i2, s2) {
            if (0 === i2.width || 0 === i2.height) return e2;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
            const a2 = t2.data, o2 = e2.data;
            if (a2 === o2) throw new Error("srcData equals dstData, so image is already copied");
            for (let l2 = 0; l2 < i2.height; l2++) {
              const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
              for (let t3 = 0; t3 < i2.width * s2; t3++) o2[c2 + t3] = a2[u2 + t3];
            }
            return e2;
          }
          class Qo2 {
            constructor(t2, e2) {
              Yo2(this, t2, 1, e2);
            }
            resize(t2) {
              Jo2(this, t2, 1);
            }
            clone() {
              return new Qo2({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              Wo2(t2, e2, r2, n2, i2, 1);
            }
          }
          class tl {
            constructor(t2, e2) {
              Yo2(this, t2, 4, e2);
            }
            resize(t2) {
              Jo2(this, t2, 4);
            }
            replace(t2, e2) {
              e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new tl({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              Wo2(t2, e2, r2, n2, i2, 4);
            }
          }
          function el(t2) {
            const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new tl({ width: r2, height: n2 });
            if (Math.log(r2) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r2}`);
            const s2 = (r3, n3, s3) => {
              e2[t2.evaluationKey] = s3;
              const a2 = t2.expression.evaluate(e2);
              i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
            };
            if (t2.clips) for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2) for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
              s2(i3, a2, l2 * (1 - o2) + u2 * o2);
            }
            else for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4) s2(0, e3, t3 / (r2 - 1));
            return i2;
          }
          is2("AlphaImage", Qo2), is2("RGBAImage", tl);
          const rl = "big-fb";
          class nl extends Rs2 {
            createBucket(t2) {
              return new Ko2(t2);
            }
            constructor(t2) {
              super(t2, Ho2), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "heatmap-color" === t2 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = el({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbos.has(rl) && this.heatmapFbos.delete(rl);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
          }
          let il;
          var sl = { get paint() {
            return il = il || new Ds2({ "hillshade-illumination-direction": new Ts2(gt2.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-altitude": new Ts2(gt2.paint_hillshade["hillshade-illumination-altitude"]), "hillshade-illumination-anchor": new Ts2(gt2.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ts2(gt2.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ts2(gt2.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ts2(gt2.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ts2(gt2.paint_hillshade["hillshade-accent-color"]), "hillshade-method": new Ts2(gt2.paint_hillshade["hillshade-method"]) });
          } };
          class al2 extends Rs2 {
            constructor(t2) {
              super(t2, sl), this.recalculate({ zoom: 0, zoomHistory: {} }, void 0);
            }
            getIlluminationProperties() {
              let t2 = this.paint.get("hillshade-illumination-direction").values, e2 = this.paint.get("hillshade-illumination-altitude").values, r2 = this.paint.get("hillshade-highlight-color").values, n2 = this.paint.get("hillshade-shadow-color").values;
              const i2 = Math.max(t2.length, e2.length, r2.length, n2.length);
              t2 = t2.concat(Array(i2 - t2.length).fill(t2.at(-1))), e2 = e2.concat(Array(i2 - e2.length).fill(e2.at(-1))), r2 = r2.concat(Array(i2 - r2.length).fill(r2.at(-1))), n2 = n2.concat(Array(i2 - n2.length).fill(n2.at(-1)));
              const s2 = e2.map(Q2);
              return { directionRadians: t2.map(Q2), altitudeRadians: s2, shadowColor: n2, highlightColor: r2 };
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
          }
          const ol = Gs2([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: ll } = ol;
          function ul(t2, e2, r2) {
            const n2 = r2.patternDependencies;
            let i2 = false;
            for (const r3 of e2) {
              const e3 = r3.paint.get(`${t2}-pattern`);
              e3.isConstant() || (i2 = true);
              const s2 = e3.constantOr(null);
              s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
            }
            return i2;
          }
          function cl(t2, e2, r2, n2, i2) {
            const s2 = i2.patternDependencies;
            for (const a2 of e2) {
              const e3 = a2.paint.get(`${t2}-pattern`).value;
              if ("constant" !== e3.kind) {
                let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
              }
            }
            return r2;
          }
          function hl(t2, e2, r2, n2, i2) {
            let s2;
            if (i2 === function(t3, e3, r3, n3) {
              let i3 = 0;
              for (let s3 = e3, a2 = r3 - n3; s3 < r3; s3 += n3) i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
              return i3;
            }(t2, e2, r2, n2) > 0) for (let i3 = e2; i3 < r2; i3 += n2) s2 = El2(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
            else for (let i3 = r2 - n2; i3 >= e2; i3 -= n2) s2 = El2(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
            return s2 && Il2(s2, s2.next) && (Tl2(s2), s2 = s2.next), s2;
          }
          function pl(t2, e2) {
            if (!t2) return t2;
            e2 || (e2 = t2);
            let r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !Il2(n2, n2.next) && 0 !== Ml2(n2.prev, n2, n2.next)) n2 = n2.next;
              else {
                if (Tl2(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
                r2 = true;
              }
            } while (r2 || n2 !== e2);
            return e2;
          }
          function fl(t2, e2, r2, n2, i2, s2, a2) {
            if (!t2) return;
            !a2 && s2 && function(t3, e3, r3, n3) {
              let i3 = t3;
              do {
                0 === i3.z && (i3.z = wl2(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                let e4, r4 = 1;
                do {
                  let n4, i4 = t4;
                  t4 = null;
                  let s3 = null;
                  for (e4 = 0; i4; ) {
                    e4++;
                    let a3 = i4, o3 = 0;
                    for (let t5 = 0; t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++) ;
                    let l2 = r4;
                    for (; o3 > 0 || l2 > 0 && a3; ) 0 !== o3 && (0 === l2 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                    i4 = a3;
                  }
                  s3.nextZ = null, r4 *= 2;
                } while (e4 > 1);
              }(i3);
            }(t2, n2, i2, s2);
            let o2 = t2;
            for (; t2.prev !== t2.next; ) {
              const l2 = t2.prev, u2 = t2.next;
              if (s2 ? yl(t2, n2, i2, s2) : dl(t2)) e2.push(l2.i, t2.i, u2.i), Tl2(t2), t2 = u2.next, o2 = u2.next;
              else if ((t2 = u2) === o2) {
                a2 ? 1 === a2 ? fl(t2 = ml(pl(t2), e2), e2, r2, n2, i2, s2, 2) : 2 === a2 && gl2(t2, e2, r2, n2, i2, s2) : fl(pl(t2), e2, r2, n2, i2, s2, 1);
                break;
              }
            }
          }
          function dl(t2) {
            const e2 = t2.prev, r2 = t2, n2 = t2.next;
            if (Ml2(e2, r2, n2) >= 0) return false;
            const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = Math.min(i2, s2, a2), h3 = Math.min(o2, l2, u2), p2 = Math.max(i2, s2, a2), f2 = Math.max(o2, l2, u2);
            let d2 = n2.next;
            for (; d2 !== e2; ) {
              if (d2.x >= c2 && d2.x <= p2 && d2.y >= h3 && d2.y <= f2 && Sl2(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && Ml2(d2.prev, d2, d2.next) >= 0) return false;
              d2 = d2.next;
            }
            return true;
          }
          function yl(t2, e2, r2, n2) {
            const i2 = t2.prev, s2 = t2, a2 = t2.next;
            if (Ml2(i2, s2, a2) >= 0) return false;
            const o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h3 = s2.y, p2 = a2.y, f2 = Math.min(o2, l2, u2), d2 = Math.min(c2, h3, p2), y2 = Math.max(o2, l2, u2), m2 = Math.max(c2, h3, p2), g3 = wl2(f2, d2, e2, r2, n2), x3 = wl2(y2, m2, e2, r2, n2);
            let v2 = t2.prevZ, b2 = t2.nextZ;
            for (; v2 && v2.z >= g3 && b2 && b2.z <= x3; ) {
              if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Sl2(o2, c2, l2, h3, u2, p2, v2.x, v2.y) && Ml2(v2.prev, v2, v2.next) >= 0) return false;
              if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Sl2(o2, c2, l2, h3, u2, p2, b2.x, b2.y) && Ml2(b2.prev, b2, b2.next) >= 0) return false;
              b2 = b2.nextZ;
            }
            for (; v2 && v2.z >= g3; ) {
              if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Sl2(o2, c2, l2, h3, u2, p2, v2.x, v2.y) && Ml2(v2.prev, v2, v2.next) >= 0) return false;
              v2 = v2.prevZ;
            }
            for (; b2 && b2.z <= x3; ) {
              if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Sl2(o2, c2, l2, h3, u2, p2, b2.x, b2.y) && Ml2(b2.prev, b2, b2.next) >= 0) return false;
              b2 = b2.nextZ;
            }
            return true;
          }
          function ml(t2, e2) {
            let r2 = t2;
            do {
              const n2 = r2.prev, i2 = r2.next.next;
              !Il2(n2, i2) && zl2(n2, r2, r2.next, i2) && Bl2(n2, i2) && Bl2(i2, n2) && (e2.push(n2.i, r2.i, i2.i), Tl2(r2), Tl2(r2.next), r2 = t2 = i2), r2 = r2.next;
            } while (r2 !== t2);
            return pl(r2);
          }
          function gl2(t2, e2, r2, n2, i2, s2) {
            let a2 = t2;
            do {
              let t3 = a2.next.next;
              for (; t3 !== a2.prev; ) {
                if (a2.i !== t3.i && kl2(a2, t3)) {
                  let o2 = Vl2(a2, t3);
                  return a2 = pl(a2, a2.next), o2 = pl(o2, o2.next), fl(a2, e2, r2, n2, i2, s2, 0), void fl(o2, e2, r2, n2, i2, s2, 0);
                }
                t3 = t3.next;
              }
              a2 = a2.next;
            } while (a2 !== t2);
          }
          function xl2(t2, e2) {
            let r2 = t2.x - e2.x;
            return 0 === r2 && (r2 = t2.y - e2.y, 0 === r2) && (r2 = (t2.next.y - t2.y) / (t2.next.x - t2.x) - (e2.next.y - e2.y) / (e2.next.x - e2.x)), r2;
          }
          function vl(t2, e2) {
            const r2 = function(t3, e3) {
              let r3 = e3;
              const n3 = t3.x, i2 = t3.y;
              let s2, a2 = -1 / 0;
              if (Il2(t3, r3)) return r3;
              do {
                if (Il2(t3, r3.next)) return r3.next;
                if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
                  const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
                  if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3)) return s2;
                }
                r3 = r3.next;
              } while (r3 !== e3);
              if (!s2) return null;
              const o2 = s2, l2 = s2.x, u2 = s2.y;
              let c2 = 1 / 0;
              r3 = s2;
              do {
                if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && Al2(i2 < u2 ? n3 : a2, i2, l2, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
                  const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
                  Bl2(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && bl2(s2, r3))) && (s2 = r3, c2 = e4);
                }
                r3 = r3.next;
              } while (r3 !== o2);
              return s2;
            }(t2, e2);
            if (!r2) return e2;
            const n2 = Vl2(r2, t2);
            return pl(n2, n2.next), pl(r2, r2.next);
          }
          function bl2(t2, e2) {
            return Ml2(t2.prev, t2, e2.prev) < 0 && Ml2(e2.next, t2, t2.next) < 0;
          }
          function wl2(t2, e2, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function _l2(t2) {
            let e2 = t2, r2 = t2;
            do {
              (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r2;
          }
          function Al2(t2, e2, r2, n2, i2, s2, a2, o2) {
            return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
          }
          function Sl2(t2, e2, r2, n2, i2, s2, a2, o2) {
            return !(t2 === a2 && e2 === o2) && Al2(t2, e2, r2, n2, i2, s2, a2, o2);
          }
          function kl2(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              let r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && zl2(r2, r2.next, t3, e3)) return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e2) && (Bl2(t2, e2) && Bl2(e2, t2) && function(t3, e3) {
              let r2 = t3, n2 = false;
              const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
              do {
                r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e2) && (Ml2(t2.prev, t2, e2.prev) || Ml2(t2, e2.prev, e2)) || Il2(t2, e2) && Ml2(t2.prev, t2, t2.next) > 0 && Ml2(e2.prev, e2, e2.next) > 0);
          }
          function Ml2(t2, e2, r2) {
            return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
          }
          function Il2(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function zl2(t2, e2, r2, n2) {
            const i2 = Cl2(Ml2(t2, e2, r2)), s2 = Cl2(Ml2(t2, e2, n2)), a2 = Cl2(Ml2(r2, n2, t2)), o2 = Cl2(Ml2(r2, n2, e2));
            return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !Pl2(t2, r2, e2)) || !(0 !== s2 || !Pl2(t2, n2, e2)) || !(0 !== a2 || !Pl2(r2, t2, n2)) || !(0 !== o2 || !Pl2(r2, e2, n2));
          }
          function Pl2(t2, e2, r2) {
            return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
          }
          function Cl2(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function Bl2(t2, e2) {
            return Ml2(t2.prev, t2, t2.next) < 0 ? Ml2(t2, e2, t2.next) >= 0 && Ml2(t2, t2.prev, e2) >= 0 : Ml2(t2, e2, t2.prev) < 0 || Ml2(t2, t2.next, e2) < 0;
          }
          function Vl2(t2, e2) {
            const r2 = Fl(t2.i, t2.x, t2.y), n2 = Fl(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
          }
          function El2(t2, e2, r2, n2) {
            const i2 = Fl(t2, e2, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function Tl2(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function Fl(t2, e2, r2) {
            return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
          }
          class $l2 {
            constructor(t2, e2) {
              if (e2 > t2) throw new Error("Min granularity must not be greater than base granularity.");
              this._baseZoomGranularity = t2, this._minGranularity = e2;
            }
            getGranularityForZoomLevel(t2) {
              return Math.max(Math.floor(this._baseZoomGranularity / (1 << t2)), this._minGranularity, 1);
            }
          }
          class Ll2 {
            constructor(t2) {
              this.fill = t2.fill, this.line = t2.line, this.tile = t2.tile, this.stencil = t2.stencil, this.circle = t2.circle;
            }
          }
          Ll2.noSubdivision = new Ll2({ fill: new $l2(0, 0), line: new $l2(0, 0), tile: new $l2(0, 0), stencil: new $l2(0, 0), circle: 1 }), is2("SubdivisionGranularityExpression", $l2), is2("SubdivisionGranularitySetting", Ll2);
          const Ol = -32768, Dl2 = 32767;
          class jl2 {
            constructor(t2, e2) {
              this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t2, this._granularityCellSize = z / t2, this._canonical = e2;
            }
            _getKey(t2, e2) {
              return (t2 += 32768) << 16 | (e2 += 32768) << 0;
            }
            _vertexToIndex(t2, e2) {
              if (t2 < -32768 || e2 < -32768 || t2 > 32767 || e2 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
              const r2 = 0 | Math.round(t2), n2 = 0 | Math.round(e2), i2 = this._getKey(r2, n2);
              if (this._vertexDictionary.has(i2)) return this._vertexDictionary.get(i2);
              const s2 = this._vertexBuffer.length / 2;
              return this._vertexDictionary.set(i2, s2), this._vertexBuffer.push(r2, n2), s2;
            }
            _subdivideTrianglesScanline(t2) {
              if (this._granularity < 2) return function(t3, e3) {
                const r3 = [];
                for (let n2 = 0; n2 < e3.length; n2 += 3) {
                  const i2 = e3[n2], s2 = e3[n2 + 1], a2 = e3[n2 + 2], o2 = t3[2 * i2], l2 = t3[2 * i2 + 1];
                  (t3[2 * s2] - o2) * (t3[2 * a2 + 1] - l2) - (t3[2 * s2 + 1] - l2) * (t3[2 * a2] - o2) > 0 ? (r3.push(i2), r3.push(a2), r3.push(s2)) : (r3.push(i2), r3.push(s2), r3.push(a2));
                }
                return r3;
              }(this._vertexBuffer, t2);
              const e2 = [], r2 = t2.length;
              for (let n2 = 0; n2 < r2; n2 += 3) {
                const r3 = [t2[n2 + 0], t2[n2 + 1], t2[n2 + 2]], i2 = [this._vertexBuffer[2 * t2[n2 + 0] + 0], this._vertexBuffer[2 * t2[n2 + 0] + 1], this._vertexBuffer[2 * t2[n2 + 1] + 0], this._vertexBuffer[2 * t2[n2 + 1] + 1], this._vertexBuffer[2 * t2[n2 + 2] + 0], this._vertexBuffer[2 * t2[n2 + 2] + 1]];
                let s2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, l2 = -1 / 0;
                for (let t3 = 0; t3 < 3; t3++) {
                  const e3 = i2[2 * t3], r4 = i2[2 * t3 + 1];
                  s2 = Math.min(s2, e3), o2 = Math.max(o2, e3), a2 = Math.min(a2, r4), l2 = Math.max(l2, r4);
                }
                if (s2 === o2 || a2 === l2) continue;
                const u2 = Math.floor(s2 / this._granularityCellSize), c2 = Math.ceil(o2 / this._granularityCellSize), h3 = Math.floor(a2 / this._granularityCellSize), p2 = Math.ceil(l2 / this._granularityCellSize);
                if (u2 !== c2 || h3 !== p2) for (let t3 = h3; t3 < p2; t3++) {
                  const n3 = this._scanlineGenerateVertexRingForCellRow(t3, i2, r3);
                  Ul2(this._vertexBuffer, n3, e2);
                }
                else e2.push(...r3);
              }
              return e2;
            }
            _scanlineGenerateVertexRingForCellRow(t2, e2, r2) {
              const n2 = t2 * this._granularityCellSize, i2 = n2 + this._granularityCellSize, s2 = [];
              for (let t3 = 0; t3 < 3; t3++) {
                const a2 = e2[2 * t3], o2 = e2[2 * t3 + 1], l2 = e2[2 * (t3 + 1) % 6], u2 = e2[(2 * (t3 + 1) + 1) % 6], c2 = e2[2 * (t3 + 2) % 6], h3 = e2[(2 * (t3 + 2) + 1) % 6], p2 = l2 - a2, f2 = u2 - o2, d2 = 0 === p2, y2 = 0 === f2, m2 = (n2 - o2) / f2, g3 = (i2 - o2) / f2, x3 = Math.min(m2, g3), v2 = Math.max(m2, g3);
                if (!y2 && (x3 >= 1 || v2 <= 0) || y2 && (o2 < n2 || o2 > i2)) {
                  u2 >= n2 && u2 <= i2 && s2.push(r2[(t3 + 1) % 3]);
                  continue;
                }
                !y2 && x3 > 0 && s2.push(this._vertexToIndex(a2 + p2 * x3, o2 + f2 * x3));
                const b2 = a2 + p2 * Math.max(x3, 0), w2 = a2 + p2 * Math.min(v2, 1);
                d2 || this._generateIntraEdgeVertices(s2, a2, o2, l2, u2, b2, w2), !y2 && v2 < 1 && s2.push(this._vertexToIndex(a2 + p2 * v2, o2 + f2 * v2)), (y2 || u2 >= n2 && u2 <= i2) && s2.push(r2[(t3 + 1) % 3]), !y2 && (u2 <= n2 || u2 >= i2) && this._generateInterEdgeVertices(s2, a2, o2, l2, u2, c2, h3, w2, n2, i2);
              }
              return s2;
            }
            _generateIntraEdgeVertices(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = n2 - e2, l2 = i2 - r2, u2 = 0 === l2, c2 = u2 ? Math.min(e2, n2) : Math.min(s2, a2), h3 = u2 ? Math.max(e2, n2) : Math.max(s2, a2), p2 = Math.floor(c2 / this._granularityCellSize) + 1, f2 = Math.ceil(h3 / this._granularityCellSize) - 1;
              if (u2 ? e2 < n2 : s2 < a2) for (let n3 = p2; n3 <= f2; n3++) {
                const i3 = n3 * this._granularityCellSize;
                t2.push(this._vertexToIndex(i3, r2 + l2 * (i3 - e2) / o2));
              }
              else for (let n3 = f2; n3 >= p2; n3--) {
                const i3 = n3 * this._granularityCellSize;
                t2.push(this._vertexToIndex(i3, r2 + l2 * (i3 - e2) / o2));
              }
            }
            _generateInterEdgeVertices(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
              const c2 = i2 - r2, h3 = s2 - n2, p2 = a2 - i2, f2 = (l2 - i2) / p2, d2 = (u2 - i2) / p2, y2 = Math.min(f2, d2), m2 = Math.max(f2, d2), g3 = n2 + h3 * y2;
              let x3 = Math.floor(Math.min(g3, o2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(g3, o2) / this._granularityCellSize) - 1, b2 = o2 < g3;
              const w2 = 0 === p2;
              if (w2 && (a2 === l2 || a2 === u2)) return;
              if (w2 || y2 >= 1 || m2 <= 0) {
                const t3 = r2 - a2, n3 = s2 + (e2 - s2) * Math.min((l2 - a2) / t3, (u2 - a2) / t3);
                x3 = Math.floor(Math.min(n3, o2) / this._granularityCellSize) + 1, v2 = Math.ceil(Math.max(n3, o2) / this._granularityCellSize) - 1, b2 = o2 < n3;
              }
              const _3 = c2 > 0 ? u2 : l2;
              if (b2) for (let e3 = x3; e3 <= v2; e3++) t2.push(this._vertexToIndex(e3 * this._granularityCellSize, _3));
              else for (let e3 = v2; e3 >= x3; e3--) t2.push(this._vertexToIndex(e3 * this._granularityCellSize, _3));
            }
            _generateOutline(t2) {
              const e2 = [];
              for (const r2 of t2) {
                const t3 = Nl2(r2, this._granularity, true), n2 = this._pointArrayToIndices(t3), i2 = [];
                for (let t4 = 1; t4 < n2.length; t4++) i2.push(n2[t4 - 1]), i2.push(n2[t4]);
                e2.push(i2);
              }
              return e2;
            }
            _handlePoles(t2) {
              let e2 = false, r2 = false;
              this._canonical && (0 === this._canonical.y && (e2 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (r2 = true)), (e2 || r2) && this._fillPoles(t2, e2, r2);
            }
            _ensureNoPoleVertices() {
              const t2 = this._vertexBuffer;
              for (let e2 = 0; e2 < t2.length; e2 += 2) {
                const r2 = t2[e2 + 1];
                r2 === Ol && (t2[e2 + 1] = -32767), r2 === Dl2 && (t2[e2 + 1] = 32766);
              }
            }
            _generatePoleQuad(t2, e2, r2, n2, i2, s2) {
              n2 > i2 != (s2 === Ol) ? (t2.push(e2), t2.push(r2), t2.push(this._vertexToIndex(n2, s2)), t2.push(r2), t2.push(this._vertexToIndex(i2, s2)), t2.push(this._vertexToIndex(n2, s2))) : (t2.push(r2), t2.push(e2), t2.push(this._vertexToIndex(n2, s2)), t2.push(this._vertexToIndex(i2, s2)), t2.push(r2), t2.push(this._vertexToIndex(n2, s2)));
            }
            _fillPoles(t2, e2, r2) {
              const n2 = this._vertexBuffer, i2 = z, s2 = t2.length;
              for (let a2 = 2; a2 < s2; a2 += 3) {
                const s3 = t2[a2 - 2], o2 = t2[a2 - 1], l2 = t2[a2], u2 = n2[2 * s3], c2 = n2[2 * s3 + 1], h3 = n2[2 * o2], p2 = n2[2 * o2 + 1], f2 = n2[2 * l2], d2 = n2[2 * l2 + 1];
                e2 && (0 === c2 && 0 === p2 && this._generatePoleQuad(t2, s3, o2, u2, h3, Ol), 0 === p2 && 0 === d2 && this._generatePoleQuad(t2, o2, l2, h3, f2, Ol), 0 === d2 && 0 === c2 && this._generatePoleQuad(t2, l2, s3, f2, u2, Ol)), r2 && (c2 === i2 && p2 === i2 && this._generatePoleQuad(t2, s3, o2, u2, h3, Dl2), p2 === i2 && d2 === i2 && this._generatePoleQuad(t2, o2, l2, h3, f2, Dl2), d2 === i2 && c2 === i2 && this._generatePoleQuad(t2, l2, s3, f2, u2, Dl2));
              }
            }
            _initializeVertices(t2) {
              for (let e2 = 0; e2 < t2.length; e2 += 2) this._vertexToIndex(t2[e2], t2[e2 + 1]);
            }
            subdividePolygonInternal(t2, e2) {
              if (this._used) throw new Error("Subdivision: multiple use not allowed.");
              this._used = true;
              const { flattened: r2, holeIndices: n2 } = function(t3) {
                const e3 = [], r3 = [];
                for (const n3 of t3) if (0 !== n3.length) {
                  n3 !== t3[0] && e3.push(r3.length / 2);
                  for (let t4 = 0; t4 < n3.length; t4++) r3.push(n3[t4].x), r3.push(n3[t4].y);
                }
                return { flattened: r3, holeIndices: e3 };
              }(t2);
              let i2;
              this._initializeVertices(r2);
              try {
                const t3 = function(t4, e4, r3 = 2) {
                  const n3 = e4 && e4.length, i3 = n3 ? e4[0] * r3 : t4.length;
                  let s3 = hl(t4, 0, i3, r3, true);
                  const a2 = [];
                  if (!s3 || s3.next === s3.prev) return a2;
                  let o2, l2, u2;
                  if (n3 && (s3 = function(t5, e5, r4, n4) {
                    const i4 = [];
                    for (let r5 = 0, s4 = e5.length; r5 < s4; r5++) {
                      const a3 = hl(t5, e5[r5] * n4, r5 < s4 - 1 ? e5[r5 + 1] * n4 : t5.length, n4, false);
                      a3 === a3.next && (a3.steiner = true), i4.push(_l2(a3));
                    }
                    i4.sort(xl2);
                    for (let t6 = 0; t6 < i4.length; t6++) r4 = vl(i4[t6], r4);
                    return r4;
                  }(t4, e4, s3, r3)), t4.length > 80 * r3) {
                    o2 = 1 / 0, l2 = 1 / 0;
                    let e5 = -1 / 0, n4 = -1 / 0;
                    for (let s4 = r3; s4 < i3; s4 += r3) {
                      const r4 = t4[s4], i4 = t4[s4 + 1];
                      r4 < o2 && (o2 = r4), i4 < l2 && (l2 = i4), r4 > e5 && (e5 = r4), i4 > n4 && (n4 = i4);
                    }
                    u2 = Math.max(e5 - o2, n4 - l2), u2 = 0 !== u2 ? 32767 / u2 : 0;
                  }
                  return fl(s3, a2, r3, o2, l2, u2, 0), a2;
                }(r2, n2), e3 = this._convertIndices(r2, t3);
                i2 = this._subdivideTrianglesScanline(e3);
              } catch (t3) {
                console.error(t3);
              }
              let s2 = [];
              return e2 && (s2 = this._generateOutline(t2)), this._ensureNoPoleVertices(), this._handlePoles(i2), { verticesFlattened: this._vertexBuffer, indicesTriangles: i2, indicesLineList: s2 };
            }
            _convertIndices(t2, e2) {
              const r2 = [];
              for (let n2 = 0; n2 < e2.length; n2++) r2.push(this._vertexToIndex(t2[2 * e2[n2]], t2[2 * e2[n2] + 1]));
              return r2;
            }
            _pointArrayToIndices(t2) {
              const e2 = [];
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2[r2];
                e2.push(this._vertexToIndex(n2.x, n2.y));
              }
              return e2;
            }
          }
          function Rl2(t2, e2, r2, n2 = true) {
            return new jl2(r2, e2).subdividePolygonInternal(t2, n2);
          }
          function Nl2(t2, e2, r2 = false) {
            if (!t2 || t2.length < 1) return [];
            if (t2.length < 2) return [];
            const n2 = t2[0], i2 = t2[t2.length - 1], s2 = r2 && (n2.x !== i2.x || n2.y !== i2.y);
            if (e2 < 2) return s2 ? [...t2, t2[0]] : [...t2];
            const a2 = Math.floor(z / e2), o2 = [];
            o2.push(new l(t2[0].x, t2[0].y));
            const u2 = t2.length, c2 = s2 ? u2 : u2 - 1;
            for (let e3 = 0; e3 < c2; e3++) {
              const r3 = t2[e3], n3 = e3 < u2 - 1 ? t2[e3 + 1] : t2[0], i3 = r3.x, s3 = r3.y, c3 = n3.x, h3 = n3.y, p2 = i3 !== c3, f2 = s3 !== h3;
              if (!p2 && !f2) continue;
              const d2 = c3 - i3, y2 = h3 - s3, m2 = Math.abs(d2), g3 = Math.abs(y2);
              let x3 = i3, v2 = s3;
              for (; ; ) {
                const t3 = d2 > 0 ? (Math.floor(x3 / a2) + 1) * a2 : (Math.ceil(x3 / a2) - 1) * a2, e4 = y2 > 0 ? (Math.floor(v2 / a2) + 1) * a2 : (Math.ceil(v2 / a2) - 1) * a2, r4 = Math.abs(x3 - t3), n4 = Math.abs(v2 - e4), i4 = Math.abs(x3 - c3), s4 = Math.abs(v2 - h3), u3 = p2 ? r4 / m2 : Number.POSITIVE_INFINITY, b3 = f2 ? n4 / g3 : Number.POSITIVE_INFINITY;
                if ((i4 <= r4 || !p2) && (s4 <= n4 || !f2)) break;
                if (u3 < b3 && p2 || !f2) {
                  x3 = t3, v2 += y2 * u3;
                  const e5 = new l(x3, Math.round(v2));
                  o2[o2.length - 1].x === e5.x && o2[o2.length - 1].y === e5.y || o2.push(e5);
                } else {
                  x3 += d2 * b3, v2 = e4;
                  const t4 = new l(Math.round(x3), v2);
                  o2[o2.length - 1].x === t4.x && o2[o2.length - 1].y === t4.y || o2.push(t4);
                }
              }
              const b2 = new l(c3, h3);
              o2[o2.length - 1].x === b2.x && o2[o2.length - 1].y === b2.y || o2.push(b2);
            }
            return o2;
          }
          function Ul2(t2, e2, r2) {
            if (0 === e2.length) throw new Error("Subdivision vertex ring is empty.");
            let n2 = 0, i2 = t2[2 * e2[0]];
            for (let r3 = 1; r3 < e2.length; r3++) {
              const s3 = t2[2 * e2[r3]];
              s3 < i2 && (i2 = s3, n2 = r3);
            }
            const s2 = e2.length;
            let a2 = n2, o2 = (a2 + 1) % s2;
            for (; ; ) {
              const n3 = a2 - 1 >= 0 ? a2 - 1 : s2 - 1, i3 = (o2 + 1) % s2, l2 = t2[2 * e2[n3]], u2 = t2[2 * e2[i3]], c2 = t2[2 * e2[a2]], h3 = t2[2 * e2[a2] + 1], p2 = t2[2 * e2[o2] + 1];
              let f2 = false;
              if (l2 < u2) f2 = true;
              else if (l2 > u2) f2 = false;
              else {
                const r3 = p2 - h3, s3 = -(t2[2 * e2[o2]] - c2), a3 = h3 < p2 ? 1 : -1;
                ((l2 - c2) * r3 + (t2[2 * e2[n3] + 1] - h3) * s3) * a3 > ((u2 - c2) * r3 + (t2[2 * e2[i3] + 1] - h3) * s3) * a3 && (f2 = true);
              }
              if (f2) {
                const t3 = e2[n3], i4 = e2[a2], l3 = e2[o2];
                t3 !== i4 && t3 !== l3 && i4 !== l3 && r2.push(l3, i4, t3), a2--, a2 < 0 && (a2 = s2 - 1);
              } else {
                const t3 = e2[i3], n4 = e2[a2], l3 = e2[o2];
                t3 !== n4 && t3 !== l3 && n4 !== l3 && r2.push(l3, n4, t3), o2++, o2 >= s2 && (o2 = 0);
              }
              if (n3 === i3) break;
            }
          }
          function ql2(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = i2.length / 2, c2 = a2 && o2 && l2;
            if (u2 < qa2.MAX_VERTEX_ARRAY_LENGTH) {
              const h3 = e2.prepareSegment(u2, r2, n2), p2 = h3.vertexLength;
              for (let t3 = 0; t3 < s2.length; t3 += 3) n2.emplaceBack(p2 + s2[t3], p2 + s2[t3 + 1], p2 + s2[t3 + 2]);
              let f2, d2;
              h3.vertexLength += u2, h3.primitiveLength += s2.length / 3, c2 && (d2 = a2.prepareSegment(u2, r2, o2), f2 = d2.vertexLength, d2.vertexLength += u2);
              for (let e3 = 0; e3 < i2.length; e3 += 2) t2(i2[e3], i2[e3 + 1]);
              if (c2) for (let t3 = 0; t3 < l2.length; t3++) {
                const e3 = l2[t3];
                for (let t4 = 1; t4 < e3.length; t4 += 2) o2.emplaceBack(f2 + e3[t4 - 1], f2 + e3[t4]);
                d2.primitiveLength += e3.length / 2;
              }
            } else !function(t3, e3, r3, n3, i3, s3) {
              const a3 = [];
              for (let t4 = 0; t4 < n3.length / 2; t4++) a3.push(-1);
              const o3 = { count: 0 };
              let l3 = 0, u3 = t3.getOrCreateLatestSegment(e3, r3), c3 = u3.vertexLength;
              for (let h3 = 2; h3 < i3.length; h3 += 3) {
                const p2 = i3[h3 - 2], f2 = i3[h3 - 1], d2 = i3[h3];
                let y2 = a3[p2] < l3, m2 = a3[f2] < l3, g3 = a3[d2] < l3;
                u3.vertexLength + ((y2 ? 1 : 0) + (m2 ? 1 : 0) + (g3 ? 1 : 0)) > qa2.MAX_VERTEX_ARRAY_LENGTH && (u3 = t3.createNewSegment(e3, r3), l3 = o3.count, y2 = true, m2 = true, g3 = true, c3 = 0);
                const x3 = Gl2(a3, n3, s3, o3, p2, y2, u3), v2 = Gl2(a3, n3, s3, o3, f2, m2, u3), b2 = Gl2(a3, n3, s3, o3, d2, g3, u3);
                r3.emplaceBack(c3 + x3 - l3, c3 + v2 - l3, c3 + b2 - l3), u3.primitiveLength++;
              }
            }(e2, r2, n2, i2, s2, t2), c2 && function(t3, e3, r3, n3, i3, s3) {
              const a3 = [];
              for (let t4 = 0; t4 < n3.length / 2; t4++) a3.push(-1);
              const o3 = { count: 0 };
              let l3 = 0, u3 = t3.getOrCreateLatestSegment(e3, r3), c3 = u3.vertexLength;
              for (let h3 = 0; h3 < i3.length; h3++) {
                const p2 = i3[h3];
                for (let f2 = 1; f2 < i3[h3].length; f2 += 2) {
                  const i4 = p2[f2 - 1], h4 = p2[f2];
                  let d2 = a3[i4] < l3, y2 = a3[h4] < l3;
                  u3.vertexLength + ((d2 ? 1 : 0) + (y2 ? 1 : 0)) > qa2.MAX_VERTEX_ARRAY_LENGTH && (u3 = t3.createNewSegment(e3, r3), l3 = o3.count, d2 = true, y2 = true, c3 = 0);
                  const m2 = Gl2(a3, n3, s3, o3, i4, d2, u3), g3 = Gl2(a3, n3, s3, o3, h4, y2, u3);
                  r3.emplaceBack(c3 + m2 - l3, c3 + g3 - l3), u3.primitiveLength++;
                }
              }
            }(a2, r2, o2, i2, l2, t2), e2.forceNewSegmentOnNextPrepare(), null == a2 || a2.forceNewSegmentOnNextPrepare();
          }
          function Gl2(t2, e2, r2, n2, i2, s2, a2) {
            if (s2) {
              const s3 = n2.count;
              return r2(e2[2 * i2], e2[2 * i2 + 1]), t2[i2] = n2.count, n2.count++, a2.vertexLength++, s3;
            }
            return t2[i2];
          }
          class Zl2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ca(), this.indexArray = new ja(), this.indexArray2 = new Ra(), this.programConfigurations = new xo2(t2.layers, t2.zoom), this.segments = new qa2(), this.segments2 = new qa2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              this.hasPattern = ul("fill", this.layers, e2);
              const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
              for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, c2 = So2(a2, t3);
                if (!this.layers[0]._featureFilter.filter(new ks2(this.zoom), c2, r2)) continue;
                const h3 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Ao2(a2), patterns: {}, sortKey: h3 };
                s2.push(p2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = cl("fill", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else this.addFeature(n3, i3, s3, r2, {}, e2.subdivisionGranularity);
                e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            addFeatures(t2, e2, r2) {
              for (const n2 of this.patternFeatures) this.addFeature(n2, n2.geometry, n2.index, e2, r2, t2.subdivisionGranularity);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ll), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2) {
              for (const t3 of Wr2(e2, 500)) {
                const e3 = Rl2(t3, n2, s2.fill.getGranularityForZoomLevel(n2.z)), r3 = this.layoutVertexArray;
                ql2((t4, e4) => {
                  r3.emplaceBack(t4, e4);
                }, this.segments, this.layoutVertexArray, this.indexArray, e3.verticesFlattened, e3.indicesTriangles, this.segments2, this.indexArray2, e3.indicesLineList);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
          }
          let Kl2, Xl2;
          is2("FillBucket", Zl2, { omit: ["layers", "patternFeatures"] });
          var Hl2 = { get paint() {
            return Xl2 = Xl2 || new Ds2({ "fill-antialias": new Ts2(gt2.paint_fill["fill-antialias"]), "fill-opacity": new Fs2(gt2.paint_fill["fill-opacity"]), "fill-color": new Fs2(gt2.paint_fill["fill-color"]), "fill-outline-color": new Fs2(gt2.paint_fill["fill-outline-color"]), "fill-translate": new Ts2(gt2.paint_fill["fill-translate"]), "fill-translate-anchor": new Ts2(gt2.paint_fill["fill-translate-anchor"]), "fill-pattern": new $s2(gt2.paint_fill["fill-pattern"]) });
          }, get layout() {
            return Kl2 = Kl2 || new Ds2({ "fill-sort-key": new Fs2(gt2.layout_fill["fill-sort-key"]) });
          } };
          class Yl2 extends Rs2 {
            constructor(t2) {
              super(t2, Hl2);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
              const r2 = this.paint._values["fill-outline-color"];
              "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new Zl2(t2);
            }
            queryRadius() {
              return jo2(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature({ queryGeometry: t2, geometry: e2, transform: r2, pixelsToTileUnits: n2 }) {
              return Co2(Ro2(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r2.bearingInRadians, n2), e2);
            }
            isTileClipped() {
              return true;
            }
          }
          const Jl2 = Gs2([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Wl2 = Gs2([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Ql2 } = Jl2;
          var tu2, eu2, ru2, nu2, iu2, su2, au2, ou2 = {};
          function lu2() {
            if (eu2) return tu2;
            eu2 = 1;
            var t2 = s();
            function e2(t3, e3, n3, i2, s2) {
              this.properties = {}, this.extent = n3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = i2, this._values = s2, t3.readFields(r2, this, e3);
            }
            function r2(t3, e3, r3) {
              1 == t3 ? e3.id = r3.readVarint() : 2 == t3 ? function(t4, e4) {
                for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
                  var n3 = e4._keys[t4.readVarint()], i2 = e4._values[t4.readVarint()];
                  e4.properties[n3] = i2;
                }
              }(r3, e3) : 3 == t3 ? e3.type = r3.readVarint() : 4 == t3 && (e3._geometry = r3.pos);
            }
            function n2(t3) {
              for (var e3, r3, n3 = 0, i2 = 0, s2 = t3.length, a2 = s2 - 1; i2 < s2; a2 = i2++) n3 += ((r3 = t3[a2]).x - (e3 = t3[i2]).x) * (e3.y + r3.y);
              return n3;
            }
            return tu2 = e2, e2.types = ["Unknown", "Point", "LineString", "Polygon"], e2.prototype.loadGeometry = function() {
              var e3 = this._pbf;
              e3.pos = this._geometry;
              for (var r3, n3 = e3.readVarint() + e3.pos, i2 = 1, s2 = 0, a2 = 0, o2 = 0, l2 = []; e3.pos < n3; ) {
                if (s2 <= 0) {
                  var u2 = e3.readVarint();
                  i2 = 7 & u2, s2 = u2 >> 3;
                }
                if (s2--, 1 === i2 || 2 === i2) a2 += e3.readSVarint(), o2 += e3.readSVarint(), 1 === i2 && (r3 && l2.push(r3), r3 = []), r3.push(new t2(a2, o2));
                else {
                  if (7 !== i2) throw new Error("unknown command " + i2);
                  r3 && r3.push(r3[0].clone());
                }
              }
              return r3 && l2.push(r3), l2;
            }, e2.prototype.bbox = function() {
              var t3 = this._pbf;
              t3.pos = this._geometry;
              for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t3.pos < e3; ) {
                if (n3 <= 0) {
                  var c2 = t3.readVarint();
                  r3 = 7 & c2, n3 = c2 >> 3;
                }
                if (n3--, 1 === r3 || 2 === r3) (i2 += t3.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t3.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
                else if (7 !== r3) throw new Error("unknown command " + r3);
              }
              return [a2, l2, o2, u2];
            }, e2.prototype.toGeoJSON = function(t3, r3, i2) {
              var s2, a2, o2 = this.extent * Math.pow(2, i2), l2 = this.extent * t3, u2 = this.extent * r3, c2 = this.loadGeometry(), h3 = e2.types[this.type];
              function p2(t4) {
                for (var e3 = 0; e3 < t4.length; e3++) {
                  var r4 = t4[e3];
                  t4[e3] = [360 * (r4.x + l2) / o2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + u2) / o2) * Math.PI / 180)) - 90];
                }
              }
              switch (this.type) {
                case 1:
                  var f2 = [];
                  for (s2 = 0; s2 < c2.length; s2++) f2[s2] = c2[s2][0];
                  p2(c2 = f2);
                  break;
                case 2:
                  for (s2 = 0; s2 < c2.length; s2++) p2(c2[s2]);
                  break;
                case 3:
                  for (c2 = function(t4) {
                    var e3 = t4.length;
                    if (e3 <= 1) return [t4];
                    for (var r4, i3, s3 = [], a3 = 0; a3 < e3; a3++) {
                      var o3 = n2(t4[a3]);
                      0 !== o3 && (void 0 === i3 && (i3 = o3 < 0), i3 === o3 < 0 ? (r4 && s3.push(r4), r4 = [t4[a3]]) : r4.push(t4[a3]));
                    }
                    return r4 && s3.push(r4), s3;
                  }(c2), s2 = 0; s2 < c2.length; s2++) for (a2 = 0; a2 < c2[s2].length; a2++) p2(c2[s2][a2]);
              }
              1 === c2.length ? c2 = c2[0] : h3 = "Multi" + h3;
              var d2 = { type: "Feature", geometry: { type: h3, coordinates: c2 }, properties: this.properties };
              return "id" in this && (d2.id = this.id), d2;
            }, tu2;
          }
          function uu2() {
            if (nu2) return ru2;
            nu2 = 1;
            var t2 = lu2();
            function e2(t3, e3) {
              this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(r2, this, e3), this.length = this._features.length;
            }
            function r2(t3, e3, r3) {
              15 === t3 ? e3.version = r3.readVarint() : 1 === t3 ? e3.name = r3.readString() : 5 === t3 ? e3.extent = r3.readVarint() : 2 === t3 ? e3._features.push(r3.pos) : 3 === t3 ? e3._keys.push(r3.readString()) : 4 === t3 && e3._values.push(function(t4) {
                for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
                  var n2 = t4.readVarint() >> 3;
                  e4 = 1 === n2 ? t4.readString() : 2 === n2 ? t4.readFloat() : 3 === n2 ? t4.readDouble() : 4 === n2 ? t4.readVarint64() : 5 === n2 ? t4.readVarint() : 6 === n2 ? t4.readSVarint() : 7 === n2 ? t4.readBoolean() : null;
                }
                return e4;
              }(r3));
            }
            return ru2 = e2, e2.prototype.feature = function(e3) {
              if (e3 < 0 || e3 >= this._features.length) throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[e3];
              var r3 = this._pbf.readVarint() + this._pbf.pos;
              return new t2(this._pbf, r3, this.extent, this._keys, this._values);
            }, ru2;
          }
          function cu2() {
            return au2 || (au2 = 1, ou2.VectorTile = function() {
              if (su2) return iu2;
              su2 = 1;
              var t2 = uu2();
              function e2(e3, r2, n2) {
                if (3 === e3) {
                  var i2 = new t2(n2, n2.readVarint() + n2.pos);
                  i2.length && (r2[i2.name] = i2);
                }
              }
              return iu2 = function(t3, r2) {
                this.layers = t3.readFields(e2, {}, r2);
              }, iu2;
            }(), ou2.VectorTileFeature = lu2(), ou2.VectorTileLayer = uu2()), ou2;
          }
          var hu2 = r(cu2());
          const pu2 = hu2.VectorTileFeature.types, fu2 = Math.pow(2, 13);
          function du2(t2, e2, r2, n2, i2, s2, a2, o2) {
            t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * fu2) + a2, i2 * fu2 * 2, s2 * fu2 * 2, Math.round(o2));
          }
          class yu2 {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Ba2(), this.centroidVertexArray = new za2(), this.indexArray = new ja(), this.programConfigurations = new xo2(t2.layers, t2.zoom), this.segments = new qa2(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              this.features = [], this.hasPattern = ul("fill-extrusion", this.layers, e2);
              for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, o2 = So2(n2, t3);
                if (!this.layers[0]._featureFilter.filter(new ks2(this.zoom), o2, r2)) continue;
                const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Ao2(n2), properties: n2.properties, type: n2.type, patterns: {} };
                this.hasPattern ? this.features.push(cl("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}, e2.subdivisionGranularity), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
              }
            }
            addFeatures(t2, e2, r2) {
              for (const n2 of this.features) {
                const { geometry: i2 } = n2;
                this.addFeature(n2, i2, n2.index, e2, r2, t2.subdivisionGranularity);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ql2), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Wl2.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2) {
              for (const r3 of Wr2(e2, 500)) {
                const e3 = { x: 0, y: 0, sampleCount: 0 }, i3 = this.layoutVertexArray.length;
                this.processPolygon(e3, n2, t2, r3, s2);
                const a2 = this.layoutVertexArray.length - i3, o2 = Math.floor(e3.x / e3.sampleCount), l2 = Math.floor(e3.y / e3.sampleCount);
                for (let t3 = 0; t3 < a2; t3++) this.centroidVertexArray.emplaceBack(o2, l2);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
            processPolygon(t2, e2, r2, n2, i2) {
              if (n2.length < 1) return;
              if (xu2(n2[0])) return;
              for (const e3 of n2) 0 !== e3.length && mu2(t2, e3);
              const s2 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a2 = i2.fill.getGranularityForZoomLevel(e2.z), o2 = "Polygon" === pu2[r2.type];
              for (const t3 of n2) {
                if (0 === t3.length) continue;
                if (xu2(t3)) continue;
                const e3 = Nl2(t3, a2, o2);
                this._generateSideFaces(e3, s2);
              }
              if (!o2) return;
              const l2 = Rl2(n2, e2, a2, false), u2 = this.layoutVertexArray;
              ql2((t3, e3) => {
                du2(u2, t3, e3, 0, 0, 1, 1, 0);
              }, this.segments, this.layoutVertexArray, this.indexArray, l2.verticesFlattened, l2.indicesTriangles);
            }
            _generateSideFaces(t2, e2) {
              let r2 = 0;
              for (let n2 = 1; n2 < t2.length; n2++) {
                const i2 = t2[n2], s2 = t2[n2 - 1];
                if (gu2(i2, s2)) continue;
                e2.segment.vertexLength + 4 > qa2.MAX_VERTEX_ARRAY_LENGTH && (e2.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                const a2 = i2.sub(s2)._perp()._unit(), o2 = s2.dist(i2);
                r2 + o2 > 32768 && (r2 = 0), du2(this.layoutVertexArray, i2.x, i2.y, a2.x, a2.y, 0, 0, r2), du2(this.layoutVertexArray, i2.x, i2.y, a2.x, a2.y, 0, 1, r2), r2 += o2, du2(this.layoutVertexArray, s2.x, s2.y, a2.x, a2.y, 0, 0, r2), du2(this.layoutVertexArray, s2.x, s2.y, a2.x, a2.y, 0, 1, r2);
                const l2 = e2.segment.vertexLength;
                this.indexArray.emplaceBack(l2, l2 + 2, l2 + 1), this.indexArray.emplaceBack(l2 + 1, l2 + 2, l2 + 3), e2.segment.vertexLength += 4, e2.segment.primitiveLength += 2;
              }
            }
          }
          function mu2(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              const n2 = e2[r2];
              r2 === e2.length - 1 && e2[0].x === n2.x && e2[0].y === n2.y || (t2.x += n2.x, t2.y += n2.y, t2.sampleCount++);
            }
          }
          function gu2(t2, e2) {
            return t2.x === e2.x && (t2.x < 0 || t2.x > z) || t2.y === e2.y && (t2.y < 0 || t2.y > z);
          }
          function xu2(t2) {
            return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > z) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > z);
          }
          let vu2;
          is2("FillExtrusionBucket", yu2, { omit: ["layers", "features"] });
          var bu2 = { get paint() {
            return vu2 = vu2 || new Ds2({ "fill-extrusion-opacity": new Ts2(gt2["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Fs2(gt2["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ts2(gt2["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ts2(gt2["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new $s2(gt2["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Fs2(gt2["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Fs2(gt2["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ts2(gt2["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
          } };
          class wu2 extends Rs2 {
            constructor(t2) {
              super(t2, bu2);
            }
            createBucket(t2) {
              return new yu2(t2);
            }
            queryRadius() {
              return jo2(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2, pixelPosMatrix: a2 }) {
              const o2 = Ro2(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -i2.bearingInRadians, s2), u2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), h3 = function(t3, e3, r3) {
                const n3 = [];
                for (const r4 of t3) {
                  const t4 = [r4.x, r4.y, 0, 1];
                  S2(t4, t4, e3), n3.push(new l(t4[0] / t4[3], t4[1] / t4[3]));
                }
                return n3;
              }(o2, a2), p2 = function(t3, e3, r3, n3) {
                const i3 = [], s3 = [], a3 = n3[8] * e3, o3 = n3[9] * e3, u3 = n3[10] * e3, c3 = n3[11] * e3, h4 = n3[8] * r3, p3 = n3[9] * r3, f2 = n3[10] * r3, d2 = n3[11] * r3;
                for (const e4 of t3) {
                  const t4 = [], r4 = [];
                  for (const i4 of e4) {
                    const e5 = i4.x, s4 = i4.y, y2 = n3[0] * e5 + n3[4] * s4 + n3[12], m2 = n3[1] * e5 + n3[5] * s4 + n3[13], g3 = n3[2] * e5 + n3[6] * s4 + n3[14], x3 = n3[3] * e5 + n3[7] * s4 + n3[15], v2 = g3 + u3, b2 = x3 + c3, w2 = y2 + h4, _3 = m2 + p3, A3 = g3 + f2, S3 = x3 + d2, k2 = new l((y2 + a3) / b2, (m2 + o3) / b2);
                    k2.z = v2 / b2, t4.push(k2);
                    const M3 = new l(w2 / S3, _3 / S3);
                    M3.z = A3 / S3, r4.push(M3);
                  }
                  i3.push(t4), s3.push(r4);
                }
                return [i3, s3];
              }(n2, c2, u2, a2);
              return function(t3, e3, r3) {
                let n3 = 1 / 0;
                Co2(r3, e3) && (n3 = Au2(r3, e3[0]));
                for (let i3 = 0; i3 < e3.length; i3++) {
                  const s3 = e3[i3], a3 = t3[i3];
                  for (let t4 = 0; t4 < s3.length - 1; t4++) {
                    const e4 = s3[t4], i4 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                    zo2(r3, i4) && (n3 = Math.min(n3, Au2(r3, i4)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(p2[0], p2[1], h3);
            }
          }
          function _u2(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function Au2(t2, e2) {
            if (1 === t2.length) {
              let r2 = 0;
              const n2 = e2[r2++];
              let i2;
              for (; !i2 || n2.equals(i2); ) if (i2 = e2[r2++], !i2) return 1 / 0;
              for (; r2 < e2.length; r2++) {
                const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = _u2(o2, o2), h3 = _u2(o2, l2), p2 = _u2(l2, l2), f2 = _u2(u2, o2), d2 = _u2(u2, l2), y2 = c2 * p2 - h3 * h3, m2 = (p2 * f2 - h3 * d2) / y2, g3 = (c2 * d2 - h3 * f2) / y2, x3 = n2.z * (1 - m2 - g3) + i2.z * m2 + s2.z * g3;
                if (isFinite(x3)) return x3;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r2 of e2) t3 = Math.min(t3, r2.z);
              return t3;
            }
          }
          const Su2 = Gs2([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: ku2 } = Su2, Mu2 = Gs2([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Iu2 } = Mu2, zu2 = hu2.VectorTileFeature.types, Pu2 = Math.cos(Math.PI / 180 * 37.5), Cu2 = Math.pow(2, 14) / 0.5;
          class Bu {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new Va2(), this.layoutVertexArray2 = new Ea(), this.indexArray = new ja(), this.programConfigurations = new xo2(t2.layers, t2.zoom), this.segments = new qa2(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e2, r2) {
              this.hasPattern = ul("line", this.layers, e2);
              const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
              for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = So2(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new ks2(this.zoom), u2, r2)) continue;
                const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h3 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Ao2(e3), patterns: {}, sortKey: c2 };
                s2.push(h3);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
                if (this.hasPattern) {
                  const t3 = cl("line", this.layers, n3, this.zoom, e2);
                  this.patternFeatures.push(t3);
                } else this.addFeature(n3, i3, s3, r2, {}, e2.subdivisionGranularity);
                e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
              }
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
            }
            addFeatures(t2, e2, r2) {
              for (const n2 of this.patternFeatures) this.addFeature(n2, n2.geometry, n2.index, e2, r2, t2.subdivisionGranularity);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Iu2)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ku2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end")) return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e2, r2, n2, i2, s2) {
              const a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), l2 = a2.get("line-cap"), u2 = a2.get("line-miter-limit"), c2 = a2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2);
              for (const r3 of e2) this.addLine(r3, t2, o2, l2, u2, c2, n2, s2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
            addLine(t2, e2, r2, n2, i2, s2, a2, o2) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t2 = Nl2(t2, a2 ? o2.line.getGranularityForZoomLevel(a2.z) : 1), this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e3 = 0; e3 < t2.length - 1; e3++) this.totalDistance += t2[e3].dist(t2[e3 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const l2 = "Polygon" === zu2[e2.type];
              let u2 = t2.length;
              for (; u2 >= 2 && t2[u2 - 1].equals(t2[u2 - 2]); ) u2--;
              let c2 = 0;
              for (; c2 < u2 - 1 && t2[c2].equals(t2[c2 + 1]); ) c2++;
              if (u2 < (l2 ? 3 : 2)) return;
              "bevel" === r2 && (i2 = 1.05);
              const h3 = this.overscaling <= 16 ? 15 * z / (512 * this.overscaling) : 0, p2 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray);
              let f2, d2, y2, m2, g3;
              this.e1 = this.e2 = -1, l2 && (f2 = t2[u2 - 2], g3 = t2[c2].sub(f2)._unit()._perp());
              for (let e3 = c2; e3 < u2; e3++) {
                if (y2 = e3 === u2 - 1 ? l2 ? t2[c2 + 1] : void 0 : t2[e3 + 1], y2 && t2[e3].equals(y2)) continue;
                g3 && (m2 = g3), f2 && (d2 = f2), f2 = t2[e3], g3 = y2 ? y2.sub(f2)._unit()._perp() : m2, m2 = m2 || g3;
                let a3 = m2.add(g3);
                0 === a3.x && 0 === a3.y || a3._unit();
                const o3 = m2.x * g3.x + m2.y * g3.y, x3 = a3.x * g3.x + a3.y * g3.y, v2 = 0 !== x3 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), w2 = x3 < Pu2 && d2 && y2, _3 = m2.x * g3.y - m2.y * g3.x > 0;
                if (w2 && e3 > c2) {
                  const t3 = f2.dist(d2);
                  if (t3 > 2 * h3) {
                    const e4 = f2.sub(f2.sub(d2)._mult(h3 / t3)._round());
                    this.updateDistance(d2, e4), this.addCurrentVertex(e4, m2, 0, 0, p2), d2 = e4;
                  }
                }
                const A3 = d2 && y2;
                let S3 = A3 ? r2 : l2 ? "butt" : n2;
                if (A3 && "round" === S3 && (v2 < s2 ? S3 = "miter" : v2 <= 2 && (S3 = "fakeround")), "miter" === S3 && v2 > i2 && (S3 = "bevel"), "bevel" === S3 && (v2 > 2 && (S3 = "flipbevel"), v2 < i2 && (S3 = "miter")), d2 && this.updateDistance(d2, f2), "miter" === S3) a3._mult(v2), this.addCurrentVertex(f2, a3, 0, 0, p2);
                else if ("flipbevel" === S3) {
                  if (v2 > 100) a3 = g3.mult(-1);
                  else {
                    const t3 = v2 * m2.add(g3).mag() / m2.sub(g3).mag();
                    a3._perp()._mult(t3 * (_3 ? -1 : 1));
                  }
                  this.addCurrentVertex(f2, a3, 0, 0, p2), this.addCurrentVertex(f2, a3.mult(-1), 0, 0, p2);
                } else if ("bevel" === S3 || "fakeround" === S3) {
                  const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _3 ? t3 : 0, r3 = _3 ? 0 : t3;
                  if (d2 && this.addCurrentVertex(f2, m2, e4, r3, p2), "fakeround" === S3) {
                    const t4 = Math.round(180 * b2 / Math.PI / 20);
                    for (let e5 = 1; e5 < t4; e5++) {
                      let r4 = e5 / t4;
                      if (0.5 !== r4) {
                        const t5 = r4 - 0.5;
                        r4 += r4 * t5 * (r4 - 1) * ((1.0904 + o3 * (o3 * (3.55645 - 1.43519 * o3) - 3.2452)) * t5 * t5 + (0.848013 + o3 * (0.215638 * o3 - 1.06021)));
                      }
                      const n3 = g3.sub(m2)._mult(r4)._add(m2)._unit()._mult(_3 ? -1 : 1);
                      this.addHalfVertex(f2, n3.x, n3.y, false, _3, 0, p2);
                    }
                  }
                  y2 && this.addCurrentVertex(f2, g3, -e4, -r3, p2);
                } else if ("butt" === S3) this.addCurrentVertex(f2, a3, 0, 0, p2);
                else if ("square" === S3) {
                  const t3 = d2 ? 1 : -1;
                  this.addCurrentVertex(f2, a3, t3, t3, p2);
                } else "round" === S3 && (d2 && (this.addCurrentVertex(f2, m2, 0, 0, p2), this.addCurrentVertex(f2, m2, 1, 1, p2, true)), y2 && (this.addCurrentVertex(f2, g3, -1, -1, p2, true), this.addCurrentVertex(f2, g3, 0, 0, p2)));
                if (w2 && e3 < u2 - 1) {
                  const t3 = f2.dist(y2);
                  if (t3 > 2 * h3) {
                    const e4 = f2.add(y2.sub(f2)._mult(h3 / t3)._round());
                    this.updateDistance(f2, e4), this.addCurrentVertex(e4, g3, 0, 0, p2), f2 = e4;
                  }
                }
              }
            }
            addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
              const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
              this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Cu2 / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
            }
            addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
              const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Cu2 - 1) : this.scaledDistance);
              this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
              const u2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u2, this.e2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
            }
            updateScaledDistance() {
              this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t2, e2) {
              this.distance += t2.dist(e2), this.updateScaledDistance();
            }
          }
          let Vu, Eu2;
          is2("LineBucket", Bu, { omit: ["layers", "patternFeatures"] });
          var Tu2 = { get paint() {
            return Eu2 = Eu2 || new Ds2({ "line-opacity": new Fs2(gt2.paint_line["line-opacity"]), "line-color": new Fs2(gt2.paint_line["line-color"]), "line-translate": new Ts2(gt2.paint_line["line-translate"]), "line-translate-anchor": new Ts2(gt2.paint_line["line-translate-anchor"]), "line-width": new Fs2(gt2.paint_line["line-width"]), "line-gap-width": new Fs2(gt2.paint_line["line-gap-width"]), "line-offset": new Fs2(gt2.paint_line["line-offset"]), "line-blur": new Fs2(gt2.paint_line["line-blur"]), "line-dasharray": new Ls2(gt2.paint_line["line-dasharray"]), "line-pattern": new $s2(gt2.paint_line["line-pattern"]), "line-gradient": new Os2(gt2.paint_line["line-gradient"]) });
          }, get layout() {
            return Vu = Vu || new Ds2({ "line-cap": new Ts2(gt2.layout_line["line-cap"]), "line-join": new Fs2(gt2.layout_line["line-join"]), "line-miter-limit": new Ts2(gt2.layout_line["line-miter-limit"]), "line-round-limit": new Ts2(gt2.layout_line["line-round-limit"]), "line-sort-key": new Fs2(gt2.layout_line["line-sort-key"]) });
          } };
          class Fu2 extends Fs2 {
            possiblyEvaluate(t2, e2) {
              return e2 = new ks2(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
            }
            evaluate(t2, e2, r2, n2) {
              return e2 = L2({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
            }
          }
          let $u2;
          class Lu2 extends Rs2 {
            constructor(t2) {
              super(t2, Tu2), this.gradientVersion = 0, $u2 || ($u2 = new Fu2(Tu2.paint.properties["line-width"].specification), $u2.useIntegerZoom = true);
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              if ("line-gradient" === t2) {
                const t3 = this.gradientExpression();
                this.stepInterpolant = !!function(t4) {
                  return void 0 !== t4._styleExpression;
                }(t3) && t3._styleExpression.expression instanceof sr, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = $u2.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new Bu(t2);
            }
            queryRadius(t2) {
              const e2 = t2, r2 = Ou2(Do2("line-width", this, e2), Do2("line-gap-width", this, e2)), n2 = Do2("line-offset", this, e2);
              return r2 / 2 + Math.abs(n2) + jo2(this.paint.get("line-translate"));
            }
            queryIntersectsFeature({ queryGeometry: t2, feature: e2, featureState: r2, geometry: n2, transform: i2, pixelsToTileUnits: s2 }) {
              const a2 = Ro2(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -i2.bearingInRadians, s2), o2 = s2 / 2 * Ou2(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), u2 = this.paint.get("line-offset").evaluate(e2, r2);
              return u2 && (n2 = function(t3, e3) {
                const r3 = [];
                for (let n3 = 0; n3 < t3.length; n3++) {
                  const i3 = t3[n3], s3 = [];
                  for (let t4 = 0; t4 < i3.length; t4++) {
                    const r4 = i3[t4 - 1], n4 = i3[t4], a3 = i3[t4 + 1], o3 = 0 === t4 ? new l(0, 0) : n4.sub(r4)._unit()._perp(), u3 = t4 === i3.length - 1 ? new l(0, 0) : a3.sub(n4)._unit()._perp(), c2 = o3._add(u3)._unit(), h3 = c2.x * u3.x + c2.y * u3.y;
                    0 !== h3 && c2._mult(1 / h3), s3.push(c2._mult(e3)._add(n4));
                  }
                  r3.push(s3);
                }
                return r3;
              }(n2, u2 * s2)), function(t3, e3, r3) {
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i3 = e3[n3];
                  if (t3.length >= 3) {
                    for (let e4 = 0; e4 < i3.length; e4++) if (Lo2(t3, i3[e4])) return true;
                  }
                  if (Bo2(t3, i3, r3)) return true;
                }
                return false;
              }(a2, n2, o2);
            }
            isTileClipped() {
              return true;
            }
          }
          function Ou2(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          const Du2 = Gs2([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), ju2 = Gs2([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          Gs2([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const Ru2 = Gs2([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
          Gs2([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const Nu2 = Gs2([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Uu = Gs2([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function qu2(t2, e2, r2) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e3, r3) {
                const n2 = e3.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Ss2.applyArabicShaping && (t4 = Ss2.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r2);
            }), t2;
          }
          Gs2([{ name: "triangle", components: 3, type: "Uint16" }]), Gs2([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Gs2([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Gs2([{ type: "Float32", name: "offsetX" }]), Gs2([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Gs2([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
          const Gu = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          var Zu, Ku, Xu, Hu = 24, Yu = {};
          function Ju() {
            return Zu || (Zu = 1, Yu.read = function(t2, e2, r2, n2, i2) {
              var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h3 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h3];
              for (h3 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h3], h3 += p2, c2 -= 8) ;
              for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h3], h3 += p2, c2 -= 8) ;
              if (0 === s2) s2 = 1 - u2;
              else {
                if (s2 === l2) return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
                a2 += Math.pow(2, n2), s2 -= u2;
              }
              return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
            }, Yu.write = function(t2, e2, r2, n2, i2, s2) {
              var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h3 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
              for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h3 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h3)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h3 >= c2 ? (o2 = 0, a2 = c2) : a2 + h3 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h3) : (o2 = e2 * Math.pow(2, h3 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8) ;
              for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8) ;
              t2[r2 + f2 - d2] |= 128 * y2;
            }), Yu;
          }
          function Wu() {
            if (Xu) return Ku;
            Xu = 1, Ku = e2;
            var t2 = Ju();
            function e2(t3) {
              this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            e2.Varint = 0, e2.Fixed64 = 1, e2.Bytes = 2, e2.Fixed32 = 5;
            var r2 = 4294967296, n2 = 1 / r2, i2 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
            function s2(t3) {
              return t3.type === e2.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
            }
            function a2(t3, e3, r3) {
              return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
            }
            function o2(t3, e3, r3) {
              var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
              r3.realloc(n3);
              for (var i3 = r3.pos - 1; i3 >= t3; i3--) r3.buf[i3 + n3] = r3.buf[i3];
            }
            function l2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeVarint(t3[r3]);
            }
            function u2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeSVarint(t3[r3]);
            }
            function c2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeFloat(t3[r3]);
            }
            function h3(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeDouble(t3[r3]);
            }
            function p2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeBoolean(t3[r3]);
            }
            function f2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeFixed32(t3[r3]);
            }
            function d2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeSFixed32(t3[r3]);
            }
            function y2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeFixed64(t3[r3]);
            }
            function m2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeSFixed64(t3[r3]);
            }
            function g3(t3, e3) {
              return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
            }
            function x3(t3, e3, r3) {
              t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
            }
            function v2(t3, e3) {
              return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
            }
            return e2.prototype = { destroy: function() {
              this.buf = null;
            }, readFields: function(t3, e3, r3) {
              for (r3 = r3 || this.length; this.pos < r3; ) {
                var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
                this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
              }
              return e3;
            }, readMessage: function(t3, e3) {
              return this.readFields(t3, e3, this.readVarint() + this.pos);
            }, readFixed32: function() {
              var t3 = g3(this.buf, this.pos);
              return this.pos += 4, t3;
            }, readSFixed32: function() {
              var t3 = v2(this.buf, this.pos);
              return this.pos += 4, t3;
            }, readFixed64: function() {
              var t3 = g3(this.buf, this.pos) + g3(this.buf, this.pos + 4) * r2;
              return this.pos += 8, t3;
            }, readSFixed64: function() {
              var t3 = g3(this.buf, this.pos) + v2(this.buf, this.pos + 4) * r2;
              return this.pos += 8, t3;
            }, readFloat: function() {
              var e3 = t2.read(this.buf, this.pos, true, 23, 4);
              return this.pos += 4, e3;
            }, readDouble: function() {
              var e3 = t2.read(this.buf, this.pos, true, 52, 8);
              return this.pos += 8, e3;
            }, readVarint: function(t3) {
              var e3, r3, n3 = this.buf;
              return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
                var n4, i3, s3 = r4.buf;
                if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128) return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128) return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128) return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128) return a2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128) return a2(t4, n4, e4);
                if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128) return a2(t4, n4, e4);
                throw new Error("Expected varint not more than 10 bytes");
              }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
            }, readVarint64: function() {
              return this.readVarint(true);
            }, readSVarint: function() {
              var t3 = this.readVarint();
              return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
            }, readBoolean: function() {
              return Boolean(this.readVarint());
            }, readString: function() {
              var t3 = this.readVarint() + this.pos, e3 = this.pos;
              return this.pos = t3, t3 - e3 >= 12 && i2 ? function(t4, e4, r3) {
                return i2.decode(t4.subarray(e4, r3));
              }(this.buf, e3, t3) : function(t4, e4, r3) {
                for (var n3 = "", i3 = e4; i3 < r3; ) {
                  var s3, a3, o3, l3 = t4[i3], u3 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
                  if (i3 + c3 > r3) break;
                  1 === c3 ? l3 < 128 && (u3 = l3) : 2 === c3 ? 128 == (192 & (s3 = t4[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & s3) <= 127 && (u3 = null) : 3 === c3 ? (a3 = t4[i3 + 2], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && ((u3 = (15 & l3) << 12 | (63 & s3) << 6 | 63 & a3) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null)) : 4 === c3 && (a3 = t4[i3 + 2], o3 = t4[i3 + 3], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & a3) && 128 == (192 & o3) && ((u3 = (15 & l3) << 18 | (63 & s3) << 12 | (63 & a3) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null)), null === u3 ? (u3 = 65533, c3 = 1) : u3 > 65535 && (u3 -= 65536, n3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), n3 += String.fromCharCode(u3), i3 += c3;
                }
                return n3;
              }(this.buf, e3, t3);
            }, readBytes: function() {
              var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
              return this.pos = t3, e3;
            }, readPackedVarint: function(t3, r3) {
              if (this.type !== e2.Bytes) return t3.push(this.readVarint(r3));
              var n3 = s2(this);
              for (t3 = t3 || []; this.pos < n3; ) t3.push(this.readVarint(r3));
              return t3;
            }, readPackedSVarint: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readSVarint());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSVarint());
              return t3;
            }, readPackedBoolean: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readBoolean());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readBoolean());
              return t3;
            }, readPackedFloat: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readFloat());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFloat());
              return t3;
            }, readPackedDouble: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readDouble());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readDouble());
              return t3;
            }, readPackedFixed32: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readFixed32());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFixed32());
              return t3;
            }, readPackedSFixed32: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readSFixed32());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSFixed32());
              return t3;
            }, readPackedFixed64: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readFixed64());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFixed64());
              return t3;
            }, readPackedSFixed64: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readSFixed64());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSFixed64());
              return t3;
            }, skip: function(t3) {
              var r3 = 7 & t3;
              if (r3 === e2.Varint) for (; this.buf[this.pos++] > 127; ) ;
              else if (r3 === e2.Bytes) this.pos = this.readVarint() + this.pos;
              else if (r3 === e2.Fixed32) this.pos += 4;
              else {
                if (r3 !== e2.Fixed64) throw new Error("Unimplemented type: " + r3);
                this.pos += 8;
              }
            }, writeTag: function(t3, e3) {
              this.writeVarint(t3 << 3 | e3);
            }, realloc: function(t3) {
              for (var e3 = this.length || 16; e3 < this.pos + t3; ) e3 *= 2;
              if (e3 !== this.length) {
                var r3 = new Uint8Array(e3);
                r3.set(this.buf), this.buf = r3, this.length = e3;
              }
            }, finish: function() {
              return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }, writeFixed32: function(t3) {
              this.realloc(4), x3(this.buf, t3, this.pos), this.pos += 4;
            }, writeSFixed32: function(t3) {
              this.realloc(4), x3(this.buf, t3, this.pos), this.pos += 4;
            }, writeFixed64: function(t3) {
              this.realloc(8), x3(this.buf, -1 & t3, this.pos), x3(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
            }, writeSFixed64: function(t3) {
              this.realloc(8), x3(this.buf, -1 & t3, this.pos), x3(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
            }, writeVarint: function(t3) {
              (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
                var r3, n3;
                if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                e3.realloc(10), function(t5, e4, r4) {
                  r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
                }(r3, 0, e3), function(t5, e4) {
                  var r4 = (7 & t5) << 4;
                  e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
                }(n3, e3);
              }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
            }, writeSVarint: function(t3) {
              this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
            }, writeBoolean: function(t3) {
              this.writeVarint(Boolean(t3));
            }, writeString: function(t3) {
              t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
              var e3 = this.pos;
              this.pos = function(t4, e4, r4) {
                for (var n3, i3, s3 = 0; s3 < e4.length; s3++) {
                  if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                    if (!i3) {
                      n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                      continue;
                    }
                    if (n3 < 56320) {
                      t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                      continue;
                    }
                    n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
                  } else i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
                  n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
                }
                return r4;
              }(this.buf, t3, this.pos);
              var r3 = this.pos - e3;
              r3 >= 128 && o2(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
            }, writeFloat: function(e3) {
              this.realloc(4), t2.write(this.buf, e3, this.pos, true, 23, 4), this.pos += 4;
            }, writeDouble: function(e3) {
              this.realloc(8), t2.write(this.buf, e3, this.pos, true, 52, 8), this.pos += 8;
            }, writeBytes: function(t3) {
              var e3 = t3.length;
              this.writeVarint(e3), this.realloc(e3);
              for (var r3 = 0; r3 < e3; r3++) this.buf[this.pos++] = t3[r3];
            }, writeRawMessage: function(t3, e3) {
              this.pos++;
              var r3 = this.pos;
              t3(e3, this);
              var n3 = this.pos - r3;
              n3 >= 128 && o2(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
            }, writeMessage: function(t3, r3, n3) {
              this.writeTag(t3, e2.Bytes), this.writeRawMessage(r3, n3);
            }, writePackedVarint: function(t3, e3) {
              e3.length && this.writeMessage(t3, l2, e3);
            }, writePackedSVarint: function(t3, e3) {
              e3.length && this.writeMessage(t3, u2, e3);
            }, writePackedBoolean: function(t3, e3) {
              e3.length && this.writeMessage(t3, p2, e3);
            }, writePackedFloat: function(t3, e3) {
              e3.length && this.writeMessage(t3, c2, e3);
            }, writePackedDouble: function(t3, e3) {
              e3.length && this.writeMessage(t3, h3, e3);
            }, writePackedFixed32: function(t3, e3) {
              e3.length && this.writeMessage(t3, f2, e3);
            }, writePackedSFixed32: function(t3, e3) {
              e3.length && this.writeMessage(t3, d2, e3);
            }, writePackedFixed64: function(t3, e3) {
              e3.length && this.writeMessage(t3, y2, e3);
            }, writePackedSFixed64: function(t3, e3) {
              e3.length && this.writeMessage(t3, m2, e3);
            }, writeBytesField: function(t3, r3) {
              this.writeTag(t3, e2.Bytes), this.writeBytes(r3);
            }, writeFixed32Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeFixed32(r3);
            }, writeSFixed32Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeSFixed32(r3);
            }, writeFixed64Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeFixed64(r3);
            }, writeSFixed64Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeSFixed64(r3);
            }, writeVarintField: function(t3, r3) {
              this.writeTag(t3, e2.Varint), this.writeVarint(r3);
            }, writeSVarintField: function(t3, r3) {
              this.writeTag(t3, e2.Varint), this.writeSVarint(r3);
            }, writeStringField: function(t3, r3) {
              this.writeTag(t3, e2.Bytes), this.writeString(r3);
            }, writeFloatField: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeFloat(r3);
            }, writeDoubleField: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeDouble(r3);
            }, writeBooleanField: function(t3, e3) {
              this.writeVarintField(t3, Boolean(e3));
            } }, Ku;
          }
          var Qu = r(Wu());
          const tc = 3;
          function ec(t2, e2, r2) {
            1 === t2 && r2.readMessage(rc, e2);
          }
          function rc(t2, e2, r2) {
            if (3 === t2) {
              const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(nc, {});
              e2.push({ id: t3, bitmap: new Qo2({ width: i2 + 2 * tc, height: s2 + 2 * tc }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
            }
          }
          function nc(t2, e2, r2) {
            1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
          }
          const ic = tc;
          function sc(t2) {
            let e2 = 0, r2 = 0;
            for (const n3 of t2) e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
            t2.sort((t3, e3) => e3.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
            let i2 = 0, s2 = 0;
            for (const e3 of t2) for (let t3 = n2.length - 1; t3 >= 0; t3--) {
              const r3 = n2[t3];
              if (!(e3.w > r3.w || e3.h > r3.h)) {
                if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                  const e4 = n2.pop();
                  t3 < n2.length && (n2[t3] = e4);
                } else e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                break;
              }
            }
            return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
          }
          const ac = 1;
          class oc {
            constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2, textFitWidth: a2, textFitHeight: o2 }) {
              this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = a2, this.textFitHeight = o2;
            }
            get tl() {
              return [this.paddedRect.x + ac, this.paddedRect.y + ac];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - ac, this.paddedRect.y + this.paddedRect.h - ac];
            }
            get tlbr() {
              return this.tl.concat(this.br);
            }
            get displaySize() {
              return [(this.paddedRect.w - 2 * ac) / this.pixelRatio, (this.paddedRect.h - 2 * ac) / this.pixelRatio];
            }
          }
          class lc {
            constructor(t2, e2) {
              const r2 = {}, n2 = {};
              this.haveRenderCallbacks = [];
              const i2 = [];
              this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
              const { w: s2, h: a2 } = sc(i2), o2 = new tl({ width: s2 || 1, height: a2 || 1 });
              for (const e3 in t2) {
                const n3 = t2[e3], i3 = r2[e3].paddedRect;
                tl.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + ac, y: i3.y + ac }, n3.data);
              }
              for (const t3 in e2) {
                const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + ac, a3 = i3.y + ac, l2 = r3.data.width, u2 = r3.data.height;
                tl.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), tl.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), tl.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), tl.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), tl.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
              }
              this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
            }
            addImages(t2, e2, r2) {
              for (const n2 in t2) {
                const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * ac, h: i2.data.height + 2 * ac };
                r2.push(s2), e2[n2] = new oc(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
              }
            }
            patchUpdatedImages(t2, e2) {
              t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r2 in t2.updatedImages) this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
            }
            patchUpdatedImage(t2, e2, r2) {
              if (!t2 || !e2) return;
              if (t2.version === e2.version) return;
              t2.version = e2.version;
              const [n2, i2] = t2.tl;
              r2.update(e2.data, void 0, { x: n2, y: i2 });
            }
          }
          var uc;
          is2("ImagePosition", oc), is2("ImageAtlas", lc), t.al = void 0, (uc = t.al || (t.al = {}))[uc.none = 0] = "none", uc[uc.horizontal = 1] = "horizontal", uc[uc.vertical = 2] = "vertical", uc[uc.horizontalOnly = 3] = "horizontalOnly";
          const cc = -17;
          class hc {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
            }
            static forText(t2, e2, r2) {
              const n2 = new hc();
              return n2.scale = t2 || 1, n2.fontStack = e2, n2.verticalAlign = r2 || "bottom", n2;
            }
            static forImage(t2, e2) {
              const r2 = new hc();
              return r2.imageName = t2, r2.verticalAlign = e2 || "bottom", r2;
            }
          }
          class pc {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e2) {
              const r2 = new pc();
              for (let n2 = 0; n2 < t2.sections.length; n2++) {
                const i2 = t2.sections[n2];
                i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
              }
              return r2;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCharCode(t2) {
              return this.text.charCodeAt(t2);
            }
            verticalizePunctuation() {
              this.text = function(t2) {
                let e2 = "";
                for (let r2 = 0; r2 < t2.length; r2++) {
                  const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                  e2 += n2 && vs2(n2) && !Gu[t2[r2 + 1]] || i2 && vs2(i2) && !Gu[t2[r2 - 1]] || !Gu[t2[r2]] ? t2[r2] : Gu[t2[r2]];
                }
                return e2;
              }(this.text);
            }
            trim() {
              let t2 = 0;
              for (let e3 = 0; e3 < this.text.length && dc[this.text.charCodeAt(e3)]; e3++) t2++;
              let e2 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && dc[this.text.charCodeAt(r2)]; r2--) e2--;
              this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
            }
            substring(t2, e2) {
              const r2 = new pc();
              return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
            }
            getMaxImageSize(t2) {
              let e2 = 0, r2 = 0;
              for (let n2 = 0; n2 < this.length(); n2++) {
                const i2 = this.getSection(n2);
                if (i2.imageName) {
                  const n3 = t2[i2.imageName];
                  if (!n3) continue;
                  const s2 = n3.displaySize;
                  e2 = Math.max(e2, s2[0]), r2 = Math.max(r2, s2[1]);
                }
              }
              return { maxImageWidth: e2, maxImageHeight: r2 };
            }
            addTextSection(t2, e2) {
              this.text += t2.text, this.sections.push(hc.forText(t2.scale, t2.fontStack || e2, t2.verticalAlign));
              const r2 = this.sections.length - 1;
              for (let e3 = 0; e3 < t2.text.length; ++e3) this.sectionIndex.push(r2);
            }
            addImageSection(t2) {
              const e2 = t2.image ? t2.image.name : "";
              if (0 === e2.length) return void U("Can't add FormattedSection with an empty image.");
              const r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCharCode(r2), this.sections.push(hc.forImage(e2, t2.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : U("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function fc(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2) {
            const m2 = pc.fromFeature(e2, s2);
            let g3;
            p2 === t.al.vertical && m2.verticalizePunctuation();
            const { processBidirectionalText: x3, processStyledBidirectionalText: v2 } = Ss2;
            if (x3 && 1 === m2.sections.length) {
              g3 = [];
              const t2 = x3(m2.toString(), _c(m2, c2, a2, r2, i2, d2));
              for (const e3 of t2) {
                const t3 = new pc();
                t3.text = e3, t3.sections = m2.sections;
                for (let r3 = 0; r3 < e3.length; r3++) t3.sectionIndex.push(0);
                g3.push(t3);
              }
            } else if (v2) {
              g3 = [];
              const t2 = v2(m2.text, m2.sectionIndex, _c(m2, c2, a2, r2, i2, d2));
              for (const e3 of t2) {
                const t3 = new pc();
                t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = m2.sections, g3.push(t3);
              }
            } else g3 = function(t2, e3) {
              const r3 = [], n3 = t2.text;
              let i3 = 0;
              for (const n4 of e3) r3.push(t2.substring(i3, n4)), i3 = n4;
              return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
            }(m2, _c(m2, c2, a2, r2, i2, d2));
            const b2 = [], w2 = { positionedLines: b2, text: m2.toString(), top: h3[1], bottom: h3[1], left: h3[0], right: h3[0], writingMode: p2, iconsInText: false, verticalizable: false };
            return function(t2, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h4) {
              let p3 = 0, f3 = 0, d3 = 0, y3 = 0;
              const m3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5, g4 = Hu / h4;
              let x4 = 0;
              for (const a4 of i3) {
                a4.trim();
                const i4 = a4.getMaxScale(), o4 = { positionedGlyphs: [], lineOffset: 0 };
                t2.positionedLines[x4] = o4;
                const h5 = o4.positionedGlyphs;
                let v5 = 0;
                if (!a4.length()) {
                  f3 += s3, ++x4;
                  continue;
                }
                const b4 = Sc(n3, a4, g4);
                for (let s4 = 0; s4 < a4.length(); s4++) {
                  const o5 = a4.getSection(s4), d4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4), m4 = Mc(l3, c3, y4);
                  let x5;
                  if (o5.imageName) {
                    if (t2.iconsInText = true, o5.scale = o5.scale * g4, x5 = zc(o5, m4, i4, b4, n3), !x5) continue;
                    v5 = Math.max(v5, x5.imageOffset);
                  } else if (x5 = Ic(o5, y4, m4, b4, e3, r3), !x5) continue;
                  const { rect: w4, metrics: _3, baselineOffset: A3 } = x5;
                  h5.push({ glyph: y4, imageName: o5.imageName, x: p3, y: f3 + A3 + cc, vertical: m4, scale: o5.scale, fontStack: o5.fontStack, sectionIndex: d4, metrics: _3, rect: w4 }), m4 ? (t2.verticalizable = true, p3 += (o5.imageName ? _3.advance : Hu) * o5.scale + u3) : p3 += _3.advance * o5.scale + u3;
                }
                0 !== h5.length && (d3 = Math.max(p3 - u3, d3), Pc(h5, 0, h5.length - 1, m3)), p3 = 0, o4.lineOffset = Math.max(v5, (i4 - 1) * Hu);
                const w3 = s3 * i4 + v5;
                f3 += w3, y3 = Math.max(w3, y3), ++x4;
              }
              const { horizontalAlign: v3, verticalAlign: b3 } = Ac(a3);
              (function(t3, e4, r4, n4, i4, s4, a4, o4, l4) {
                const u4 = (e4 - r4) * i4;
                let c4 = 0;
                c4 = s4 !== a4 ? -o4 * n4 - cc : -n4 * l4 * a4 + 0.5 * a4;
                for (const e5 of t3) for (const t4 of e5.positionedGlyphs) t4.x += u4, t4.y += c4;
              })(t2.positionedLines, m3, v3, b3, d3, y3, s3, f3, i3.length), t2.top += -b3 * f3, t2.bottom = t2.top + f3, t2.left += -v3 * d3, t2.right = t2.left + d3;
            }(w2, r2, n2, i2, g3, o2, l2, u2, p2, c2, f2, y2), !function(t2) {
              for (const e3 of t2) if (0 !== e3.positionedGlyphs.length) return false;
              return true;
            }(b2) && w2;
          }
          const dc = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, yc = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, mc = { 40: true };
          function gc(t2, e2, r2, n2, i2, s2) {
            if (e2.imageName) {
              const t3 = n2[e2.imageName];
              return t3 ? t3.displaySize[0] * e2.scale * Hu / s2 + i2 : 0;
            }
            {
              const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
              return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
            }
          }
          function xc(t2, e2, r2, n2) {
            const i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function vc(t2, e2, r2) {
            let n2 = 0;
            return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
          }
          function bc(t2, e2, r2, n2, i2, s2) {
            let a2 = null, o2 = xc(e2, r2, i2, s2);
            for (const t3 of n2) {
              const n3 = xc(e2 - t3.x, r2, i2, s2) + t3.badness;
              n3 <= o2 && (a2 = t3, o2 = n3);
            }
            return { index: t2, x: e2, priorBreak: a2, badness: o2 };
          }
          function wc(t2) {
            return t2 ? wc(t2.priorBreak).concat(t2.index) : [];
          }
          function _c(t2, e2, r2, n2, i2, s2) {
            if (!t2) return [];
            const a2 = [], o2 = function(t3, e3, r3, n3, i3, s3) {
              let a3 = 0;
              for (let r4 = 0; r4 < t3.length(); r4++) {
                const o3 = t3.getSection(r4);
                a3 += gc(t3.getCharCode(r4), o3, n3, i3, e3, s3);
              }
              return a3 / Math.max(1, Math.ceil(a3 / r3));
            }(t2, e2, r2, n2, i2, s2), l2 = t2.text.indexOf("\u200B") >= 0;
            let u2 = 0;
            for (let r3 = 0; r3 < t2.length(); r3++) {
              const h3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
              if (dc[p2] || (u2 += gc(p2, h3, n2, i2, e2, s2)), r3 < t2.length() - 1) {
                const e3 = !((c2 = p2) < 11904) && (!!hs2["CJK Compatibility Forms"](c2) || !!hs2["CJK Compatibility"](c2) || !!hs2["CJK Strokes"](c2) || !!hs2["CJK Symbols and Punctuation"](c2) || !!hs2["Enclosed CJK Letters and Months"](c2) || !!hs2["Halfwidth and Fullwidth Forms"](c2) || !!hs2["Ideographic Description Characters"](c2) || !!hs2["Vertical Forms"](c2) || gs2.test(String.fromCodePoint(c2)));
                (yc[p2] || e3 || h3.imageName || r3 !== t2.length() - 2 && mc[t2.getCharCode(r3 + 1)]) && a2.push(bc(r3 + 1, u2, o2, a2, vc(p2, t2.getCharCode(r3 + 1), e3 && l2), false));
              }
            }
            var c2;
            return wc(bc(t2.length(), u2, o2, a2, 0, true));
          }
          function Ac(t2) {
            let e2 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r2 };
          }
          function Sc(t2, e2, r2) {
            const n2 = e2.getMaxScale() * Hu, { maxImageWidth: i2, maxImageHeight: s2 } = e2.getMaxImageSize(t2), a2 = Math.max(n2, s2 * r2);
            return { verticalLineContentWidth: Math.max(n2, i2 * r2), horizontalLineContentHeight: a2 };
          }
          function kc(t2) {
            switch (t2) {
              case "top":
                return 0;
              case "center":
                return 0.5;
              default:
                return 1;
            }
          }
          function Mc(e2, r2, n2) {
            return !(e2 === t.al.horizontal || !r2 && !xs2(n2) || r2 && (dc[n2] || (i2 = n2, /\p{sc=Arab}/u.test(String.fromCodePoint(i2)))));
            var i2;
          }
          function Ic(t2, e2, r2, n2, i2, s2) {
            const a2 = s2[t2.fontStack], o2 = function(t3, e3, r3, n3) {
              if (t3 && t3.rect) return t3;
              const i3 = e3[r3.fontStack], s3 = i3 && i3[n3];
              return s3 ? { rect: null, metrics: s3.metrics } : null;
            }(a2 && a2[e2], i2, t2, e2);
            if (null === o2) return null;
            let l2;
            if (r2) l2 = n2.verticalLineContentWidth - t2.scale * Hu;
            else {
              const e3 = kc(t2.verticalAlign);
              l2 = (n2.horizontalLineContentHeight - t2.scale * Hu) * e3;
            }
            return { rect: o2.rect, metrics: o2.metrics, baselineOffset: l2 };
          }
          function zc(t2, e2, r2, n2, i2) {
            const s2 = i2[t2.imageName];
            if (!s2) return null;
            const a2 = s2.paddedRect, o2 = s2.displaySize, l2 = { width: o2[0], height: o2[1], left: ac, top: -3, advance: e2 ? o2[1] : o2[0] };
            let u2;
            if (e2) u2 = n2.verticalLineContentWidth - o2[1] * t2.scale;
            else {
              const e3 = kc(t2.verticalAlign);
              u2 = (n2.horizontalLineContentHeight - o2[1] * t2.scale) * e3;
            }
            return { rect: a2, metrics: l2, baselineOffset: u2, imageOffset: (e2 ? o2[0] : o2[1]) * t2.scale - Hu * r2 };
          }
          function Pc(t2, e2, r2, n2) {
            if (0 === n2) return;
            const i2 = t2[r2], s2 = (t2[r2].x + i2.metrics.advance * i2.scale) * n2;
            for (let n3 = e2; n3 <= r2; n3++) t2[n3].x -= s2;
          }
          function Cc(t2, e2, r2) {
            const { horizontalAlign: n2, verticalAlign: i2 } = Ac(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
            return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
          }
          function Bc(t2) {
            var e2, r2;
            let n2 = t2.left, i2 = t2.top, s2 = t2.right - n2, a2 = t2.bottom - i2;
            const o2 = null !== (e2 = t2.image.textFitWidth) && void 0 !== e2 ? e2 : "stretchOrShrink", l2 = null !== (r2 = t2.image.textFitHeight) && void 0 !== r2 ? r2 : "stretchOrShrink", u2 = (t2.image.content[2] - t2.image.content[0]) / (t2.image.content[3] - t2.image.content[1]);
            if ("proportional" === l2) {
              if ("stretchOnly" === o2 && s2 / a2 < u2 || "proportional" === o2) {
                const t3 = Math.ceil(a2 * u2);
                n2 *= t3 / s2, s2 = t3;
              }
            } else if ("proportional" === o2 && "stretchOnly" === l2 && 0 !== u2 && s2 / a2 > u2) {
              const t3 = Math.ceil(s2 / u2);
              i2 *= t3 / a2, a2 = t3;
            }
            return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + a2 };
          }
          function Vc(t2, e2, r2, n2, i2, s2) {
            const a2 = t2.image;
            let o2;
            if (a2.content) {
              const t3 = a2.content, e3 = a2.pixelRatio || 1;
              o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
            }
            const l2 = e2.left * s2, u2 = e2.right * s2;
            let c2, h3, p2, f2;
            "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h3 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h3 = f2 + a2.displaySize[0]);
            const d2 = e2.top * s2, y2 = e2.bottom * s2;
            return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h3, bottom: p2, left: f2, collisionPadding: o2 };
          }
          const Ec = 255, Tc = 128, Fc = Ec * Tc;
          function $c(t2, e2) {
            const { expression: r2 } = e2;
            if ("constant" === r2.kind) return { kind: "constant", layoutSize: r2.evaluate(new ks2(t2 + 1)) };
            if ("source" === r2.kind) return { kind: "source" };
            {
              const { zoomStops: e3, interpolationType: n2 } = r2;
              let i2 = 0;
              for (; i2 < e3.length && e3[i2] <= t2; ) i2++;
              i2 = Math.max(0, i2 - 1);
              let s2 = i2;
              for (; s2 < e3.length && e3[s2] < t2 + 1; ) s2++;
              s2 = Math.min(e3.length - 1, s2);
              const a2 = e3[i2], o2 = e3[s2];
              return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new ks2(a2)), maxSize: r2.evaluate(new ks2(o2)), interpolationType: n2 };
            }
          }
          function Lc(t2, e2, r2) {
            let n2 = "never";
            const i2 = t2.get(e2);
            return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
          }
          const Oc = hu2.VectorTileFeature.types, Dc = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function jc(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2) {
            const f2 = o2 ? Math.min(Fc, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Fc, Math.round(o2[1])) : 0;
            t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h3, 256 * p2);
          }
          function Rc(t2, e2, r2) {
            t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
          }
          function Nc(t2) {
            for (const e2 of t2.sections) if (As2(e2.text)) return true;
            return false;
          }
          class Uc {
            constructor(t2) {
              this.layoutVertexArray = new Fa(), this.indexArray = new ja(), this.programConfigurations = t2, this.segments = new qa2(), this.dynamicLayoutVertexArray = new $a(), this.opacityVertexArray = new La(), this.hasVisibleVertices = false, this.placedSymbolArray = new va();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t2, e2, r2, n2) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Du2.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, ju2.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Dc, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          is2("SymbolBuffers", Uc);
          class qc {
            constructor(t2, e2, r2) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new qa2(), this.collisionVertexArray = new Da();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ru2.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
          }
          is2("CollisionBuffers", qc);
          class Gc {
            constructor(e2) {
              this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
              const r2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = $c(this.zoom, r2["text-size"]), this.iconSizeData = $c(this.zoom, r2["icon-size"]);
              const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
              this.canOverlap = "never" !== Lc(n2, "text-overlap", "text-allow-overlap") || "never" !== Lc(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === s2 || "auto" === s2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.al[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
            }
            createArrays() {
              this.text = new Uc(new xo2(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Uc(new xo2(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new _a2(), this.lineVertexArray = new Aa(), this.symbolInstances = new wa(), this.textAnchorOffsets = new ka();
            }
            calculateGlyphDependencies(t2, e2, r2, n2, i2) {
              for (let s2 = 0; s2 < t2.length; s2++) if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
                const r3 = Gu[t2.charAt(s2)];
                r3 && (e2[r3.charCodeAt(0)] = true);
              }
            }
            populate(e2, r2, n2) {
              const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Pe2 && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h3 = s2.get("symbol-sort-key");
              if (this.features = [], !u2 && !c2) return;
              const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y2 = new ks2(this.zoom);
              for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
                const e3 = i2._featureFilter.needGeometry, g3 = So2(r3, e3);
                if (!i2._featureFilter.filter(y2, g3, n2)) continue;
                let x3, v2;
                if (e3 || (g3.geometry = Ao2(r3)), u2) {
                  const t2 = i2.getValueAndResolveTokens("text-field", g3, n2, d2), e4 = Pe2.factory(t2), r4 = this.hasRTLText = this.hasRTLText || Nc(e4);
                  (!r4 || "unavailable" === Ss2.getRTLTextPluginStatus() || r4 && Ss2.isParsed()) && (x3 = qu2(e4, i2, g3));
                }
                if (c2) {
                  const t2 = i2.getValueAndResolveTokens("icon-image", g3, n2, d2);
                  v2 = t2 instanceof $e2 ? t2 : $e2.fromString(t2);
                }
                if (!x3 && !v2) continue;
                const b2 = this.sortFeaturesByKey ? h3.evaluate(g3, {}, n2) : void 0;
                if (this.features.push({ id: o3, text: x3, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g3.geometry, properties: r3.properties, type: Oc[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x3) {
                  const e4 = a2.evaluate(g3, {}, n2).join(","), r4 = "viewport" !== s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.al.vertical) >= 0;
                  for (const t2 of x3.sections) if (t2.image) p2[t2.image.name] = true;
                  else {
                    const n3 = ps2(x3.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                    this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                  }
                }
              }
              "line" === s2.get("symbol-placement") && (this.features = function(t2) {
                const e3 = {}, r3 = {}, n3 = [];
                let i3 = 0;
                function s3(e4) {
                  n3.push(t2[e4]), i3++;
                }
                function a3(t3, e4, i4) {
                  const s4 = r3[t3];
                  return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
                }
                function o3(t3, r4, i4) {
                  const s4 = e3[r4];
                  return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
                }
                function l3(t3, e4, r4) {
                  const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return `${t3}:${n4.x}:${n4.y}`;
                }
                for (let u3 = 0; u3 < t2.length; u3++) {
                  const c3 = t2[u3], h4 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    s3(u3);
                    continue;
                  }
                  const f3 = l3(p3, h4), d3 = l3(p3, h4, true);
                  if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                    const t3 = o3(f3, d3, h4), i4 = a3(f3, d3, n3[t3].geometry);
                    delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                  } else f3 in r3 ? a3(f3, d3, h4) : d3 in e3 ? o3(f3, d3, h4) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
                }
                return n3.filter((t3) => t3.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
            }
            update(t2, e2, r2) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e2) {
              const r2 = this.lineVertexArray.length;
              if (void 0 !== t2.segment) {
                let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
                const i2 = {};
                for (let n3 = t2.segment + 1; n3 < e2.length; n3++) i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
                for (let r4 = t2.segment || 0; r4 >= 0; r4--) i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
                for (let t3 = 0; t3 < e2.length; t3++) {
                  const e3 = i2[t3];
                  this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2) {
              const f2 = e2.indexArray, d2 = e2.layoutVertexArray, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g3 = y2.vertexLength, x3 = this.allowVerticalPlacement && o2 === t.al.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
              for (let t2 = 0; t2 < r2.length; t2++) {
                const { tl: i3, tr: s3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h4, pixelOffsetBR: m3, minFontScaleX: g4, minFontScaleY: b2, glyphOffset: w2, isSDF: _3, sectionIndex: A3 } = r2[t2], S3 = y2.vertexLength, k2 = w2[1];
                jc(d2, l2.x, l2.y, i3.x, k2 + i3.y, c3.x, c3.y, n2, _3, h4.x, h4.y, g4, b2), jc(d2, l2.x, l2.y, s3.x, k2 + s3.y, c3.x + c3.w, c3.y, n2, _3, m3.x, h4.y, g4, b2), jc(d2, l2.x, l2.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _3, h4.x, m3.y, g4, b2), jc(d2, l2.x, l2.y, u3.x, k2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _3, m3.x, m3.y, g4, b2), Rc(e2.dynamicLayoutVertexArray, l2, x3), f2.emplaceBack(S3, S3 + 2, S3 + 1), f2.emplaceBack(S3 + 1, S3 + 2, S3 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A3 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A3]);
              }
              e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g3, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h3);
            }
            _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
              return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
            }
            addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, a2) {
              const o2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), u2 = o2.vertexLength, c2 = i2.layoutVertexArray, h3 = i2.collisionVertexArray, p2 = a2.anchorX, f2 = a2.anchorY;
              this._addCollisionDebugVertex(c2, h3, s2, p2, f2, new l(t2, e2)), this._addCollisionDebugVertex(c2, h3, s2, p2, f2, new l(r2, e2)), this._addCollisionDebugVertex(c2, h3, s2, p2, f2, new l(r2, n2)), this._addCollisionDebugVertex(c2, h3, s2, p2, f2, new l(t2, n2)), o2.vertexLength += 4;
              const d2 = i2.indexArray;
              d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), o2.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t2, e2, r2, n2) {
              for (let i2 = t2; i2 < e2; i2++) {
                const t3 = this.collisionBoxArray.get(i2);
                this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
              }
            }
            generateCollisionDebugBuffers() {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new qc(Oa2, Nu2.members, Ra), this.iconCollisionBox = new qc(Oa2, Nu2.members, Ra);
              for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
                const e2 = this.symbolInstances.get(t2);
                this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
              }
            }
            _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
              const u2 = {};
              for (let n3 = e2; n3 < r2; n3++) {
                const e3 = t2.get(n3);
                u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u2.textFeatureIndex = e3.featureIndex;
                break;
              }
              for (let e3 = n2; e3 < i2; e3++) {
                const r3 = t2.get(e3);
                u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e3 = s2; e3 < a2; e3++) {
                const r3 = t2.get(e3);
                u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e3 = o2; e3 < l2; e3++) {
                const r3 = t2.get(e3);
                u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
                break;
              }
              return u2;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r2 = this.symbolInstances.get(e2);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t2, e2) {
              const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4) t2.indexArray.emplaceBack(e3, e3 + 2, e3 + 1), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
              const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                s2.push(t3);
                const a2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
              }
              return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
            }
            addToSortKeyRanges(t2, e2) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e2 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                    t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
                  }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          let Zc, Kc;
          is2("SymbolBucket", Gc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Gc.MAX_GLYPHS = 65535, Gc.addDynamicAttributes = Rc;
          var Xc = { get paint() {
            return Kc = Kc || new Ds2({ "icon-opacity": new Fs2(gt2.paint_symbol["icon-opacity"]), "icon-color": new Fs2(gt2.paint_symbol["icon-color"]), "icon-halo-color": new Fs2(gt2.paint_symbol["icon-halo-color"]), "icon-halo-width": new Fs2(gt2.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Fs2(gt2.paint_symbol["icon-halo-blur"]), "icon-translate": new Ts2(gt2.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ts2(gt2.paint_symbol["icon-translate-anchor"]), "text-opacity": new Fs2(gt2.paint_symbol["text-opacity"]), "text-color": new Fs2(gt2.paint_symbol["text-color"], { runtimeType: Lt2, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Fs2(gt2.paint_symbol["text-halo-color"]), "text-halo-width": new Fs2(gt2.paint_symbol["text-halo-width"]), "text-halo-blur": new Fs2(gt2.paint_symbol["text-halo-blur"]), "text-translate": new Ts2(gt2.paint_symbol["text-translate"]), "text-translate-anchor": new Ts2(gt2.paint_symbol["text-translate-anchor"]) });
          }, get layout() {
            return Zc = Zc || new Ds2({ "symbol-placement": new Ts2(gt2.layout_symbol["symbol-placement"]), "symbol-spacing": new Ts2(gt2.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ts2(gt2.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Fs2(gt2.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ts2(gt2.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ts2(gt2.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Ts2(gt2.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Ts2(gt2.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ts2(gt2.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ts2(gt2.layout_symbol["icon-rotation-alignment"]), "icon-size": new Fs2(gt2.layout_symbol["icon-size"]), "icon-text-fit": new Ts2(gt2.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ts2(gt2.layout_symbol["icon-text-fit-padding"]), "icon-image": new Fs2(gt2.layout_symbol["icon-image"]), "icon-rotate": new Fs2(gt2.layout_symbol["icon-rotate"]), "icon-padding": new Fs2(gt2.layout_symbol["icon-padding"]), "icon-keep-upright": new Ts2(gt2.layout_symbol["icon-keep-upright"]), "icon-offset": new Fs2(gt2.layout_symbol["icon-offset"]), "icon-anchor": new Fs2(gt2.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ts2(gt2.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ts2(gt2.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ts2(gt2.layout_symbol["text-rotation-alignment"]), "text-field": new Fs2(gt2.layout_symbol["text-field"]), "text-font": new Fs2(gt2.layout_symbol["text-font"]), "text-size": new Fs2(gt2.layout_symbol["text-size"]), "text-max-width": new Fs2(gt2.layout_symbol["text-max-width"]), "text-line-height": new Ts2(gt2.layout_symbol["text-line-height"]), "text-letter-spacing": new Fs2(gt2.layout_symbol["text-letter-spacing"]), "text-justify": new Fs2(gt2.layout_symbol["text-justify"]), "text-radial-offset": new Fs2(gt2.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ts2(gt2.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Fs2(gt2.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Fs2(gt2.layout_symbol["text-anchor"]), "text-max-angle": new Ts2(gt2.layout_symbol["text-max-angle"]), "text-writing-mode": new Ts2(gt2.layout_symbol["text-writing-mode"]), "text-rotate": new Fs2(gt2.layout_symbol["text-rotate"]), "text-padding": new Ts2(gt2.layout_symbol["text-padding"]), "text-keep-upright": new Ts2(gt2.layout_symbol["text-keep-upright"]), "text-transform": new Fs2(gt2.layout_symbol["text-transform"]), "text-offset": new Fs2(gt2.layout_symbol["text-offset"]), "text-allow-overlap": new Ts2(gt2.layout_symbol["text-allow-overlap"]), "text-overlap": new Ts2(gt2.layout_symbol["text-overlap"]), "text-ignore-placement": new Ts2(gt2.layout_symbol["text-ignore-placement"]), "text-optional": new Ts2(gt2.layout_symbol["text-optional"]) });
          } };
          class Hc {
            constructor(t2) {
              if (void 0 === t2.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Et2, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e2 = this.defaultValue.property.overrides;
                if (e2 && e2.hasOverride(t2.formattedSection)) return e2.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          is2("FormatSectionOverride", Hc, { omit: ["defaultValue"] });
          class Yc extends Rs2 {
            constructor(t2) {
              super(t2, Xc);
            }
            recalculate(t2, e2) {
              if (super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                const t3 = this.layout.get("text-writing-mode");
                if (t3) {
                  const e3 = [];
                  for (const r2 of t3) e3.indexOf(r2) < 0 && e3.push(r2);
                  this.layout._values["text-writing-mode"] = e3;
                } else this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t2, e2, r2, n2) {
              const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
              return s2.isDataDriven() || ti2(s2.value) || !i2 ? i2 : function(t3, e3) {
                return e3.replace(/{([^{}]+)}/g, (e4, r3) => t3 && r3 in t3 ? String(t3[r3]) : "");
              }(e2.properties, i2);
            }
            createBucket(t2) {
              return new Gc(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              throw new Error("Should take a different path in FeatureIndex");
            }
            _setPaintOverrides() {
              for (const t2 of Xc.paint.overridableProperties) {
                if (!Yc.hasPaintOverride(this.layout, t2)) continue;
                const e2 = this.paint.get(t2), r2 = new Hc(e2), n2 = new Qn2(r2, e2.property.specification);
                let i2 = null;
                i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new ri2("source", n2) : new ni2("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new Vs2(e2.property, i2, e2.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Yc.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e2) {
              const r2 = t2.get("text-field"), n2 = Xc.paint.properties[e2];
              let i2 = false;
              const s2 = (t3) => {
                for (const e3 of t3) if (n2.overrides && n2.overrides.hasOverride(e3)) return void (i2 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof Pe2) s2(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                const t3 = (e4) => {
                  i2 || (e4 instanceof Ne2 && je2(e4.value) === Nt2 ? s2(e4.value.sections) : e4 instanceof Mr2 ? s2(e4.sections) : e4.eachChild(t3));
                }, e3 = r2.value;
                e3._styleExpression && t3(e3._styleExpression.expression);
              }
              return i2;
            }
          }
          let Jc;
          var Wc = { get paint() {
            return Jc = Jc || new Ds2({ "background-color": new Ts2(gt2.paint_background["background-color"]), "background-pattern": new Ls2(gt2.paint_background["background-pattern"]), "background-opacity": new Ts2(gt2.paint_background["background-opacity"]) });
          } };
          class Qc extends Rs2 {
            constructor(t2) {
              super(t2, Wc);
            }
          }
          let th;
          var eh = { get paint() {
            return th = th || new Ds2({ "raster-opacity": new Ts2(gt2.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ts2(gt2.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ts2(gt2.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ts2(gt2.paint_raster["raster-brightness-max"]), "raster-saturation": new Ts2(gt2.paint_raster["raster-saturation"]), "raster-contrast": new Ts2(gt2.paint_raster["raster-contrast"]), "raster-resampling": new Ts2(gt2.paint_raster["raster-resampling"]), "raster-fade-duration": new Ts2(gt2.paint_raster["raster-fade-duration"]) });
          } };
          class rh extends Rs2 {
            constructor(t2) {
              super(t2, eh);
            }
          }
          class nh extends Rs2 {
            constructor(t2) {
              super(t2, {}), this.onAdd = (t3) => {
                this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
              }, this.onRemove = (t3) => {
                this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
              }, this.implementation = t2;
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
              throw new Error("Custom layers cannot be serialized");
            }
          }
          class ih {
            constructor(t2) {
              this._methodToThrottle = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._methodToThrottle();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._methodToThrottle();
              }, 0));
            }
            remove() {
              delete this._channel, this._methodToThrottle = () => {
              };
            }
          }
          const sh = { once: true }, ah = 63710088e-1;
          class oh {
            constructor(t2, e2) {
              if (isNaN(t2) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
              if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new oh($2(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
              return ah * Math.acos(Math.min(i2, 1));
            }
            static convert(t2) {
              if (t2 instanceof oh) return t2;
              if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length)) return new oh(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2) return new oh(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          const lh = 2 * Math.PI * ah;
          function uh(t2) {
            return lh * Math.cos(t2 * Math.PI / 180);
          }
          function ch(t2) {
            return (180 + t2) / 360;
          }
          function hh(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function ph(t2, e2) {
            return t2 / uh(e2);
          }
          function fh(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function dh(t2, e2) {
            return t2 * uh(fh(e2));
          }
          class yh {
            constructor(t2, e2, r2 = 0) {
              this.x = +t2, this.y = +e2, this.z = +r2;
            }
            static fromLngLat(t2, e2 = 0) {
              const r2 = oh.convert(t2);
              return new yh(ch(r2.lng), hh(r2.lat), ph(e2, r2.lat));
            }
            toLngLat() {
              return new oh(360 * this.x - 180, fh(this.y));
            }
            toAltitude() {
              return dh(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
              return 1 / lh * (t2 = fh(this.y), 1 / Math.cos(t2 * Math.PI / 180));
              var t2;
            }
          }
          function mh(t2, e2, r2) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          class gh {
            constructor(t2, e2, r2) {
              if (!function(t3, e3, r3) {
                return !(t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3));
              }(t2, e2, r2)) throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
              this.z = t2, this.x = e2, this.y = r2, this.key = bh(0, t2, t2, e2, r2);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e2, r2) {
              const n2 = (s2 = this.y, a2 = this.z, o2 = mh(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l2 = mh(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
              var i2, s2, a2, o2, l2;
              const u2 = function(t3, e3, r3) {
                let n3, i3 = "";
                for (let s3 = t3; s3 > 0; s3--) n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
                return i3;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
            }
            isChildOf(t2) {
              const e2 = this.z - t2.z;
              return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
            }
            getTilePoint(t2) {
              const e2 = Math.pow(2, this.z);
              return new l((t2.x * e2 - this.x) * z, (t2.y * e2 - this.y) * z);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class xh {
            constructor(t2, e2) {
              this.wrap = t2, this.canonical = e2, this.key = bh(t2, e2.z, e2.z, e2.x, e2.y);
            }
          }
          class vh {
            constructor(t2, e2, r2, n2, i2) {
              if (this.terrainRttPosMatrix32f = null, t2 < r2) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
              this.overscaledZ = t2, this.wrap = e2, this.canonical = new gh(r2, +n2, +i2), this.key = bh(e2, t2, r2, n2, i2);
            }
            clone() {
              return new vh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              if (t2 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
              const e2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new vh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new vh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
            }
            calculateScaledKey(t2, e2) {
              if (t2 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
              const r2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? bh(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : bh(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap) return false;
              const e2 = this.canonical.z - t2.canonical.z;
              return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
            }
            children(t2) {
              if (this.overscaledZ >= t2) return [new vh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new vh(e2, this.wrap, e2, r2, n2), new vh(e2, this.wrap, e2, r2 + 1, n2), new vh(e2, this.wrap, e2, r2, n2 + 1), new vh(e2, this.wrap, e2, r2 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new vh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new vh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new xh(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t2) {
              return this.canonical.getTilePoint(new yh(t2.x - this.wrap, t2.y));
            }
          }
          function bh(t2, e2, r2, n2, i2) {
            (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
            const s2 = 1 << r2;
            return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
          }
          is2("CanonicalTileID", gh), is2("OverscaledTileID", vh, { omit: ["terrainRttPosMatrix32f"] });
          class wh {
            constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
              if (this.uid = t2, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
              if (r2 && !["mapbox", "terrarium", "custom"].includes(r2)) return void U(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
              this.stride = e2.height;
              const o2 = this.dim = e2.height - 2;
              switch (this.data = new Uint32Array(e2.data.buffer), r2) {
                case "terrarium":
                  this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                  break;
                case "custom":
                  this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
                  break;
                default:
                  this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
              }
              for (let t3 = 0; t3 < o2; t3++) this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t3 = 0; t3 < o2; t3++) for (let e3 = 0; e3 < o2; e3++) {
                const r3 = this.get(t3, e3);
                r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
              }
            }
            get(t2, e2) {
              const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
              return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
            }
            getUnpackVector() {
              return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
            }
            _idx(t2, e2) {
              if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
              return (e2 + 1) * this.stride + (t2 + 1);
            }
            unpack(t2, e2, r2) {
              return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
            }
            getPixels() {
              return new tl({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t2, e2, r2) {
              if (this.dim !== t2.dim) throw new Error("dem dimension mismatch");
              let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
              switch (e2) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r2) {
                case -1:
                  s2 = a2 - 1;
                  break;
                case 1:
                  a2 = s2 + 1;
              }
              const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
              for (let e3 = s2; e3 < a2; e3++) for (let r3 = n2; r3 < i2; r3++) this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
            }
          }
          is2("DEMData", wh);
          class _h {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r2 = t2[e2];
                this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              if (t2 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
              return this._numberToString[t2];
            }
          }
          class Ah {
            constructor(t2, e2, r2, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { geometry: this.geometry };
              for (const e2 in this) "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
              return t2;
            }
          }
          class Sh {
            constructor(t2, e2) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new rs2(z, 16, 0), this.grid3D = new rs2(z, 16, 0), this.featureIndexArray = new Ia(), this.promoteId = e2;
            }
            insert(t2, e2, r2, n2, i2, s2) {
              const a2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n2, i2);
              const o2 = s2 ? this.grid3D : this.grid;
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r3.length; t4++) {
                  const e3 = r3[t4];
                  n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
                }
                n3[0] < z && n3[1] < z && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new hu2.VectorTile(new Qu(this.rawTileData)).layers, this.sourceLayerCoder = new _h(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t2, e2, r2, n2) {
              this.loadVTLayers();
              const i2 = t2.params, s2 = z / t2.tileSize / t2.scale, a2 = ui2(i2.filter), o2 = t2.queryGeometry, u2 = t2.queryPadding * s2, c2 = Mh(o2), h3 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = Mh(t2.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u2, p2.minY - u2, p2.maxX + u2, p2.maxY + u2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
                for (const s4 of t3) if (e4 <= s4.x && r4 <= s4.y && n4 >= s4.x && i4 >= s4.y) return true;
                const s3 = [new l(e4, r4), new l(e4, i4), new l(n4, i4), new l(n4, r4)];
                if (t3.length > 2) {
                  for (const e5 of s3) if (Lo2(t3, e5)) return true;
                }
                for (let e5 = 0; e5 < t3.length - 1; e5++) if (Oo2(t3[e5], t3[e5 + 1], s3)) return true;
                return false;
              }(t2.cameraQueryGeometry, e3 - u2, r3 - u2, n3 + u2, i3 + u2));
              for (const t3 of f2) h3.push(t3);
              h3.sort(Ih);
              const d2 = {};
              let y2;
              for (let l2 = 0; l2 < h3.length; l2++) {
                const u3 = h3[l2];
                if (u3 === y2) continue;
                y2 = u3;
                const c3 = this.featureIndexArray.get(u3);
                let p3 = null;
                this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, a2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Ao2(e3)), r3.queryIntersectsFeature({ queryGeometry: o2, feature: e3, featureState: n3, geometry: p3, zoom: this.z, transform: t2.transform, pixelsToTileUnits: s2, pixelPosMatrix: t2.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t2.getElevation })));
              }
              return d2;
            }
            loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
              const h3 = this.bucketLayerIDs[e2];
              if (s2 && !h3.some((t3) => s2.has(t3))) return;
              const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
              if (i2.needGeometry) {
                const t3 = So2(f2, true);
                if (!i2.filter(new ks2(this.tileID.overscaledZ), t3, this.tileID.canonical)) return;
              } else if (!i2.filter(new ks2(this.tileID.overscaledZ), f2)) return;
              const d2 = this.getId(f2, p2);
              for (let e3 = 0; e3 < h3.length; e3++) {
                const r3 = h3[e3];
                if (s2 && !s2.has(r3)) continue;
                const i3 = o2[r3];
                if (!i3) continue;
                let p3 = {};
                d2 && u2 && (p3 = u2.getState(i3.sourceLayer || "_geojsonTileLayer", d2));
                const y2 = L2({}, l2[r3]);
                y2.paint = kh(y2.paint, i3.paint, f2, p3, a2), y2.layout = kh(y2.layout, i3.layout, f2, p3, a2);
                const m2 = !c2 || c2(f2, i3, p3);
                if (!m2) continue;
                const g3 = new Ah(f2, this.z, this.x, this.y, d2);
                g3.layer = y2;
                let x3 = t2[r3];
                void 0 === x3 && (x3 = t2[r3] = []), x3.push({ featureIndex: n2, feature: g3, intersectionZ: m2 });
              }
            }
            lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = ui2(i2);
              for (const i3 of t2) this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, a2, o2, e2);
              return l2;
            }
            hasLayer(t2) {
              for (const e2 of this.bucketLayerIDs) for (const r2 of e2) if (t2 === r2) return true;
              return false;
            }
            getId(t2, e2) {
              var r2;
              let n2 = t2.id;
              return this.promoteId && (n2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof n2 && (n2 = Number(n2)), void 0 === n2 && (null === (r2 = t2.properties) || void 0 === r2 ? void 0 : r2.cluster) && this.promoteId && (n2 = Number(t2.properties.cluster_id))), n2;
            }
          }
          function kh(t2, e2, r2, n2, i2) {
            return D2(t2, (t3, s2) => {
              const a2 = e2 instanceof Es2 ? e2.get(s2) : null;
              return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
            });
          }
          function Mh(t2) {
            let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
          }
          function Ih(t2, e2) {
            return e2 - t2;
          }
          function zh(t2, e2, r2, n2, i2) {
            const s2 = [];
            for (let a2 = 0; a2 < t2.length; a2++) {
              const o2 = t2[a2];
              let u2;
              for (let t3 = 0; t3 < o2.length - 1; t3++) {
                let a3 = o2[t3], c2 = o2[t3 + 1];
                a3.x < e2 && c2.x < e2 || (a3.x < e2 ? a3 = new l(e2, a3.y + (e2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round() : c2.x < e2 && (c2 = new l(e2, a3.y + (e2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round()), a3.y < r2 && c2.y < r2 || (a3.y < r2 ? a3 = new l(a3.x + (r2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), r2)._round() : c2.y < r2 && (c2 = new l(a3.x + (r2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), r2)._round()), a3.x >= n2 && c2.x >= n2 || (a3.x >= n2 ? a3 = new l(n2, a3.y + (n2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round() : c2.x >= n2 && (c2 = new l(n2, a3.y + (n2 - a3.x) / (c2.x - a3.x) * (c2.y - a3.y))._round()), a3.y >= i2 && c2.y >= i2 || (a3.y >= i2 ? a3 = new l(a3.x + (i2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), i2)._round() : c2.y >= i2 && (c2 = new l(a3.x + (i2 - a3.y) / (c2.y - a3.y) * (c2.x - a3.x), i2)._round()), u2 && a3.equals(u2[u2.length - 1]) || (u2 = [a3], s2.push(u2)), u2.push(c2)))));
              }
            }
            return s2;
          }
          is2("FeatureIndex", Sh, { omit: ["rawTileData", "sourceLayerCoder"] });
          class Ph extends l {
            constructor(t2, e2, r2, n2) {
              super(t2, e2), this.angle = r2, void 0 !== n2 && (this.segment = n2);
            }
            clone() {
              return new Ph(this.x, this.y, this.angle, this.segment);
            }
          }
          function Ch(t2, e2, r2, n2, i2) {
            if (void 0 === e2.segment || 0 === r2) return true;
            let s2 = e2, a2 = e2.segment + 1, o2 = 0;
            for (; o2 > -r2 / 2; ) {
              if (a2--, a2 < 0) return false;
              o2 -= t2[a2].dist(s2), s2 = t2[a2];
            }
            o2 += t2[a2].dist(t2[a2 + 1]), a2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r2 / 2; ) {
              const e3 = t2[a2], r3 = t2[a2 + 1];
              if (!r3) return false;
              let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
              for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; ) u2 -= l2.shift().angleDelta;
              if (u2 > i2) return false;
              a2++, o2 += e3.dist(r3);
            }
            return true;
          }
          function Bh(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += t2[r2].dist(t2[r2 + 1]);
            return e2;
          }
          function Vh(t2, e2, r2) {
            return t2 ? 0.6 * e2 * r2 : 0;
          }
          function Eh(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function Th(t2, e2, r2, n2, i2, s2) {
            const a2 = Vh(r2, i2, s2), o2 = Eh(r2, n2) * s2;
            let l2 = 0;
            const u2 = Bh(t2) / 2;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
              if (l2 + s3 > u2) {
                const c2 = (u2 - l2) / s3, h3 = fr2.number(n3.x, i3.x, c2), p2 = fr2.number(n3.y, i3.y, c2), f2 = new Ph(h3, p2, i3.angleTo(n3), r3);
                return f2._round(), !a2 || Ch(t2, f2, o2, a2, e2) ? f2 : void 0;
              }
              l2 += s3;
            }
          }
          function Fh(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = Vh(n2, s2, a2), c2 = Eh(n2, i2), h3 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
            return e2 - h3 < e2 / 4 && (e2 = h3 + e2 / 4), $h(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h3, p2, false, l2);
          }
          function $h(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
            const u2 = s2 / 2, c2 = Bh(t2);
            let h3 = 0, p2 = e2 - r2, f2 = [];
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
              for (; p2 + r2 < h3 + d2; ) {
                p2 += r2;
                const m2 = (p2 - h3) / d2, g3 = fr2.number(a3.x, o3.x, m2), x3 = fr2.number(a3.y, o3.y, m2);
                if (g3 >= 0 && g3 < l2 && x3 >= 0 && x3 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                  const r3 = new Ph(g3, x3, y2, e3);
                  r3._round(), n2 && !Ch(t2, r3, s2, n2, i2) || f2.push(r3);
                }
              }
              h3 += d2;
            }
            return o2 || f2.length || a2 || (f2 = $h(t2, h3 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
          }
          is2("Anchor", Ph);
          const Lh = ac;
          function Oh(t2, e2, r2, n2) {
            const i2 = [], s2 = t2.image, a2 = s2.pixelRatio, o2 = s2.paddedRect.w - 2 * Lh, u2 = s2.paddedRect.h - 2 * Lh;
            let c2 = { x1: t2.left, y1: t2.top, x2: t2.right, y2: t2.bottom };
            const h3 = s2.stretchX || [[0, o2]], p2 = s2.stretchY || [[0, u2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h3.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = o2 - d2, g3 = u2 - y2;
            let x3 = 0, v2 = d2, b2 = 0, w2 = y2, _3 = 0, A3 = m2, S3 = 0, k2 = g3;
            if (s2.content && n2) {
              const e3 = s2.content, r3 = e3[2] - e3[0], n3 = e3[3] - e3[1];
              (s2.textFitWidth || s2.textFitHeight) && (c2 = Bc(t2)), x3 = Dh(h3, 0, e3[0]), b2 = Dh(p2, 0, e3[1]), v2 = Dh(h3, e3[0], e3[2]), w2 = Dh(p2, e3[1], e3[3]), _3 = e3[0] - x3, S3 = e3[1] - b2, A3 = r3 - v2, k2 = n3 - w2;
            }
            const M3 = c2.x1, I3 = c2.y1, z2 = c2.x2 - M3, P2 = c2.y2 - I3, C3 = (t3, n3, i3, o3) => {
              const u3 = Rh(t3.stretch - x3, v2, z2, M3), c3 = Nh(t3.fixed - _3, A3, t3.stretch, d2), h4 = Rh(n3.stretch - b2, w2, P2, I3), p3 = Nh(n3.fixed - S3, k2, n3.stretch, y2), f3 = Rh(i3.stretch - x3, v2, z2, M3), m3 = Nh(i3.fixed - _3, A3, i3.stretch, d2), g4 = Rh(o3.stretch - b2, w2, P2, I3), C4 = Nh(o3.fixed - S3, k2, o3.stretch, y2), B3 = new l(u3, h4), V3 = new l(f3, h4), E3 = new l(f3, g4), T2 = new l(u3, g4), F3 = new l(c3 / a2, p3 / a2), $3 = new l(m3 / a2, C4 / a2), L3 = e2 * Math.PI / 180;
              if (L3) {
                const t4 = Math.sin(L3), e3 = Math.cos(L3), r3 = [e3, -t4, t4, e3];
                B3._matMult(r3), V3._matMult(r3), T2._matMult(r3), E3._matMult(r3);
              }
              const O3 = t3.stretch + t3.fixed, D3 = n3.stretch + n3.fixed;
              return { tl: B3, tr: V3, bl: T2, br: E3, tex: { x: s2.paddedRect.x + Lh + O3, y: s2.paddedRect.y + Lh + D3, w: i3.stretch + i3.fixed - O3, h: o3.stretch + o3.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F3, pixelOffsetBR: $3, minFontScaleX: A3 / a2 / z2, minFontScaleY: k2 / a2 / P2, isSDF: r2 };
            };
            if (n2 && (s2.stretchX || s2.stretchY)) {
              const t3 = jh(h3, m2, d2), e3 = jh(p2, g3, y2);
              for (let r3 = 0; r3 < t3.length - 1; r3++) {
                const n3 = t3[r3], s3 = t3[r3 + 1];
                for (let t4 = 0; t4 < e3.length - 1; t4++) i2.push(C3(n3, e3[t4], s3, e3[t4 + 1]));
              }
            } else i2.push(C3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
            return i2;
          }
          function Dh(t2, e2, r2) {
            let n2 = 0;
            for (const i2 of t2) n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
            return n2;
          }
          function jh(t2, e2, r2) {
            const n2 = [{ fixed: -1, stretch: 0 }];
            for (const [e3, r3] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
            }
            return n2.push({ fixed: e2 + Lh, stretch: r2 }), n2;
          }
          function Rh(t2, e2, r2, n2) {
            return t2 / e2 * r2 + n2;
          }
          function Nh(t2, e2, r2, n2) {
            return t2 - e2 * r2 / n2;
          }
          class Uh {
            constructor(t2, e2, r2, n2, i2, s2, a2, o2, u2, c2) {
              var h3;
              if (this.boxStartIndex = t2.length, u2) {
                let t3 = s2.top, e3 = s2.bottom;
                const r3 = s2.collisionPadding;
                r3 && (t3 -= r3[1], e3 += r3[3]);
                let n3 = e3 - t3;
                n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
              } else {
                const u3 = (null === (h3 = s2.image) || void 0 === h3 ? void 0 : h3.content) && (s2.image.textFitWidth || s2.image.textFitHeight) ? Bc(s2) : { x1: s2.left, y1: s2.top, x2: s2.right, y2: s2.bottom };
                u3.y1 = u3.y1 * a2 - o2[0], u3.y2 = u3.y2 * a2 + o2[2], u3.x1 = u3.x1 * a2 - o2[3], u3.x2 = u3.x2 * a2 + o2[1];
                const p2 = s2.collisionPadding;
                if (p2 && (u3.x1 -= p2[0] * a2, u3.y1 -= p2[1] * a2, u3.x2 += p2[2] * a2, u3.y2 += p2[3] * a2), c2) {
                  const t3 = new l(u3.x1, u3.y1), e3 = new l(u3.x2, u3.y1), r3 = new l(u3.x1, u3.y2), n3 = new l(u3.x2, u3.y2), i3 = c2 * Math.PI / 180;
                  t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), u3.x1 = Math.min(t3.x, e3.x, r3.x, n3.x), u3.x2 = Math.max(t3.x, e3.x, r3.x, n3.x), u3.y1 = Math.min(t3.y, e3.y, r3.y, n3.y), u3.y2 = Math.max(t3.y, e3.y, r3.y, n3.y);
                }
                t2.emplaceBack(e2.x, e2.y, u3.x1, u3.y1, u3.x2, u3.y2, r2, n2, i2);
              }
              this.boxEndIndex = t2.length;
            }
          }
          class qh {
            constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this._up(this.length++);
            }
            pop() {
              if (0 === this.length) return;
              const t2 = this.data[0], e2 = this.data.pop();
              return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r2 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r2(n2, s2) >= 0) break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1);
                const s2 = n3 + 1;
                if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
                e2[t2] = e2[n3], t2 = n3;
              }
              e2[t2] = i2;
            }
          }
          function Gh(t2, e2 = 1, r2 = false) {
            let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0;
            const o2 = t2[0];
            for (let t3 = 0; t3 < o2.length; t3++) {
              const e3 = o2[t3];
              (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > a2) && (a2 = e3.y);
            }
            const u2 = Math.min(s2 - n2, a2 - i2);
            let c2 = u2 / 2;
            const h3 = new qh([], Zh);
            if (0 === u2) return new l(n2, i2);
            for (let e3 = n2; e3 < s2; e3 += u2) for (let r3 = i2; r3 < a2; r3 += u2) h3.push(new Kh(e3 + c2, r3 + c2, c2, t2));
            let p2 = function(t3) {
              let e3 = 0, r3 = 0, n3 = 0;
              const i3 = t3[0];
              for (let t4 = 0, s3 = i3.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
                const s4 = i3[t4], o3 = i3[a3], l2 = s4.x * o3.y - o3.x * s4.y;
                r3 += (s4.x + o3.x) * l2, n3 += (s4.y + o3.y) * l2, e3 += 3 * l2;
              }
              return new Kh(r3 / e3, n3 / e3, 0, t3);
            }(t2), f2 = h3.length;
            for (; h3.length; ) {
              const n3 = h3.pop();
              (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h3.push(new Kh(n3.p.x - c2, n3.p.y - c2, c2, t2)), h3.push(new Kh(n3.p.x + c2, n3.p.y - c2, c2, t2)), h3.push(new Kh(n3.p.x - c2, n3.p.y + c2, c2, t2)), h3.push(new Kh(n3.p.x + c2, n3.p.y + c2, c2, t2)), f2 += 4);
            }
            return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
          }
          function Zh(t2, e2) {
            return e2.max - t2.max;
          }
          function Kh(t2, e2, r2, n2) {
            this.p = new l(t2, e2), this.h = r2, this.d = function(t3, e3) {
              let r3 = false, n3 = 1 / 0;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const s2 = e3[i2];
                for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
                  const i4 = s2[e4], o2 = s2[a2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Fo2(t3, i4, o2));
                }
              }
              return (r3 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
          var Xh;
          t.aB = void 0, (Xh = t.aB || (t.aB = {}))[Xh.center = 1] = "center", Xh[Xh.left = 2] = "left", Xh[Xh.right = 3] = "right", Xh[Xh.top = 4] = "top", Xh[Xh.bottom = 5] = "bottom", Xh[Xh["top-left"] = 6] = "top-left", Xh[Xh["top-right"] = 7] = "top-right", Xh[Xh["bottom-left"] = 8] = "bottom-left", Xh[Xh["bottom-right"] = 9] = "bottom-right";
          const Hh = 7, Yh = Number.POSITIVE_INFINITY;
          function Jh(t2, e2) {
            return e2[1] !== Yh ? function(t3, e3, r2) {
              let n2 = 0, i2 = 0;
              switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - Hh;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = -r2 + Hh;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e3;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e3;
              }
              return [n2, i2];
            }(t2, e2[0], e2[1]) : function(t3, e3) {
              let r2 = 0, n2 = 0;
              e3 < 0 && (e3 = 0);
              const i2 = e3 / Math.SQRT2;
              switch (t3) {
                case "top-right":
                case "top-left":
                  n2 = i2 - Hh;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n2 = -i2 + Hh;
                  break;
                case "bottom":
                  n2 = -e3 + Hh;
                  break;
                case "top":
                  n2 = e3 - Hh;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                  r2 = -i2;
                  break;
                case "top-left":
                case "bottom-left":
                  r2 = i2;
                  break;
                case "left":
                  r2 = e3;
                  break;
                case "right":
                  r2 = -e3;
              }
              return [r2, n2];
            }(t2, e2[0]);
          }
          function Wh(t2, e2, r2) {
            var n2;
            const i2 = t2.layout, s2 = null === (n2 = i2.get("text-variable-anchor-offset")) || void 0 === n2 ? void 0 : n2.evaluate(e2, {}, r2);
            if (s2) {
              const t3 = s2.values, e3 = [];
              for (let r3 = 0; r3 < t3.length; r3 += 2) {
                const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map((t4) => t4 * Hu);
                n3.startsWith("top") ? i3[1] -= Hh : n3.startsWith("bottom") && (i3[1] += Hh), e3[r3 + 1] = i3;
              }
              return new Fe2(e3);
            }
            const a2 = i2.get("text-variable-anchor");
            if (a2) {
              let n3;
              n3 = void 0 !== t2._unevaluatedLayout.getValue("text-radial-offset") ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * Hu, Yh] : i2.get("text-offset").evaluate(e2, {}, r2).map((t3) => t3 * Hu);
              const s3 = [];
              for (const t3 of a2) s3.push(t3, Jh(t3, n3));
              return new Fe2(s3);
            }
            return null;
          }
          function Qh(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function tp(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2) {
            let f2 = a2.textMaxSize.evaluate(r2, {});
            void 0 === f2 && (f2 = o2);
            const d2 = e2.layers[0].layout, y2 = d2.get("icon-offset").evaluate(r2, {}, h3), m2 = rp(n2.horizontal), g3 = o2 / 24, x3 = e2.tilePixelRatio * g3, v2 = e2.tilePixelRatio * f2 / 24, b2 = e2.tilePixelRatio * l2, w2 = e2.tilePixelRatio * d2.get("symbol-spacing"), _3 = d2.get("text-padding") * e2.tilePixelRatio, A3 = function(t2, e3, r3, n3 = 1) {
              const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
              return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
            }(d2, r2, h3, e2.tilePixelRatio), S3 = d2.get("text-max-angle") / 180 * Math.PI, k2 = "viewport" !== d2.get("text-rotation-alignment") && "point" !== d2.get("symbol-placement"), M3 = "map" === d2.get("icon-rotation-alignment") && "point" !== d2.get("symbol-placement"), I3 = d2.get("symbol-placement"), P2 = w2 / 2, C3 = d2.get("icon-text-fit");
            let B3;
            i2 && "none" !== C3 && (e2.allowVerticalPlacement && n2.vertical && (B3 = Vc(i2, n2.vertical, C3, d2.get("icon-text-fit-padding"), y2, g3)), m2 && (i2 = Vc(i2, m2, C3, d2.get("icon-text-fit-padding"), y2, g3)));
            const V3 = h3 ? p2.line.getGranularityForZoomLevel(h3.z) : 1, E3 = (l3, p3) => {
              p3.x < 0 || p3.x >= z || p3.y < 0 || p3.y >= z || function(e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h4, p4, f3, d3, y3, m3, g4, x4, v3, b3, w3, _4, A4, S4, k3) {
                const M4 = e3.addToLineVertexArray(r3, n3);
                let I4, z2, P3, C4, B4 = 0, V4 = 0, E4 = 0, T2 = 0, F3 = -1, $3 = -1;
                const L3 = {};
                let O3 = to2("");
                if (e3.allowVerticalPlacement && i3.vertical) {
                  const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, S4) + 90;
                  P3 = new Uh(u3, r3, c3, h4, p4, i3.vertical, f3, d3, y3, t2), o3 && (C4 = new Uh(u3, r3, c3, h4, p4, o3, g4, x4, y3, t2));
                }
                if (s3) {
                  const n4 = l4.layout.get("icon-rotate").evaluate(w3, {}), i4 = "none" !== l4.layout.get("icon-text-fit"), a4 = Oh(s3, n4, A4, i4), f4 = o3 ? Oh(o3, n4, A4, i4) : void 0;
                  z2 = new Uh(u3, r3, c3, h4, p4, s3, g4, x4, false, n4), B4 = 4 * a4.length;
                  const d4 = e3.iconSizeData;
                  let y4 = null;
                  "source" === d4.kind ? (y4 = [Tc * l4.layout.get("icon-size").evaluate(w3, {})], y4[0] > Fc && U(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Ec}. Reduce your "icon-size".`)) : "composite" === d4.kind && (y4 = [Tc * _4.compositeIconSizes[0].evaluate(w3, {}, S4), Tc * _4.compositeIconSizes[1].evaluate(w3, {}, S4)], (y4[0] > Fc || y4[1] > Fc) && U(`${e3.layerIds[0]}: Value for "icon-size" is >= ${Ec}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, y4, b3, v3, w3, t.al.none, r3, M4.lineStartIndex, M4.lineLength, -1, S4), F3 = e3.icon.placedSymbolArray.length - 1, f4 && (V4 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y4, b3, v3, w3, t.al.vertical, r3, M4.lineStartIndex, M4.lineLength, -1, S4), $3 = e3.icon.placedSymbolArray.length - 1);
                }
                const D3 = Object.keys(i3.horizontal);
                for (const n4 of D3) {
                  const s4 = i3.horizontal[n4];
                  if (!I4) {
                    O3 = to2(s4.text);
                    const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, S4);
                    I4 = new Uh(u3, r3, c3, h4, p4, s4, f3, d3, y3, t2);
                  }
                  const o4 = 1 === s4.positionedLines.length;
                  if (E4 += ep(e3, r3, s4, a3, l4, y3, w3, m3, M4, i3.vertical ? t.al.horizontal : t.al.horizontalOnly, o4 ? D3 : [n4], L3, F3, _4, S4), o4) break;
                }
                i3.vertical && (T2 += ep(e3, r3, i3.vertical, a3, l4, y3, w3, m3, M4, t.al.vertical, ["vertical"], L3, $3, _4, S4));
                const j2 = I4 ? I4.boxStartIndex : e3.collisionBoxArray.length, R2 = I4 ? I4.boxEndIndex : e3.collisionBoxArray.length, N3 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, q3 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length, G3 = z2 ? z2.boxStartIndex : e3.collisionBoxArray.length, Z3 = z2 ? z2.boxEndIndex : e3.collisionBoxArray.length, K3 = C4 ? C4.boxStartIndex : e3.collisionBoxArray.length, X3 = C4 ? C4.boxEndIndex : e3.collisionBoxArray.length;
                let H3 = -1;
                const Y3 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
                H3 = Y3(I4, H3), H3 = Y3(P3, H3), H3 = Y3(z2, H3), H3 = Y3(C4, H3);
                const J3 = H3 > -1 ? 1 : 0;
                J3 && (H3 *= k3 / Hu), e3.glyphOffsetArray.length >= Gc.MAX_GLYPHS && U("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w3.sortKey && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
                const W3 = Wh(l4, w3, S4), [Q3, tt2] = function(e4, r4) {
                  const n4 = e4.length, i4 = null == r4 ? void 0 : r4.values;
                  if ((null == i4 ? void 0 : i4.length) > 0) for (let r5 = 0; r5 < i4.length; r5 += 2) {
                    const n5 = i4[r5 + 1];
                    e4.emplaceBack(t.aB[i4[r5]], n5[0], n5[1]);
                  }
                  return [n4, e4.length];
                }(e3.textAnchorOffsets, W3);
                e3.symbolInstances.emplaceBack(r3.x, r3.y, L3.right >= 0 ? L3.right : -1, L3.center >= 0 ? L3.center : -1, L3.left >= 0 ? L3.left : -1, L3.vertical || -1, F3, $3, O3, j2, R2, N3, q3, G3, Z3, K3, X3, c3, E4, T2, B4, V4, J3, 0, f3, H3, Q3, tt2);
              }(e2, p3, l3, n2, i2, s2, B3, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, x3, [_3, _3, _3, _3], k2, u2, b2, A3, M3, y2, r2, a2, c2, h3, o2);
            };
            if ("line" === I3) for (const t2 of zh(r2.geometry, 0, 0, z, z)) {
              const r3 = Nl2(t2, V3), s3 = Fh(r3, w2, S3, n2.vertical || m2, i2, 24, v2, e2.overscaling, z);
              for (const t3 of s3) m2 && np(e2, m2.text, P2, t3) || E3(r3, t3);
            }
            else if ("line-center" === I3) {
              for (const t2 of r2.geometry) if (t2.length > 1) {
                const e3 = Nl2(t2, V3), r3 = Th(e3, S3, n2.vertical || m2, i2, 24, v2);
                r3 && E3(e3, r3);
              }
            } else if ("Polygon" === r2.type) for (const t2 of Wr2(r2.geometry, 0)) {
              const e3 = Gh(t2, 16);
              E3(Nl2(t2[0], V3, true), new Ph(e3.x, e3.y, 0));
            }
            else if ("LineString" === r2.type) for (const t2 of r2.geometry) {
              const e3 = Nl2(t2, V3);
              E3(e3, new Ph(e3[0].x, e3[0].y, 0));
            }
            else if ("Point" === r2.type) for (const t2 of r2.geometry) for (const e3 of t2) E3([e3], new Ph(e3.x, e3.y, 0));
          }
          function ep(t2, e2, r2, n2, i2, s2, a2, o2, u2, c2, h3, p2, f2, d2, y2) {
            const m2 = function(t3, e3, r3, n3, i3, s3, a3, o3) {
              const u3 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = [];
              for (const t4 of e3.positionedLines) for (const n4 of t4.positionedGlyphs) {
                if (!n4.rect) continue;
                const s4 = n4.rect || {};
                let h4 = ic + 1, p3 = true, f3 = 1, d3 = 0;
                const y3 = (i3 || o3) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
                if (o3 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (n4.imageName ? -(Hu - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * Hu)), n4.imageName) {
                  const t5 = a3[n4.imageName];
                  p3 = t5.sdf, f3 = t5.pixelRatio, h4 = ac / f3;
                }
                const g4 = i3 ? [n4.x + m3, n4.y] : [0, 0];
                let x4 = i3 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v2 = [0, 0];
                y3 && (v2 = x4, x4 = [0, 0]);
                const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h4) * n4.scale - m3 + x4[0], _3 = (-n4.metrics.top - h4) * n4.scale + x4[1], A3 = w2 + s4.w / b2 * n4.scale / f3, S3 = _3 + s4.h / b2 * n4.scale / f3, k2 = new l(w2, _3), M3 = new l(A3, _3), I3 = new l(w2, S3), z2 = new l(A3, S3);
                if (y3) {
                  const t5 = new l(-m3, m3 - cc), e4 = -Math.PI / 2, r4 = Hu / 2 - m3, i4 = new l(5 - cc - r4, -(n4.imageName ? r4 : 0)), s5 = new l(...v2);
                  k2._rotateAround(e4, t5)._add(i4)._add(s5), M3._rotateAround(e4, t5)._add(i4)._add(s5), I3._rotateAround(e4, t5)._add(i4)._add(s5), z2._rotateAround(e4, t5)._add(i4)._add(s5);
                }
                if (u3) {
                  const t5 = Math.sin(u3), e4 = Math.cos(u3), r4 = [e4, -t5, t5, e4];
                  k2._matMult(r4), M3._matMult(r4), I3._matMult(r4), z2._matMult(r4);
                }
                const P2 = new l(0, 0), C3 = new l(0, 0);
                c3.push({ tl: k2, tr: M3, bl: I3, br: z2, tex: s4, writingMode: e3.writingMode, glyphOffset: g4, sectionIndex: n4.sectionIndex, isSDF: p3, pixelOffsetTL: P2, pixelOffsetBR: C3, minFontScaleX: 0, minFontScaleY: 0 });
              }
              return c3;
            }(0, r2, o2, i2, s2, a2, n2, t2.allowVerticalPlacement), g3 = t2.textSizeData;
            let x3 = null;
            "source" === g3.kind ? (x3 = [Tc * i2.layout.get("text-size").evaluate(a2, {})], x3[0] > Fc && U(`${t2.layerIds[0]}: Value for "text-size" is >= ${Ec}. Reduce your "text-size".`)) : "composite" === g3.kind && (x3 = [Tc * d2.compositeTextSizes[0].evaluate(a2, {}, y2), Tc * d2.compositeTextSizes[1].evaluate(a2, {}, y2)], (x3[0] > Fc || x3[1] > Fc) && U(`${t2.layerIds[0]}: Value for "text-size" is >= ${Ec}. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x3, o2, s2, a2, c2, e2, u2.lineStartIndex, u2.lineLength, f2, y2);
            for (const e3 of h3) p2[e3] = t2.text.placedSymbolArray.length - 1;
            return 4 * m2.length;
          }
          function rp(t2) {
            for (const e2 in t2) return t2[e2];
            return null;
          }
          function np(t2, e2, r2, n2) {
            const i2 = t2.compareText;
            if (e2 in i2) {
              const t3 = i2[e2];
              for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n2.dist(t3[e3]) < r2) return true;
            } else i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          const ip = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          class sp {
            static from(t2) {
              if (!(t2 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
              const [e2, r2] = new Uint8Array(t2, 0, 2);
              if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
              const n2 = r2 >> 4;
              if (1 !== n2) throw new Error(`Got v${n2} data when expected v1.`);
              const i2 = ip[15 & r2];
              if (!i2) throw new Error("Unrecognized array type.");
              const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
              return new sp(a2, s2, i2, t2);
            }
            constructor(t2, e2 = 64, r2 = Float64Array, n2) {
              if (isNaN(t2) || t2 < 0) throw new Error(`Unpexpected numItems value: ${t2}.`);
              this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
              const i2 = ip.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
              if (i2 < 0) throw new Error(`Unexpected typed array class: ${r2}.`);
              n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
            }
            add(t2, e2) {
              const r2 = this._pos >> 1;
              return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
            }
            finish() {
              const t2 = this._pos >> 1;
              if (t2 !== this.numItems) throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
              return ap(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
            }
            range(t2, e2, r2, n2) {
              if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
              const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
              for (; o2.length; ) {
                const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h3 = o2.pop() || 0;
                if (c2 - h3 <= a2) {
                  for (let a3 = h3; a3 <= c2; a3++) {
                    const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                    o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i2[a3]);
                  }
                  continue;
                }
                const p2 = h3 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
                f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (0 === u2 ? t2 <= f2 : e2 <= d2) && (o2.push(h3), o2.push(p2 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
              }
              return l2;
            }
            within(t2, e2, r2) {
              if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
              const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
              for (; a2.length; ) {
                const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h3 = a2.pop() || 0;
                if (c2 - h3 <= s2) {
                  for (let r3 = h3; r3 <= c2; r3++) cp(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
                  continue;
                }
                const p2 = h3 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
                cp(f2, d2, t2, e2) <= l2 && o2.push(n2[p2]), (0 === u2 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h3), a2.push(p2 - 1), a2.push(1 - u2)), (0 === u2 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
              }
              return o2;
            }
          }
          function ap(t2, e2, r2, n2, i2, s2) {
            if (i2 - n2 <= r2) return;
            const a2 = n2 + i2 >> 1;
            op(t2, e2, a2, n2, i2, s2), ap(t2, e2, r2, n2, a2 - 1, 1 - s2), ap(t2, e2, r2, a2 + 1, i2, 1 - s2);
          }
          function op(t2, e2, r2, n2, i2, s2) {
            for (; i2 > n2; ) {
              if (i2 - n2 > 600) {
                const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
                op(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
              }
              const a2 = e2[2 * r2 + s2];
              let o2 = n2, l2 = i2;
              for (lp(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && lp(t2, e2, n2, i2); o2 < l2; ) {
                for (lp(t2, e2, o2, l2), o2++, l2--; e2[2 * o2 + s2] < a2; ) o2++;
                for (; e2[2 * l2 + s2] > a2; ) l2--;
              }
              e2[2 * n2 + s2] === a2 ? lp(t2, e2, n2, l2) : (l2++, lp(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
            }
          }
          function lp(t2, e2, r2, n2) {
            up(t2, r2, n2), up(e2, 2 * r2, 2 * n2), up(e2, 2 * r2 + 1, 2 * n2 + 1);
          }
          function up(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function cp(t2, e2, r2, n2) {
            const i2 = t2 - r2, s2 = e2 - n2;
            return i2 * i2 + s2 * s2;
          }
          var hp;
          t.co = void 0, (hp = t.co || (t.co = {})).create = "create", hp.load = "load", hp.fullLoad = "fullLoad";
          let pp = null, fp = [];
          const dp = 1e3 / 60, yp = "loadTime", mp = "fullLoadTime", gp = { mark(t2) {
            performance.mark(t2);
          }, frame(t2) {
            const e2 = t2;
            null != pp && fp.push(e2 - pp), pp = e2;
          }, clearMetrics() {
            pp = null, fp = [], performance.clearMeasures(yp), performance.clearMeasures(mp);
            for (const e2 in t.co) performance.clearMarks(t.co[e2]);
          }, getPerformanceMetrics() {
            performance.measure(yp, t.co.create, t.co.load), performance.measure(mp, t.co.create, t.co.fullLoad);
            const e2 = performance.getEntriesByName(yp)[0].duration, r2 = performance.getEntriesByName(mp)[0].duration, n2 = fp.length, i2 = 1 / (fp.reduce((t2, e3) => t2 + e3, 0) / n2 / 1e3), s2 = fp.filter((t2) => t2 > dp).reduce((t2, e3) => t2 + (e3 - dp) / dp, 0);
            return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
          } };
          t.$ = yh, t.A = m, t.B = fr2, t.C = ks2, t.D = Ts2, t.E = mt2, t.F = Wi2, t.G = function(t2) {
            if (null == Z2) {
              const e2 = t2.navigator ? t2.navigator.userAgent : null;
              Z2 = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
            }
            return Z2;
          }, t.H = class {
            constructor(t2, e2) {
              this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new ih(() => this.process()), this.subscription = W2(this.target, "message", (t3) => this.receive(t3), false), this.globalScope = G2(self) ? t2 : window;
            }
            registerMessageHandler(t2, e2) {
              this.messageHandlers[t2] = e2;
            }
            sendAsync(t2, e2) {
              return new Promise((r2, n2) => {
                const i2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), s2 = e2 ? W2(e2.signal, "abort", () => {
                  null == s2 || s2.unsubscribe(), delete this.resolveRejects[i2];
                  const e3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: t2.targetMapId, sourceMapId: this.mapId };
                  this.target.postMessage(e3);
                }, sh) : null;
                this.resolveRejects[i2] = { resolve: (t3) => {
                  null == s2 || s2.unsubscribe(), r2(t3);
                }, reject: (t3) => {
                  null == s2 || s2.unsubscribe(), n2(t3);
                } };
                const a2 = [], o2 = Object.assign(Object.assign({}, t2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: ls2(t2.data, a2) });
                this.target.postMessage(o2, { transfer: a2 });
              });
            }
            receive(t2) {
              const e2 = t2.data, r2 = e2.id;
              if (!("file://" !== e2.origin && "file://" !== location.origin && "resource://android" !== e2.origin && "resource://android" !== location.origin && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
                if ("<cancel>" === e2.type) {
                  delete this.tasks[r2];
                  const t3 = this.abortControllers[r2];
                  return delete this.abortControllers[r2], void (t3 && t3.abort());
                }
                if (G2(self) || e2.mustQueue) return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
                this.processTask(r2, e2);
              }
            }
            process() {
              if (0 === this.taskQueue.length) return;
              const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
              delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
            }
            processTask(t2, r2) {
              return e(this, void 0, void 0, function* () {
                if ("<response>" === r2.type) {
                  const e3 = this.resolveRejects[t2];
                  if (delete this.resolveRejects[t2], !e3) return;
                  return void (r2.error ? e3.reject(us2(r2.error)) : e3.resolve(us2(r2.data)));
                }
                if (!this.messageHandlers[r2.type]) return void this.completeTask(t2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                const e2 = us2(r2.data), n2 = new AbortController();
                this.abortControllers[t2] = n2;
                try {
                  const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
                  this.completeTask(t2, null, i2);
                } catch (e3) {
                  this.completeTask(t2, e3);
                }
              });
            }
            completeTask(t2, e2, r2) {
              const n2 = [];
              delete this.abortControllers[t2];
              const i2 = { id: t2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e2 ? ls2(e2) : null, data: ls2(r2, n2) };
              this.target.postMessage(i2, { transfer: n2 });
            }
            remove() {
              this.invoker.remove(), this.subscription.unsubscribe();
            }
          }, t.I = oc, t.J = ot2, t.K = function() {
            var t2 = new m(16);
            return m != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }, t.L = function(t2, e2, r2) {
            var n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2 = r2[0], m2 = r2[1], g3 = r2[2];
            return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g3 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g3 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g3 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g3 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h3 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h3, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h3 * g3 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g3 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g3 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g3 + e2[15]), t2;
          }, t.M = function(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], s2 = r2[2];
            return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }, t.N = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h3 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g3 = e2[14], x3 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _3 = r2[3];
            return t2[0] = v2 * n2 + b2 * o2 + w2 * h3 + _3 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _3 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _3 * g3, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _3 * x3, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h3 + (_3 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _3 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _3 * g3, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _3 * x3, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h3 + (_3 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _3 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _3 * g3, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _3 * x3, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h3 + (_3 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _3 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _3 * g3, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _3 * x3, t2;
          }, t.O = function(t2, e2) {
            const r2 = {};
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.P = l, t.Q = oh, t.R = tl, t.S = hh, t.T = zs2, t.U = ch, t.V = f, t.W = d, t.X = H2, t.Y = vh, t.Z = z, t._ = e, t.a = st2, t.a$ = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h3 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h3 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h3 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
          }, t.a0 = 25, t.a1 = gh, t.a2 = (t2) => {
            const e2 = window.document.createElement("video");
            return e2.muted = true, new Promise((r2) => {
              e2.onloadstart = () => {
                r2(e2);
              };
              for (const r3 of t2) {
                const t3 = window.document.createElement("source");
                ht2(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
              }
            });
          }, t.a3 = Pt, t.a4 = function() {
            return O2++;
          }, t.a5 = ga, t.a6 = Gc, t.a7 = ui2, t.a8 = So2, t.a9 = Ah, t.aA = function(t2, e2, r2, n2, i2 = false) {
            if (!r2[0] && !r2[1]) return [0, 0];
            const s2 = i2 ? "map" === n2 ? -t2.bearingInRadians : 0 : "viewport" === n2 ? t2.bearingInRadians : 0;
            if (s2) {
              const t3 = Math.sin(s2), e3 = Math.cos(s2);
              r2 = [r2[0] * e3 - r2[1] * t3, r2[0] * t3 + r2[1] * e3];
            }
            return [i2 ? r2[0] : P(e2, r2[0], t2.zoom), i2 ? r2[1] : P(e2, r2[1], t2.zoom)];
          }, t.aC = Lc, t.aD = Qh, t.aE = Ac, t.aF = sp, t.aG = Gs2, t.aH = Ll2, t.aI = za2, t.aJ = qa2, t.aK = ja, t.aL = $2, t.aM = tt, t.aN = dh, t.aO = function(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
          }, t.aP = function(t2, e2, r2) {
            return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
          }, t.aQ = function(t2) {
            var e2 = new m(3);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
          }, t.aR = function(t2, e2, r2) {
            return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
          }, t.aS = function(t2, e2, r2) {
            return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
          }, t.aT = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
            return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
          }, t.aU = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
            return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
          }, t.aV = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
          }, t.aW = xh, t.aX = bh, t.aY = function(t2, e2, r2, n2, i2) {
            var s2, a2 = 1 / Math.tan(e2 / 2);
            return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.aZ = function(t2) {
            var e2 = new m(16);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
          }, t.a_ = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h3 = e2[6], p2 = e2[7];
            return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h3 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h3 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
          }, t.aa = function(t2) {
            const e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
              const s2 = n2 || i2;
              return e2[r2] = !s2 || s2.toLowerCase(), "";
            }), e2["max-age"]) {
              const t3 = parseInt(e2["max-age"], 10);
              isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
            }
            return e2;
          }, t.ab = Q2, t.ac = function(t2) {
            return Math.pow(2, t2);
          }, t.ad = x2, t.ae = F2, t.af = 85.051129, t.ag = ph, t.ah = function(t2) {
            return Math.log(t2) / Math.LN2;
          }, t.ai = function(t2) {
            var e2 = t2[0], r2 = t2[1];
            return e2 * e2 + r2 * r2;
          }, t.aj = function(t2, e2) {
            const r2 = [];
            for (const n2 in t2) n2 in e2 || r2.push(n2);
            return r2;
          }, t.ak = function(t2, e2) {
            let r2 = 0, n2 = 0;
            if ("constant" === t2.kind) n2 = t2.layoutSize;
            else if ("source" !== t2.kind) {
              const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? F2(hr2.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
              "camera" === t2.kind ? n2 = fr2.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
            }
            return { uSizeT: r2, uSize: n2 };
          }, t.am = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
            return "source" === t2.kind ? n2 / Tc : "composite" === t2.kind ? fr2.number(n2 / Tc, i2 / Tc, r2) : e2;
          }, t.an = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h3 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g3 = e2[15], x3 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _3 = n2 * u2 - s2 * o2, A3 = i2 * u2 - s2 * l2, S3 = c2 * y2 - h3 * d2, k2 = c2 * m2 - p2 * d2, M3 = c2 * g3 - f2 * d2, I3 = h3 * m2 - p2 * y2, z2 = h3 * g3 - f2 * y2, P2 = p2 * g3 - f2 * m2, C3 = x3 * P2 - v2 * z2 + b2 * I3 + w2 * M3 - _3 * k2 + A3 * S3;
            return C3 ? (t2[0] = (o2 * P2 - l2 * z2 + u2 * I3) * (C3 = 1 / C3), t2[1] = (i2 * z2 - n2 * P2 - s2 * I3) * C3, t2[2] = (y2 * A3 - m2 * _3 + g3 * w2) * C3, t2[3] = (p2 * _3 - h3 * A3 - f2 * w2) * C3, t2[4] = (l2 * M3 - a2 * P2 - u2 * k2) * C3, t2[5] = (r2 * P2 - i2 * M3 + s2 * k2) * C3, t2[6] = (m2 * b2 - d2 * A3 - g3 * v2) * C3, t2[7] = (c2 * A3 - p2 * b2 + f2 * v2) * C3, t2[8] = (a2 * z2 - o2 * M3 + u2 * S3) * C3, t2[9] = (n2 * M3 - r2 * z2 - s2 * S3) * C3, t2[10] = (d2 * _3 - y2 * b2 + g3 * x3) * C3, t2[11] = (h3 * b2 - c2 * _3 - f2 * x3) * C3, t2[12] = (o2 * k2 - a2 * I3 - l2 * S3) * C3, t2[13] = (r2 * I3 - n2 * k2 + i2 * S3) * C3, t2[14] = (y2 * v2 - d2 * w2 - m2 * x3) * C3, t2[15] = (c2 * w2 - h3 * v2 + p2 * x3) * C3, t2) : null;
          }, t.ao = M2, t.ap = function(t2) {
            return Math.hypot(t2[0], t2[1]);
          }, t.aq = function(t2) {
            return t2[0] = 0, t2[1] = 0, t2;
          }, t.ar = function(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2;
          }, t.as = Rc, t.at = S2, t.au = function(t2, e2, r2, n2) {
            const i2 = e2.y - t2.y, s2 = e2.x - t2.x, a2 = n2.y - r2.y, o2 = n2.x - r2.x, u2 = a2 * s2 - o2 * i2;
            if (0 === u2) return null;
            const c2 = (o2 * (t2.y - r2.y) - a2 * (t2.x - r2.x)) / u2;
            return new l(t2.x + c2 * s2, t2.y + c2 * i2);
          }, t.av = zh, t.aw = zo2, t.ax = function(t2) {
            let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            return [e2, r2, n2, i2];
          }, t.ay = Hu, t.az = P, t.b = K2, t.b$ = class extends da {
          }, t.b0 = function() {
            const t2 = new Float32Array(16);
            return x2(t2), t2;
          }, t.b1 = function() {
            const t2 = new Float64Array(16);
            return x2(t2), t2;
          }, t.b2 = function() {
            return new Float64Array(16);
          }, t.b3 = function(t2, e2, r2) {
            const n2 = new Float64Array(4);
            return function(t3, e3, r3, n3) {
              var i2 = 0.5 * Math.PI / 180;
              e3 *= i2, r3 *= i2, n3 *= i2;
              var s2 = Math.sin(e3), a2 = Math.cos(e3), o2 = Math.sin(r3), l2 = Math.cos(r3), u2 = Math.sin(n3), c2 = Math.cos(n3);
              t3[0] = s2 * l2 * c2 - a2 * o2 * u2, t3[1] = a2 * o2 * c2 + s2 * l2 * u2, t3[2] = a2 * l2 * u2 - s2 * o2 * c2, t3[3] = a2 * l2 * c2 + s2 * o2 * u2;
            }(n2, t2, e2 - 90, r2), n2;
          }, t.b4 = function(t2, e2, r2, n2) {
            var i2, s2, a2, o2, l2, u2 = e2[0], c2 = e2[1], h3 = e2[2], p2 = e2[3], f2 = r2[0], d2 = r2[1], m2 = r2[2], g3 = r2[3];
            return (s2 = u2 * f2 + c2 * d2 + h3 * m2 + p2 * g3) < 0 && (s2 = -s2, f2 = -f2, d2 = -d2, m2 = -m2, g3 = -g3), 1 - s2 > y ? (i2 = Math.acos(s2), a2 = Math.sin(i2), o2 = Math.sin((1 - n2) * i2) / a2, l2 = Math.sin(n2 * i2) / a2) : (o2 = 1 - n2, l2 = n2), t2[0] = o2 * u2 + l2 * f2, t2[1] = o2 * c2 + l2 * d2, t2[2] = o2 * h3 + l2 * m2, t2[3] = o2 * p2 + l2 * g3, t2;
          }, t.b5 = function(t2) {
            const e2 = new Float64Array(9);
            var r2, n2, i2, s2, a2, o2, l2, u2, c2, h3, p2, f2, d2, y2, m2, g3, x3, v2;
            h3 = (i2 = (n2 = t2)[0]) * (l2 = i2 + i2), p2 = (s2 = n2[1]) * l2, d2 = (a2 = n2[2]) * l2, y2 = a2 * (u2 = s2 + s2), g3 = (o2 = n2[3]) * l2, x3 = o2 * u2, v2 = o2 * (c2 = a2 + a2), (r2 = e2)[0] = 1 - (f2 = s2 * u2) - (m2 = a2 * c2), r2[3] = p2 - v2, r2[6] = d2 + x3, r2[1] = p2 + v2, r2[4] = 1 - h3 - m2, r2[7] = y2 - g3, r2[2] = d2 - x3, r2[5] = y2 + g3, r2[8] = 1 - h3 - f2;
            const b2 = tt(-Math.asin(F2(e2[2], -1, 1)));
            let w2, _3;
            return Math.hypot(e2[5], e2[8]) < 1e-3 ? (w2 = 0, _3 = -tt(Math.atan2(e2[3], e2[4]))) : (w2 = tt(0 === e2[5] && 0 === e2[8] ? 0 : Math.atan2(e2[5], e2[8])), _3 = tt(0 === e2[1] && 0 === e2[0] ? 0 : Math.atan2(e2[1], e2[0]))), { roll: w2, pitch: b2 + 90, bearing: _3 };
          }, t.b6 = function(t2, e2) {
            return t2.roll == e2.roll && t2.pitch == e2.pitch && t2.bearing == e2.bearing;
          }, t.b7 = ke2, t.b8 = ao2, t.b9 = Ol, t.bA = function(t2) {
            if ("custom" === t2.type) return new nh(t2);
            switch (t2.type) {
              case "background":
                return new Qc(t2);
              case "circle":
                return new Go2(t2);
              case "fill":
                return new Yl2(t2);
              case "fill-extrusion":
                return new wu2(t2);
              case "heatmap":
                return new nl(t2);
              case "hillshade":
                return new al2(t2);
              case "line":
                return new Lu2(t2);
              case "raster":
                return new rh(t2);
              case "symbol":
                return new Yc(t2);
            }
          }, t.bB = R, t.bC = function(t2, e2) {
            if (!t2) return [{ command: "setStyle", args: [e2] }];
            let r2 = [];
            try {
              if (!bt2(t2.version, e2.version)) return [{ command: "setStyle", args: [e2] }];
              bt2(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), bt2(t2.state, e2.state) || r2.push({ command: "setGlobalState", args: [e2.state] }), bt2(t2.centerAltitude, e2.centerAltitude) || r2.push({ command: "setCenterAltitude", args: [e2.centerAltitude] }), bt2(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), bt2(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), bt2(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), bt2(t2.roll, e2.roll) || r2.push({ command: "setRoll", args: [e2.roll] }), bt2(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), bt2(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), bt2(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), bt2(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), bt2(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), bt2(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] }), bt2(t2.projection, e2.projection) || r2.push({ command: "setProjection", args: [e2.projection] });
              const n2 = {}, i2 = [];
              !function(t3, e3, r3, n3) {
                let i3;
                for (i3 in e3 = e3 || {}, t3 = t3 || {}) Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || At2(i3, r3, n3));
                for (i3 in e3) Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? bt2(t3[i3], e3[i3]) || ("geojson" === t3[i3].type && "geojson" === e3[i3].type && kt2(t3, e3, i3) ? wt2(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : St2(i3, e3, r3, n3)) : _t2(i3, e3, r3));
              }(t2.sources, e2.sources, i2, n2);
              const s2 = [];
              t2.layers && t2.layers.forEach((t3) => {
                "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
              }), r2 = r2.concat(i2), function(t3, e3, r3) {
                e3 = e3 || [];
                const n3 = (t3 = t3 || []).map(It2), i3 = e3.map(It2), s3 = t3.reduce(zt2, {}), a2 = e3.reduce(zt2, {}), o2 = n3.slice(), l2 = /* @__PURE__ */ Object.create(null);
                let u2, c2, h3, p2, f2;
                for (let t4 = 0, e4 = 0; t4 < n3.length; t4++) u2 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u2) ? e4++ : (wt2(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.indexOf(u2, e4), 1));
                for (let t4 = 0, e4 = 0; t4 < i3.length; t4++) u2 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (wt2(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.lastIndexOf(u2, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], wt2(r3, { command: "addLayer", args: [a2[u2], p2] }), o2.splice(o2.length - t4, 0, u2), l2[u2] = true);
                for (let t4 = 0; t4 < i3.length; t4++) if (u2 = i3[t4], c2 = s3[u2], h3 = a2[u2], !l2[u2] && !bt2(c2, h3)) if (bt2(c2.source, h3.source) && bt2(c2["source-layer"], h3["source-layer"]) && bt2(c2.type, h3.type)) {
                  for (f2 in Mt2(c2.layout, h3.layout, r3, u2, null, "setLayoutProperty"), Mt2(c2.paint, h3.paint, r3, u2, null, "setPaintProperty"), bt2(c2.filter, h3.filter) || wt2(r3, { command: "setFilter", args: [u2, h3.filter] }), bt2(c2.minzoom, h3.minzoom) && bt2(c2.maxzoom, h3.maxzoom) || wt2(r3, { command: "setLayerZoomRange", args: [u2, h3.minzoom, h3.maxzoom] }), c2) Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Mt2(c2[f2], h3[f2], r3, u2, f2.slice(6), "setPaintProperty") : bt2(c2[f2], h3[f2]) || wt2(r3, { command: "setLayerProperty", args: [u2, f2, h3[f2]] }));
                  for (f2 in h3) Object.prototype.hasOwnProperty.call(h3, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Mt2(c2[f2], h3[f2], r3, u2, f2.slice(6), "setPaintProperty") : bt2(c2[f2], h3[f2]) || wt2(r3, { command: "setLayerProperty", args: [u2, f2, h3[f2]] }));
                } else wt2(r3, { command: "removeLayer", args: [u2] }), p2 = o2[o2.lastIndexOf(u2) + 1], wt2(r3, { command: "addLayer", args: [h3, p2] });
              }(s2, e2.layers, r2);
            } catch (t3) {
              console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
            }
            return r2;
          }, t.bD = function(t2) {
            const e2 = [], r2 = t2.id;
            return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
          }, t.bE = function t2(e2, r2) {
            if (Array.isArray(e2)) {
              if (!Array.isArray(r2) || e2.length !== r2.length) return false;
              for (let n2 = 0; n2 < e2.length; n2++) if (!t2(e2[n2], r2[n2])) return false;
              return true;
            }
            if ("object" == typeof e2 && null !== e2 && null !== r2) {
              if ("object" != typeof r2) return false;
              if (Object.keys(e2).length !== Object.keys(r2).length) return false;
              for (const n2 in e2) if (!t2(e2[n2], r2[n2])) return false;
              return true;
            }
            return e2 === r2;
          }, t.bF = D2, t.bG = j, t.bH = class extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
            }
          }, t.bI = lo2, t.bJ = class extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = uo2;
            }
            set(t2) {
              if (t2[12] !== this.current[12] || t2[0] !== this.current[0]) return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
              for (let e2 = 1; e2 < 16; e2++) if (t2[e2] !== this.current[e2]) {
                this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
                break;
              }
            }
          }, t.bK = oo2, t.bL = class extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
            }
          }, t.bM = class extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = [0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
            }
          }, t.bN = g2, t.bO = function(t2, e2) {
            var r2 = Math.sin(e2), n2 = Math.cos(e2);
            return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
          }, t.bP = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2];
            return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
          }, t.bQ = function(t2, e2, r2, n2, i2, s2, a2) {
            var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
            return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
          }, t.bR = class extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = new Array();
            }
            set(t2) {
              if (t2 != this.current) {
                this.current = t2;
                const e2 = new Float32Array(4 * t2.length);
                for (let r2 = 0; r2 < t2.length; r2++) e2[4 * r2] = t2[r2].r, e2[4 * r2 + 1] = t2[r2].g, e2[4 * r2 + 2] = t2[r2].b, e2[4 * r2 + 3] = t2[r2].a;
                this.gl.uniform4fv(this.location, e2);
              }
            }
          }, t.bS = class extends so2 {
            constructor(t2, e2) {
              super(t2, e2), this.current = new Array();
            }
            set(t2) {
              if (t2 != this.current) {
                this.current = t2;
                const e2 = new Float32Array(t2);
                this.gl.uniform1fv(this.location, e2);
              }
            }
          }, t.bT = class extends sa2 {
          }, t.bU = Uu, t.bV = class extends oa2 {
          }, t.bW = rl, t.bX = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }, t.bY = el, t.bZ = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
            return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
          }, t.b_ = class extends Hs2 {
          }, t.ba = Dl2, t.bb = $l2, t.bc = B2, t.bd = V2, t.be = Le2, t.bf = function(t2, e2, r2, n2, i2) {
            return B2(n2, i2, F2((t2 - e2) / (r2 - e2), 0, 1));
          }, t.bg = C2, t.bh = function() {
            return new Float64Array(3);
          }, t.bi = function(t2, e2, r2, n2) {
            return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
          }, t.bj = A2, t.bk = function() {
            return new Float64Array(4);
          }, t.bl = function(t2, e2, r2, n2) {
            var i2 = [], s2 = [];
            return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[0] * Math.cos(n2) - i2[1] * Math.sin(n2), s2[1] = i2[0] * Math.sin(n2) + i2[1] * Math.cos(n2), s2[2] = i2[2], t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
          }, t.bm = function(t2, e2, r2, n2) {
            var i2 = [], s2 = [];
            return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[0], s2[1] = i2[1] * Math.cos(n2) - i2[2] * Math.sin(n2), s2[2] = i2[1] * Math.sin(n2) + i2[2] * Math.cos(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
          }, t.bn = function(t2, e2, r2, n2) {
            var i2 = [], s2 = [];
            return i2[0] = e2[0] - r2[0], i2[1] = e2[1] - r2[1], i2[2] = e2[2] - r2[2], s2[0] = i2[2] * Math.sin(n2) + i2[0] * Math.cos(n2), s2[1] = i2[1], s2[2] = i2[2] * Math.cos(n2) - i2[0] * Math.sin(n2), t2[0] = s2[0] + r2[0], t2[1] = s2[1] + r2[1], t2[2] = s2[2] + r2[2], t2;
          }, t.bo = b, t.bp = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h3 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h3 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h3 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
          }, t.bq = function(t2, e2) {
            const r2 = C2(t2, 360), n2 = C2(e2, 360), i2 = n2 - r2, s2 = n2 > r2 ? i2 - 360 : i2 + 360;
            return Math.abs(i2) < Math.abs(s2) ? i2 : s2;
          }, t.br = function(t2) {
            return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
          }, t.bs = function(t2, e2, r2, n2) {
            const i2 = Math.sqrt(t2 * t2 + e2 * e2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
            t2 /= i2, e2 /= i2, r2 /= s2, n2 /= s2;
            const a2 = Math.acos(t2 * r2 + e2 * n2);
            return -e2 * r2 + t2 * n2 > 0 ? a2 : -a2;
          }, t.bt = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3];
          }, t.bu = ah, t.bv = function(t2, e2) {
            const r2 = C2(t2, 2 * Math.PI), n2 = C2(e2, 2 * Math.PI);
            return Math.min(Math.abs(r2 - n2), Math.abs(r2 - n2 + 2 * Math.PI), Math.abs(r2 - n2 - 2 * Math.PI));
          }, t.bw = function() {
            const t2 = {}, e2 = gt2.$version;
            for (const r2 in gt2.$root) {
              const n2 = gt2.$root[r2];
              if (n2.required) {
                let i2 = null;
                i2 = "version" === r2 ? e2 : "array" === n2.type ? [] : {}, null != i2 && (t2[r2] = i2);
              }
            }
            return t2;
          }, t.bx = cs2, t.by = ut, t.bz = function(t2) {
            t2 = t2.slice();
            const e2 = /* @__PURE__ */ Object.create(null);
            for (let r2 = 0; r2 < t2.length; r2++) e2[t2[r2].id] = t2[r2];
            for (let r2 = 0; r2 < t2.length; r2++) "ref" in t2[r2] && (t2[r2] = vt(t2[r2], e2[t2[r2].ref]));
            return t2;
          }, t.c = it2, t.c0 = function(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
          }, t.c1 = function(t2, e2) {
            var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h3 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], m2 = t2[13], g3 = t2[14], x3 = t2[15], v2 = e2[0], b2 = e2[1], w2 = e2[2], _3 = e2[3], A3 = e2[4], S3 = e2[5], k2 = e2[6], M3 = e2[7], I3 = e2[8], z2 = e2[9], P2 = e2[10], C3 = e2[11], B3 = e2[12], V3 = e2[13], E3 = e2[14], T2 = e2[15];
            return Math.abs(r2 - v2) <= y * Math.max(1, Math.abs(r2), Math.abs(v2)) && Math.abs(n2 - b2) <= y * Math.max(1, Math.abs(n2), Math.abs(b2)) && Math.abs(i2 - w2) <= y * Math.max(1, Math.abs(i2), Math.abs(w2)) && Math.abs(s2 - _3) <= y * Math.max(1, Math.abs(s2), Math.abs(_3)) && Math.abs(a2 - A3) <= y * Math.max(1, Math.abs(a2), Math.abs(A3)) && Math.abs(o2 - S3) <= y * Math.max(1, Math.abs(o2), Math.abs(S3)) && Math.abs(l2 - k2) <= y * Math.max(1, Math.abs(l2), Math.abs(k2)) && Math.abs(u2 - M3) <= y * Math.max(1, Math.abs(u2), Math.abs(M3)) && Math.abs(c2 - I3) <= y * Math.max(1, Math.abs(c2), Math.abs(I3)) && Math.abs(h3 - z2) <= y * Math.max(1, Math.abs(h3), Math.abs(z2)) && Math.abs(p2 - P2) <= y * Math.max(1, Math.abs(p2), Math.abs(P2)) && Math.abs(f2 - C3) <= y * Math.max(1, Math.abs(f2), Math.abs(C3)) && Math.abs(d2 - B3) <= y * Math.max(1, Math.abs(d2), Math.abs(B3)) && Math.abs(m2 - V3) <= y * Math.max(1, Math.abs(m2), Math.abs(V3)) && Math.abs(g3 - E3) <= y * Math.max(1, Math.abs(g3), Math.abs(E3)) && Math.abs(x3 - T2) <= y * Math.max(1, Math.abs(x3), Math.abs(T2));
          }, t.c2 = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }, t.c3 = (t2) => "symbol" === t2.type, t.c4 = (t2) => "circle" === t2.type, t.c5 = (t2) => "heatmap" === t2.type, t.c6 = (t2) => "line" === t2.type, t.c7 = (t2) => "fill" === t2.type, t.c8 = (t2) => "fill-extrusion" === t2.type, t.c9 = (t2) => "hillshade" === t2.type, t.cA = Zl2, t.cB = yu2, t.cC = hu2, t.cD = Qu, t.cE = class {
            constructor(t2) {
              this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
            }
            finish() {
              performance.mark(this._marks.end);
              let t2 = performance.getEntriesByName(this._marks.measure);
              return 0 === t2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
            }
          }, t.cF = function(t2, r2, n2, i2, s2) {
            return e(this, void 0, void 0, function* () {
              if (d()) try {
                return yield H2(t2, r2, n2, i2, s2);
              } catch (t3) {
              }
              return function(t3, e2, r3, n3, i3) {
                const s3 = t3.width, a2 = t3.height;
                Y2 && J2 || (Y2 = new OffscreenCanvas(s3, a2), J2 = Y2.getContext("2d", { willReadFrequently: true })), Y2.width = s3, Y2.height = a2, J2.drawImage(t3, 0, 0, s3, a2);
                const o2 = J2.getImageData(e2, r3, n3, i3);
                return J2.clearRect(0, 0, s3, a2), o2.data;
              }(t2, r2, n2, i2, s2);
            });
          }, t.cG = wh, t.cH = r, t.cI = s, t.cJ = cu2, t.cK = Wu, t.cL = ei2, t.cM = Ss2, t.ca = (t2) => "raster" === t2.type, t.cb = (t2) => "background" === t2.type, t.cc = (t2) => "custom" === t2.type, t.cd = E2, t.ce = function(t2, e2, r2) {
            const n2 = I2(e2.x - r2.x, e2.y - r2.y), i2 = I2(t2.x - r2.x, t2.y - r2.y);
            var s2, a2;
            return tt(Math.atan2(n2[0] * i2[1] - n2[1] * i2[0], (s2 = n2)[0] * (a2 = i2)[0] + s2[1] * a2[1]));
          }, t.cf = T, t.cg = function(t2, e2) {
            return rt[e2] && (t2 instanceof MouseEvent || t2 instanceof WheelEvent);
          }, t.ch = function(t2, e2) {
            return et[e2] && "touches" in t2;
          }, t.ci = function(t2) {
            return et[t2] || rt[t2];
          }, t.cj = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], t2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], t2;
          }, t.ck = function(t2, e2) {
            const { x: r2, y: n2 } = yh.fromLngLat(e2);
            return !(t2 < 0 || t2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
          }, t.cl = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }, t.cm = class extends Xs {
          }, t.cn = gp, t.cp = function(t2) {
            return t2.message === nt;
          }, t.cq = lt2, t.cr = function(t2, e2) {
            st2.REGISTERED_PROTOCOLS[t2] = e2;
          }, t.cs = function(t2) {
            delete st2.REGISTERED_PROTOCOLS[t2];
          }, t.ct = function(t2, e2) {
            const r2 = {};
            for (let n3 = 0; n3 < t2.length; n3++) {
              const i2 = e2 && e2[t2[n3].id] || xi2(t2[n3]);
              e2 && (e2[t2[n3].id] = i2);
              let s2 = r2[i2];
              s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
            }
            const n2 = [];
            for (const t3 in r2) n2.push(r2[t3]);
            return n2;
          }, t.cu = is2, t.cv = _h, t.cw = Sh, t.cx = lc, t.cy = function(e2) {
            e2.bucket.createArrays(), e2.bucket.tilePixelRatio = z / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
            const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new ks2(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new ks2(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new ks2(18)) };
            if ("composite" === e2.bucket.textSizeData.kind) {
              const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
              s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new ks2(t2), e2.canonical), i2["text-size"].possiblyEvaluate(new ks2(r3), e2.canonical)];
            }
            if ("composite" === e2.bucket.iconSizeData.kind) {
              const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
              s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new ks2(t2), e2.canonical), i2["icon-size"].possiblyEvaluate(new ks2(r3), e2.canonical)];
            }
            const a2 = n2.get("text-line-height") * Hu, o2 = "viewport" !== n2.get("text-rotation-alignment") && "point" !== n2.get("symbol-placement"), l2 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
            for (const i3 of e2.bucket.features) {
              const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h3 = u2.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: void 0 }, y2 = i3.text;
              let m2, g3 = [0, 0];
              if (y2) {
                const s3 = y2.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * Hu, f3 = fs2(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x4 = Wh(r2, i3, e2.canonical);
                if (!x4) {
                  const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
                  g3 = t2 ? Jh(m3, [t2 * Hu, Yh]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map((t3) => t3 * Hu);
                }
                let v3 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
                const b2 = "point" === n2.get("symbol-placement") ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * Hu : 1 / 0, w2 = () => {
                  e2.bucket.allowVerticalPlacement && ps2(s3) && (d2.vertical = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, "left", f3, g3, t.al.vertical, true, p2, h3));
                };
                if (!o2 && x4) {
                  const r3 = /* @__PURE__ */ new Set();
                  if ("auto" === v3) for (let t2 = 0; t2 < x4.values.length; t2 += 2) r3.add(Qh(x4.values[t2]));
                  else r3.add(v3);
                  let n3 = false;
                  for (const i4 of r3) if (!d2.horizontal[i4]) if (n3) d2.horizontal[i4] = d2.horizontal[0];
                  else {
                    const r4 = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, "center", i4, f3, g3, t.al.horizontal, false, p2, h3);
                    r4 && (d2.horizontal[i4] = r4, n3 = 1 === r4.positionedLines.length);
                  }
                  w2();
                } else {
                  "auto" === v3 && (v3 = Qh(m3));
                  const r3 = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g3, t.al.horizontal, false, p2, h3);
                  r3 && (d2.horizontal[v3] = r3), w2(), ps2(s3) && o2 && l2 && (d2.vertical = fc(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g3, t.al.vertical, false, p2, h3));
                }
              }
              let x3 = false;
              if (i3.icon && i3.icon.name) {
                const t2 = e2.imageMap[i3.icon.name];
                t2 && (m2 = Cc(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x3 = !!t2.sdf, void 0 === e2.bucket.sdfIcons ? e2.bucket.sdfIcons = x3 : e2.bucket.sdfIcons !== x3 && U("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || 0 !== n2.get("icon-rotate").constantOr(1)) && (e2.bucket.iconsNeedLinear = true));
              }
              const v2 = rp(d2.horizontal) || d2.vertical;
              e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && tp(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f2, g3, x3, e2.canonical, e2.subdivisionGranularity);
            }
            e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
          }, t.cz = Bu, t.d = ht2, t.e = L2, t.f = (t2) => e(void 0, void 0, void 0, function* () {
            if (0 === t2.byteLength) return createImageBitmap(new ImageData(1, 1));
            const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
            try {
              return createImageBitmap(e2);
            } catch (t3) {
              throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
            }
          }), t.g = at2, t.h = (t2) => new Promise((e2, r2) => {
            const n2 = new Image();
            n2.onload = () => {
              e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
                n2.src = X2;
              });
            }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
            n2.src = t2.byteLength ? URL.createObjectURL(i2) : X2;
          }), t.i = G2, t.j = (t2, e2) => ct2(L2(t2, { type: "json" }), e2), t.k = yt2, t.l = dt2, t.m = ct2, t.n = (t2, e2) => ct2(L2(t2, { type: "arrayBuffer" }), e2), t.o = function(t2) {
            return new Qu(t2).readFields(ec, []);
          }, t.p = sc, t.q = Qo2, t.r = Ds2, t.s = W2, t.t = Ji2, t.u = hs2, t.v = gt2, t.w = U, t.x = es2, t.y = Yi2, t.z = function([t2, e2, r2]) {
            return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
          };
        });
        define2("worker", ["./shared"], function(e) {
          "use strict";
          class t {
            constructor(e2) {
              this.keyCache = {}, e2 && this.replace(e2);
            }
            replace(e2) {
              this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
            }
            update(t2, o2) {
              for (const o3 of t2) {
                this._layerConfigs[o3.id] = o3;
                const t3 = this._layers[o3.id] = e.bA(o3);
                t3._featureFilter = e.a7(t3.filter), this.keyCache[o3.id] && delete this.keyCache[o3.id];
              }
              for (const e2 of o2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
              this.familiesBySource = {};
              const i2 = e.ct(Object.values(this._layerConfigs), this.keyCache);
              for (const e2 of i2) {
                const t3 = e2.map((e3) => this._layers[e3.id]), o3 = t3[0];
                if ("none" === o3.visibility) continue;
                const i3 = o3.source || "";
                let r2 = this.familiesBySource[i3];
                r2 || (r2 = this.familiesBySource[i3] = {});
                const s2 = o3.sourceLayer || "_geojsonTileLayer";
                let n2 = r2[s2];
                n2 || (n2 = r2[s2] = []), n2.push(t3);
              }
            }
          }
          class o {
            constructor(t2) {
              const o2 = {}, i2 = [];
              for (const e2 in t2) {
                const r3 = t2[e2], s3 = o2[e2] = {};
                for (const e3 in r3) {
                  const t3 = r3[+e3];
                  if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
                  const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                  i2.push(o3), s3[e3] = { rect: o3, metrics: t3.metrics };
                }
              }
              const { w: r2, h: s2 } = e.p(i2), n2 = new e.q({ width: r2 || 1, height: s2 || 1 });
              for (const i3 in t2) {
                const r3 = t2[i3];
                for (const t3 in r3) {
                  const s3 = r3[+t3];
                  if (!s3 || 0 === s3.bitmap.width || 0 === s3.bitmap.height) continue;
                  const a2 = o2[i3][t3].rect;
                  e.q.copy(s3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, s3.bitmap);
                }
              }
              this.image = n2, this.positions = o2;
            }
          }
          e.cu("GlyphAtlas", o);
          class i {
            constructor(t2) {
              this.tileID = new e.Y(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
            }
            parse(t2, i2, s2, n2, a2) {
              return e._(this, void 0, void 0, function* () {
                this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.a5();
                const l2 = new e.cv(Object.keys(t2.layers).sort()), c2 = new e.cw(this.tileID, this.promoteId);
                c2.bucketLayerIDs = [];
                const u2 = {}, h3 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s2, subdivisionGranularity: a2 }, d2 = i2.familiesBySource[this.source];
                for (const o2 in d2) {
                  const i3 = t2.layers[o2];
                  if (!i3) continue;
                  1 === i3.version && e.w(`Vector tile source "${this.source}" layer "${o2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                  const n3 = l2.encode(o2), a3 = [];
                  for (let e2 = 0; e2 < i3.length; e2++) {
                    const t3 = i3.feature(e2), r2 = c2.getId(t3, o2);
                    a3.push({ feature: t3, id: r2, index: e2, sourceLayerIndex: n3 });
                  }
                  for (const t3 of d2[o2]) {
                    const o3 = t3[0];
                    o3.source !== this.source && e.w(`layer.source = ${o3.source} does not equal this.source = ${this.source}`), o3.minzoom && this.zoom < Math.floor(o3.minzoom) || o3.maxzoom && this.zoom >= o3.maxzoom || "none" !== o3.visibility && (r(t3, this.zoom, s2), (u2[o3.id] = o3.createBucket({ index: c2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, h3, this.tileID.canonical), c2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
                  }
                }
                const f2 = e.bF(h3.glyphDependencies, (e2) => Object.keys(e2).map(Number));
                this.inFlightDependencies.forEach((e2) => null == e2 ? void 0 : e2.abort()), this.inFlightDependencies = [];
                let g3 = Promise.resolve({});
                if (Object.keys(f2).length) {
                  const e2 = new AbortController();
                  this.inFlightDependencies.push(e2), g3 = n2.sendAsync({ type: "GG", data: { stacks: f2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
                }
                const p2 = Object.keys(h3.iconDependencies);
                let m2 = Promise.resolve({});
                if (p2.length) {
                  const e2 = new AbortController();
                  this.inFlightDependencies.push(e2), m2 = n2.sendAsync({ type: "GI", data: { icons: p2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
                }
                const y2 = Object.keys(h3.patternDependencies);
                let v2 = Promise.resolve({});
                if (y2.length) {
                  const e2 = new AbortController();
                  this.inFlightDependencies.push(e2), v2 = n2.sendAsync({ type: "GI", data: { icons: y2, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
                }
                const [w2, x3, _3] = yield Promise.all([g3, m2, v2]), b2 = new o(w2), M3 = new e.cx(x3, _3);
                for (const t3 in u2) {
                  const o2 = u2[t3];
                  o2 instanceof e.a6 ? (r(o2.layers, this.zoom, s2), e.cy({ bucket: o2, glyphMap: w2, glyphPositions: b2.positions, imageMap: x3, imagePositions: M3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: h3.subdivisionGranularity })) : o2.hasPattern && (o2 instanceof e.cz || o2 instanceof e.cA || o2 instanceof e.cB) && (r(o2.layers, this.zoom, s2), o2.addFeatures(h3, this.tileID.canonical, M3.patternPositions));
                }
                return this.status = "done", { buckets: Object.values(u2).filter((e2) => !e2.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b2.image, imageAtlas: M3, glyphMap: this.returnDependencies ? w2 : null, iconMap: this.returnDependencies ? x3 : null, glyphPositions: this.returnDependencies ? b2.positions : null };
              });
            }
          }
          function r(t2, o2, i2) {
            const r2 = new e.C(o2);
            for (const e2 of t2) e2.recalculate(r2, i2);
          }
          class s {
            constructor(e2, t2, o2) {
              this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.fetching = {}, this.loading = {}, this.loaded = {};
            }
            loadVectorTile(t2, o2) {
              return e._(this, void 0, void 0, function* () {
                const i2 = yield e.n(t2.request, o2);
                try {
                  return { vectorTile: new e.cC.VectorTile(new e.cD(i2.data)), rawData: i2.data, cacheControl: i2.cacheControl, expires: i2.expires };
                } catch (e2) {
                  const o3 = new Uint8Array(i2.data);
                  let r2 = `Unable to parse the tile at ${t2.request.url}, `;
                  throw r2 += 31 === o3[0] && 139 === o3[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.message}`, new Error(r2);
                }
              });
            }
            loadTile(t2) {
              return e._(this, void 0, void 0, function* () {
                const o2 = t2.uid, r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.cE(t2.request), s2 = new i(t2);
                this.loading[o2] = s2;
                const n2 = new AbortController();
                s2.abort = n2;
                try {
                  const i2 = yield this.loadVectorTile(t2, n2);
                  if (delete this.loading[o2], !i2) return null;
                  const a2 = i2.rawData, l2 = {};
                  i2.expires && (l2.expires = i2.expires), i2.cacheControl && (l2.cacheControl = i2.cacheControl);
                  const c2 = {};
                  if (r2) {
                    const e2 = r2.finish();
                    e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
                  }
                  s2.vectorTile = i2.vectorTile;
                  const u2 = s2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
                  this.loaded[o2] = s2, this.fetching[o2] = { rawTileData: a2, cacheControl: l2, resourceTiming: c2 };
                  try {
                    const t3 = yield u2;
                    return e.e({ rawTileData: a2.slice(0) }, t3, l2, c2);
                  } finally {
                    delete this.fetching[o2];
                  }
                } catch (e2) {
                  throw delete this.loading[o2], s2.status = "done", this.loaded[o2] = s2, e2;
                }
              });
            }
            reloadTile(t2) {
              return e._(this, void 0, void 0, function* () {
                const o2 = t2.uid;
                if (!this.loaded || !this.loaded[o2]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                const i2 = this.loaded[o2];
                if (i2.showCollisionBoxes = t2.showCollisionBoxes, "parsing" === i2.status) {
                  const r2 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
                  let s2;
                  if (this.fetching[o2]) {
                    const { rawTileData: t3, cacheControl: i3, resourceTiming: n2 } = this.fetching[o2];
                    delete this.fetching[o2], s2 = e.e({ rawTileData: t3.slice(0) }, r2, i3, n2);
                  } else s2 = r2;
                  return s2;
                }
                if ("done" === i2.status && i2.vectorTile) return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor, t2.subdivisionGranularity);
              });
            }
            abortTile(t2) {
              return e._(this, void 0, void 0, function* () {
                const e2 = this.loading, o2 = t2.uid;
                e2 && e2[o2] && e2[o2].abort && (e2[o2].abort.abort(), delete e2[o2]);
              });
            }
            removeTile(t2) {
              return e._(this, void 0, void 0, function* () {
                this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
              });
            }
          }
          class n {
            constructor() {
              this.loaded = {};
            }
            loadTile(t2) {
              return e._(this, void 0, void 0, function* () {
                const { uid: o2, encoding: i2, rawImageData: r2, redFactor: s2, greenFactor: n2, blueFactor: a2, baseShift: l2 } = t2, c2 = r2.width + 2, u2 = r2.height + 2, h3 = e.b(r2) ? new e.R({ width: c2, height: u2 }, yield e.cF(r2, -1, -1, c2, u2)) : r2, d2 = new e.cG(o2, h3, i2, s2, n2, a2, l2);
                return this.loaded = this.loaded || {}, this.loaded[o2] = d2, d2;
              });
            }
            removeTile(e2) {
              const t2 = this.loaded, o2 = e2.uid;
              t2 && t2[o2] && delete t2[o2];
            }
          }
          var a, l, c = function() {
            if (l) return a;
            function e2(e3, o2) {
              if (0 !== e3.length) {
                t2(e3[0], o2);
                for (var i2 = 1; i2 < e3.length; i2++) t2(e3[i2], !o2);
              }
            }
            function t2(e3, t3) {
              for (var o2 = 0, i2 = 0, r2 = 0, s2 = e3.length, n2 = s2 - 1; r2 < s2; n2 = r2++) {
                var a2 = (e3[r2][0] - e3[n2][0]) * (e3[n2][1] + e3[r2][1]), l2 = o2 + a2;
                i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
              }
              o2 + i2 >= 0 != !!t3 && e3.reverse();
            }
            return l = 1, a = function t3(o2, i2) {
              var r2, s2 = o2 && o2.type;
              if ("FeatureCollection" === s2) for (r2 = 0; r2 < o2.features.length; r2++) t3(o2.features[r2], i2);
              else if ("GeometryCollection" === s2) for (r2 = 0; r2 < o2.geometries.length; r2++) t3(o2.geometries[r2], i2);
              else if ("Feature" === s2) t3(o2.geometry, i2);
              else if ("Polygon" === s2) e2(o2.coordinates, i2);
              else if ("MultiPolygon" === s2) for (r2 = 0; r2 < o2.coordinates.length; r2++) e2(o2.coordinates[r2], i2);
              return o2;
            };
          }(), u = e.cH(c);
          const h2 = e.cC.VectorTileFeature.prototype.toGeoJSON;
          class d {
            constructor(t2) {
              this._feature = t2, this.extent = e.Z, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                const t2 = [];
                for (const o2 of this._feature.geometry) t2.push([new e.P(o2[0], o2[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const o2 of this._feature.geometry) {
                  const i2 = [];
                  for (const t3 of o2) i2.push(new e.P(t3[0], t3[1]));
                  t2.push(i2);
                }
                return t2;
              }
            }
            toGeoJSON(e2, t2, o2) {
              return h2.call(this, e2, t2, o2);
            }
          }
          class f {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.Z, this.length = t2.length, this._features = t2;
            }
            feature(e2) {
              return new d(this._features[e2]);
            }
          }
          var g2, p, m, y = { exports: {} }, v = function() {
            if (m) return y.exports;
            m = 1;
            var t2 = e.cK(), o2 = function() {
              if (p) return g2;
              p = 1;
              var t3 = e.cI(), o3 = e.cJ().VectorTileFeature;
              function i3(e2, t4) {
                this.options = t4 || {}, this.features = e2, this.length = e2.length;
              }
              function r3(e2, t4) {
                this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t4 || 4096;
              }
              return g2 = i3, i3.prototype.feature = function(e2) {
                return new r3(this.features[e2], this.options.extent);
              }, r3.prototype.loadGeometry = function() {
                var e2 = this.rawGeometry;
                this.geometry = [];
                for (var o4 = 0; o4 < e2.length; o4++) {
                  for (var i4 = e2[o4], r4 = [], s3 = 0; s3 < i4.length; s3++) r4.push(new t3(i4[s3][0], i4[s3][1]));
                  this.geometry.push(r4);
                }
                return this.geometry;
              }, r3.prototype.bbox = function() {
                this.geometry || this.loadGeometry();
                for (var e2 = this.geometry, t4 = 1 / 0, o4 = -1 / 0, i4 = 1 / 0, r4 = -1 / 0, s3 = 0; s3 < e2.length; s3++) for (var n3 = e2[s3], a3 = 0; a3 < n3.length; a3++) {
                  var l3 = n3[a3];
                  t4 = Math.min(t4, l3.x), o4 = Math.max(o4, l3.x), i4 = Math.min(i4, l3.y), r4 = Math.max(r4, l3.y);
                }
                return [t4, i4, o4, r4];
              }, r3.prototype.toGeoJSON = o3.prototype.toGeoJSON, g2;
            }();
            function i2(e2) {
              var o3 = new t2();
              return function(e3, t3) {
                for (var o4 in e3.layers) t3.writeMessage(3, r2, e3.layers[o4]);
              }(e2, o3), o3.finish();
            }
            function r2(e2, t3) {
              var o3;
              t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
              var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
              for (o3 = 0; o3 < e2.length; o3++) i3.feature = e2.feature(o3), t3.writeMessage(2, s2, i3);
              var r3 = i3.keys;
              for (o3 = 0; o3 < r3.length; o3++) t3.writeStringField(3, r3[o3]);
              var n3 = i3.values;
              for (o3 = 0; o3 < n3.length; o3++) t3.writeMessage(4, u2, n3[o3]);
            }
            function s2(e2, t3) {
              var o3 = e2.feature;
              void 0 !== o3.id && t3.writeVarintField(1, o3.id), t3.writeMessage(2, n2, e2), t3.writeVarintField(3, o3.type), t3.writeMessage(4, c2, o3);
            }
            function n2(e2, t3) {
              var o3 = e2.feature, i3 = e2.keys, r3 = e2.values, s3 = e2.keycache, n3 = e2.valuecache;
              for (var a3 in o3.properties) {
                var l3 = o3.properties[a3], c3 = s3[a3];
                if (null !== l3) {
                  void 0 === c3 && (i3.push(a3), s3[a3] = c3 = i3.length - 1), t3.writeVarint(c3);
                  var u3 = typeof l3;
                  "string" !== u3 && "boolean" !== u3 && "number" !== u3 && (l3 = JSON.stringify(l3));
                  var h3 = u3 + ":" + l3, d2 = n3[h3];
                  void 0 === d2 && (r3.push(l3), n3[h3] = d2 = r3.length - 1), t3.writeVarint(d2);
                }
              }
            }
            function a2(e2, t3) {
              return (t3 << 3) + (7 & e2);
            }
            function l2(e2) {
              return e2 << 1 ^ e2 >> 31;
            }
            function c2(e2, t3) {
              for (var o3 = e2.loadGeometry(), i3 = e2.type, r3 = 0, s3 = 0, n3 = o3.length, c3 = 0; c3 < n3; c3++) {
                var u3 = o3[c3], h3 = 1;
                1 === i3 && (h3 = u3.length), t3.writeVarint(a2(1, h3));
                for (var d2 = 3 === i3 ? u3.length - 1 : u3.length, f2 = 0; f2 < d2; f2++) {
                  1 === f2 && 1 !== i3 && t3.writeVarint(a2(2, d2 - 1));
                  var g3 = u3[f2].x - r3, p2 = u3[f2].y - s3;
                  t3.writeVarint(l2(g3)), t3.writeVarint(l2(p2)), r3 += g3, s3 += p2;
                }
                3 === i3 && t3.writeVarint(a2(7, 1));
              }
            }
            function u2(e2, t3) {
              var o3 = typeof e2;
              "string" === o3 ? t3.writeStringField(1, e2) : "boolean" === o3 ? t3.writeBooleanField(7, e2) : "number" === o3 && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
            }
            return y.exports = i2, y.exports.fromVectorTileJs = i2, y.exports.fromGeojsonVt = function(e2, t3) {
              t3 = t3 || {};
              var r3 = {};
              for (var s3 in e2) r3[s3] = new o2(e2[s3].features, t3), r3[s3].name = s3, r3[s3].version = t3.version, r3[s3].extent = t3.extent;
              return i2({ layers: r3 });
            }, y.exports.GeoJSONWrapper = o2, y.exports;
          }(), w = e.cH(v);
          const x2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, _2 = Math.fround || (b = new Float32Array(1), (e2) => (b[0] = +e2, b[0]));
          var b;
          const M2 = 3, S2 = 5, I2 = 6;
          class P {
            constructor(e2) {
              this.options = Object.assign(Object.create(x2), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e2) {
              const { log: t2, minZoom: o2, maxZoom: i2 } = this.options;
              t2 && console.time("total time");
              const r2 = `prepare ${e2.length} points`;
              t2 && console.time(r2), this.points = e2;
              const s2 = [];
              for (let t3 = 0; t3 < e2.length; t3++) {
                const o3 = e2[t3];
                if (!o3.geometry) continue;
                const [i3, r3] = o3.geometry.coordinates, n3 = _2(D2(i3)), a2 = _2(C2(r3));
                s2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && s2.push(0);
              }
              let n2 = this.trees[i2 + 1] = this._createTree(s2);
              t2 && console.timeEnd(r2);
              for (let e3 = i2; e3 >= o2; e3--) {
                const o3 = +Date.now();
                n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - o3);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e2, t2) {
              let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
              const i2 = Math.max(-90, Math.min(90, e2[1]));
              let r2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
              const s2 = Math.max(-90, Math.min(90, e2[3]));
              if (e2[2] - e2[0] >= 360) o2 = -180, r2 = 180;
              else if (o2 > r2) {
                const e3 = this.getClusters([o2, i2, 180, s2], t2), n3 = this.getClusters([-180, i2, r2, s2], t2);
                return e3.concat(n3);
              }
              const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(D2(o2), C2(s2), D2(r2), C2(i2)), l2 = n2.data, c2 = [];
              for (const e3 of a2) {
                const t3 = this.stride * e3;
                c2.push(l2[t3 + S2] > 1 ? k(l2, t3, this.clusterProps) : this.points[l2[t3 + M2]]);
              }
              return c2;
            }
            getChildren(e2) {
              const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", r2 = this.trees[o2];
              if (!r2) throw new Error(i2);
              const s2 = r2.data;
              if (t2 * this.stride >= s2.length) throw new Error(i2);
              const n2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = r2.within(s2[t2 * this.stride], s2[t2 * this.stride + 1], n2), l2 = [];
              for (const t3 of a2) {
                const o3 = t3 * this.stride;
                s2[o3 + 4] === e2 && l2.push(s2[o3 + S2] > 1 ? k(s2, o3, this.clusterProps) : this.points[s2[o3 + M2]]);
              }
              if (0 === l2.length) throw new Error(i2);
              return l2;
            }
            getLeaves(e2, t2, o2) {
              const i2 = [];
              return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
            }
            getTile(e2, t2, o2) {
              const i2 = this.trees[this._limitZoom(e2)], r2 = Math.pow(2, e2), { extent: s2, radius: n2 } = this.options, a2 = n2 / s2, l2 = (o2 - a2) / r2, c2 = (o2 + 1 + a2) / r2, u2 = { features: [] };
              return this._addTileFeatures(i2.range((t2 - a2) / r2, l2, (t2 + 1 + a2) / r2, c2), i2.data, t2, o2, r2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / r2, l2, 1, c2), i2.data, r2, o2, r2, u2), t2 === r2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / r2, c2), i2.data, -1, o2, r2, u2), u2.features.length ? u2 : null;
            }
            getClusterExpansionZoom(e2) {
              let t2 = this._getOriginZoom(e2) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const o2 = this.getChildren(e2);
                if (t2++, 1 !== o2.length) break;
                e2 = o2[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e2, t2, o2, i2, r2) {
              const s2 = this.getChildren(t2);
              for (const t3 of s2) {
                const s3 = t3.properties;
                if (s3 && s3.cluster ? r2 + s3.point_count <= i2 ? r2 += s3.point_count : r2 = this._appendLeaves(e2, s3.cluster_id, o2, i2, r2) : r2 < i2 ? r2++ : e2.push(t3), e2.length === o2) break;
              }
              return r2;
            }
            _createTree(t2) {
              const o2 = new e.aF(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
              for (let e2 = 0; e2 < t2.length; e2 += this.stride) o2.add(t2[e2], t2[e2 + 1]);
              return o2.finish(), o2.data = t2, o2;
            }
            _addTileFeatures(e2, t2, o2, i2, r2, s2) {
              for (const n2 of e2) {
                const e3 = n2 * this.stride, a2 = t2[e3 + S2] > 1;
                let l2, c2, u2;
                if (a2) l2 = T(t2, e3, this.clusterProps), c2 = t2[e3], u2 = t2[e3 + 1];
                else {
                  const o3 = this.points[t2[e3 + M2]];
                  l2 = o3.properties;
                  const [i3, r3] = o3.geometry.coordinates;
                  c2 = D2(i3), u2 = C2(r3);
                }
                const h3 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i2))]], tags: l2 };
                let d2;
                d2 = a2 || this.options.generateId ? t2[e3 + M2] : this.points[t2[e3 + M2]].id, void 0 !== d2 && (h3.id = d2), s2.features.push(h3);
              }
            }
            _limitZoom(e2) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
            }
            _cluster(e2, t2) {
              const { radius: o2, extent: i2, reduce: r2, minPoints: s2 } = this.options, n2 = o2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
              for (let o3 = 0; o3 < a2.length; o3 += c2) {
                if (a2[o3 + 2] <= t2) continue;
                a2[o3 + 2] = t2;
                const i3 = a2[o3], u2 = a2[o3 + 1], h3 = e2.within(a2[o3], a2[o3 + 1], n2), d2 = a2[o3 + S2];
                let f2 = d2;
                for (const e3 of h3) {
                  const o4 = e3 * c2;
                  a2[o4 + 2] > t2 && (f2 += a2[o4 + S2]);
                }
                if (f2 > d2 && f2 >= s2) {
                  let e3, s3 = i3 * d2, n3 = u2 * d2, g3 = -1;
                  const p2 = ((o3 / c2 | 0) << 5) + (t2 + 1) + this.points.length;
                  for (const i4 of h3) {
                    const l3 = i4 * c2;
                    if (a2[l3 + 2] <= t2) continue;
                    a2[l3 + 2] = t2;
                    const u3 = a2[l3 + S2];
                    s3 += a2[l3] * u3, n3 += a2[l3 + 1] * u3, a2[l3 + 4] = p2, r2 && (e3 || (e3 = this._map(a2, o3, true), g3 = this.clusterProps.length, this.clusterProps.push(e3)), r2(e3, this._map(a2, l3)));
                  }
                  a2[o3 + 4] = p2, l2.push(s3 / f2, n3 / f2, 1 / 0, p2, -1, f2), r2 && l2.push(g3);
                } else {
                  for (let e3 = 0; e3 < c2; e3++) l2.push(a2[o3 + e3]);
                  if (f2 > 1) for (const e3 of h3) {
                    const o4 = e3 * c2;
                    if (!(a2[o4 + 2] <= t2)) {
                      a2[o4 + 2] = t2;
                      for (let e4 = 0; e4 < c2; e4++) l2.push(a2[o4 + e4]);
                    }
                  }
                }
              }
              return l2;
            }
            _getOriginId(e2) {
              return e2 - this.points.length >> 5;
            }
            _getOriginZoom(e2) {
              return (e2 - this.points.length) % 32;
            }
            _map(e2, t2, o2) {
              if (e2[t2 + S2] > 1) {
                const i3 = this.clusterProps[e2[t2 + I2]];
                return o2 ? Object.assign({}, i3) : i3;
              }
              const i2 = this.points[e2[t2 + M2]].properties, r2 = this.options.map(i2);
              return o2 && r2 === i2 ? Object.assign({}, r2) : r2;
            }
          }
          function k(e2, t2, o2) {
            return { type: "Feature", id: e2[t2 + M2], properties: T(e2, t2, o2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), O2(e2[t2 + 1])] } };
            var i2;
          }
          function T(e2, t2, o2) {
            const i2 = e2[t2 + S2], r2 = i2 >= 1e4 ? `${Math.round(i2 / 1e3)}k` : i2 >= 1e3 ? Math.round(i2 / 100) / 10 + "k" : i2, s2 = e2[t2 + I2], n2 = -1 === s2 ? {} : Object.assign({}, o2[s2]);
            return Object.assign(n2, { cluster: true, cluster_id: e2[t2 + M2], point_count: i2, point_count_abbreviated: r2 });
          }
          function D2(e2) {
            return e2 / 360 + 0.5;
          }
          function C2(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function O2(e2) {
            const t2 = (180 - 360 * e2) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function L2(e2, t2, o2, i2) {
            let r2 = i2;
            const s2 = t2 + (o2 - t2 >> 1);
            let n2, a2 = o2 - t2;
            const l2 = e2[t2], c2 = e2[t2 + 1], u2 = e2[o2], h3 = e2[o2 + 1];
            for (let i3 = t2 + 3; i3 < o2; i3 += 3) {
              const t3 = F2(e2[i3], e2[i3 + 1], l2, c2, u2, h3);
              if (t3 > r2) n2 = i3, r2 = t3;
              else if (t3 === r2) {
                const e3 = Math.abs(i3 - s2);
                e3 < a2 && (n2 = i3, a2 = e3);
              }
            }
            r2 > i2 && (n2 - t2 > 3 && L2(e2, t2, n2, i2), e2[n2 + 2] = r2, o2 - n2 > 3 && L2(e2, n2, o2, i2));
          }
          function F2(e2, t2, o2, i2, r2, s2) {
            let n2 = r2 - o2, a2 = s2 - i2;
            if (0 !== n2 || 0 !== a2) {
              const l2 = ((e2 - o2) * n2 + (t2 - i2) * a2) / (n2 * n2 + a2 * a2);
              l2 > 1 ? (o2 = r2, i2 = s2) : l2 > 0 && (o2 += n2 * l2, i2 += a2 * l2);
            }
            return n2 = e2 - o2, a2 = t2 - i2, n2 * n2 + a2 * a2;
          }
          function G2(e2, t2, o2, i2) {
            const r2 = { id: null == e2 ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2) z(r2, o2);
            else if ("Polygon" === t2) z(r2, o2[0]);
            else if ("MultiLineString" === t2) for (const e3 of o2) z(r2, e3);
            else if ("MultiPolygon" === t2) for (const e3 of o2) z(r2, e3[0]);
            return r2;
          }
          function z(e2, t2) {
            for (let o2 = 0; o2 < t2.length; o2 += 3) e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
          }
          function A2(e2, t2, o2, i2) {
            if (!t2.geometry) return;
            const r2 = t2.geometry.coordinates;
            if (r2 && 0 === r2.length) return;
            const s2 = t2.geometry.type, n2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
            let a2 = [], l2 = t2.id;
            if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), "Point" === s2) E2(r2, a2);
            else if ("MultiPoint" === s2) for (const e3 of r2) E2(e3, a2);
            else if ("LineString" === s2) j(r2, a2, n2, false);
            else if ("MultiLineString" === s2) {
              if (o2.lineMetrics) {
                for (const o3 of r2) a2 = [], j(o3, a2, n2, false), e2.push(G2(l2, "LineString", a2, t2.properties));
                return;
              }
              Z2(r2, a2, n2, false);
            } else if ("Polygon" === s2) Z2(r2, a2, n2, true);
            else {
              if ("MultiPolygon" !== s2) {
                if ("GeometryCollection" === s2) {
                  for (const r3 of t2.geometry.geometries) A2(e2, { id: l2, geometry: r3, properties: t2.properties }, o2, i2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (const e3 of r2) {
                const t3 = [];
                Z2(e3, t3, n2, true), a2.push(t3);
              }
            }
            e2.push(G2(l2, s2, a2, t2.properties));
          }
          function E2(e2, t2) {
            t2.push(N2(e2[0]), J2(e2[1]), 0);
          }
          function j(e2, t2, o2, i2) {
            let r2, s2, n2 = 0;
            for (let o3 = 0; o3 < e2.length; o3++) {
              const a3 = N2(e2[o3][0]), l2 = J2(e2[o3][1]);
              t2.push(a3, l2, 0), o3 > 0 && (n2 += i2 ? (r2 * l2 - a3 * s2) / 2 : Math.sqrt(Math.pow(a3 - r2, 2) + Math.pow(l2 - s2, 2))), r2 = a3, s2 = l2;
            }
            const a2 = t2.length - 3;
            t2[2] = 1, L2(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(n2), t2.start = 0, t2.end = t2.size;
          }
          function Z2(e2, t2, o2, i2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              const s2 = [];
              j(e2[r2], s2, o2, i2), t2.push(s2);
            }
          }
          function N2(e2) {
            return e2 / 360 + 0.5;
          }
          function J2(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function W2(e2, t2, o2, i2, r2, s2, n2, a2) {
            if (i2 /= t2, s2 >= (o2 /= t2) && n2 < i2) return e2;
            if (n2 < o2 || s2 >= i2) return null;
            const l2 = [];
            for (const t3 of e2) {
              const e3 = t3.geometry;
              let s3 = t3.type;
              const n3 = 0 === r2 ? t3.minX : t3.minY, c2 = 0 === r2 ? t3.maxX : t3.maxY;
              if (n3 >= o2 && c2 < i2) {
                l2.push(t3);
                continue;
              }
              if (c2 < o2 || n3 >= i2) continue;
              let u2 = [];
              if ("Point" === s3 || "MultiPoint" === s3) R(e3, u2, o2, i2, r2);
              else if ("LineString" === s3) Y2(e3, u2, o2, i2, r2, false, a2.lineMetrics);
              else if ("MultiLineString" === s3) q2(e3, u2, o2, i2, r2, false);
              else if ("Polygon" === s3) q2(e3, u2, o2, i2, r2, true);
              else if ("MultiPolygon" === s3) for (const t4 of e3) {
                const e4 = [];
                q2(t4, e4, o2, i2, r2, true), e4.length && u2.push(e4);
              }
              if (u2.length) {
                if (a2.lineMetrics && "LineString" === s3) {
                  for (const e4 of u2) l2.push(G2(t3.id, s3, e4, t3.tags));
                  continue;
                }
                "LineString" !== s3 && "MultiLineString" !== s3 || (1 === u2.length ? (s3 = "LineString", u2 = u2[0]) : s3 = "MultiLineString"), "Point" !== s3 && "MultiPoint" !== s3 || (s3 = 3 === u2.length ? "Point" : "MultiPoint"), l2.push(G2(t3.id, s3, u2, t3.tags));
              }
            }
            return l2.length ? l2 : null;
          }
          function R(e2, t2, o2, i2, r2) {
            for (let s2 = 0; s2 < e2.length; s2 += 3) {
              const n2 = e2[s2 + r2];
              n2 >= o2 && n2 <= i2 && H2(t2, e2[s2], e2[s2 + 1], e2[s2 + 2]);
            }
          }
          function Y2(e2, t2, o2, i2, r2, s2, n2) {
            let a2 = V2(e2);
            const l2 = 0 === r2 ? X2 : B2;
            let c2, u2, h3 = e2.start;
            for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
              const f3 = e2[d3], g4 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], v2 = 0 === r2 ? f3 : g4, w2 = 0 === r2 ? m2 : y2;
              let x3 = false;
              n2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(g4 - y2, 2))), v2 < o2 ? w2 > o2 && (u2 = l2(a2, f3, g4, m2, y2, o2), n2 && (a2.start = h3 + c2 * u2)) : v2 > i2 ? w2 < i2 && (u2 = l2(a2, f3, g4, m2, y2, i2), n2 && (a2.start = h3 + c2 * u2)) : H2(a2, f3, g4, p3), w2 < o2 && v2 >= o2 && (u2 = l2(a2, f3, g4, m2, y2, o2), x3 = true), w2 > i2 && v2 <= i2 && (u2 = l2(a2, f3, g4, m2, y2, i2), x3 = true), !s2 && x3 && (n2 && (a2.end = h3 + c2 * u2), t2.push(a2), a2 = V2(e2)), n2 && (h3 += c2);
            }
            let d2 = e2.length - 3;
            const f2 = e2[d2], g3 = e2[d2 + 1], p2 = 0 === r2 ? f2 : g3;
            p2 >= o2 && p2 <= i2 && H2(a2, f2, g3, e2[d2 + 2]), d2 = a2.length - 3, s2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && H2(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
          }
          function V2(e2) {
            const t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function q2(e2, t2, o2, i2, r2, s2) {
            for (const n2 of e2) Y2(n2, t2, o2, i2, r2, s2, false);
          }
          function H2(e2, t2, o2, i2) {
            e2.push(t2, o2, i2);
          }
          function X2(e2, t2, o2, i2, r2, s2) {
            const n2 = (s2 - t2) / (i2 - t2);
            return H2(e2, s2, o2 + (r2 - o2) * n2, 1), n2;
          }
          function B2(e2, t2, o2, i2, r2, s2) {
            const n2 = (s2 - o2) / (r2 - o2);
            return H2(e2, t2 + (i2 - t2) * n2, s2, 1), n2;
          }
          function $2(e2, t2) {
            const o2 = [];
            for (let i2 = 0; i2 < e2.length; i2++) {
              const r2 = e2[i2], s2 = r2.type;
              let n2;
              if ("Point" === s2 || "MultiPoint" === s2 || "LineString" === s2) n2 = U(r2.geometry, t2);
              else if ("MultiLineString" === s2 || "Polygon" === s2) {
                n2 = [];
                for (const e3 of r2.geometry) n2.push(U(e3, t2));
              } else if ("MultiPolygon" === s2) {
                n2 = [];
                for (const e3 of r2.geometry) {
                  const o3 = [];
                  for (const i3 of e3) o3.push(U(i3, t2));
                  n2.push(o3);
                }
              }
              o2.push(G2(r2.id, s2, n2, r2.tags));
            }
            return o2;
          }
          function U(e2, t2) {
            const o2 = [];
            o2.size = e2.size, void 0 !== e2.start && (o2.start = e2.start, o2.end = e2.end);
            for (let i2 = 0; i2 < e2.length; i2 += 3) o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
            return o2;
          }
          function K2(e2, t2) {
            if (e2.transformed) return e2;
            const o2 = 1 << e2.z, i2 = e2.x, r2 = e2.y;
            for (const s2 of e2.features) {
              const e3 = s2.geometry, n2 = s2.type;
              if (s2.geometry = [], 1 === n2) for (let n3 = 0; n3 < e3.length; n3 += 2) s2.geometry.push(Q2(e3[n3], e3[n3 + 1], t2, o2, i2, r2));
              else for (let n3 = 0; n3 < e3.length; n3++) {
                const a2 = [];
                for (let s3 = 0; s3 < e3[n3].length; s3 += 2) a2.push(Q2(e3[n3][s3], e3[n3][s3 + 1], t2, o2, i2, r2));
                s2.geometry.push(a2);
              }
            }
            return e2.transformed = true, e2;
          }
          function Q2(e2, t2, o2, i2, r2, s2) {
            return [Math.round(o2 * (e2 * i2 - r2)), Math.round(o2 * (t2 * i2 - s2))];
          }
          function ee2(e2, t2, o2, i2, r2) {
            const s2 = t2 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t2) * r2.extent), n2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
            for (const t3 of e2) te2(n2, t3, s2, r2);
            return n2;
          }
          function te2(e2, t2, o2, i2) {
            const r2 = t2.geometry, s2 = t2.type, n2 = [];
            if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === s2 || "MultiPoint" === s2) for (let t3 = 0; t3 < r2.length; t3 += 3) n2.push(r2[t3], r2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
            else if ("LineString" === s2) oe2(n2, r2, e2, o2, false, false);
            else if ("MultiLineString" === s2 || "Polygon" === s2) for (let t3 = 0; t3 < r2.length; t3++) oe2(n2, r2[t3], e2, o2, "Polygon" === s2, 0 === t3);
            else if ("MultiPolygon" === s2) for (let t3 = 0; t3 < r2.length; t3++) {
              const i3 = r2[t3];
              for (let t4 = 0; t4 < i3.length; t4++) oe2(n2, i3[t4], e2, o2, true, 0 === t4);
            }
            if (n2.length) {
              let o3 = t2.tags || null;
              if ("LineString" === s2 && i2.lineMetrics) {
                o3 = {};
                for (const e3 in t2.tags) o3[e3] = t2.tags[e3];
                o3.mapbox_clip_start = r2.start / r2.size, o3.mapbox_clip_end = r2.end / r2.size;
              }
              const a2 = { geometry: n2, type: "Polygon" === s2 || "MultiPolygon" === s2 ? 3 : "LineString" === s2 || "MultiLineString" === s2 ? 2 : 1, tags: o3 };
              null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
            }
          }
          function oe2(e2, t2, o2, i2, r2, s2) {
            const n2 = i2 * i2;
            if (i2 > 0 && t2.size < (r2 ? n2 : i2)) return void (o2.numPoints += t2.length / 3);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3 += 3) (0 === i2 || t2[e3 + 2] > n2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
            r2 && function(e3, t3) {
              let o3 = 0;
              for (let t4 = 0, i3 = e3.length, r3 = i3 - 2; t4 < i3; r3 = t4, t4 += 2) o3 += (e3[t4] - e3[r3]) * (e3[t4 + 1] + e3[r3 + 1]);
              if (o3 > 0 === t3) for (let t4 = 0, o4 = e3.length; t4 < o4 / 2; t4 += 2) {
                const i3 = e3[t4], r3 = e3[t4 + 1];
                e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = i3, e3[o4 - 1 - t4] = r3;
              }
            }(a2, s2), e2.push(a2);
          }
          const ie2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
          class re2 {
            constructor(e2, t2) {
              const o2 = (t2 = this.options = function(e3, t3) {
                for (const o3 in t3) e3[o3] = t3[o3];
                return e3;
              }(Object.create(ie2), t2)).debug;
              if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
              if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
              let i2 = function(e3, t3) {
                const o3 = [];
                if ("FeatureCollection" === e3.type) for (let i3 = 0; i3 < e3.features.length; i3++) A2(o3, e3.features[i3], t3, i3);
                else A2(o3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
                return o3;
              }(e2, t2);
              this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
                const o3 = t3.buffer / t3.extent;
                let i3 = e3;
                const r2 = W2(e3, 1, -1 - o3, o3, 0, -1, 2, t3), s2 = W2(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
                return (r2 || s2) && (i3 = W2(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], r2 && (i3 = $2(r2, 1).concat(i3)), s2 && (i3 = i3.concat($2(s2, -1)))), i3;
              }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e2, t2, o2, i2, r2, s2, n2) {
              const a2 = [e2, t2, o2, i2], l2 = this.options, c2 = l2.debug;
              for (; a2.length; ) {
                i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
                const u2 = 1 << t2, h3 = se2(t2, o2, i2);
                let d2 = this.tiles[h3];
                if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[h3] = ee2(e2, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
                  c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
                  const e3 = `z${t2}`;
                  this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
                }
                if (d2.source = e2, null == r2) {
                  if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints) continue;
                } else {
                  if (t2 === l2.maxZoom || t2 === r2) continue;
                  if (null != r2) {
                    const e3 = r2 - t2;
                    if (o2 !== s2 >> e3 || i2 !== n2 >> e3) continue;
                  }
                }
                if (d2.source = null, 0 === e2.length) continue;
                c2 > 1 && console.time("clipping");
                const f2 = 0.5 * l2.buffer / l2.extent, g3 = 0.5 - f2, p2 = 0.5 + f2, m2 = 1 + f2;
                let y2 = null, v2 = null, w2 = null, x3 = null, _3 = W2(e2, u2, o2 - f2, o2 + p2, 0, d2.minX, d2.maxX, l2), b2 = W2(e2, u2, o2 + g3, o2 + m2, 0, d2.minX, d2.maxX, l2);
                e2 = null, _3 && (y2 = W2(_3, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l2), v2 = W2(_3, u2, i2 + g3, i2 + m2, 1, d2.minY, d2.maxY, l2), _3 = null), b2 && (w2 = W2(b2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l2), x3 = W2(b2, u2, i2 + g3, i2 + m2, 1, d2.minY, d2.maxY, l2), b2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(w2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(x3 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
              }
            }
            getTile(e2, t2, o2) {
              e2 = +e2, t2 = +t2, o2 = +o2;
              const i2 = this.options, { extent: r2, debug: s2 } = i2;
              if (e2 < 0 || e2 > 24) return null;
              const n2 = 1 << e2, a2 = se2(e2, t2 = t2 + n2 & n2 - 1, o2);
              if (this.tiles[a2]) return K2(this.tiles[a2], r2);
              s2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
              let l2, c2 = e2, u2 = t2, h3 = o2;
              for (; !l2 && c2 > 0; ) c2--, u2 >>= 1, h3 >>= 1, l2 = this.tiles[se2(c2, u2, h3)];
              return l2 && l2.source ? (s2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, u2, h3), console.time("drilling down")), this.splitTile(l2.source, c2, u2, h3, e2, t2, o2), s2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? K2(this.tiles[a2], r2) : null) : null;
            }
          }
          function se2(e2, t2, o2) {
            return 32 * ((1 << e2) * o2 + t2) + e2;
          }
          function ne2(e2, t2) {
            return t2 ? e2.properties[t2] : e2.id;
          }
          function ae(e2, t2) {
            if (null == e2) return true;
            if ("Feature" === e2.type) return null != ne2(e2, t2);
            if ("FeatureCollection" === e2.type) {
              const o2 = /* @__PURE__ */ new Set();
              for (const i2 of e2.features) {
                const e3 = ne2(i2, t2);
                if (null == e3) return false;
                if (o2.has(e3)) return false;
                o2.add(e3);
              }
              return true;
            }
            return false;
          }
          function le2(e2, t2) {
            const o2 = /* @__PURE__ */ new Map();
            if (null == e2) ;
            else if ("Feature" === e2.type) o2.set(ne2(e2, t2), e2);
            else for (const i2 of e2.features) o2.set(ne2(i2, t2), i2);
            return o2;
          }
          class ce2 extends s {
            constructor() {
              super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
            }
            loadVectorTile(t2, o2) {
              return e._(this, void 0, void 0, function* () {
                const e2 = t2.tileID.canonical;
                if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
                const o3 = this._geoJSONIndex.getTile(e2.z, e2.x, e2.y);
                if (!o3) return null;
                const i2 = new f(o3.features);
                let r2 = w(i2);
                return 0 === r2.byteOffset && r2.byteLength === r2.buffer.byteLength || (r2 = new Uint8Array(r2)), { vectorTile: i2, rawData: r2.buffer };
              });
            }
            loadData(t2) {
              return e._(this, void 0, void 0, function* () {
                var o2;
                null === (o2 = this._pendingRequest) || void 0 === o2 || o2.abort();
                const i2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.cE(t2.request);
                this._pendingRequest = new AbortController();
                try {
                  this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest), this._geoJSONIndex = t2.cluster ? new P(function({ superclusterOptions: t3, clusterProperties: o4 }) {
                    if (!o4 || !t3) return t3;
                    const i3 = {}, r3 = {}, s2 = { accumulated: null, zoom: 0 }, n2 = { properties: null }, a2 = Object.keys(o4);
                    for (const t4 of a2) {
                      const [s3, n3] = o4[t4], a3 = e.cL(n3), l2 = e.cL("string" == typeof s3 ? [s3, ["accumulated"], ["get", t4]] : s3);
                      i3[t4] = a3.value, r3[t4] = l2.value;
                    }
                    return t3.map = (e2) => {
                      n2.properties = e2;
                      const t4 = {};
                      for (const e3 of a2) t4[e3] = i3[e3].evaluate(s2, n2);
                      return t4;
                    }, t3.reduce = (e2, t4) => {
                      n2.properties = t4;
                      for (const t5 of a2) s2.accumulated = e2[t5], e2[t5] = r3[t5].evaluate(s2, n2);
                    }, t3;
                  }(t2)).load((yield this._pendingData).features) : (r2 = yield this._pendingData, new re2(r2, t2.geojsonVtOptions)), this.loaded = {};
                  const o3 = {};
                  if (i2) {
                    const e2 = i2.finish();
                    e2 && (o3.resourceTiming = {}, o3.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
                  }
                  return o3;
                } catch (t3) {
                  if (delete this._pendingRequest, e.cp(t3)) return { abandoned: true };
                  throw t3;
                }
                var r2;
              });
            }
            getData() {
              return e._(this, void 0, void 0, function* () {
                return this._pendingData;
              });
            }
            reloadTile(e2) {
              const t2 = this.loaded;
              return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
            }
            loadAndProcessGeoJSON(t2, o2) {
              return e._(this, void 0, void 0, function* () {
                let i2 = yield this.loadGeoJSON(t2, o2);
                if (delete this._pendingRequest, "object" != typeof i2) throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
                if (u(i2, true), t2.filter) {
                  const o3 = e.cL(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === o3.result) throw new Error(o3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                  const r2 = i2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2));
                  i2 = { type: "FeatureCollection", features: r2 };
                }
                return i2;
              });
            }
            loadGeoJSON(t2, o2) {
              return e._(this, void 0, void 0, function* () {
                const { promoteId: i2 } = t2;
                if (t2.request) {
                  const r2 = yield e.j(t2.request, o2);
                  return this._dataUpdateable = ae(r2.data, i2) ? le2(r2.data, i2) : void 0, r2.data;
                }
                if ("string" == typeof t2.data) try {
                  const e2 = JSON.parse(t2.data);
                  return this._dataUpdateable = ae(e2, i2) ? le2(e2, i2) : void 0, e2;
                } catch (e2) {
                  throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
                }
                if (!t2.dataDiff) throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
                if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${t2.source}`);
                return function(e2, t3, o3) {
                  var i3, r2, s2, n2;
                  if (t3.removeAll && e2.clear(), t3.remove) for (const o4 of t3.remove) e2.delete(o4);
                  if (t3.add) for (const i4 of t3.add) {
                    const t4 = ne2(i4, o3);
                    null != t4 && e2.set(t4, i4);
                  }
                  if (t3.update) for (const o4 of t3.update) {
                    let t4 = e2.get(o4.id);
                    if (null == t4) continue;
                    const a2 = !o4.removeAllProperties && ((null === (i3 = o4.removeProperties) || void 0 === i3 ? void 0 : i3.length) > 0 || (null === (r2 = o4.addOrUpdateProperties) || void 0 === r2 ? void 0 : r2.length) > 0);
                    if ((o4.newGeometry || o4.removeAllProperties || a2) && (t4 = Object.assign({}, t4), e2.set(o4.id, t4), a2 && (t4.properties = Object.assign({}, t4.properties))), o4.newGeometry && (t4.geometry = o4.newGeometry), o4.removeAllProperties) t4.properties = {};
                    else if ((null === (s2 = o4.removeProperties) || void 0 === s2 ? void 0 : s2.length) > 0) for (const e3 of o4.removeProperties) Object.prototype.hasOwnProperty.call(t4.properties, e3) && delete t4.properties[e3];
                    if ((null === (n2 = o4.addOrUpdateProperties) || void 0 === n2 ? void 0 : n2.length) > 0) for (const { key: e3, value: i4 } of o4.addOrUpdateProperties) t4.properties[e3] = i4;
                  }
                }(this._dataUpdateable, t2.dataDiff, i2), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
              });
            }
            removeSource(t2) {
              return e._(this, void 0, void 0, function* () {
                this._pendingRequest && this._pendingRequest.abort();
              });
            }
            getClusterExpansionZoom(e2) {
              return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
            }
            getClusterChildren(e2) {
              return this._geoJSONIndex.getChildren(e2.clusterId);
            }
            getClusterLeaves(e2) {
              return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
            }
          }
          class ue2 {
            constructor(t2) {
              this.self = t2, this.actor = new e.H(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e2, t3) => {
                if (this.externalWorkerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
                this.externalWorkerSourceTypes[e2] = t3;
              }, this.self.addProtocol = e.cr, this.self.removeProtocol = e.cs, this.self.registerRTLTextPlugin = (t3) => {
                e.cM.setMethods(t3);
              }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, o2) => e._(this, void 0, void 0, function* () {
                this._getDEMWorkerSource(t3, o2.source).removeTile(o2);
              })), this.actor.registerMessageHandler("GCEZ", (t3, o2) => e._(this, void 0, void 0, function* () {
                return this._getWorkerSource(t3, o2.type, o2.source).getClusterExpansionZoom(o2);
              })), this.actor.registerMessageHandler("GCC", (t3, o2) => e._(this, void 0, void 0, function* () {
                return this._getWorkerSource(t3, o2.type, o2.source).getClusterChildren(o2);
              })), this.actor.registerMessageHandler("GCL", (t3, o2) => e._(this, void 0, void 0, function* () {
                return this._getWorkerSource(t3, o2.type, o2.source).getClusterLeaves(o2);
              })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("GD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData()), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, o2) => e._(this, void 0, void 0, function* () {
                if (!this.workerSources[t3] || !this.workerSources[t3][o2.type] || !this.workerSources[t3][o2.type][o2.source]) return;
                const e2 = this.workerSources[t3][o2.type][o2.source];
                delete this.workerSources[t3][o2.type][o2.source], void 0 !== e2.removeSource && e2.removeSource(o2);
              })), this.actor.registerMessageHandler("RM", (t3) => e._(this, void 0, void 0, function* () {
                delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3];
              })), this.actor.registerMessageHandler("SR", (t3, o2) => e._(this, void 0, void 0, function* () {
                this.referrer = o2;
              })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, o2) => e._(this, void 0, void 0, function* () {
                this.self.importScripts(o2);
              })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, o2) => e._(this, void 0, void 0, function* () {
                this._getLayerIndex(t3).update(o2.layers, o2.removedIds);
              })), this.actor.registerMessageHandler("SL", (t3, o2) => e._(this, void 0, void 0, function* () {
                this._getLayerIndex(t3).replace(o2);
              }));
            }
            _setImages(t2, o2) {
              return e._(this, void 0, void 0, function* () {
                this.availableImages[t2] = o2;
                for (const e2 in this.workerSources[t2]) {
                  const i2 = this.workerSources[t2][e2];
                  for (const e3 in i2) i2[e3].availableImages = o2;
                }
              });
            }
            _syncRTLPluginState(t2, o2) {
              return e._(this, void 0, void 0, function* () {
                return yield e.cM.syncState(o2, this.self.importScripts);
              });
            }
            _getAvailableImages(e2) {
              let t2 = this.availableImages[e2];
              return t2 || (t2 = []), t2;
            }
            _getLayerIndex(e2) {
              let o2 = this.layerIndexes[e2];
              return o2 || (o2 = this.layerIndexes[e2] = new t()), o2;
            }
            _getWorkerSource(e2, t2, o2) {
              if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
                const i2 = { sendAsync: (t3, o3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, o3)) };
                switch (t2) {
                  case "vector":
                    this.workerSources[e2][t2][o2] = new s(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                    break;
                  case "geojson":
                    this.workerSources[e2][t2][o2] = new ce2(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                    break;
                  default:
                    this.workerSources[e2][t2][o2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                }
              }
              return this.workerSources[e2][t2][o2];
            }
            _getDEMWorkerSource(e2, t2) {
              return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n()), this.demWorkerSources[e2][t2];
            }
          }
          return e.i(self) && (self.worker = new ue2(self)), ue2;
        });
        define2("index", ["exports", "./shared"], function(e, t) {
          "use strict";
          var i = "5.5.0";
          function r() {
            var e2 = new t.A(4);
            return t.A != Float32Array && (e2[1] = 0, e2[2] = 0), e2[0] = 1, e2[3] = 1, e2;
          }
          let o, a;
          const s = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(e2, i2, r2) {
            const o2 = requestAnimationFrame((e3) => {
              a2(), i2(e3);
            }), { unsubscribe: a2 } = t.s(e2.signal, "abort", () => {
              a2(), cancelAnimationFrame(o2), r2(t.c());
            }, false);
          }, frameAsync(e2) {
            return new Promise((t2, i2) => {
              this.frame(e2, t2, i2);
            });
          }, getImageData(e2, t2 = 0) {
            return this.getImageCanvasContext(e2).getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
          }, getImageCanvasContext(e2) {
            const t2 = window.document.createElement("canvas"), i2 = t2.getContext("2d", { willReadFrequently: true });
            if (!i2) throw new Error("failed to create canvas 2d context");
            return t2.width = e2.width, t2.height = e2.height, i2.drawImage(e2, 0, 0, e2.width, e2.height), i2;
          }, resolveURL: (e2) => (o || (o = document.createElement("a")), o.href = e2, o.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
            return !!matchMedia && (null == a && (a = matchMedia("(prefers-reduced-motion: reduce)")), a.matches);
          } };
          class n {
            static testProp(e2) {
              if (!n.docStyle) return e2[0];
              for (let t2 = 0; t2 < e2.length; t2++) if (e2[t2] in n.docStyle) return e2[t2];
              return e2[0];
            }
            static create(e2, t2, i2) {
              const r2 = window.document.createElement(e2);
              return void 0 !== t2 && (r2.className = t2), i2 && i2.appendChild(r2), r2;
            }
            static createNS(e2, t2) {
              return window.document.createElementNS(e2, t2);
            }
            static disableDrag() {
              n.docStyle && n.selectProp && (n.userSelect = n.docStyle[n.selectProp], n.docStyle[n.selectProp] = "none");
            }
            static enableDrag() {
              n.docStyle && n.selectProp && (n.docStyle[n.selectProp] = n.userSelect);
            }
            static setTransform(e2, t2) {
              e2.style[n.transformProp] = t2;
            }
            static addEventListener(e2, t2, i2, r2 = {}) {
              e2.addEventListener(t2, i2, "passive" in r2 ? r2 : r2.capture);
            }
            static removeEventListener(e2, t2, i2, r2 = {}) {
              e2.removeEventListener(t2, i2, "passive" in r2 ? r2 : r2.capture);
            }
            static suppressClickInternal(e2) {
              e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", n.suppressClickInternal, true);
            }
            static suppressClick() {
              window.addEventListener("click", n.suppressClickInternal, true), window.setTimeout(() => {
                window.removeEventListener("click", n.suppressClickInternal, true);
              }, 0);
            }
            static getScale(e2) {
              const t2 = e2.getBoundingClientRect();
              return { x: t2.width / e2.offsetWidth || 1, y: t2.height / e2.offsetHeight || 1, boundingClientRect: t2 };
            }
            static getPoint(e2, i2, r2) {
              const o2 = i2.boundingClientRect;
              return new t.P((r2.clientX - o2.left) / i2.x - e2.clientLeft, (r2.clientY - o2.top) / i2.y - e2.clientTop);
            }
            static mousePos(e2, t2) {
              const i2 = n.getScale(e2);
              return n.getPoint(e2, i2, t2);
            }
            static touchPos(e2, t2) {
              const i2 = [], r2 = n.getScale(e2);
              for (let o2 = 0; o2 < t2.length; o2++) i2.push(n.getPoint(e2, r2, t2[o2]));
              return i2;
            }
            static mouseButton(e2) {
              return e2.button;
            }
            static remove(e2) {
              e2.parentNode && e2.parentNode.removeChild(e2);
            }
            static sanitize(e2) {
              const t2 = new DOMParser().parseFromString(e2, "text/html").body || document.createElement("body"), i2 = t2.querySelectorAll("script");
              for (const e3 of i2) e3.remove();
              return n.clean(t2), t2.innerHTML;
            }
            static isPossiblyDangerous(e2, t2) {
              const i2 = t2.replace(/\s+/g, "").toLowerCase();
              return !(!["src", "href", "xlink:href"].includes(e2) || !i2.includes("javascript:") && !i2.includes("data:")) || !!e2.startsWith("on") || void 0;
            }
            static clean(e2) {
              const t2 = e2.children;
              for (const e3 of t2) n.removeAttributes(e3), n.clean(e3);
            }
            static removeAttributes(e2) {
              for (const { name: t2, value: i2 } of e2.attributes) n.isPossiblyDangerous(t2, i2) && e2.removeAttribute(t2);
            }
          }
          n.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, n.selectProp = n.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), n.transformProp = n.testProp(["transform", "WebkitTransform"]);
          const l = { supported: false, testSupport: function(e2) {
            !u && h2 && (d ? _2(e2) : c = e2);
          } };
          let c, h2, u = false, d = false;
          function _2(e2) {
            const t2 = e2.createTexture();
            e2.bindTexture(e2.TEXTURE_2D, t2);
            try {
              if (e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, e2.RGBA, e2.UNSIGNED_BYTE, h2), e2.isContextLost()) return;
              l.supported = true;
            } catch (e3) {
            }
            e2.deleteTexture(t2), u = true;
          }
          var p;
          "undefined" != typeof document && (h2 = document.createElement("img"), h2.onload = () => {
            c && _2(c), c = null, d = true;
          }, h2.onerror = () => {
            u = true, c = null;
          }, h2.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e2) {
            let i2, r2, o2, a2;
            e2.resetRequestQueue = () => {
              i2 = [], r2 = 0, o2 = 0, a2 = {};
            }, e2.addThrottleControl = (e3) => {
              const t2 = o2++;
              return a2[t2] = e3, t2;
            }, e2.removeThrottleControl = (e3) => {
              delete a2[e3], n2();
            }, e2.getImage = (e3, r3, o3 = true) => new Promise((a3, s3) => {
              l.supported && (e3.headers || (e3.headers = {}), e3.headers.accept = "image/webp,*/*"), t.e(e3, { type: "image" }), i2.push({ abortController: r3, requestParameters: e3, supportImageRefresh: o3, state: "queued", onError: (e4) => {
                s3(e4);
              }, onSuccess: (e4) => {
                a3(e4);
              } }), n2();
            });
            const s2 = (e3) => t._(this, void 0, void 0, function* () {
              e3.state = "running";
              const { requestParameters: i3, supportImageRefresh: o3, onError: a3, onSuccess: s3, abortController: l2 } = e3, h3 = false === o3 && !t.i(self) && !t.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((e4, t2) => e4 && "accept" === t2, true));
              r2++;
              const u2 = h3 ? c2(i3, l2) : t.m(i3, l2);
              try {
                const i4 = yield u2;
                delete e3.abortController, e3.state = "completed", i4.data instanceof HTMLImageElement || t.b(i4.data) ? s3(i4) : i4.data && s3({ data: yield (d2 = i4.data, "function" == typeof createImageBitmap ? t.f(d2) : t.h(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
              } catch (t2) {
                delete e3.abortController, a3(t2);
              } finally {
                r2--, n2();
              }
              var d2;
            }), n2 = () => {
              const e3 = (() => {
                for (const e4 of Object.keys(a2)) if (a2[e4]()) return true;
                return false;
              })() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let t2 = r2; t2 < e3 && i2.length > 0; t2++) {
                const e4 = i2.shift();
                e4.abortController.signal.aborted ? t2-- : s2(e4);
              }
            }, c2 = (e3, i3) => new Promise((r3, o3) => {
              const a3 = new Image(), s3 = e3.url, n3 = e3.credentials;
              n3 && "include" === n3 ? a3.crossOrigin = "use-credentials" : (n3 && "same-origin" === n3 || !t.d(s3)) && (a3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
                a3.src = "", o3(t.c());
              }), a3.fetchPriority = "high", a3.onload = () => {
                a3.onerror = a3.onload = null, r3({ data: a3 });
              }, a3.onerror = () => {
                a3.onerror = a3.onload = null, i3.signal.aborted || o3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              }, a3.src = s3;
            });
          }(p || (p = {})), p.resetRequestQueue();
          class m {
            constructor(e2) {
              this._transformRequestFn = e2;
            }
            transformRequest(e2, t2) {
              return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
            }
            setTransformRequest(e2) {
              this._transformRequestFn = e2;
            }
          }
          function f(e2) {
            const t2 = [];
            if ("string" == typeof e2) t2.push({ id: "default", url: e2 });
            else if (e2 && e2.length > 0) {
              const i2 = [];
              for (const { id: r2, url: o2 } of e2) {
                const e3 = `${r2}${o2}`;
                -1 === i2.indexOf(e3) && (i2.push(e3), t2.push({ id: r2, url: o2 }));
              }
            }
            return t2;
          }
          function g2(e2, t2, i2) {
            try {
              const r2 = new URL(e2);
              return r2.pathname += `${t2}${i2}`, r2.toString();
            } catch (t3) {
              throw new Error(`Invalid sprite URL "${e2}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
            }
          }
          class v {
            constructor(e2, t2, i2, r2) {
              this.context = e2, this.format = i2, this.texture = e2.gl.createTexture(), this.update(t2, r2);
            }
            update(e2, i2, r2) {
              const { width: o2, height: a2 } = e2, s2 = !(this.size && this.size[0] === o2 && this.size[1] === a2 || r2), { context: n2 } = this, { gl: l2 } = n2;
              if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || false !== i2.premultiply)), s2) this.size = [o2, a2], e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.b(e2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, o2, a2, 0, this.format, l2.UNSIGNED_BYTE, e2.data);
              else {
                const { x: i3, y: s3 } = r2 || { x: 0, y: 0 };
                e2 instanceof HTMLImageElement || e2 instanceof HTMLCanvasElement || e2 instanceof HTMLVideoElement || e2 instanceof ImageData || t.b(e2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, s3, l2.RGBA, l2.UNSIGNED_BYTE, e2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, s3, o2, a2, l2.RGBA, l2.UNSIGNED_BYTE, e2.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D), n2.pixelStoreUnpackFlipY.setDefault(), n2.pixelStoreUnpack.setDefault(), n2.pixelStoreUnpackPremultiplyAlpha.setDefault();
            }
            bind(e2, t2, i2) {
              const { context: r2 } = this, { gl: o2 } = r2;
              o2.bindTexture(o2.TEXTURE_2D, this.texture), i2 !== o2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = o2.LINEAR), e2 !== this.filter && (o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, e2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, i2 || e2), this.filter = e2), t2 !== this.wrap && (o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, t2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, t2), this.wrap = t2);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: e2 } = this.context;
              e2.deleteTexture(this.texture), this.texture = null;
            }
          }
          function x2(e2) {
            const { userImage: t2 } = e2;
            return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
          }
          class b extends t.E {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(e2) {
              if (this.loaded !== e2 && (this.loaded = e2, e2)) {
                for (const { ids: e3, promiseResolve: t2 } of this.requestors) t2(this._getImagesForIds(e3));
                this.requestors = [];
              }
            }
            getImage(e2) {
              const i2 = this.images[e2];
              if (i2 && !i2.data && i2.spriteData) {
                const e3 = i2.spriteData;
                i2.data = new t.R({ width: e3.width, height: e3.height }, e3.context.getImageData(e3.x, e3.y, e3.width, e3.height).data), i2.spriteData = null;
              }
              return i2;
            }
            addImage(e2, t2) {
              if (this.images[e2]) throw new Error(`Image id ${e2} already exist, use updateImage instead`);
              this._validate(e2, t2) && (this.images[e2] = t2);
            }
            _validate(e2, i2) {
              let r2 = true;
              const o2 = i2.data || i2.spriteData;
              return this._validateStretch(i2.stretchX, o2 && o2.width) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchX" value`))), r2 = false), this._validateStretch(i2.stretchY, o2 && o2.height) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "stretchY" value`))), r2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.k(new Error(`Image "${e2}" has invalid "content" value`))), r2 = false), r2;
            }
            _validateStretch(e2, t2) {
              if (!e2) return true;
              let i2 = 0;
              for (const r2 of e2) {
                if (r2[0] < i2 || r2[1] < r2[0] || t2 < r2[1]) return false;
                i2 = r2[1];
              }
              return true;
            }
            _validateContent(e2, t2) {
              if (!e2) return true;
              if (4 !== e2.length) return false;
              const i2 = t2.spriteData, r2 = i2 && i2.width || t2.data.width, o2 = i2 && i2.height || t2.data.height;
              return !(e2[0] < 0 || r2 < e2[0] || e2[1] < 0 || o2 < e2[1] || e2[2] < 0 || r2 < e2[2] || e2[3] < 0 || o2 < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]);
            }
            updateImage(e2, t2, i2 = true) {
              const r2 = this.getImage(e2);
              if (i2 && (r2.data.width !== t2.data.width || r2.data.height !== t2.data.height)) throw new Error(`size mismatch between old image (${r2.data.width}x${r2.data.height}) and new image (${t2.data.width}x${t2.data.height}).`);
              t2.version = r2.version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
            }
            removeImage(e2) {
              const t2 = this.images[e2];
              delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(e2) {
              return new Promise((t2, i2) => {
                let r2 = true;
                if (!this.isLoaded()) for (const t3 of e2) this.images[t3] || (r2 = false);
                this.isLoaded() || r2 ? t2(this._getImagesForIds(e2)) : this.requestors.push({ ids: e2, promiseResolve: t2 });
              });
            }
            _getImagesForIds(e2) {
              const i2 = {};
              for (const r2 of e2) {
                let e3 = this.getImage(r2);
                e3 || (this.fire(new t.l("styleimagemissing", { id: r2 })), e3 = this.getImage(r2)), e3 ? i2[r2] = { data: e3.data.clone(), pixelRatio: e3.pixelRatio, sdf: e3.sdf, version: e3.version, stretchX: e3.stretchX, stretchY: e3.stretchY, content: e3.content, textFitWidth: e3.textFitWidth, textFitHeight: e3.textFitHeight, hasRenderCallback: Boolean(e3.userImage && e3.userImage.render) } : t.w(`Image "${r2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              return i2;
            }
            getPixelSize() {
              const { width: e2, height: t2 } = this.atlasImage;
              return { width: e2, height: t2 };
            }
            getPattern(e2) {
              const i2 = this.patterns[e2], r2 = this.getImage(e2);
              if (!r2) return null;
              if (i2 && i2.position.version === r2.version) return i2.position;
              if (i2) i2.position.version = r2.version;
              else {
                const i3 = { w: r2.data.width + 2, h: r2.data.height + 2, x: 0, y: 0 }, o2 = new t.I(i3, r2);
                this.patterns[e2] = { bin: i3, position: o2 };
              }
              return this._updatePatternAtlas(), this.patterns[e2].position;
            }
            bind(e2) {
              const t2 = e2.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new v(e2, this.atlasImage, t2.RGBA), this.atlasTexture.bind(t2.LINEAR, t2.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e2 = [];
              for (const t2 in this.patterns) e2.push(this.patterns[t2].bin);
              const { w: i2, h: r2 } = t.p(e2), o2 = this.atlasImage;
              o2.resize({ width: i2 || 1, height: r2 || 1 });
              for (const e3 in this.patterns) {
                const { bin: i3 } = this.patterns[e3], r3 = i3.x + 1, a2 = i3.y + 1, s2 = this.getImage(e3).data, n2 = s2.width, l2 = s2.height;
                t.R.copy(s2, o2, { x: 0, y: 0 }, { x: r3, y: a2 }, { width: n2, height: l2 }), t.R.copy(s2, o2, { x: 0, y: l2 - 1 }, { x: r3, y: a2 - 1 }, { width: n2, height: 1 }), t.R.copy(s2, o2, { x: 0, y: 0 }, { x: r3, y: a2 + l2 }, { width: n2, height: 1 }), t.R.copy(s2, o2, { x: n2 - 1, y: 0 }, { x: r3 - 1, y: a2 }, { width: 1, height: l2 }), t.R.copy(s2, o2, { x: 0, y: 0 }, { x: r3 + n2, y: a2 }, { width: 1, height: l2 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e2) {
              for (const i2 of e2) {
                if (this.callbackDispatchedThisFrame[i2]) continue;
                this.callbackDispatchedThisFrame[i2] = true;
                const e3 = this.getImage(i2);
                e3 || t.w(`Image with ID: "${i2}" was not found`), x2(e3) && this.updateImage(i2, e3);
              }
            }
          }
          const y = 1e20;
          function w(e2, t2, i2, r2, o2, a2, s2, n2, l2) {
            for (let c2 = t2; c2 < t2 + r2; c2++) T(e2, i2 * a2 + c2, a2, o2, s2, n2, l2);
            for (let c2 = i2; c2 < i2 + o2; c2++) T(e2, c2 * a2 + t2, 1, r2, s2, n2, l2);
          }
          function T(e2, t2, i2, r2, o2, a2, s2) {
            a2[0] = 0, s2[0] = -1e20, s2[1] = y, o2[0] = e2[t2];
            for (let n2 = 1, l2 = 0, c2 = 0; n2 < r2; n2++) {
              o2[n2] = e2[t2 + n2 * i2];
              const r3 = n2 * n2;
              do {
                const e3 = a2[l2];
                c2 = (o2[n2] - o2[e3] + r3 - e3 * e3) / (n2 - e3) / 2;
              } while (c2 <= s2[l2] && --l2 > -1);
              l2++, a2[l2] = n2, s2[l2] = c2, s2[l2 + 1] = y;
            }
            for (let n2 = 0, l2 = 0; n2 < r2; n2++) {
              for (; s2[l2 + 1] < n2; ) l2++;
              const r3 = a2[l2], c2 = n2 - r3;
              e2[t2 + n2 * i2] = o2[r3] + c2 * c2;
            }
          }
          class P {
            constructor(e2, t2) {
              this.requestManager = e2, this.localIdeographFontFamily = t2, this.entries = {};
            }
            setURL(e2) {
              this.url = e2;
            }
            getGlyphs(e2) {
              return t._(this, void 0, void 0, function* () {
                const t2 = [];
                for (const i3 in e2) for (const r3 of e2[i3]) t2.push(this._getAndCacheGlyphsPromise(i3, r3));
                const i2 = yield Promise.all(t2), r2 = {};
                for (const { stack: e3, id: t3, glyph: o2 } of i2) r2[e3] || (r2[e3] = {}), r2[e3][t3] = o2 && { id: o2.id, bitmap: o2.bitmap.clone(), metrics: o2.metrics };
                return r2;
              });
            }
            _getAndCacheGlyphsPromise(e2, i2) {
              return t._(this, void 0, void 0, function* () {
                let t2 = this.entries[e2];
                t2 || (t2 = this.entries[e2] = { glyphs: {}, requests: {}, ranges: {} });
                let r2 = t2.glyphs[i2];
                if (void 0 !== r2) return { stack: e2, id: i2, glyph: r2 };
                if (r2 = this._tinySDF(t2, e2, i2), r2) return t2.glyphs[i2] = r2, { stack: e2, id: i2, glyph: r2 };
                const o2 = Math.floor(i2 / 256);
                if (256 * o2 > 65535) throw new Error("glyphs > 65535 not supported");
                if (t2.ranges[o2]) return { stack: e2, id: i2, glyph: r2 };
                if (!this.url) throw new Error("glyphsUrl is not set");
                if (!t2.requests[o2]) {
                  const i3 = P.loadGlyphRange(e2, o2, this.url, this.requestManager);
                  t2.requests[o2] = i3;
                }
                const a2 = yield t2.requests[o2];
                for (const e3 in a2) this._doesCharSupportLocalGlyph(+e3) || (t2.glyphs[+e3] = a2[+e3]);
                return t2.ranges[o2] = true, { stack: e2, id: i2, glyph: a2[i2] || null };
              });
            }
            _doesCharSupportLocalGlyph(e2) {
              return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e2)) || t.u["CJK Unified Ideographs"](e2) || t.u["Hangul Syllables"](e2) || t.u.Hiragana(e2) || t.u.Katakana(e2) || t.u["CJK Symbols and Punctuation"](e2) || t.u["Halfwidth and Fullwidth Forms"](e2));
            }
            _tinySDF(e2, i2, r2) {
              const o2 = this.localIdeographFontFamily;
              if (!o2) return;
              if (!this._doesCharSupportLocalGlyph(r2)) return;
              let a2 = e2.tinySDF;
              if (!a2) {
                let t2 = "400";
                /bold/i.test(i2) ? t2 = "900" : /medium/i.test(i2) ? t2 = "500" : /light/i.test(i2) && (t2 = "200"), a2 = e2.tinySDF = new P.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o2, fontWeight: t2 });
              }
              const s2 = a2.draw(String.fromCharCode(r2));
              return { id: r2, bitmap: new t.q({ width: s2.width || 60, height: s2.height || 60 }, s2.data), metrics: { width: s2.glyphWidth / 2 || 24, height: s2.glyphHeight / 2 || 24, left: s2.glyphLeft / 2 + 0.5 || 0, top: s2.glyphTop / 2 - 27.5 || -8, advance: s2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
            }
          }
          P.loadGlyphRange = function(e2, i2, r2, o2) {
            return t._(this, void 0, void 0, function* () {
              const a2 = 256 * i2, s2 = a2 + 255, n2 = o2.transformRequest(r2.replace("{fontstack}", e2).replace("{range}", `${a2}-${s2}`), "Glyphs"), l2 = yield t.n(n2, new AbortController());
              if (!l2 || !l2.data) throw new Error(`Could not load glyph range. range: ${i2}, ${a2}-${s2}`);
              const c2 = {};
              for (const e3 of t.o(l2.data)) c2[e3.id] = e3;
              return c2;
            });
          }, P.TinySDF = class {
            constructor({ fontSize: e2 = 24, buffer: t2 = 3, radius: i2 = 8, cutoff: r2 = 0.25, fontFamily: o2 = "sans-serif", fontWeight: a2 = "normal", fontStyle: s2 = "normal" } = {}) {
              this.buffer = t2, this.cutoff = r2, this.radius = i2;
              const n2 = this.size = e2 + 4 * t2, l2 = this._createCanvas(n2), c2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              c2.font = `${s2} ${a2} ${e2}px ${o2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
            }
            _createCanvas(e2) {
              const t2 = document.createElement("canvas");
              return t2.width = t2.height = e2, t2;
            }
            draw(e2) {
              const { width: t2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: r2, actualBoundingBoxLeft: o2, actualBoundingBoxRight: a2 } = this.ctx.measureText(e2), s2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a2 - o2))), l2 = Math.min(this.size - this.buffer, s2 + Math.ceil(r2)), c2 = n2 + 2 * this.buffer, h3 = l2 + 2 * this.buffer, u2 = Math.max(c2 * h3, 0), d2 = new Uint8ClampedArray(u2), _3 = { data: d2, width: c2, height: h3, glyphWidth: n2, glyphHeight: l2, glyphTop: s2, glyphLeft: 0, glyphAdvance: t2 };
              if (0 === n2 || 0 === l2) return _3;
              const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g3 } = this;
              p2.clearRect(m2, m2, n2, l2), p2.fillText(e2, m2, m2 + s2);
              const v2 = p2.getImageData(m2, m2, n2, l2);
              g3.fill(y, 0, u2), f2.fill(0, 0, u2);
              for (let e3 = 0; e3 < l2; e3++) for (let t3 = 0; t3 < n2; t3++) {
                const i3 = v2.data[4 * (e3 * n2 + t3) + 3] / 255;
                if (0 === i3) continue;
                const r3 = (e3 + m2) * c2 + t3 + m2;
                if (1 === i3) g3[r3] = 0, f2[r3] = y;
                else {
                  const e4 = 0.5 - i3;
                  g3[r3] = e4 > 0 ? e4 * e4 : 0, f2[r3] = e4 < 0 ? e4 * e4 : 0;
                }
              }
              w(g3, 0, 0, c2, h3, c2, this.f, this.v, this.z), w(f2, m2, m2, n2, l2, c2, this.f, this.v, this.z);
              for (let e3 = 0; e3 < u2; e3++) {
                const t3 = Math.sqrt(g3[e3]) - Math.sqrt(f2[e3]);
                d2[e3] = Math.round(255 - 255 * (t3 / this.radius + this.cutoff));
              }
              return _3;
            }
          };
          class C2 {
            constructor() {
              this.specification = t.v.light.position;
            }
            possiblyEvaluate(e2, i2) {
              return t.z(e2.expression.evaluate(i2));
            }
            interpolate(e2, i2, r2) {
              return { x: t.B.number(e2.x, i2.x, r2), y: t.B.number(e2.y, i2.y, r2), z: t.B.number(e2.z, i2.z, r2) };
            }
          }
          let M2;
          class I2 extends t.E {
            constructor(e2) {
              super(), M2 = M2 || new t.r({ anchor: new t.D(t.v.light.anchor), position: new C2(), color: new t.D(t.v.light.color), intensity: new t.D(t.v.light.intensity) }), this._transitionable = new t.T(M2), this.setLight(e2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e2, i2 = {}) {
              if (!this._validate(t.t, e2, i2)) for (const t2 in e2) {
                const i3 = e2[t2];
                t2.endsWith("-transition") ? this._transitionable.setTransition(t2.slice(0, -11), i3) : this._transitionable.setValue(t2, i3);
              }
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(e2, i2, r2) {
              return (!r2 || false !== r2.validate) && t.x(this, e2.call(t.y, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.v }));
            }
          }
          const E2 = new t.r({ "sky-color": new t.D(t.v.sky["sky-color"]), "horizon-color": new t.D(t.v.sky["horizon-color"]), "fog-color": new t.D(t.v.sky["fog-color"]), "fog-ground-blend": new t.D(t.v.sky["fog-ground-blend"]), "horizon-fog-blend": new t.D(t.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new t.D(t.v.sky["sky-horizon-blend"]), "atmosphere-blend": new t.D(t.v.sky["atmosphere-blend"]) });
          class S2 extends t.E {
            constructor(e2) {
              super(), this._transitionable = new t.T(E2), this.setSky(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.C(0));
            }
            setSky(e2, i2 = {}) {
              if (!this._validate(t.F, e2, i2)) {
                e2 || (e2 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
                for (const t2 in e2) {
                  const i3 = e2[t2];
                  t2.endsWith("-transition") ? this._transitionable.setTransition(t2.slice(0, -11), i3) : this._transitionable.setValue(t2, i3);
                }
              }
            }
            getSky() {
              return this._transitionable.serialize();
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(e2, i2, r2 = {}) {
              return false !== (null == r2 ? void 0 : r2.validate) && t.x(this, e2.call(t.y, t.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.v })));
            }
            calculateFogBlendOpacity(e2) {
              return e2 < 60 ? 0 : e2 < 70 ? (e2 - 60) / 10 : 1;
            }
          }
          class R {
            constructor(e2, t2) {
              this.width = e2, this.height = t2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(e2, t2) {
              const i2 = e2.join(",") + String(t2);
              return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(e2, t2)), this.dashEntry[i2];
            }
            getDashRanges(e2, t2, i2) {
              const r2 = [];
              let o2 = e2.length % 2 == 1 ? -e2[e2.length - 1] * i2 : 0, a2 = e2[0] * i2, s2 = true;
              r2.push({ left: o2, right: a2, isDash: s2, zeroLength: 0 === e2[0] });
              let n2 = e2[0];
              for (let t3 = 1; t3 < e2.length; t3++) {
                s2 = !s2;
                const l2 = e2[t3];
                o2 = n2 * i2, n2 += l2, a2 = n2 * i2, r2.push({ left: o2, right: a2, isDash: s2, zeroLength: 0 === l2 });
              }
              return r2;
            }
            addRoundDash(e2, t2, i2) {
              const r2 = t2 / 2;
              for (let t3 = -i2; t3 <= i2; t3++) {
                const o2 = this.width * (this.nextRow + i2 + t3);
                let a2 = 0, s2 = e2[a2];
                for (let n2 = 0; n2 < this.width; n2++) {
                  n2 / s2.right > 1 && (s2 = e2[++a2]);
                  const l2 = Math.abs(n2 - s2.left), c2 = Math.abs(n2 - s2.right), h3 = Math.min(l2, c2);
                  let u2;
                  const d2 = t3 / i2 * (r2 + 1);
                  if (s2.isDash) {
                    const e3 = r2 - Math.abs(d2);
                    u2 = Math.sqrt(h3 * h3 + e3 * e3);
                  } else u2 = r2 - Math.sqrt(h3 * h3 + d2 * d2);
                  this.data[o2 + n2] = Math.max(0, Math.min(255, u2 + 128));
                }
              }
            }
            addRegularDash(e2) {
              for (let t3 = e2.length - 1; t3 >= 0; --t3) {
                const i3 = e2[t3], r3 = e2[t3 + 1];
                i3.zeroLength ? e2.splice(t3, 1) : r3 && r3.isDash === i3.isDash && (r3.left = i3.left, e2.splice(t3, 1));
              }
              const t2 = e2[0], i2 = e2[e2.length - 1];
              t2.isDash === i2.isDash && (t2.left = i2.left - this.width, i2.right = t2.right + this.width);
              const r2 = this.width * this.nextRow;
              let o2 = 0, a2 = e2[o2];
              for (let t3 = 0; t3 < this.width; t3++) {
                t3 / a2.right > 1 && (a2 = e2[++o2]);
                const i3 = Math.abs(t3 - a2.left), s2 = Math.abs(t3 - a2.right), n2 = Math.min(i3, s2);
                this.data[r2 + t3] = Math.max(0, Math.min(255, (a2.isDash ? n2 : -n2) + 128));
              }
            }
            addDash(e2, i2) {
              const r2 = i2 ? 7 : 0, o2 = 2 * r2 + 1;
              if (this.nextRow + o2 > this.height) return t.w("LineAtlas out of space"), null;
              let a2 = 0;
              for (let t2 = 0; t2 < e2.length; t2++) a2 += e2[t2];
              if (0 !== a2) {
                const t2 = this.width / a2, o3 = this.getDashRanges(e2, this.width, t2);
                i2 ? this.addRoundDash(o3, t2, r2) : this.addRegularDash(o3);
              }
              const s2 = { y: (this.nextRow + r2 + 0.5) / this.height, height: 2 * r2 / this.height, width: a2 };
              return this.nextRow += o2, this.dirty = true, s2;
            }
            bind(e2) {
              const t2 = e2.gl;
              this.texture ? (t2.bindTexture(t2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t2.texSubImage2D(t2.TEXTURE_2D, 0, 0, 0, this.width, this.height, t2.ALPHA, t2.UNSIGNED_BYTE, this.data))) : (this.texture = t2.createTexture(), t2.bindTexture(t2.TEXTURE_2D, this.texture), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.REPEAT), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, t2.LINEAR), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, t2.LINEAR), t2.texImage2D(t2.TEXTURE_2D, 0, t2.ALPHA, this.width, this.height, 0, t2.ALPHA, t2.UNSIGNED_BYTE, this.data));
            }
          }
          const z = "maplibre_preloaded_worker_pool";
          class D2 {
            constructor() {
              this.active = {};
            }
            acquire(e2) {
              if (!this.workers) for (this.workers = []; this.workers.length < D2.workerCount; ) this.workers.push(new Worker(t.a.WORKER_URL));
              return this.active[e2] = true, this.workers.slice();
            }
            release(e2) {
              delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
                e3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[z];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          const A2 = Math.floor(s.hardwareConcurrency / 2);
          let L2, k;
          function F2() {
            return L2 || (L2 = new D2()), L2;
          }
          D2.workerCount = t.G(globalThis) ? Math.max(Math.min(A2, 3), 1) : 1;
          class B2 {
            constructor(e2, i2) {
              this.workerPool = e2, this.actors = [], this.currentActor = 0, this.id = i2;
              const r2 = this.workerPool.acquire(i2);
              for (let e3 = 0; e3 < r2.length; e3++) {
                const o2 = new t.H(r2[e3], i2);
                o2.name = `Worker ${e3}`, this.actors.push(o2);
              }
              if (!this.actors.length) throw new Error("No actors found");
            }
            broadcast(e2, t2) {
              const i2 = [];
              for (const r2 of this.actors) i2.push(r2.sendAsync({ type: e2, data: t2 }));
              return Promise.all(i2);
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove(e2 = true) {
              this.actors.forEach((e3) => {
                e3.remove();
              }), this.actors = [], e2 && this.workerPool.release(this.id);
            }
            registerMessageHandler(e2, t2) {
              for (const i2 of this.actors) i2.registerMessageHandler(e2, t2);
            }
          }
          function O2() {
            return k || (k = new B2(F2(), t.J), k.registerMessageHandler("GR", (e2, i2, r2) => t.m(i2, r2))), k;
          }
          function j(e2, i2) {
            const r2 = t.K();
            return t.L(r2, r2, [1, 1, 0]), t.M(r2, r2, [0.5 * e2.width, 0.5 * e2.height, 1]), e2.calculatePosMatrix ? t.N(r2, r2, e2.calculatePosMatrix(i2.toUnwrapped())) : r2;
          }
          function Z2(e2, t2, i2, r2, o2, a2, s2) {
            var n2;
            const l2 = function(e3, t3, i3) {
              if (e3) for (const r3 of e3) {
                const e4 = t3[r3];
                if (e4 && e4.source === i3 && "fill-extrusion" === e4.type) return true;
              }
              else for (const e4 in t3) {
                const r3 = t3[e4];
                if (r3.source === i3 && "fill-extrusion" === r3.type) return true;
              }
              return false;
            }(null !== (n2 = null == o2 ? void 0 : o2.layers) && void 0 !== n2 ? n2 : null, t2, e2.id), c2 = a2.maxPitchScaleFactor(), h3 = e2.tilesIn(r2, c2, l2);
            h3.sort(N2);
            const u2 = [];
            for (const r3 of h3) u2.push({ wrappedTileID: r3.tileID.wrapped().key, queryResults: r3.tile.queryRenderedFeatures(t2, i2, e2._state, r3.queryGeometry, r3.cameraQueryGeometry, r3.scale, o2, a2, c2, j(e2.transform, r3.tileID), s2 ? (e3, t3) => s2(r3.tileID, e3, t3) : void 0) });
            return function(e3, t3) {
              for (const i3 in e3) for (const r3 of e3[i3]) U(r3, t3);
              return e3;
            }(function(e3) {
              const t3 = {}, i3 = {};
              for (const r3 of e3) {
                const e4 = r3.queryResults, o3 = r3.wrappedTileID, a3 = i3[o3] = i3[o3] || {};
                for (const i4 in e4) {
                  const r4 = e4[i4], o4 = a3[i4] = a3[i4] || {}, s3 = t3[i4] = t3[i4] || [];
                  for (const e5 of r4) o4[e5.featureIndex] || (o4[e5.featureIndex] = true, s3.push(e5));
                }
              }
              return t3;
            }(u2), e2);
          }
          function N2(e2, t2) {
            const i2 = e2.tileID, r2 = t2.tileID;
            return i2.overscaledZ - r2.overscaledZ || i2.canonical.y - r2.canonical.y || i2.wrap - r2.wrap || i2.canonical.x - r2.canonical.x;
          }
          function U(e2, t2) {
            const i2 = e2.feature, r2 = t2.getFeatureState(i2.layer["source-layer"], i2.id);
            i2.source = i2.layer.source, i2.layer["source-layer"] && (i2.sourceLayer = i2.layer["source-layer"]), i2.state = r2;
          }
          function G2(e2, i2, r2) {
            return t._(this, void 0, void 0, function* () {
              let o2 = e2;
              if (e2.url ? o2 = (yield t.j(i2.transformRequest(e2.url, "Source"), r2)).data : yield s.frameAsync(r2), !o2) return null;
              const a2 = t.O(t.e(o2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
              return "vector_layers" in o2 && o2.vector_layers && (a2.vectorLayerIds = o2.vector_layers.map((e3) => e3.id)), a2;
            });
          }
          class V2 {
            constructor(e2, t2) {
              e2 && (t2 ? this.setSouthWest(e2).setNorthEast(t2) : Array.isArray(e2) && (4 === e2.length ? this.setSouthWest([e2[0], e2[1]]).setNorthEast([e2[2], e2[3]]) : this.setSouthWest(e2[0]).setNorthEast(e2[1])));
            }
            setNorthEast(e2) {
              return this._ne = e2 instanceof t.Q ? new t.Q(e2.lng, e2.lat) : t.Q.convert(e2), this;
            }
            setSouthWest(e2) {
              return this._sw = e2 instanceof t.Q ? new t.Q(e2.lng, e2.lat) : t.Q.convert(e2), this;
            }
            extend(e2) {
              const i2 = this._sw, r2 = this._ne;
              let o2, a2;
              if (e2 instanceof t.Q) o2 = e2, a2 = e2;
              else {
                if (!(e2 instanceof V2)) return Array.isArray(e2) ? 4 === e2.length || e2.every(Array.isArray) ? this.extend(V2.convert(e2)) : this.extend(t.Q.convert(e2)) : e2 && ("lng" in e2 || "lon" in e2) && "lat" in e2 ? this.extend(t.Q.convert(e2)) : this;
                if (o2 = e2._sw, a2 = e2._ne, !o2 || !a2) return this;
              }
              return i2 || r2 ? (i2.lng = Math.min(o2.lng, i2.lng), i2.lat = Math.min(o2.lat, i2.lat), r2.lng = Math.max(a2.lng, r2.lng), r2.lat = Math.max(a2.lat, r2.lat)) : (this._sw = new t.Q(o2.lng, o2.lat), this._ne = new t.Q(a2.lng, a2.lat)), this;
            }
            getCenter() {
              return new t.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new t.Q(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new t.Q(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(e2) {
              const { lng: i2, lat: r2 } = t.Q.convert(e2);
              let o2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (o2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && o2;
            }
            static convert(e2) {
              return e2 instanceof V2 ? e2 : e2 ? new V2(e2) : e2;
            }
            static fromLngLat(e2, i2 = 0) {
              const r2 = 360 * i2 / 40075017, o2 = r2 / Math.cos(Math.PI / 180 * e2.lat);
              return new V2(new t.Q(e2.lng - o2, e2.lat - r2), new t.Q(e2.lng + o2, e2.lat + r2));
            }
            adjustAntiMeridian() {
              const e2 = new t.Q(this._sw.lng, this._sw.lat), i2 = new t.Q(this._ne.lng, this._ne.lat);
              return new V2(e2, e2.lng > i2.lng ? new t.Q(i2.lng + 360, i2.lat) : i2);
            }
          }
          class q2 {
            constructor(e2, t2, i2) {
              this.bounds = V2.convert(this.validateBounds(e2)), this.minzoom = t2 || 0, this.maxzoom = i2 || 24;
            }
            validateBounds(e2) {
              return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
            }
            contains(e2) {
              const i2 = Math.pow(2, e2.z), r2 = Math.floor(t.U(this.bounds.getWest()) * i2), o2 = Math.floor(t.S(this.bounds.getNorth()) * i2), a2 = Math.ceil(t.U(this.bounds.getEast()) * i2), s2 = Math.ceil(t.S(this.bounds.getSouth()) * i2);
              return e2.x >= r2 && e2.x < a2 && e2.y >= o2 && e2.y < s2;
            }
          }
          class W2 extends t.E {
            constructor(e2, i2, r2, o2) {
              if (super(), this.id = e2, this.dispatcher = r2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.e(this, t.O(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(o2);
            }
            load() {
              return t._(this, void 0, void 0, function* () {
                this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
                try {
                  const e2 = yield G2(this._options, this.map._requestManager, this._tileJSONRequest);
                  this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e2 && (t.e(this, e2), e2.bounds && (this.tileBounds = new q2(e2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })));
                } catch (e2) {
                  this._tileJSONRequest = null, this.fire(new t.k(e2));
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            setSourceProperty(e2) {
              this._tileJSONRequest && this._tileJSONRequest.abort(), e2(), this.load();
            }
            setTiles(e2) {
              return this.setSourceProperty(() => {
                this._options.tiles = e2;
              }), this;
            }
            setUrl(e2) {
              return this.setSourceProperty(() => {
                this.url = e2, this._options.url = e2;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.e({}, this._options);
            }
            loadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                const t2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(t2, "Tile"), uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, tileSize: this.tileSize * e2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
                i2.request.collectResourceTiming = this._collectResourceTiming;
                let r2 = "RT";
                if (e2.actor && "expired" !== e2.state) {
                  if ("loading" === e2.state) return new Promise((t3, i3) => {
                    e2.reloadPromise = { resolve: t3, reject: i3 };
                  });
                } else e2.actor = this.dispatcher.getActor(), r2 = "LT";
                e2.abortController = new AbortController();
                try {
                  const t3 = yield e2.actor.sendAsync({ type: r2, data: i2 }, e2.abortController);
                  if (delete e2.abortController, e2.aborted) return;
                  this._afterTileLoadWorkerResponse(e2, t3);
                } catch (t3) {
                  if (delete e2.abortController, e2.aborted) return;
                  if (t3 && 404 !== t3.status) throw t3;
                  this._afterTileLoadWorkerResponse(e2, null);
                }
              });
            }
            _afterTileLoadWorkerResponse(e2, t2) {
              if (t2 && t2.resourceTiming && (e2.resourceTiming = t2.resourceTiming), t2 && this.map._refreshExpiredTiles && e2.setExpiryData(t2), e2.loadVectorData(t2, this.map.painter), e2.reloadPromise) {
                const t3 = e2.reloadPromise;
                e2.reloadPromise = null, this.loadTile(e2).then(t3.resolve).catch(t3.reject);
              }
            }
            abortTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.actor && (yield e2.actor.sendAsync({ type: "AT", data: { uid: e2.uid, type: this.type, source: this.id } }));
              });
            }
            unloadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.unloadVectorData(), e2.actor && (yield e2.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } }));
              });
            }
            hasTransition() {
              return false;
            }
          }
          class H2 extends t.E {
            constructor(e2, i2, r2, o2) {
              super(), this.id = e2, this.dispatcher = r2, this.setEventedParent(o2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.e({ type: "raster" }, i2), t.e(this, t.O(i2, ["url", "scheme", "tileSize"]));
            }
            load() {
              return t._(this, arguments, void 0, function* (e2 = false) {
                this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
                try {
                  const i2 = yield G2(this._options, this.map._requestManager, this._tileJSONRequest);
                  this._tileJSONRequest = null, this._loaded = true, i2 && (t.e(this, i2), i2.bounds && (this.tileBounds = new q2(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e2 })));
                } catch (e3) {
                  this._tileJSONRequest = null, this.fire(new t.k(e3));
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
            }
            setSourceProperty(e2) {
              this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e2(), this.load(true);
            }
            setTiles(e2) {
              return this.setSourceProperty(() => {
                this._options.tiles = e2;
              }), this;
            }
            setUrl(e2) {
              return this.setSourceProperty(() => {
                this.url = e2, this._options.url = e2;
              }), this;
            }
            serialize() {
              return t.e({}, this._options);
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                const t2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                e2.abortController = new AbortController();
                try {
                  const i2 = yield p.getImage(this.map._requestManager.transformRequest(t2, "Tile"), e2.abortController, this.map._refreshExpiredTiles);
                  if (delete e2.abortController, e2.aborted) return void (e2.state = "unloaded");
                  if (i2 && i2.data) {
                    this.map._refreshExpiredTiles && (i2.cacheControl || i2.expires) && e2.setExpiryData({ cacheControl: i2.cacheControl, expires: i2.expires });
                    const t3 = this.map.painter.context, r2 = t3.gl, o2 = i2.data;
                    e2.texture = this.map.painter.getTileTexture(o2.width), e2.texture ? e2.texture.update(o2, { useMipmap: true }) : (e2.texture = new v(t3, o2, r2.RGBA, { useMipmap: true }), e2.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST)), e2.state = "loaded";
                  }
                } catch (t3) {
                  if (delete e2.abortController, e2.aborted) e2.state = "unloaded";
                  else if (t3) throw e2.state = "errored", t3;
                }
              });
            }
            abortTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.abortController && (e2.abortController.abort(), delete e2.abortController);
              });
            }
            unloadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.texture && this.map.painter.saveTileTexture(e2.texture);
              });
            }
            hasTransition() {
              return false;
            }
          }
          class $2 extends H2 {
            constructor(e2, i2, r2, o2) {
              super(e2, i2, r2, o2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
            }
            loadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                const i2 = e2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), r2 = this.map._requestManager.transformRequest(i2, "Tile");
                e2.neighboringTiles = this._getNeighboringTiles(e2.tileID), e2.abortController = new AbortController();
                try {
                  const i3 = yield p.getImage(r2, e2.abortController, this.map._refreshExpiredTiles);
                  if (delete e2.abortController, e2.aborted) return void (e2.state = "unloaded");
                  if (i3 && i3.data) {
                    const r3 = i3.data;
                    this.map._refreshExpiredTiles && (i3.cacheControl || i3.expires) && e2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                    const o2 = t.b(r3) && t.V() ? r3 : yield this.readImageNow(r3), a2 = { type: this.type, uid: e2.uid, source: this.id, rawImageData: o2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                    if (!e2.actor || "expired" === e2.state) {
                      e2.actor = this.dispatcher.getActor();
                      const t2 = yield e2.actor.sendAsync({ type: "LDT", data: a2 });
                      e2.dem = t2, e2.needsHillshadePrepare = true, e2.needsTerrainPrepare = true, e2.state = "loaded";
                    }
                  }
                } catch (t2) {
                  if (delete e2.abortController, e2.aborted) e2.state = "unloaded";
                  else if (t2) throw e2.state = "errored", t2;
                }
              });
            }
            readImageNow(e2) {
              return t._(this, void 0, void 0, function* () {
                if ("undefined" != typeof VideoFrame && t.W()) {
                  const i2 = e2.width + 2, r2 = e2.height + 2;
                  try {
                    return new t.R({ width: i2, height: r2 }, yield t.X(e2, -1, -1, i2, r2));
                  } catch (e3) {
                  }
                }
                return s.getImageData(e2, 1);
              });
            }
            _getNeighboringTiles(e2) {
              const i2 = e2.canonical, r2 = Math.pow(2, i2.z), o2 = (i2.x - 1 + r2) % r2, a2 = 0 === i2.x ? e2.wrap - 1 : e2.wrap, s2 = (i2.x + 1 + r2) % r2, n2 = i2.x + 1 === r2 ? e2.wrap + 1 : e2.wrap, l2 = {};
              return l2[new t.Y(e2.overscaledZ, a2, i2.z, o2, i2.y).key] = { backfilled: false }, l2[new t.Y(e2.overscaledZ, n2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.Y(e2.overscaledZ, a2, i2.z, o2, i2.y - 1).key] = { backfilled: false }, l2[new t.Y(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.Y(e2.overscaledZ, n2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < r2 && (l2[new t.Y(e2.overscaledZ, a2, i2.z, o2, i2.y + 1).key] = { backfilled: false }, l2[new t.Y(e2.overscaledZ, e2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.Y(e2.overscaledZ, n2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
            }
            unloadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded", e2.actor && (yield e2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e2.uid, source: this.id } }));
              });
            }
          }
          class X2 extends t.E {
            constructor(e2, i2, r2, o2) {
              super(), this.id = e2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = r2.getActor(), this.setEventedParent(o2), this._data = i2.data, this._options = t.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId, void 0 !== i2.clusterMaxZoom && this.maxzoom <= i2.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i2.clusterMaxZoom}".`), this.workerOptions = t.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(void 0 !== i2.buffer ? i2.buffer : 128), tolerance: this._pixelsToTileUnits(void 0 !== i2.tolerance ? i2.tolerance : 0.375), extent: t.Z, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.Z, radius: this._pixelsToTileUnits(i2.clusterRadius || 50), log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
            }
            _pixelsToTileUnits(e2) {
              return e2 * (t.Z / this.tileSize);
            }
            load() {
              return t._(this, void 0, void 0, function* () {
                yield this._updateWorkerData();
              });
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            setData(e2) {
              return this._data = e2, this._updateWorkerData(), this;
            }
            updateData(e2) {
              return this._updateWorkerData(e2), this;
            }
            getData() {
              return t._(this, void 0, void 0, function* () {
                const e2 = t.e({ type: this.type }, this.workerOptions);
                return this.actor.sendAsync({ type: "GD", data: e2 });
              });
            }
            getCoordinatesFromGeometry(e2) {
              return "GeometryCollection" === e2.type ? e2.geometries.map((e3) => e3.coordinates).flat(1 / 0) : e2.coordinates.flat(1 / 0);
            }
            getBounds() {
              return t._(this, void 0, void 0, function* () {
                const e2 = new V2(), t2 = yield this.getData();
                let i2;
                switch (t2.type) {
                  case "FeatureCollection":
                    i2 = t2.features.map((e3) => this.getCoordinatesFromGeometry(e3.geometry)).flat(1 / 0);
                    break;
                  case "Feature":
                    i2 = this.getCoordinatesFromGeometry(t2.geometry);
                    break;
                  default:
                    i2 = this.getCoordinatesFromGeometry(t2);
                }
                if (0 == i2.length) return e2;
                for (let t3 = 0; t3 < i2.length - 1; t3 += 2) e2.extend([i2[t3], i2[t3 + 1]]);
                return e2;
              });
            }
            setClusterOptions(e2) {
              return this.workerOptions.cluster = e2.cluster, e2 && (void 0 !== e2.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e2.clusterRadius)), void 0 !== e2.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = e2.clusterMaxZoom)), this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(e2) {
              return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e2, source: this.id } });
            }
            getClusterChildren(e2) {
              return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e2, source: this.id } });
            }
            getClusterLeaves(e2, t2, i2) {
              return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e2, limit: t2, offset: i2 } });
            }
            _updateWorkerData(e2) {
              return t._(this, void 0, void 0, function* () {
                const i2 = t.e({ type: this.type }, this.workerOptions);
                e2 ? i2.dataDiff = e2 : "string" == typeof this._data ? (i2.request = this.map._requestManager.transformRequest(s.resolveURL(this._data), "Source"), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t.l("dataloading", { dataType: "source" }));
                try {
                  const e3 = yield this.actor.sendAsync({ type: "LD", data: i2 });
                  if (this._pendingLoads--, this._removed || e3.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
                  let r2 = null;
                  e3.resourceTiming && e3.resourceTiming[this.id] && (r2 = e3.resourceTiming[this.id].slice(0));
                  const o2 = { dataType: "source" };
                  this._collectResourceTiming && r2 && r2.length > 0 && t.e(o2, { resourceTiming: r2 }), this.fire(new t.l("data", Object.assign(Object.assign({}, o2), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, o2), { sourceDataType: "content" })));
                } catch (e3) {
                  if (this._pendingLoads--, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
                  this.fire(new t.k(e3));
                }
              });
            }
            loaded() {
              return 0 === this._pendingLoads;
            }
            loadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                const t2 = e2.actor ? "RT" : "LT";
                e2.actor = this.actor;
                const i2 = { type: this.type, uid: e2.uid, tileID: e2.tileID, zoom: e2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
                e2.abortController = new AbortController();
                const r2 = yield this.actor.sendAsync({ type: t2, data: i2 }, e2.abortController);
                delete e2.abortController, e2.unloadVectorData(), e2.aborted || e2.loadVectorData(r2, this.map.painter, "RT" === t2);
              });
            }
            abortTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.abortController && (e2.abortController.abort(), delete e2.abortController), e2.aborted = true;
              });
            }
            unloadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                e2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e2.uid, type: this.type, source: this.id } });
              });
            }
            onRemove() {
              this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
            }
            serialize() {
              return t.e({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }
          class K2 extends t.E {
            constructor(e2, t2, i2, r2) {
              super(), this.flippedWindingOrder = false, this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = t2;
            }
            load(e2) {
              return t._(this, void 0, void 0, function* () {
                this._loaded = false, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
                try {
                  const t2 = yield p.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                  this._request = null, this._loaded = true, t2 && t2.data && (this.image = t2.data, e2 && (this.coordinates = e2), this._finishLoading());
                } catch (e3) {
                  this._request = null, this._loaded = true, this.fire(new t.k(e3));
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(e2) {
              return e2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e2.url, this.load(e2.coordinates).finally(() => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            onRemove() {
              this._request && (this._request.abort(), this._request = null);
            }
            setCoordinates(e2) {
              this.coordinates = e2;
              const i2 = e2.map(t.$.fromLngLat);
              var r2;
              return this.tileID = function(e3) {
                let i3 = 1 / 0, r3 = 1 / 0, o2 = -1 / 0, a2 = -1 / 0;
                for (const t2 of e3) i3 = Math.min(i3, t2.x), r3 = Math.min(r3, t2.y), o2 = Math.max(o2, t2.x), a2 = Math.max(a2, t2.y);
                const s2 = Math.max(o2 - i3, a2 - r3), n2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l2 = Math.pow(2, n2);
                return new t.a1(n2, Math.floor((i3 + o2) / 2 * l2), Math.floor((r3 + a2) / 2 * l2));
              }(i2), this.terrainTileRanges = this._getOverlappingTileRanges(i2), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i2.map((e3) => this.tileID.getTilePoint(e3)._round()), this.flippedWindingOrder = ((r2 = this.tileCoords)[1].x - r2[0].x) * (r2[2].y - r2[0].y) - (r2[1].y - r2[0].y) * (r2[2].x - r2[0].x) < 0, this.fire(new t.l("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || !this.image) return;
              const e2 = this.map.painter.context, i2 = e2.gl;
              this.texture || (this.texture = new v(e2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              let r2 = false;
              for (const e3 in this.tiles) {
                const t2 = this.tiles[e3];
                "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, r2 = true);
              }
              r2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }
            loadTile(e2) {
              return t._(this, void 0, void 0, function* () {
                this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}) : e2.state = "errored";
              });
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
            _getOverlappingTileRanges(e2) {
              let i2 = 1 / 0, r2 = 1 / 0, o2 = -1 / 0, a2 = -1 / 0;
              for (const t2 of e2) i2 = Math.min(i2, t2.x), r2 = Math.min(r2, t2.y), o2 = Math.max(o2, t2.x), a2 = Math.max(a2, t2.y);
              const s2 = {};
              for (let e3 = 0; e3 <= t.a0; e3++) {
                const t2 = Math.pow(2, e3), n2 = Math.floor(i2 * t2), l2 = Math.floor(r2 * t2), c2 = Math.floor(o2 * t2), h3 = Math.floor(a2 * t2);
                s2[e3] = { minTileX: n2, minTileY: l2, maxTileX: c2, maxTileY: h3 };
              }
              return s2;
            }
          }
          class Q2 extends K2 {
            constructor(e2, t2, i2, r2) {
              super(e2, t2, i2, r2), this.roundZoom = true, this.type = "video", this.options = t2;
            }
            load() {
              return t._(this, void 0, void 0, function* () {
                this._loaded = false;
                const e2 = this.options;
                this.urls = [];
                for (const t2 of e2.urls) this.urls.push(this.map._requestManager.transformRequest(t2, "Source").url);
                try {
                  const e3 = yield t.a2(this.urls);
                  if (this._loaded = true, !e3) return;
                  this.video = e3, this.video.loop = true, this.video.addEventListener("playing", () => {
                    this.map.triggerRepaint();
                  }), this.map && this.video.play(), this._finishLoading();
                } catch (e3) {
                  this.fire(new t.k(e3));
                }
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e2) {
              if (this.video) {
                const i2 = this.video.seekable;
                e2 < i2.start(0) || e2 > i2.end(0) ? this.fire(new t.k(new t.a3(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e2;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(e2) {
              this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
              const e2 = this.map.painter.context, i2 = e2.gl;
              this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new v(e2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              let r2 = false;
              for (const e3 in this.tiles) {
                const t2 = this.tiles[e3];
                "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, r2 = true);
              }
              r2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }
          class Y2 extends K2 {
            constructor(e2, i2, r2, o2) {
              super(e2, i2, r2, o2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e3) => !Array.isArray(e3) || 2 !== e3.length || e3.some((e4) => "number" != typeof e4)) || this.fire(new t.k(new t.a3(`sources.${e2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.k(new t.a3(`sources.${e2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new t.k(new t.a3(`sources.${e2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.a3(`sources.${e2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.k(new t.a3(`sources.${e2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
            }
            load() {
              return t._(this, void 0, void 0, function* () {
                this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                  this._playing = true, this.map.triggerRepaint();
                }, this.pause = function() {
                  this._playing && (this.prepare(), this._playing = false);
                }, this._finishLoading());
              });
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(e2) {
              this.map = e2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let e2 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e2 = true), this._hasInvalidDimensions()) return;
              if (0 === Object.keys(this.tiles).length) return;
              const i2 = this.map.painter.context, r2 = i2.gl;
              this.texture ? (e2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new v(i2, this.canvas, r2.RGBA, { premultiply: true });
              let o2 = false;
              for (const e3 in this.tiles) {
                const t2 = this.tiles[e3];
                "loaded" !== t2.state && (t2.state = "loaded", t2.texture = this.texture, o2 = true);
              }
              o2 && this.fire(new t.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const e2 of [this.canvas.width, this.canvas.height]) if (isNaN(e2) || e2 <= 0) return true;
              return false;
            }
          }
          const J2 = {}, ee2 = (e2) => {
            switch (e2) {
              case "geojson":
                return X2;
              case "image":
                return K2;
              case "raster":
                return H2;
              case "raster-dem":
                return $2;
              case "vector":
                return W2;
              case "video":
                return Q2;
              case "canvas":
                return Y2;
            }
            return J2[e2];
          }, te2 = "RTLPluginLoaded";
          class ie2 extends t.E {
            constructor() {
              super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = O2();
            }
            _syncState(e2) {
              return this.status = e2, this.dispatcher.broadcast("SRPS", { pluginStatus: e2, pluginURL: this.url }).catch((e3) => {
                throw this.status = "error", e3;
              });
            }
            getRTLTextPluginStatus() {
              return this.status;
            }
            clearRTLTextPlugin() {
              this.status = "unavailable", this.url = null;
            }
            setRTLTextPlugin(e2) {
              return t._(this, arguments, void 0, function* (e3, t2 = false) {
                if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                if (this.url = s.resolveURL(e3), !this.url) throw new Error(`requested url ${e3} is invalid`);
                if ("unavailable" === this.status) {
                  if (!t2) return this._requestImport();
                  this.status = "deferred", this._syncState(this.status);
                } else if ("requested" === this.status) return this._requestImport();
              });
            }
            _requestImport() {
              return t._(this, void 0, void 0, function* () {
                yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(te2));
              });
            }
            lazyLoad() {
              "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
            }
          }
          let re2 = null;
          function oe2() {
            return re2 || (re2 = new ie2()), re2;
          }
          class ae {
            constructor(e2, i2) {
              this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e2, this.uid = t.a4(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(e2) {
              const t2 = e2 + this.timeAdded;
              t2 < this.fadeEndTime || (this.fadeEndTime = t2);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            clearTextures(e2) {
              this.demTexture && e2.saveTileTexture(this.demTexture), this.demTexture = null;
            }
            loadVectorData(e2, i2, r2) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e2) {
                e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex, e2.rawTileData ? (this.latestRawTileData = e2.rawTileData, this.latestFeatureIndex.rawTileData = e2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e2.collisionBoxArray, this.buckets = function(e3, t2) {
                  const i3 = {};
                  if (!t2) return i3;
                  for (const r3 of e3) {
                    const e4 = r3.layerIds.map((e5) => t2.getLayer(e5)).filter(Boolean);
                    if (0 !== e4.length) {
                      r3.layers = e4, r3.stateDependentLayerIds && (r3.stateDependentLayers = r3.stateDependentLayerIds.map((t3) => e4.filter((e5) => e5.id === t3)[0]));
                      for (const t3 of e4) i3[t3.id] = r3;
                    }
                  }
                  return i3;
                }(e2.buckets, null == i2 ? void 0 : i2.style), this.hasSymbolBuckets = false;
                for (const e3 in this.buckets) {
                  const i3 = this.buckets[e3];
                  if (i3 instanceof t.a6) {
                    if (this.hasSymbolBuckets = true, !r2) break;
                    i3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e3 in this.buckets) {
                  const i3 = this.buckets[e3];
                  if (i3 instanceof t.a6 && i3.hasRTLText) {
                    this.hasRTLText = true, oe2().lazyLoad();
                    break;
                  }
                }
                this.queryPadding = 0;
                for (const e3 in this.buckets) {
                  const t2 = this.buckets[e3];
                  this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(e3).queryRadius(t2));
                }
                e2.imageAtlas && (this.imageAtlas = e2.imageAtlas), e2.glyphAtlasImage && (this.glyphAtlasImage = e2.glyphAtlasImage);
              } else this.collisionBoxArray = new t.a5();
            }
            unloadVectorData() {
              for (const e2 in this.buckets) this.buckets[e2].destroy();
              this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(e2) {
              return this.buckets[e2.id];
            }
            upload(e2) {
              for (const t3 in this.buckets) {
                const i2 = this.buckets[t3];
                i2.uploadPending() && i2.upload(e2);
              }
              const t2 = e2.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new v(e2, this.imageAtlas.image, t2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new v(e2, this.glyphAtlasImage, t2.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(e2) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture);
            }
            queryRenderedFeatures(e2, t2, i2, r2, o2, a2, s2, n2, l2, c2, h3) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r2, cameraQueryGeometry: o2, scale: a2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: s2, queryPadding: this.queryPadding * l2, getElevation: h3 }, e2, t2, i2) : {};
            }
            querySourceFeatures(e2, i2) {
              const r2 = this.latestFeatureIndex;
              if (!r2 || !r2.rawTileData) return;
              const o2 = r2.loadVTLayers(), a2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", s2 = o2._geojsonTileLayer || o2[a2];
              if (!s2) return;
              const n2 = t.a7(i2 && i2.filter), { z: l2, x: c2, y: h3 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h3 };
              for (let i3 = 0; i3 < s2.length; i3++) {
                const o3 = s2.feature(i3);
                if (n2.needGeometry) {
                  const e3 = t.a8(o3, true);
                  if (!n2.filter(new t.C(this.tileID.overscaledZ), e3, this.tileID.canonical)) continue;
                } else if (!n2.filter(new t.C(this.tileID.overscaledZ), o3)) continue;
                const d2 = r2.getId(o3, a2), _3 = new t.a9(o3, l2, c2, h3, d2);
                _3.tile = u2, e2.push(_3);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e2) {
              const i2 = this.expirationTime;
              if (e2.cacheControl) {
                const i3 = t.aa(e2.cacheControl);
                i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
              } else e2.expires && (this.expirationTime = new Date(e2.expires).getTime());
              if (this.expirationTime) {
                const e3 = Date.now();
                let t2 = false;
                if (this.expirationTime > e3) t2 = false;
                else if (i2) if (this.expirationTime < i2) t2 = true;
                else {
                  const r2 = this.expirationTime - i2;
                  r2 ? this.expirationTime = e3 + Math.max(r2, 3e4) : t2 = true;
                }
                else t2 = true;
                t2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(e2, t2) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e2).length) return;
              const i2 = this.latestFeatureIndex.loadVTLayers();
              for (const r2 in this.buckets) {
                if (!t2.style.hasLayer(r2)) continue;
                const o2 = this.buckets[r2], a2 = o2.layers[0].sourceLayer || "_geojsonTileLayer", s2 = i2[a2], n2 = e2[a2];
                if (!s2 || !n2 || 0 === Object.keys(n2).length) continue;
                o2.update(n2, s2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l2 = t2 && t2.style && t2.style.getLayer(r2);
                l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(o2)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e2) {
              this.symbolFadeHoldUntil = s.now() + e2;
            }
            setDependencies(e2, t2) {
              const i2 = {};
              for (const e3 of t2) i2[e3] = true;
              this.dependencies[e2] = i2;
            }
            hasDependency(e2, t2) {
              for (const i2 of e2) {
                const e3 = this.dependencies[i2];
                if (e3) {
                  for (const i3 of t2) if (e3[i3]) return true;
                }
              }
              return false;
            }
          }
          class se2 {
            constructor(e2, t2) {
              this.max = e2, this.onRemove = t2, this.reset();
            }
            reset() {
              for (const e2 in this.data) for (const t2 of this.data[e2]) t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
              return this.data = {}, this.order = [], this;
            }
            add(e2, t2, i2) {
              const r2 = e2.wrapped().key;
              void 0 === this.data[r2] && (this.data[r2] = []);
              const o2 = { value: t2, timeout: void 0 };
              if (void 0 !== i2 && (o2.timeout = setTimeout(() => {
                this.remove(e2, o2);
              }, i2)), this.data[r2].push(o2), this.order.push(r2), this.order.length > this.max) {
                const e3 = this._getAndRemoveByKey(this.order[0]);
                e3 && this.onRemove(e3);
              }
              return this;
            }
            has(e2) {
              return e2.wrapped().key in this.data;
            }
            getAndRemove(e2) {
              return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
            }
            _getAndRemoveByKey(e2) {
              const t2 = this.data[e2].shift();
              return t2.timeout && clearTimeout(t2.timeout), 0 === this.data[e2].length && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
            }
            getByKey(e2) {
              const t2 = this.data[e2];
              return t2 ? t2[0].value : null;
            }
            get(e2) {
              return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
            }
            remove(e2, t2) {
              if (!this.has(e2)) return this;
              const i2 = e2.wrapped().key, r2 = void 0 === t2 ? 0 : this.data[i2].indexOf(t2), o2 = this.data[i2][r2];
              return this.data[i2].splice(r2, 1), o2.timeout && clearTimeout(o2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(o2.value), this.order.splice(this.order.indexOf(i2), 1), this;
            }
            setMaxSize(e2) {
              for (this.max = e2; this.order.length > this.max; ) {
                const e3 = this._getAndRemoveByKey(this.order[0]);
                e3 && this.onRemove(e3);
              }
              return this;
            }
            filter(e2) {
              const t2 = [];
              for (const i2 in this.data) for (const r2 of this.data[i2]) e2(r2.value) || t2.push(r2);
              for (const e3 of t2) this.remove(e3.value.tileID, e3);
            }
          }
          class ne2 {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e2, i2, r2) {
              const o2 = String(i2);
              if (this.stateChanges[e2] = this.stateChanges[e2] || {}, this.stateChanges[e2][o2] = this.stateChanges[e2][o2] || {}, t.e(this.stateChanges[e2][o2], r2), null === this.deletedStates[e2]) {
                this.deletedStates[e2] = {};
                for (const t2 in this.state[e2]) t2 !== o2 && (this.deletedStates[e2][t2] = null);
              } else if (this.deletedStates[e2] && null === this.deletedStates[e2][o2]) {
                this.deletedStates[e2][o2] = {};
                for (const t2 in this.state[e2][o2]) r2[t2] || (this.deletedStates[e2][o2][t2] = null);
              } else for (const t2 in r2) this.deletedStates[e2] && this.deletedStates[e2][o2] && null === this.deletedStates[e2][o2][t2] && delete this.deletedStates[e2][o2][t2];
            }
            removeFeatureState(e2, t2, i2) {
              if (null === this.deletedStates[e2]) return;
              const r2 = String(t2);
              if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2) null !== this.deletedStates[e2][r2] && (this.deletedStates[e2][r2] = this.deletedStates[e2][r2] || {}, this.deletedStates[e2][r2][i2] = null);
              else if (void 0 !== t2) if (this.stateChanges[e2] && this.stateChanges[e2][r2]) for (i2 in this.deletedStates[e2][r2] = {}, this.stateChanges[e2][r2]) this.deletedStates[e2][r2][i2] = null;
              else this.deletedStates[e2][r2] = null;
              else this.deletedStates[e2] = null;
            }
            getState(e2, i2) {
              const r2 = String(i2), o2 = t.e({}, (this.state[e2] || {})[r2], (this.stateChanges[e2] || {})[r2]);
              if (null === this.deletedStates[e2]) return {};
              if (this.deletedStates[e2]) {
                const t2 = this.deletedStates[e2][i2];
                if (null === t2) return {};
                for (const e3 in t2) delete o2[e3];
              }
              return o2;
            }
            initializeTileState(e2, t2) {
              e2.setFeatureState(this.state, t2);
            }
            coalesceChanges(e2, i2) {
              const r2 = {};
              for (const e3 in this.stateChanges) {
                this.state[e3] = this.state[e3] || {};
                const i3 = {};
                for (const r3 in this.stateChanges[e3]) this.state[e3][r3] || (this.state[e3][r3] = {}), t.e(this.state[e3][r3], this.stateChanges[e3][r3]), i3[r3] = this.state[e3][r3];
                r2[e3] = i3;
              }
              for (const e3 in this.deletedStates) {
                this.state[e3] = this.state[e3] || {};
                const i3 = {};
                if (null === this.deletedStates[e3]) for (const t2 in this.state[e3]) i3[t2] = {}, this.state[e3][t2] = {};
                else for (const t2 in this.deletedStates[e3]) {
                  if (null === this.deletedStates[e3][t2]) this.state[e3][t2] = {};
                  else for (const i4 of Object.keys(this.deletedStates[e3][t2])) delete this.state[e3][t2][i4];
                  i3[t2] = this.state[e3][t2];
                }
                r2[e3] = r2[e3] || {}, t.e(r2[e3], i3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length) for (const t2 in e2) e2[t2].setFeatureState(r2, i2);
            }
          }
          const le2 = 89.25;
          function ce2(e2, i2) {
            const r2 = t.ae(i2.lat, -85.051129, t.af);
            return new t.P(t.U(i2.lng) * e2, t.S(r2) * e2);
          }
          function he2(e2, i2) {
            return new t.$(i2.x / e2, i2.y / e2).toLngLat();
          }
          function ue2(e2) {
            return e2.cameraToCenterDistance * Math.min(0.85 * Math.tan(t.ab(90 - e2.pitch)), Math.tan(t.ab(le2 - e2.pitch)));
          }
          function de2(e2, i2) {
            const r2 = e2.canonical, o2 = i2 / t.ac(r2.z), a2 = r2.x + Math.pow(2, r2.z) * e2.wrap, s2 = t.ad(new Float64Array(16));
            return t.L(s2, s2, [a2 * o2, r2.y * o2, 0]), t.M(s2, s2, [o2 / t.Z, o2 / t.Z, 1]), s2;
          }
          function _e2(e2, i2, r2, o2, a2) {
            const s2 = t.$.fromLngLat(e2, i2), n2 = a2 * t.ag(1, e2.lat), l2 = n2 * Math.cos(t.ab(r2)), c2 = Math.sqrt(n2 * n2 - l2 * l2), h3 = c2 * Math.sin(t.ab(-o2)), u2 = c2 * Math.cos(t.ab(-o2));
            return new t.$(s2.x + h3, s2.y + u2, s2.z + l2);
          }
          function pe2(e2, t2, i2) {
            const r2 = t2.intersectsFrustum(e2);
            if (!i2) return r2;
            const o2 = t2.intersectsPlane(i2);
            return 0 === r2 || 0 === o2 ? 0 : 2 === r2 && 2 === o2 ? 2 : 1;
          }
          function me2(e2, t2, i2) {
            let r2 = 0;
            const o2 = (i2 - t2) / 10;
            for (let a2 = 0; a2 < 10; a2++) r2 += o2 * Math.pow(Math.cos(t2 + (a2 + 0.5) / 10 * (i2 - t2)), e2);
            return r2;
          }
          function fe2(e2, i2) {
            return function(r2, o2, a2, s2, n2) {
              const l2 = 2 * ((e2 - 1) / t.ah(Math.cos(t.ab(le2 - n2)) / Math.cos(t.ab(le2))) - 1), c2 = Math.acos(a2 / s2), h3 = 2 * me2(l2 - 1, 0, t.ab(n2 / 2)), u2 = Math.min(t.ab(le2), c2 + t.ab(n2 / 2)), d2 = me2(l2 - 1, Math.min(u2, c2 - t.ab(n2 / 2)), u2), _3 = Math.atan(o2 / a2), p2 = Math.hypot(o2, a2);
              let m2 = r2;
              return m2 += t.ah(s2 / p2 / Math.max(0.5, Math.cos(t.ab(n2 / 2)))), m2 += l2 * t.ah(Math.cos(_3)) / 2, m2 -= t.ah(Math.max(1, d2 / h3 / i2)) / 2, m2;
            };
          }
          const ge2 = fe2(9.314, 3);
          function ve2(e2, i2) {
            const r2 = (i2.roundZoom ? Math.round : Math.floor)(e2.zoom + t.ah(e2.tileSize / i2.tileSize));
            return Math.max(0, r2);
          }
          function xe2(e2, i2) {
            const r2 = e2.getCameraFrustum(), o2 = e2.getClippingPlane(), a2 = e2.screenPointToMercatorCoordinate(e2.getCameraPoint()), s2 = t.$.fromLngLat(e2.center, e2.elevation);
            a2.z = s2.z + Math.cos(e2.pitchInRadians) * e2.cameraToCenterDistance / e2.worldSize;
            const n2 = e2.getCoveringTilesDetailsProvider(), l2 = n2.allowVariableZoom(e2, i2), c2 = ve2(e2, i2), h3 = i2.minzoom || 0, u2 = void 0 !== i2.maxzoom ? i2.maxzoom : e2.maxZoom, d2 = Math.min(Math.max(0, c2), u2), _3 = Math.pow(2, d2), p2 = [_3 * a2.x, _3 * a2.y, 0], m2 = [_3 * s2.x, _3 * s2.y, 0], f2 = Math.hypot(s2.x - a2.x, s2.y - a2.y), g3 = Math.abs(s2.z - a2.z), v2 = Math.hypot(f2, g3), x3 = (e3) => ({ zoom: 0, x: 0, y: 0, wrap: e3, fullyVisible: false }), b2 = [], y2 = [];
            if (e2.renderWorldCopies && n2.allowWorldCopies()) for (let e3 = 1; e3 <= 3; e3++) b2.push(x3(-e3)), b2.push(x3(e3));
            for (b2.push(x3(0)); b2.length > 0; ) {
              const _4 = b2.pop(), f3 = _4.x, x4 = _4.y;
              let w2 = _4.fullyVisible;
              const T2 = { x: f3, y: x4, z: _4.zoom }, P2 = n2.getTileAABB(T2, _4.wrap, e2.elevation, i2);
              if (!w2) {
                const e3 = pe2(r2, P2, o2);
                if (0 === e3) continue;
                w2 = 2 === e3;
              }
              const C3 = n2.distanceToTile2d(a2.x, a2.y, T2, P2);
              let M3 = c2;
              l2 && (M3 = (i2.calculateTileZoom || ge2)(e2.zoom + t.ah(e2.tileSize / i2.tileSize), C3, g3, v2, e2.fov)), M3 = (i2.roundZoom ? Math.round : Math.floor)(M3), M3 = Math.max(0, M3);
              const I3 = Math.min(M3, u2);
              if (_4.wrap = n2.getWrap(s2, T2, _4.wrap), _4.zoom >= I3) {
                if (_4.zoom < h3) continue;
                const e3 = d2 - _4.zoom, r3 = p2[0] - 0.5 - (f3 << e3), o3 = p2[1] - 0.5 - (x4 << e3), a3 = i2.reparseOverscaled ? Math.max(_4.zoom, M3) : _4.zoom;
                y2.push({ tileID: new t.Y(_4.zoom === u2 ? a3 : _4.zoom, _4.wrap, _4.zoom, f3, x4), distanceSq: t.ai([m2[0] - 0.5 - f3, m2[1] - 0.5 - x4]), tileDistanceToCamera: Math.sqrt(r3 * r3 + o3 * o3) });
              } else for (let e3 = 0; e3 < 4; e3++) b2.push({ zoom: _4.zoom + 1, x: (f3 << 1) + e3 % 2, y: (x4 << 1) + (e3 >> 1), wrap: _4.wrap, fullyVisible: w2 });
            }
            return y2.sort((e3, t2) => e3.distanceSq - t2.distanceSq).map((e3) => e3.tileID);
          }
          class be extends t.E {
            constructor(e2, t2, i2) {
              super(), this.id = e2, this.dispatcher = i2, this.on("data", (e3) => this._dataHandler(e3)), this.on("dataloading", () => {
                this._sourceErrored = false;
              }), this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }), this._source = ((e3, t3, i3, r2) => {
                const o2 = new (ee2(t3.type))(e3, t3, i3, r2);
                if (o2.id !== e3) throw new Error(`Expected Source id to be ${e3} instead of ${o2.id}`);
                return o2;
              })(e2, t2, i2, this), this._tiles = {}, this._cache = new se2(0, (e3) => this._unloadTile(e3)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ne2(), this._didEmitContent = false, this._updated = false;
            }
            onAdd(e2) {
              this.map = e2, this._maxTileCacheSize = e2 ? e2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e2 ? e2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e2);
            }
            onRemove(e2) {
              this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e2);
            }
            loaded() {
              if (this._sourceErrored) return true;
              if (!this._sourceLoaded) return false;
              if (!this._source.loaded()) return false;
              if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
              if (!this._updated) return false;
              for (const e2 in this._tiles) {
                const t2 = this._tiles[e2];
                if ("loaded" !== t2.state && "errored" !== t2.state) return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused) return;
              const e2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(e2, i2, r2) {
              return t._(this, void 0, void 0, function* () {
                try {
                  yield this._source.loadTile(e2), this._tileLoaded(e2, i2, r2);
                } catch (i3) {
                  e2.state = "errored", 404 !== i3.status ? this._source.fire(new t.k(i3, { tile: e2 })) : this.update(this.transform, this.terrain);
                }
              });
            }
            _unloadTile(e2) {
              this._source.unloadTile && this._source.unloadTile(e2);
            }
            _abortTile(e2) {
              this._source.abortTile && this._source.abortTile(e2), this._source.fire(new t.l("dataabort", { tile: e2, coord: e2.tileID, dataType: "source" }));
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(e2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const t2 in this._tiles) {
                const i2 = this._tiles[t2];
                i2.upload(e2), i2.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((e2) => e2.tileID).sort(ye2).map((e2) => e2.key);
            }
            getRenderableIds(e2) {
              const i2 = [];
              for (const t2 in this._tiles) this._isIdRenderable(t2, e2) && i2.push(this._tiles[t2]);
              return e2 ? i2.sort((e3, i3) => {
                const r2 = e3.tileID, o2 = i3.tileID, a2 = new t.P(r2.canonical.x, r2.canonical.y)._rotate(-this.transform.bearingInRadians), s2 = new t.P(o2.canonical.x, o2.canonical.y)._rotate(-this.transform.bearingInRadians);
                return r2.overscaledZ - o2.overscaledZ || s2.y - a2.y || s2.x - a2.x;
              }).map((e3) => e3.tileID.key) : i2.map((e3) => e3.tileID).sort(ye2).map((e3) => e3.key);
            }
            hasRenderableParent(e2) {
              const t2 = this.findLoadedParent(e2, 0);
              return !!t2 && this._isIdRenderable(t2.tileID.key);
            }
            _isIdRenderable(e2, t2) {
              return this._tiles[e2] && this._tiles[e2].hasData() && !this._coveredTiles[e2] && (t2 || !this._tiles[e2].holdingForFade());
            }
            reload(e2) {
              if (this._paused) this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t2 in this._tiles) (e2 || "errored" !== this._tiles[t2].state) && this._reloadTile(t2, "reloading");
              }
            }
            _reloadTile(e2, i2) {
              return t._(this, void 0, void 0, function* () {
                const t2 = this._tiles[e2];
                t2 && ("loading" !== t2.state && (t2.state = i2), yield this._loadTile(t2, e2, i2));
              });
            }
            _tileLoaded(e2, i2, r2) {
              e2.timeAdded = s.now(), "expired" === r2 && (e2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e2), "raster-dem" === this.getSource().type && e2.dem && this._backfillDEM(e2), this._state.initializeTileState(e2, this.map ? this.map.painter : null), e2.aborted || this._source.fire(new t.l("data", { dataType: "source", tile: e2, coord: e2.tileID }));
            }
            _backfillDEM(e2) {
              const t2 = this.getRenderableIds();
              for (let r2 = 0; r2 < t2.length; r2++) {
                const o2 = t2[r2];
                if (e2.neighboringTiles && e2.neighboringTiles[o2]) {
                  const t3 = this.getTileByID(o2);
                  i2(e2, t3), i2(t3, e2);
                }
              }
              function i2(e3, t3) {
                e3.needsHillshadePrepare = true, e3.needsTerrainPrepare = true;
                let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
                const r2 = t3.tileID.canonical.y - e3.tileID.canonical.y, o2 = Math.pow(2, e3.tileID.canonical.z), a2 = t3.tileID.key;
                0 === i3 && 0 === r2 || Math.abs(r2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + o2) ? i3 += o2 : 1 === Math.abs(i3 - o2) && (i3 -= o2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, r2), e3.neighboringTiles && e3.neighboringTiles[a2] && (e3.neighboringTiles[a2].backfilled = true)));
              }
            }
            getTile(e2) {
              return this.getTileByID(e2.key);
            }
            getTileByID(e2) {
              return this._tiles[e2];
            }
            _retainLoadedChildren(e2, t2, i2, r2) {
              for (const o2 in this._tiles) {
                let a2 = this._tiles[o2];
                if (r2[o2] || !a2.hasData() || a2.tileID.overscaledZ <= t2 || a2.tileID.overscaledZ > i2) continue;
                let s2 = a2.tileID;
                for (; a2 && a2.tileID.overscaledZ > t2 + 1; ) {
                  const e3 = a2.tileID.scaledTo(a2.tileID.overscaledZ - 1);
                  a2 = this._tiles[e3.key], a2 && a2.hasData() && (s2 = e3);
                }
                let n2 = s2;
                for (; n2.overscaledZ > t2; ) if (n2 = n2.scaledTo(n2.overscaledZ - 1), e2[n2.key] || e2[n2.canonical.key]) {
                  r2[s2.key] = s2;
                  break;
                }
              }
            }
            findLoadedParent(e2, t2) {
              if (e2.key in this._loadedParentTiles) {
                const i2 = this._loadedParentTiles[e2.key];
                return i2 && i2.tileID.overscaledZ >= t2 ? i2 : null;
              }
              for (let i2 = e2.overscaledZ - 1; i2 >= t2; i2--) {
                const t3 = e2.scaledTo(i2), r2 = this._getLoadedTile(t3);
                if (r2) return r2;
              }
            }
            findLoadedSibling(e2) {
              return this._getLoadedTile(e2);
            }
            _getLoadedTile(e2) {
              const t2 = this._tiles[e2.key];
              return t2 && t2.hasData() ? t2 : this._cache.getByKey(e2.wrapped().key);
            }
            updateCacheSize(e2) {
              const i2 = Math.ceil(e2.width / this._source.tileSize) + 1, r2 = Math.ceil(e2.height / this._source.tileSize) + 1, o2 = Math.floor(i2 * r2 * (null === this._maxTileCacheZoomLevels ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
              this._cache.setMaxSize(a2);
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
              if (this._prevLng = e2, t2) {
                const e3 = {};
                for (const i2 in this._tiles) {
                  const r2 = this._tiles[i2];
                  r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), e3[r2.tileID.key] = r2;
                }
                this._tiles = e3;
                for (const e4 in this._timers) clearTimeout(this._timers[e4]), delete this._timers[e4];
                for (const e4 in this._tiles) this._setTileReloadTimer(e4, this._tiles[e4]);
              }
            }
            _updateCoveredAndRetainedTiles(e2, t2, i2, r2, o2, a2) {
              const n2 = {}, l2 = {}, c2 = Object.keys(e2), h3 = s.now();
              for (const i3 of c2) {
                const r3 = e2[i3], o3 = this._tiles[i3];
                if (!o3 || 0 !== o3.fadeEndTime && o3.fadeEndTime <= h3) continue;
                const a3 = this.findLoadedParent(r3, t2), s2 = this.findLoadedSibling(r3), c3 = a3 || s2 || null;
                c3 && (this._addTile(c3.tileID), n2[c3.tileID.key] = c3.tileID), l2[i3] = r3;
              }
              this._retainLoadedChildren(l2, r2, i2, e2);
              for (const t3 in n2) e2[t3] || (this._coveredTiles[t3] = true, e2[t3] = n2[t3]);
              if (a2) {
                const t3 = {}, i3 = {};
                for (const e3 of o2) this._tiles[e3.key].hasData() ? t3[e3.key] = e3 : i3[e3.key] = e3;
                for (const r3 in i3) {
                  const o3 = i3[r3].children(this._source.maxzoom);
                  this._tiles[o3[0].key] && this._tiles[o3[1].key] && this._tiles[o3[2].key] && this._tiles[o3[3].key] && (t3[o3[0].key] = e2[o3[0].key] = o3[0], t3[o3[1].key] = e2[o3[1].key] = o3[1], t3[o3[2].key] = e2[o3[2].key] = o3[2], t3[o3[3].key] = e2[o3[3].key] = o3[3], delete i3[r3]);
                }
                for (const r3 in i3) {
                  const o3 = i3[r3], a3 = this.findLoadedParent(o3, this._source.minzoom), s2 = this.findLoadedSibling(o3), n3 = a3 || s2 || null;
                  if (n3) {
                    t3[n3.tileID.key] = e2[n3.tileID.key] = n3.tileID;
                    for (const e3 in t3) t3[e3].isChildOf(n3.tileID) && delete t3[e3];
                  }
                }
                for (const e3 in this._tiles) t3[e3] || (this._coveredTiles[e3] = true);
              }
            }
            update(e2, i2) {
              if (!this._sourceLoaded || this._paused) return;
              let r2;
              this.transform = e2, this.terrain = i2, this.updateCacheSize(e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? r2 = e2.getVisibleUnwrappedCoordinates(this._source.tileID).map((e3) => new t.Y(e3.canonical.z, e3.wrap, e3.canonical.z, e3.canonical.x, e3.canonical.y)) : (r2 = xe2(e2, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (r2 = r2.filter((e3) => this._source.hasTile(e3)))) : r2 = [];
              const o2 = ve2(e2, this._source), a2 = Math.max(o2 - be.maxOverzooming, this._source.minzoom), s2 = Math.max(o2 + be.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                const e3 = {};
                for (const t2 of r2) if (t2.canonical.z > this._source.minzoom) {
                  const i3 = t2.scaledTo(t2.canonical.z - 1);
                  e3[i3.key] = i3;
                  const r3 = t2.scaledTo(Math.max(this._source.minzoom, Math.min(t2.canonical.z, 5)));
                  e3[r3.key] = r3;
                }
                r2 = r2.concat(Object.values(e3));
              }
              const n2 = 0 === r2.length && !this._updated && this._didEmitContent;
              this._updated = true, n2 && this.fire(new t.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
              const l2 = this._updateRetainedTiles(r2, o2);
              we2(this._source.type) && this._updateCoveredAndRetainedTiles(l2, a2, s2, o2, r2, i2);
              for (const e3 in l2) this._tiles[e3].clearFadeHold();
              const c2 = t.aj(this._tiles, l2);
              for (const e3 of c2) {
                const t2 = this._tiles[e3];
                t2.hasSymbolBuckets && !t2.holdingForFade() ? t2.setHoldDuration(this.map._fadeDuration) : t2.hasSymbolBuckets && !t2.symbolFadeFinished() || this._removeTile(e3);
              }
              this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
            }
            releaseSymbolFadeTiles() {
              for (const e2 in this._tiles) this._tiles[e2].holdingForFade() && this._removeTile(e2);
            }
            _updateRetainedTiles(e2, t2) {
              var i2;
              const r2 = {}, o2 = {}, a2 = Math.max(t2 - be.maxOverzooming, this._source.minzoom), s2 = Math.max(t2 + be.maxUnderzooming, this._source.minzoom), n2 = {};
              for (const i3 of e2) {
                const e3 = this._addTile(i3);
                r2[i3.key] = i3, e3.hasData() || t2 < this._source.maxzoom && (n2[i3.key] = i3);
              }
              this._retainLoadedChildren(n2, t2, s2, r2);
              for (const s3 of e2) {
                let e3 = this._tiles[s3.key];
                if (e3.hasData()) continue;
                if (t2 + 1 > this._source.maxzoom) {
                  const e4 = s3.children(this._source.maxzoom)[0], t3 = this.getTile(e4);
                  if (t3 && t3.hasData()) {
                    r2[e4.key] = e4;
                    continue;
                  }
                } else {
                  const e4 = s3.children(this._source.maxzoom);
                  if (r2[e4[0].key] && r2[e4[1].key] && r2[e4[2].key] && r2[e4[3].key]) continue;
                }
                let n3 = e3.wasRequested();
                for (let t3 = s3.overscaledZ - 1; t3 >= a2; --t3) {
                  const a3 = s3.scaledTo(t3);
                  if (o2[a3.key]) break;
                  if (o2[a3.key] = true, e3 = this.getTile(a3), !e3 && n3 && (e3 = this._addTile(a3)), e3) {
                    const t4 = e3.hasData();
                    if ((t4 || !(null === (i2 = this.map) || void 0 === i2 ? void 0 : i2.cancelPendingTileRequestsWhileZooming) || n3) && (r2[a3.key] = a3), n3 = e3.wasRequested(), t4) break;
                  }
                }
              }
              return r2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const e2 in this._tiles) {
                const t2 = [];
                let i2, r2 = this._tiles[e2].tileID;
                for (; r2.overscaledZ > 0; ) {
                  if (r2.key in this._loadedParentTiles) {
                    i2 = this._loadedParentTiles[r2.key];
                    break;
                  }
                  t2.push(r2.key);
                  const e3 = r2.scaledTo(r2.overscaledZ - 1);
                  if (i2 = this._getLoadedTile(e3), i2) break;
                  r2 = e3;
                }
                for (const e3 of t2) this._loadedParentTiles[e3] = i2;
              }
            }
            _updateLoadedSiblingTileCache() {
              this._loadedSiblingTiles = {};
              for (const e2 in this._tiles) {
                const t2 = this._tiles[e2].tileID, i2 = this._getLoadedTile(t2);
                this._loadedSiblingTiles[t2.key] = i2;
              }
            }
            _addTile(e2) {
              let i2 = this._tiles[e2.key];
              if (i2) return i2;
              i2 = this._cache.getAndRemove(e2), i2 && (this._setTileReloadTimer(e2.key, i2), i2.tileID = e2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[e2.key] && (clearTimeout(this._cacheTimers[e2.key]), delete this._cacheTimers[e2.key], this._setTileReloadTimer(e2.key, i2)));
              const r2 = i2;
              return i2 || (i2 = new ae(e2, this._source.tileSize * e2.overscaleFactor()), this._loadTile(i2, e2.key, i2.state)), i2.uses++, this._tiles[e2.key] = i2, r2 || this._source.fire(new t.l("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
            }
            _setTileReloadTimer(e2, t2) {
              e2 in this._timers && (clearTimeout(this._timers[e2]), delete this._timers[e2]);
              const i2 = t2.getExpiryTimeout();
              i2 && (this._timers[e2] = setTimeout(() => {
                this._reloadTile(e2, "expired"), delete this._timers[e2];
              }, i2));
            }
            refreshTiles(e2) {
              for (const t2 in this._tiles) this._isIdRenderable(t2) && e2.some((e3) => e3.equals(this._tiles[t2].tileID.canonical)) && this._reloadTile(t2, "expired");
            }
            _removeTile(e2) {
              const t2 = this._tiles[e2];
              t2 && (t2.uses--, delete this._tiles[e2], this._timers[e2] && (clearTimeout(this._timers[e2]), delete this._timers[e2]), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
            }
            _dataHandler(e2) {
              const t2 = e2.sourceDataType;
              "source" === e2.dataType && "metadata" === t2 && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e2.dataType && "content" === t2 && (this.reload(e2.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const e2 in this._tiles) this._removeTile(e2);
              this._cache.reset();
            }
            tilesIn(e2, i2, r2) {
              const o2 = [], a2 = this.transform;
              if (!a2) return o2;
              const s2 = r2 ? a2.getCameraQueryGeometry(e2) : e2, n2 = e2.map((e3) => a2.screenPointToMercatorCoordinate(e3, this.terrain)), l2 = s2.map((e3) => a2.screenPointToMercatorCoordinate(e3, this.terrain)), c2 = this.getIds();
              let h3 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _3 = -1 / 0;
              for (const e3 of l2) h3 = Math.min(h3, e3.x), u2 = Math.min(u2, e3.y), d2 = Math.max(d2, e3.x), _3 = Math.max(_3, e3.y);
              for (let e3 = 0; e3 < c2.length; e3++) {
                const r3 = this._tiles[c2[e3]];
                if (r3.holdingForFade()) continue;
                const s3 = a2.getCoveringTilesDetailsProvider().allowWorldCopies() ? r3.tileID : r3.tileID.unwrapTo(0), p2 = Math.pow(2, a2.zoom - r3.tileID.overscaledZ), m2 = i2 * r3.queryPadding * t.Z / r3.tileSize / p2, f2 = [s3.getTilePoint(new t.$(h3, u2)), s3.getTilePoint(new t.$(d2, _3))];
                if (f2[0].x - m2 < t.Z && f2[0].y - m2 < t.Z && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
                  const e4 = n2.map((e5) => s3.getTilePoint(e5)), t2 = l2.map((e5) => s3.getTilePoint(e5));
                  o2.push({ tile: r3, tileID: s3, queryGeometry: e4, cameraQueryGeometry: t2, scale: p2 });
                }
              }
              return o2;
            }
            getVisibleCoordinates(e2) {
              const t2 = this.getRenderableIds(e2).map((e3) => this._tiles[e3].tileID);
              return this.transform && this.transform.populateCache(t2), t2;
            }
            hasTransition() {
              if (this._source.hasTransition()) return true;
              if (we2(this._source.type)) {
                const e2 = s.now();
                for (const t2 in this._tiles) if (this._tiles[t2].fadeEndTime >= e2) return true;
              }
              return false;
            }
            setFeatureState(e2, t2, i2) {
              this._state.updateState(e2 = e2 || "_geojsonTileLayer", t2, i2);
            }
            removeFeatureState(e2, t2, i2) {
              this._state.removeFeatureState(e2 = e2 || "_geojsonTileLayer", t2, i2);
            }
            getFeatureState(e2, t2) {
              return this._state.getState(e2 = e2 || "_geojsonTileLayer", t2);
            }
            setDependencies(e2, t2, i2) {
              const r2 = this._tiles[e2];
              r2 && r2.setDependencies(t2, i2);
            }
            reloadTilesForDependencies(e2, t2) {
              for (const i2 in this._tiles) this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(i2, "reloading");
              this._cache.filter((i2) => !i2.hasDependency(e2, t2));
            }
          }
          function ye2(e2, t2) {
            const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
            return e2.overscaledZ - t2.overscaledZ || r2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
          }
          function we2(e2) {
            return "raster" === e2 || "image" === e2 || "video" === e2;
          }
          be.maxOverzooming = 10, be.maxUnderzooming = 3;
          class Te2 {
            constructor(e2, t2) {
              this.reset(e2, t2);
            }
            reset(e2, t2) {
              this.points = e2 || [], this._distances = [0];
              for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e2) {
              if (1 === this.points.length) return this.points[0];
              e2 = t.ae(e2, 0, 1);
              let i2 = 1, r2 = this._distances[i2];
              const o2 = e2 * this.paddedLength + this.padding;
              for (; r2 < o2 && i2 < this._distances.length; ) r2 = this._distances[++i2];
              const a2 = i2 - 1, s2 = this._distances[a2], n2 = r2 - s2, l2 = n2 > 0 ? (o2 - s2) / n2 : 0;
              return this.points[a2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          function Pe2(e2, t2) {
            let i2 = true;
            return "always" === e2 || "never" !== e2 && "never" !== t2 || (i2 = false), i2;
          }
          class Ce2 {
            constructor(e2, t2, i2) {
              const r2 = this.boxCells = [], o2 = this.circleCells = [];
              this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
              for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) r2.push([]), o2.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e2, t2, i2, r2, o2) {
              this._forEachCell(t2, i2, r2, o2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(r2), this.bboxes.push(o2);
            }
            insertCircle(e2, t2, i2, r2) {
              this._forEachCell(t2 - r2, i2 - r2, t2 + r2, i2 + r2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(r2);
            }
            _insertBoxCell(e2, t2, i2, r2, o2, a2) {
              this.boxCells[o2].push(a2);
            }
            _insertCircleCell(e2, t2, i2, r2, o2, a2) {
              this.circleCells[o2].push(a2);
            }
            _query(e2, t2, i2, r2, o2, a2, s2) {
              if (i2 < 0 || e2 > this.width || r2 < 0 || t2 > this.height) return [];
              const n2 = [];
              if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= r2) {
                if (o2) return [{ key: null, x1: e2, y1: t2, x2: i2, y2: r2 }];
                for (let e3 = 0; e3 < this.boxKeys.length; e3++) n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
                for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                  const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], r3 = this.circles[3 * e3 + 2];
                  n2.push({ key: this.circleKeys[e3], x1: t3 - r3, y1: i3 - r3, x2: t3 + r3, y2: i3 + r3 });
                }
              } else this._forEachCell(e2, t2, i2, r2, this._queryCell, n2, { hitTest: o2, overlapMode: a2, seenUids: { box: {}, circle: {} } }, s2);
              return n2;
            }
            query(e2, t2, i2, r2) {
              return this._query(e2, t2, i2, r2, false, null);
            }
            hitTest(e2, t2, i2, r2, o2, a2) {
              return this._query(e2, t2, i2, r2, true, o2, a2).length > 0;
            }
            hitTestCircle(e2, t2, i2, r2, o2) {
              const a2 = e2 - i2, s2 = e2 + i2, n2 = t2 - i2, l2 = t2 + i2;
              if (s2 < 0 || a2 > this.width || l2 < 0 || n2 > this.height) return false;
              const c2 = [];
              return this._forEachCell(a2, n2, s2, l2, this._queryCellCircle, c2, { hitTest: true, overlapMode: r2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, o2), c2.length > 0;
            }
            _queryCell(e2, t2, i2, r2, o2, a2, s2, n2) {
              const { seenUids: l2, hitTest: c2, overlapMode: h3 } = s2, u2 = this.boxCells[o2];
              if (null !== u2) {
                const o3 = this.bboxes;
                for (const s3 of u2) if (!l2.box[s3]) {
                  l2.box[s3] = true;
                  const u3 = 4 * s3, d3 = this.boxKeys[s3];
                  if (e2 <= o3[u3 + 2] && t2 <= o3[u3 + 3] && i2 >= o3[u3 + 0] && r2 >= o3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !Pe2(h3, d3.overlapMode)) && (a2.push({ key: d3, x1: o3[u3], y1: o3[u3 + 1], x2: o3[u3 + 2], y2: o3[u3 + 3] }), c2)) return true;
                }
              }
              const d2 = this.circleCells[o2];
              if (null !== d2) {
                const o3 = this.circles;
                for (const s3 of d2) if (!l2.circle[s3]) {
                  l2.circle[s3] = true;
                  const u3 = 3 * s3, d3 = this.circleKeys[s3];
                  if (this._circleAndRectCollide(o3[u3], o3[u3 + 1], o3[u3 + 2], e2, t2, i2, r2) && (!n2 || n2(d3)) && (!c2 || !Pe2(h3, d3.overlapMode))) {
                    const e3 = o3[u3], t3 = o3[u3 + 1], i3 = o3[u3 + 2];
                    if (a2.push({ key: d3, x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 }), c2) return true;
                  }
                }
              }
              return false;
            }
            _queryCellCircle(e2, t2, i2, r2, o2, a2, s2, n2) {
              const { circle: l2, seenUids: c2, overlapMode: h3 } = s2, u2 = this.boxCells[o2];
              if (null !== u2) {
                const e3 = this.bboxes;
                for (const t3 of u2) if (!c2.box[t3]) {
                  c2.box[t3] = true;
                  const i3 = 4 * t3, r3 = this.boxKeys[t3];
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!n2 || n2(r3)) && !Pe2(h3, r3.overlapMode)) return a2.push(true), true;
                }
              }
              const d2 = this.circleCells[o2];
              if (null !== d2) {
                const e3 = this.circles;
                for (const t3 of d2) if (!c2.circle[t3]) {
                  c2.circle[t3] = true;
                  const i3 = 3 * t3, r3 = this.circleKeys[t3];
                  if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(r3)) && !Pe2(h3, r3.overlapMode)) return a2.push(true), true;
                }
              }
            }
            _forEachCell(e2, t2, i2, r2, o2, a2, s2, n2) {
              const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h3 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(r2);
              for (let d2 = l2; d2 <= h3; d2++) for (let l3 = c2; l3 <= u2; l3++) if (o2.call(this, e2, t2, i2, r2, this.xCellCount * l3 + d2, a2, s2, n2)) return;
            }
            _convertToXCellCoord(e2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
            }
            _convertToYCellCoord(e2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
            }
            _circlesCollide(e2, t2, i2, r2, o2, a2) {
              const s2 = r2 - e2, n2 = o2 - t2, l2 = i2 + a2;
              return l2 * l2 > s2 * s2 + n2 * n2;
            }
            _circleAndRectCollide(e2, t2, i2, r2, o2, a2, s2) {
              const n2 = (a2 - r2) / 2, l2 = Math.abs(e2 - (r2 + n2));
              if (l2 > n2 + i2) return false;
              const c2 = (s2 - o2) / 2, h3 = Math.abs(t2 - (o2 + c2));
              if (h3 > c2 + i2) return false;
              if (l2 <= n2 || h3 <= c2) return true;
              const u2 = l2 - n2, d2 = h3 - c2;
              return u2 * u2 + d2 * d2 <= i2 * i2;
            }
          }
          function Me2(e2, i2, o2) {
            const a2 = t.K();
            if (!e2) {
              const { vecSouth: e3, vecEast: t2 } = Ee2(i2), o3 = r();
              o3[0] = t2[0], o3[1] = t2[1], o3[2] = e3[0], o3[3] = e3[1], s2 = o3, (d2 = (l2 = (n2 = o3)[0]) * (u2 = n2[3]) - (h3 = n2[2]) * (c2 = n2[1])) && (s2[0] = u2 * (d2 = 1 / d2), s2[1] = -c2 * d2, s2[2] = -h3 * d2, s2[3] = l2 * d2), a2[0] = o3[0], a2[1] = o3[1], a2[4] = o3[2], a2[5] = o3[3];
            }
            var s2, n2, l2, c2, h3, u2, d2;
            return t.M(a2, a2, [1 / o2, 1 / o2, 1]), a2;
          }
          function Ie(e2, i2, r2, o2) {
            if (e2) {
              const e3 = t.K();
              if (!i2) {
                const { vecSouth: t2, vecEast: i3 } = Ee2(r2);
                e3[0] = i3[0], e3[1] = i3[1], e3[4] = t2[0], e3[5] = t2[1];
              }
              return t.M(e3, e3, [o2, o2, 1]), e3;
            }
            return r2.pixelsToClipSpaceMatrix;
          }
          function Ee2(e2) {
            const i2 = Math.cos(e2.rollInRadians), r2 = Math.sin(e2.rollInRadians), o2 = Math.cos(e2.pitchInRadians), a2 = Math.cos(e2.bearingInRadians), s2 = Math.sin(e2.bearingInRadians), n2 = t.ao();
            n2[0] = -a2 * o2 * r2 - s2 * i2, n2[1] = -s2 * o2 * r2 + a2 * i2;
            const l2 = t.ap(n2);
            l2 < 1e-9 ? t.aq(n2) : t.ar(n2, n2, 1 / l2);
            const c2 = t.ao();
            c2[0] = a2 * o2 * i2 - s2 * r2, c2[1] = s2 * o2 * i2 + a2 * r2;
            const h3 = t.ap(c2);
            return h3 < 1e-9 ? t.aq(c2) : t.ar(c2, c2, 1 / h3), { vecEast: c2, vecSouth: n2 };
          }
          function Se(e2, i2, r2, o2) {
            let a2;
            o2 ? (a2 = [e2, i2, o2(e2, i2), 1], t.at(a2, a2, r2)) : (a2 = [e2, i2, 0, 1], We2(a2, a2, r2));
            const s2 = a2[3];
            return { point: new t.P(a2[0] / s2, a2[1] / s2), signedDistanceFromCamera: s2, isOccluded: false };
          }
          function Re2(e2, t2) {
            return 0.5 + e2 / t2 * 0.5;
          }
          function ze2(e2, t2) {
            return e2.x >= -t2[0] && e2.x <= t2[0] && e2.y >= -t2[1] && e2.y <= t2[1];
          }
          function De(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3) {
            const p2 = r2 ? e2.textSizeData : e2.iconSizeData, m2 = t.ak(p2, i2.transform.zoom), f2 = [256 / i2.width * 2 + 1, 256 / i2.height * 2 + 1], g3 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
            g3.clear();
            const v2 = e2.lineVertexArray, x3 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, b2 = i2.transform.width / i2.transform.height;
            let y2 = false;
            for (let r3 = 0; r3 < x3.length; r3++) {
              const w2 = x3.get(r3);
              if (w2.hidden || w2.writingMode === t.al.vertical && !y2) {
                qe(w2.numGlyphs, g3);
                continue;
              }
              y2 = false;
              const T2 = new t.P(w2.anchorX, w2.anchorY), P2 = { getElevation: _3, pitchedLabelPlaneMatrix: o2, lineVertexArray: v2, pitchWithMap: s2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: i2.transform, tileAnchorPoint: T2, unwrappedTileID: c2, width: h3, height: u2, translation: d2 }, C3 = Ze2(w2.anchorX, w2.anchorY, P2);
              if (!ze2(C3.point, f2)) {
                qe(w2.numGlyphs, g3);
                continue;
              }
              const M3 = Re2(i2.transform.cameraToCenterDistance, C3.signedDistanceFromCamera), I3 = t.am(p2, m2, w2), E3 = s2 ? I3 * i2.transform.getPitchedTextCorrection(w2.anchorX, w2.anchorY, c2) / M3 : I3 * M3, S3 = ke2({ projectionContext: P2, pitchedLabelPlaneMatrixInverse: a2, symbol: w2, fontSize: E3, flip: false, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g3, aspectRatio: b2, rotateToLine: l2 });
              y2 = S3.useVertical, (S3.notEnoughRoom || y2 || S3.needsFlipping && ke2({ projectionContext: P2, pitchedLabelPlaneMatrixInverse: a2, symbol: w2, fontSize: E3, flip: true, keepUpright: n2, glyphOffsetArray: e2.glyphOffsetArray, dynamicLayoutVertexArray: g3, aspectRatio: b2, rotateToLine: l2 }).notEnoughRoom) && qe(w2.numGlyphs, g3);
            }
            r2 ? e2.text.dynamicLayoutVertexBuffer.updateData(g3) : e2.icon.dynamicLayoutVertexBuffer.updateData(g3);
          }
          function Ae2(e2, t2, i2, r2, o2, a2, s2, n2) {
            const l2 = a2.glyphStartIndex + a2.numGlyphs, c2 = a2.lineStartIndex, h3 = a2.lineStartIndex + a2.lineLength, u2 = t2.getoffsetX(a2.glyphStartIndex), d2 = t2.getoffsetX(l2 - 1), _3 = Ge2(e2 * u2, i2, r2, o2, a2.segment, c2, h3, n2, s2);
            if (!_3) return null;
            const p2 = Ge2(e2 * d2, i2, r2, o2, a2.segment, c2, h3, n2, s2);
            return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _3, last: p2 } : null;
          }
          function Le2(e2, i2, r2, o2) {
            return e2 === t.al.horizontal && Math.abs(r2.y - i2.y) > Math.abs(r2.x - i2.x) * o2 ? { useVertical: true } : (e2 === t.al.vertical ? i2.y < r2.y : i2.x > r2.x) ? { needsFlipping: true } : null;
          }
          function ke2(e2) {
            const { projectionContext: i2, pitchedLabelPlaneMatrixInverse: r2, symbol: o2, fontSize: a2, flip: s2, keepUpright: n2, glyphOffsetArray: l2, dynamicLayoutVertexArray: c2, aspectRatio: h3, rotateToLine: u2 } = e2, d2 = a2 / 24, _3 = o2.lineOffsetX * d2, p2 = o2.lineOffsetY * d2;
            let m2;
            if (o2.numGlyphs > 1) {
              const e3 = o2.glyphStartIndex + o2.numGlyphs, t2 = o2.lineStartIndex, a3 = o2.lineStartIndex + o2.lineLength, c3 = Ae2(d2, l2, _3, p2, s2, o2, u2, i2);
              if (!c3) return { notEnoughRoom: true };
              const f2 = je2(c3.first.point.x, c3.first.point.y, i2, r2), g3 = je2(c3.last.point.x, c3.last.point.y, i2, r2);
              if (n2 && !s2) {
                const e4 = Le2(o2.writingMode, f2, g3, h3);
                if (e4) return e4;
              }
              m2 = [c3.first];
              for (let r3 = o2.glyphStartIndex + 1; r3 < e3 - 1; r3++) m2.push(Ge2(d2 * l2.getoffsetX(r3), _3, p2, s2, o2.segment, t2, a3, i2, u2));
              m2.push(c3.last);
            } else {
              if (n2 && !s2) {
                const e4 = Oe2(i2.tileAnchorPoint.x, i2.tileAnchorPoint.y, i2).point, a3 = o2.lineStartIndex + o2.segment + 1, s3 = new t.P(i2.lineVertexArray.getx(a3), i2.lineVertexArray.gety(a3)), n3 = Oe2(s3.x, s3.y, i2), l3 = n3.signedDistanceFromCamera > 0 ? n3.point : Fe2(i2.tileAnchorPoint, s3, e4, 1, i2), c3 = je2(e4.x, e4.y, i2, r2), u3 = je2(l3.x, l3.y, i2, r2), d3 = Le2(o2.writingMode, c3, u3, h3);
                if (d3) return d3;
              }
              const e3 = Ge2(d2 * l2.getoffsetX(o2.glyphStartIndex), _3, p2, s2, o2.segment, o2.lineStartIndex, o2.lineStartIndex + o2.lineLength, i2, u2);
              if (!e3 || i2.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
              m2 = [e3];
            }
            for (const e3 of m2) t.as(c2, e3.point, e3.angle);
            return {};
          }
          function Fe2(e2, t2, i2, r2, o2) {
            const a2 = e2.add(e2.sub(t2)._unit()), s2 = Oe2(a2.x, a2.y, o2).point, n2 = i2.sub(s2);
            return i2.add(n2._mult(r2 / n2.mag()));
          }
          function Be2(e2, i2, r2) {
            const o2 = i2.projectionCache;
            if (o2.projections[e2]) return o2.projections[e2];
            const a2 = new t.P(i2.lineVertexArray.getx(e2), i2.lineVertexArray.gety(e2)), s2 = Oe2(a2.x, a2.y, i2);
            if (s2.signedDistanceFromCamera > 0) return o2.projections[e2] = s2.point, o2.anyProjectionOccluded = o2.anyProjectionOccluded || s2.isOccluded, s2.point;
            const n2 = e2 - r2.direction;
            return Fe2(0 === r2.distanceFromAnchor ? i2.tileAnchorPoint : new t.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), a2, r2.previousVertex, r2.absOffsetX - r2.distanceFromAnchor + 1, i2);
          }
          function Oe2(e2, t2, i2) {
            const r2 = e2 + i2.translation[0], o2 = t2 + i2.translation[1];
            let a2;
            return i2.pitchWithMap ? (a2 = Se(r2, o2, i2.pitchedLabelPlaneMatrix, i2.getElevation), a2.isOccluded = false) : (a2 = i2.transform.projectTileCoordinates(r2, o2, i2.unwrappedTileID, i2.getElevation), a2.point.x = (0.5 * a2.point.x + 0.5) * i2.width, a2.point.y = (0.5 * -a2.point.y + 0.5) * i2.height), a2;
          }
          function je2(e2, i2, r2, o2) {
            if (r2.pitchWithMap) {
              const a2 = [e2, i2, 0, 1];
              return t.at(a2, a2, o2), r2.transform.projectTileCoordinates(a2[0] / a2[3], a2[1] / a2[3], r2.unwrappedTileID, r2.getElevation).point;
            }
            return { x: e2 / r2.width * 2 - 1, y: i2 / r2.height * 2 - 1 };
          }
          function Ze2(e2, t2, i2) {
            return i2.transform.projectTileCoordinates(e2, t2, i2.unwrappedTileID, i2.getElevation);
          }
          function Ne2(e2, t2, i2) {
            return e2._unit()._perp()._mult(t2 * i2);
          }
          function Ue2(e2, i2, r2, o2, a2, s2, n2, l2, c2) {
            if (l2.projectionCache.offsets[e2]) return l2.projectionCache.offsets[e2];
            const h3 = r2.add(i2);
            if (e2 + c2.direction < o2 || e2 + c2.direction >= a2) return l2.projectionCache.offsets[e2] = h3, h3;
            const u2 = Be2(e2 + c2.direction, l2, c2), d2 = Ne2(u2.sub(r2), n2, c2.direction), _3 = r2.add(d2), p2 = u2.add(d2);
            return l2.projectionCache.offsets[e2] = t.au(s2, h3, _3, p2) || h3, l2.projectionCache.offsets[e2];
          }
          function Ge2(e2, t2, i2, r2, o2, a2, s2, n2, l2) {
            const c2 = r2 ? e2 - t2 : e2 + t2;
            let h3 = c2 > 0 ? 1 : -1, u2 = 0;
            r2 && (h3 *= -1, u2 = Math.PI), h3 < 0 && (u2 += Math.PI);
            let d2, _3 = h3 > 0 ? a2 + o2 : a2 + o2 + 1;
            n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = Oe2(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
            let p2, m2, f2 = d2, g3 = d2, v2 = 0, x3 = 0;
            const b2 = Math.abs(c2), y2 = [];
            let w2;
            for (; v2 + x3 <= b2; ) {
              if (_3 += h3, _3 < a2 || _3 >= s2) return null;
              v2 += x3, g3 = f2, m2 = p2;
              const e3 = { absOffsetX: b2, direction: h3, distanceFromAnchor: v2, previousVertex: g3 };
              if (f2 = Be2(_3, n2, e3), 0 === i2) y2.push(g3), w2 = f2.sub(g3);
              else {
                let t3;
                const r3 = f2.sub(g3);
                t3 = 0 === r3.mag() ? Ne2(Be2(_3 + h3, n2, e3).sub(f2), i2, h3) : Ne2(r3, i2, h3), m2 || (m2 = g3.add(t3)), p2 = Ue2(_3, t3, f2, a2, s2, m2, i2, n2, e3), y2.push(m2), w2 = p2.sub(m2);
              }
              x3 = w2.mag();
            }
            const T2 = w2._mult((b2 - v2) / x3)._add(m2 || g3), P2 = u2 + Math.atan2(f2.y - g3.y, f2.x - g3.x);
            return y2.push(T2), { point: T2, angle: l2 ? P2 : 0, path: y2 };
          }
          const Ve2 = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function qe(e2, t2) {
            for (let i2 = 0; i2 < e2; i2++) {
              const e3 = t2.length;
              t2.resize(e3 + 4), t2.float32.set(Ve2, 3 * e3);
            }
          }
          function We2(e2, t2, i2) {
            const r2 = t2[0], o2 = t2[1];
            return e2[0] = i2[0] * r2 + i2[4] * o2 + i2[12], e2[1] = i2[1] * r2 + i2[5] * o2 + i2[13], e2[3] = i2[3] * r2 + i2[7] * o2 + i2[15], e2;
          }
          const He2 = 100;
          class $e2 {
            constructor(e2, t2 = new Ce2(e2.width + 200, e2.height + 200, 25), i2 = new Ce2(e2.width + 200, e2.height + 200, 25)) {
              this.transform = e2, this.grid = t2, this.ignoredGrid = i2, this.pitchFactor = Math.cos(e2.pitch * Math.PI / 180) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + He2, this.screenBottomBoundary = e2.height + He2, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.perspectiveRatioCutoff = 0.6;
            }
            placeCollisionBox(e2, t2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2) {
              const d2 = this.projectAndGetPerspectiveRatio(e2.anchorPointX + n2[0], e2.anchorPointY + n2[1], o2, c2, u2), _3 = i2 * d2.perspectiveRatio;
              let p2;
              if (a2 || s2) p2 = this._projectCollisionBox(e2, _3, r2, o2, a2, s2, n2, d2, c2, h3, u2);
              else {
                const t3 = d2.x + (h3 ? h3.x * _3 : 0), i3 = d2.y + (h3 ? h3.y * _3 : 0);
                p2 = { allPointsOccluded: false, box: [t3 + e2.x1 * _3, i3 + e2.y1 * _3, t3 + e2.x2 * _3, i3 + e2.y2 * _3] };
              }
              const [m2, f2, g3, v2] = p2.box, x3 = a2 ? p2.allPointsOccluded : d2.isOccluded;
              let b2 = x3;
              return b2 || (b2 = d2.perspectiveRatio < this.perspectiveRatioCutoff), b2 || (b2 = !this.isInsideGrid(m2, f2, g3, v2)), b2 || "always" !== t2 && this.grid.hitTest(m2, f2, g3, v2, t2, l2) ? { box: [m2, f2, g3, v2], placeable: false, offscreen: false, occluded: x3 } : { box: [m2, f2, g3, v2], placeable: true, offscreen: this.isOffscreen(m2, f2, g3, v2), occluded: x3 };
            }
            placeCollisionCircles(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3, p2) {
              const m2 = [], f2 = new t.P(i2.anchorX, i2.anchorY), g3 = this.getPerspectiveRatio(f2.x, f2.y, s2, p2), v2 = (c2 ? a2 * this.transform.getPitchedTextCorrection(i2.anchorX, i2.anchorY, s2) / g3 : a2 * g3) / t.ay, x3 = { getElevation: p2, pitchedLabelPlaneMatrix: n2, lineVertexArray: r2, pitchWithMap: c2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: f2, unwrappedTileID: s2, width: this.transform.width, height: this.transform.height, translation: _3 }, b2 = Ae2(v2, o2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, i2, false, x3);
              let y2 = false, w2 = false, T2 = true;
              if (b2) {
                const i3 = 0.5 * u2 * g3 + d2, r3 = new t.P(-100, -100), o3 = new t.P(this.screenRightBoundary, this.screenBottomBoundary), a3 = new Te2(), s3 = b2.first, n3 = b2.last;
                let _4 = [];
                for (let e3 = s3.path.length - 1; e3 >= 1; e3--) _4.push(s3.path[e3]);
                for (let e3 = 1; e3 < n3.path.length; e3++) _4.push(n3.path[e3]);
                const p3 = 2.5 * i3;
                if (c2) {
                  const e3 = this.projectPathToScreenSpace(_4, x3);
                  _4 = e3.some((e4) => e4.signedDistanceFromCamera <= 0) ? [] : e3.map((e4) => e4.point);
                }
                let f3 = [];
                if (_4.length > 0) {
                  const e3 = _4[0].clone(), i4 = _4[0].clone();
                  for (let t2 = 1; t2 < _4.length; t2++) e3.x = Math.min(e3.x, _4[t2].x), e3.y = Math.min(e3.y, _4[t2].y), i4.x = Math.max(i4.x, _4[t2].x), i4.y = Math.max(i4.y, _4[t2].y);
                  f3 = e3.x >= r3.x && i4.x <= o3.x && e3.y >= r3.y && i4.y <= o3.y ? [_4] : i4.x < r3.x || e3.x > o3.x || i4.y < r3.y || e3.y > o3.y ? [] : t.av([_4], r3.x, r3.y, o3.x, o3.y);
                }
                for (const t2 of f3) {
                  a3.reset(t2, 0.25 * i3);
                  let r4 = 0;
                  r4 = a3.length <= 0.5 * i3 ? 1 : Math.ceil(a3.paddedLength / p3) + 1;
                  for (let t3 = 0; t3 < r4; t3++) {
                    const o4 = t3 / Math.max(r4 - 1, 1), s4 = a3.lerp(o4), n4 = s4.x + He2, c3 = s4.y + He2;
                    m2.push(n4, c3, i3, 0);
                    const u3 = n4 - i3, d3 = c3 - i3, _5 = n4 + i3, p4 = c3 + i3;
                    if (T2 = T2 && this.isOffscreen(u3, d3, _5, p4), w2 = w2 || this.isInsideGrid(u3, d3, _5, p4), "always" !== e2 && this.grid.hitTestCircle(n4, c3, i3, e2, h3) && (y2 = true, !l2)) return { circles: [], offscreen: false, collisionDetected: y2 };
                  }
                }
              }
              return { circles: !l2 && y2 || !w2 || g3 < this.perspectiveRatioCutoff ? [] : m2, offscreen: T2, collisionDetected: y2 };
            }
            projectPathToScreenSpace(e2, i2) {
              const r2 = function(e3, i3) {
                const r3 = t.K();
                return t.an(r3, i3.pitchedLabelPlaneMatrix), e3.map((e4) => {
                  const t2 = Se(e4.x, e4.y, r3, i3.getElevation), o2 = i3.transform.projectTileCoordinates(t2.point.x, t2.point.y, i3.unwrappedTileID, i3.getElevation);
                  return o2.point.x = (0.5 * o2.point.x + 0.5) * i3.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i3.height, o2;
                });
              }(e2, i2);
              return function(e3) {
                let t2 = 0, i3 = 0, r3 = 0, o2 = 0;
                for (let a2 = 0; a2 < e3.length; a2++) e3[a2].isOccluded ? (r3 = a2 + 1, o2 = 0) : (o2++, o2 > i3 && (i3 = o2, t2 = r3));
                return e3.slice(t2, t2 + i3);
              }(r2);
            }
            queryRenderedSymbols(e2) {
              if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
              const i2 = [];
              let r2 = 1 / 0, o2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
              for (const n3 of e2) {
                const e3 = new t.P(n3.x + He2, n3.y + He2);
                r2 = Math.min(r2, e3.x), o2 = Math.min(o2, e3.y), a2 = Math.max(a2, e3.x), s2 = Math.max(s2, e3.y), i2.push(e3);
              }
              const n2 = this.grid.query(r2, o2, a2, s2).concat(this.ignoredGrid.query(r2, o2, a2, s2)), l2 = {}, c2 = {};
              for (const e3 of n2) {
                const r3 = e3.key;
                if (void 0 === l2[r3.bucketInstanceId] && (l2[r3.bucketInstanceId] = {}), l2[r3.bucketInstanceId][r3.featureIndex]) continue;
                const o3 = [new t.P(e3.x1, e3.y1), new t.P(e3.x2, e3.y1), new t.P(e3.x2, e3.y2), new t.P(e3.x1, e3.y2)];
                t.aw(i2, o3) && (l2[r3.bucketInstanceId][r3.featureIndex] = true, void 0 === c2[r3.bucketInstanceId] && (c2[r3.bucketInstanceId] = []), c2[r3.bucketInstanceId].push(r3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(e2, t2, i2, r2, o2, a2) {
              (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r2, featureIndex: o2, collisionGroupID: a2, overlapMode: t2 }, e2[0], e2[1], e2[2], e2[3]);
            }
            insertCollisionCircles(e2, t2, i2, r2, o2, a2) {
              const s2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: r2, featureIndex: o2, collisionGroupID: a2, overlapMode: t2 };
              for (let t3 = 0; t3 < e2.length; t3 += 4) s2.insertCircle(n2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
            }
            projectAndGetPerspectiveRatio(e2, i2, r2, o2, a2) {
              if (a2) {
                let r3;
                o2 ? (r3 = [e2, i2, o2(e2, i2), 1], t.at(r3, r3, a2)) : (r3 = [e2, i2, 0, 1], We2(r3, r3, a2));
                const s2 = r3[3];
                return { x: (r3[0] / s2 + 1) / 2 * this.transform.width + He2, y: (-r3[1] / s2 + 1) / 2 * this.transform.height + He2, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s2 * 0.5, isOccluded: false, signedDistanceFromCamera: s2 };
              }
              {
                const t2 = this.transform.projectTileCoordinates(e2, i2, r2, o2);
                return { x: (t2.point.x + 1) / 2 * this.transform.width + He2, y: (1 - t2.point.y) / 2 * this.transform.height + He2, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t2.signedDistanceFromCamera * 0.5, isOccluded: t2.isOccluded, signedDistanceFromCamera: t2.signedDistanceFromCamera };
              }
            }
            getPerspectiveRatio(e2, t2, i2, r2) {
              const o2 = this.transform.projectTileCoordinates(e2, t2, i2, r2);
              return 0.5 + this.transform.cameraToCenterDistance / o2.signedDistanceFromCamera * 0.5;
            }
            isOffscreen(e2, t2, i2, r2) {
              return i2 < He2 || e2 >= this.screenRightBoundary || r2 < He2 || t2 > this.screenBottomBoundary;
            }
            isInsideGrid(e2, t2, i2, r2) {
              return i2 >= 0 && e2 < this.gridRightBoundary && r2 >= 0 && t2 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e2 = t.ad([]);
              return t.L(e2, e2, [-100, -100, 0]), e2;
            }
            _projectCollisionBox(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2) {
              let d2 = 1, _3 = 0, p2 = 0, m2 = 1;
              const f2 = e2.anchorPointX + n2[0], g3 = e2.anchorPointY + n2[1];
              if (s2 && !a2) {
                const e3 = this.projectAndGetPerspectiveRatio(f2 + 1, g3, o2, c2, u2), t2 = e3.x - l2.x, i3 = Math.atan((e3.y - l2.y) / t2) + (t2 < 0 ? Math.PI : 0), r3 = Math.sin(i3), a3 = Math.cos(i3);
                d2 = a3, _3 = r3, p2 = -r3, m2 = a3;
              } else if (!s2 && a2) {
                const e3 = Ee2(this.transform);
                d2 = e3.vecEast[0], _3 = e3.vecEast[1], p2 = e3.vecSouth[0], m2 = e3.vecSouth[1];
              }
              let v2 = l2.x, x3 = l2.y, b2 = i2;
              a2 && (v2 = f2, x3 = g3, b2 = Math.pow(2, -(this.transform.zoom - r2.overscaledZ)), b2 *= this.transform.getPitchedTextCorrection(f2, g3, o2), h3 || (b2 *= t.ae(0.5 + l2.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), h3 && (v2 += d2 * h3.x * b2 + p2 * h3.y * b2, x3 += _3 * h3.x * b2 + m2 * h3.y * b2);
              const y2 = e2.x1 * b2, w2 = e2.x2 * b2, T2 = (y2 + w2) / 2, P2 = e2.y1 * b2, C3 = e2.y2 * b2, M3 = (P2 + C3) / 2, I3 = [{ offsetX: y2, offsetY: P2 }, { offsetX: T2, offsetY: P2 }, { offsetX: w2, offsetY: P2 }, { offsetX: w2, offsetY: M3 }, { offsetX: w2, offsetY: C3 }, { offsetX: T2, offsetY: C3 }, { offsetX: y2, offsetY: C3 }, { offsetX: y2, offsetY: M3 }];
              let E3 = [];
              for (const { offsetX: e3, offsetY: i3 } of I3) E3.push(new t.P(v2 + d2 * e3 + p2 * i3, x3 + _3 * e3 + m2 * i3));
              let S3 = false;
              if (a2) {
                const e3 = E3.map((e4) => this.projectAndGetPerspectiveRatio(e4.x, e4.y, o2, c2, u2));
                S3 = e3.some((e4) => !e4.isOccluded), E3 = e3.map((e4) => new t.P(e4.x, e4.y));
              } else S3 = true;
              return { box: t.ax(E3), allPointsOccluded: !S3 };
            }
          }
          class Xe2 {
            constructor(e2, t2, i2, r2) {
              this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : r2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class Ke2 {
            constructor(e2, t2, i2, r2, o2) {
              this.text = new Xe2(e2 ? e2.text : null, t2, i2, o2), this.icon = new Xe2(e2 ? e2.icon : null, t2, r2, o2);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class Qe2 {
            constructor(e2, t2, i2) {
              this.text = e2, this.icon = t2, this.skipFade = i2;
            }
          }
          class Ye2 {
            constructor(e2, t2, i2, r2, o2) {
              this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = r2, this.tileID = o2;
            }
          }
          class Je2 {
            constructor(e2) {
              this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e2) {
              if (this.crossSourceCollisions) return { ID: 0, predicate: null };
              if (!this.collisionGroups[e2]) {
                const t2 = ++this.maxGroupID;
                this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
              }
              return this.collisionGroups[e2];
            }
          }
          function et(e2, i2, r2, o2, a2) {
            const { horizontalAlign: s2, verticalAlign: n2 } = t.aE(e2);
            return new t.P(-(s2 - 0.5) * i2 + o2[0] * a2, -(n2 - 0.5) * r2 + o2[1] * a2);
          }
          class tt {
            constructor(e2, t2, i2, r2, o2) {
              this.transform = e2.clone(), this.terrain = t2, this.collisionIndex = new $e2(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new Je2(r2), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
            }
            _getTerrainElevationFunc(e2) {
              const t2 = this.terrain;
              return t2 ? (i2, r2) => t2.getElevation(e2, i2, r2) : null;
            }
            getBucketParts(e2, i2, r2, o2) {
              const a2 = r2.getBucket(i2), s2 = r2.latestFeatureIndex;
              if (!a2 || !s2 || i2.id !== a2.layerIds[0]) return;
              const n2 = r2.collisionBoxArray, l2 = a2.layers[0].layout, c2 = a2.layers[0].paint, h3 = Math.pow(2, this.transform.zoom - r2.tileID.overscaledZ), u2 = r2.tileSize / t.Z, d2 = r2.tileID.toUnwrapped(), _3 = "map" === l2.get("text-rotation-alignment"), p2 = t.az(r2, 1, this.transform.zoom), m2 = t.aA(this.collisionIndex.transform, r2, c2.get("text-translate"), c2.get("text-translate-anchor")), f2 = t.aA(this.collisionIndex.transform, r2, c2.get("icon-translate"), c2.get("icon-translate-anchor")), g3 = Me2(_3, this.transform, p2);
              this.retainedQueryData[a2.bucketInstanceId] = new Ye2(a2.bucketInstanceId, s2, a2.sourceLayerIndex, a2.index, r2.tileID);
              const v2 = { bucket: a2, layout: l2, translationText: m2, translationIcon: f2, unwrappedTileID: d2, pitchedLabelPlaneMatrix: g3, scale: h3, textPixelRatio: u2, holdingForFade: r2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.ak(a2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a2.sourceID) };
              if (o2) for (const t2 of a2.sortKeyRanges) {
                const { sortKey: i3, symbolInstanceStart: r3, symbolInstanceEnd: o3 } = t2;
                e2.push({ sortKey: i3, symbolInstanceStart: r3, symbolInstanceEnd: o3, parameters: v2 });
              }
              else e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: a2.symbolInstances.length, parameters: v2 });
            }
            attemptAnchorPlacement(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3, p2, m2, f2, g3, v2, x3, b2) {
              const y2 = t.aB[e2.textAnchor], w2 = [e2.textOffset0, e2.textOffset1], T2 = et(y2, r2, o2, w2, a2), P2 = this.collisionIndex.placeCollisionBox(i2, d2, l2, c2, h3, n2, s2, f2, u2.predicate, x3, T2, b2);
              if ((!v2 || this.collisionIndex.placeCollisionBox(v2, d2, l2, c2, h3, n2, s2, g3, u2.predicate, x3, T2, b2).placeable) && P2.placeable) {
                let e3;
                if (this.prevPlacement && this.prevPlacement.variableOffsets[_3.crossTileID] && this.prevPlacement.placements[_3.crossTileID] && this.prevPlacement.placements[_3.crossTileID].text && (e3 = this.prevPlacement.variableOffsets[_3.crossTileID].anchor), 0 === _3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                return this.variableOffsets[_3.crossTileID] = { textOffset: w2, width: r2, height: o2, anchor: y2, textBoxScale: a2, prevAnchor: e3 }, this.markUsedJustification(p2, y2, _3, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _3), this.placedOrientations[_3.crossTileID] = m2), { shift: T2, placedGlyphBoxes: P2 };
              }
            }
            placeLayerBucketPart(e2, i2, r2) {
              const { bucket: o2, layout: a2, translationText: s2, translationIcon: n2, unwrappedTileID: l2, pitchedLabelPlaneMatrix: c2, textPixelRatio: h3, holdingForFade: u2, collisionBoxArray: d2, partiallyEvaluatedTextSize: _3, collisionGroup: p2 } = e2.parameters, m2 = a2.get("text-optional"), f2 = a2.get("icon-optional"), g3 = t.aC(a2, "text-overlap", "text-allow-overlap"), v2 = "always" === g3, x3 = t.aC(a2, "icon-overlap", "icon-allow-overlap"), b2 = "always" === x3, y2 = "map" === a2.get("text-rotation-alignment"), w2 = "map" === a2.get("text-pitch-alignment"), T2 = "none" !== a2.get("icon-text-fit"), P2 = "viewport-y" === a2.get("symbol-z-order"), C3 = v2 && (b2 || !o2.hasIconData() || f2), M3 = b2 && (v2 || !o2.hasTextData() || m2);
              !o2.collisionArrays && d2 && o2.deserializeCollisionBoxes(d2);
              const I3 = this.retainedQueryData[o2.bucketInstanceId].tileID, E3 = this._getTerrainElevationFunc(I3), S3 = this.transform.getFastPathSimpleProjectionMatrix(I3), R2 = (e3, d3, b3) => {
                var P3, R3;
                if (i2[e3.crossTileID]) return;
                if (u2) return void (this.placements[e3.crossTileID] = new Qe2(false, false, false));
                let z2 = false, D3 = false, A3 = true, L3 = null, k2 = { box: null, placeable: false, offscreen: null, occluded: false }, F3 = { placeable: false }, B3 = null, O3 = null, j2 = null, Z3 = 0, N3 = 0, U2 = 0;
                d3.textFeatureIndex ? Z3 = d3.textFeatureIndex : e3.useRuntimeCollisionCircles && (Z3 = e3.featureIndex), d3.verticalTextFeatureIndex && (N3 = d3.verticalTextFeatureIndex);
                const G3 = d3.textBox;
                if (G3) {
                  const i3 = (i4) => {
                    let r3 = t.al.horizontal;
                    if (o2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const t2 = this.prevPlacement.placedOrientations[e3.crossTileID];
                      t2 && (this.placedOrientations[e3.crossTileID] = t2, r3 = t2, this.markUsedOrientation(o2, r3, e3));
                    }
                    return r3;
                  }, a3 = (i4, r3) => {
                    if (o2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
                      for (const e4 of o2.writingModes) if (e4 === t.al.vertical ? (k2 = r3(), F3 = k2) : k2 = i4(), k2 && k2.placeable) break;
                    } else k2 = i4();
                  }, c3 = e3.textAnchorOffsetStartIndex, u3 = e3.textAnchorOffsetEndIndex;
                  if (u3 === c3) {
                    const r3 = (t2, i4) => {
                      const r4 = this.collisionIndex.placeCollisionBox(t2, g3, h3, I3, l2, w2, y2, s2, p2.predicate, E3, void 0, S3);
                      return r4 && r4.placeable && (this.markUsedOrientation(o2, i4, e3), this.placedOrientations[e3.crossTileID] = i4), r4;
                    };
                    a3(() => r3(G3, t.al.horizontal), () => {
                      const i4 = d3.verticalTextBox;
                      return o2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i4 ? r3(i4, t.al.vertical) : { box: null, offscreen: null };
                    }), i3(k2 && k2.placeable);
                  } else {
                    let _4 = t.aB[null === (R3 = null === (P3 = this.prevPlacement) || void 0 === P3 ? void 0 : P3.variableOffsets[e3.crossTileID]) || void 0 === R3 ? void 0 : R3.anchor];
                    const m3 = (t2, i4, a4) => {
                      const d4 = t2.x2 - t2.x1, m4 = t2.y2 - t2.y1, f4 = e3.textBoxScale, v3 = T2 && "never" === x3 ? i4 : null;
                      let b4 = null, P4 = "never" === g3 ? 1 : 2, C4 = "never";
                      _4 && P4++;
                      for (let i5 = 0; i5 < P4; i5++) {
                        for (let i6 = c3; i6 < u3; i6++) {
                          const r3 = o2.textAnchorOffsets.get(i6);
                          if (_4 && r3.textAnchor !== _4) continue;
                          const c4 = this.attemptAnchorPlacement(r3, t2, d4, m4, f4, y2, w2, h3, I3, l2, p2, C4, e3, o2, a4, s2, n2, v3, E3);
                          if (c4 && (b4 = c4.placedGlyphBoxes, b4 && b4.placeable)) return z2 = true, L3 = c4.shift, b4;
                        }
                        _4 ? _4 = null : C4 = g3;
                      }
                      return r2 && !b4 && (b4 = { box: this.collisionIndex.placeCollisionBox(G3, "always", h3, I3, l2, w2, y2, s2, p2.predicate, E3, void 0, S3).box, offscreen: false, placeable: false, occluded: false }), b4;
                    };
                    a3(() => m3(G3, d3.iconBox, t.al.horizontal), () => {
                      const i4 = d3.verticalTextBox;
                      return o2.allowVerticalPlacement && (!k2 || !k2.placeable) && e3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, d3.verticalIconBox, t.al.vertical) : { box: null, occluded: true, offscreen: null };
                    }), k2 && (z2 = k2.placeable, A3 = k2.offscreen);
                    const f3 = i3(k2 && k2.placeable);
                    if (!z2 && this.prevPlacement) {
                      const t2 = this.prevPlacement.variableOffsets[e3.crossTileID];
                      t2 && (this.variableOffsets[e3.crossTileID] = t2, this.markUsedJustification(o2, t2.anchor, e3, f3));
                    }
                  }
                }
                if (B3 = k2, z2 = B3 && B3.placeable, A3 = B3 && B3.offscreen, e3.useRuntimeCollisionCircles) {
                  const i3 = o2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), n3 = t.am(o2.textSizeData, _3, i3), h4 = a2.get("text-padding");
                  O3 = this.collisionIndex.placeCollisionCircles(g3, i3, o2.lineVertexArray, o2.glyphOffsetArray, n3, l2, c2, r2, w2, p2.predicate, e3.collisionCircleDiameter, h4, s2, E3), O3.circles.length && O3.collisionDetected && !r2 && t.w("Collisions detected, but collision boxes are not shown"), z2 = v2 || O3.circles.length > 0 && !O3.collisionDetected, A3 = A3 && O3.offscreen;
                }
                if (d3.iconFeatureIndex && (U2 = d3.iconFeatureIndex), d3.iconBox) {
                  const e4 = (e5) => this.collisionIndex.placeCollisionBox(e5, x3, h3, I3, l2, w2, y2, n2, p2.predicate, E3, T2 && L3 ? L3 : void 0, S3);
                  F3 && F3.placeable && d3.verticalIconBox ? (j2 = e4(d3.verticalIconBox), D3 = j2.placeable) : (j2 = e4(d3.iconBox), D3 = j2.placeable), A3 = A3 && j2.offscreen;
                }
                const V3 = m2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, q3 = f2 || 0 === e3.numIconVertices;
                V3 || q3 ? q3 ? V3 || (D3 = D3 && z2) : z2 = D3 && z2 : D3 = z2 = D3 && z2;
                const W3 = D3 && j2.placeable;
                if (z2 && B3.placeable && this.collisionIndex.insertCollisionBox(B3.box, g3, a2.get("text-ignore-placement"), o2.bucketInstanceId, F3 && F3.placeable && N3 ? N3 : Z3, p2.ID), W3 && this.collisionIndex.insertCollisionBox(j2.box, x3, a2.get("icon-ignore-placement"), o2.bucketInstanceId, U2, p2.ID), O3 && z2 && this.collisionIndex.insertCollisionCircles(O3.circles, g3, a2.get("text-ignore-placement"), o2.bucketInstanceId, Z3, p2.ID), r2 && this.storeCollisionData(o2.bucketInstanceId, b3, d3, B3, j2, O3), 0 === e3.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === o2.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[e3.crossTileID] = new Qe2((z2 || C3) && !(null == B3 ? void 0 : B3.occluded), (D3 || M3) && !(null == j2 ? void 0 : j2.occluded), A3 || o2.justReloaded), i2[e3.crossTileID] = true;
              };
              if (P2) {
                if (0 !== e2.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
                const t2 = o2.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                  const i3 = t2[e3];
                  R2(o2.symbolInstances.get(i3), o2.collisionArrays[i3], i3);
                }
              } else for (let t2 = e2.symbolInstanceStart; t2 < e2.symbolInstanceEnd; t2++) R2(o2.symbolInstances.get(t2), o2.collisionArrays[t2], t2);
              o2.justReloaded = false;
            }
            storeCollisionData(e2, t2, i2, r2, o2, a2) {
              if (i2.textBox || i2.iconBox) {
                let a3, s2;
                this.collisionBoxArrays.has(e2) ? a3 = this.collisionBoxArrays.get(e2) : (a3 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e2, a3)), a3.has(t2) ? s2 = a3.get(t2) : (s2 = { text: null, icon: null }, a3.set(t2, s2)), i2.textBox && (s2.text = r2.box), i2.iconBox && (s2.icon = o2.box);
              }
              if (a2) {
                let t3 = this.collisionCircleArrays[e2];
                void 0 === t3 && (t3 = this.collisionCircleArrays[e2] = []);
                for (let e3 = 0; e3 < a2.circles.length; e3 += 4) t3.push(a2.circles[e3 + 0] - He2), t3.push(a2.circles[e3 + 1] - He2), t3.push(a2.circles[e3 + 2]), t3.push(a2.collisionDetected ? 1 : 0);
              }
            }
            markUsedJustification(e2, i2, r2, o2) {
              let a2;
              a2 = o2 === t.al.vertical ? r2.verticalPlacedTextSymbolIndex : { left: r2.leftJustifiedTextSymbolIndex, center: r2.centerJustifiedTextSymbolIndex, right: r2.rightJustifiedTextSymbolIndex }[t.aD(i2)];
              const s2 = [r2.leftJustifiedTextSymbolIndex, r2.centerJustifiedTextSymbolIndex, r2.rightJustifiedTextSymbolIndex, r2.verticalPlacedTextSymbolIndex];
              for (const t2 of s2) t2 >= 0 && (e2.text.placedSymbolArray.get(t2).crossTileID = a2 >= 0 && t2 !== a2 ? 0 : r2.crossTileID);
            }
            markUsedOrientation(e2, i2, r2) {
              const o2 = i2 === t.al.horizontal || i2 === t.al.horizontalOnly ? i2 : 0, a2 = i2 === t.al.vertical ? i2 : 0, s2 = [r2.leftJustifiedTextSymbolIndex, r2.centerJustifiedTextSymbolIndex, r2.rightJustifiedTextSymbolIndex];
              for (const t2 of s2) e2.text.placedSymbolArray.get(t2).placedOrientation = o2;
              r2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(r2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
            }
            commit(e2) {
              this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const t2 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
              const r2 = t2 ? t2.symbolFadeChange(e2) : 1, o2 = t2 ? t2.opacities : {}, a2 = t2 ? t2.variableOffsets : {}, s2 = t2 ? t2.placedOrientations : {};
              for (const e3 in this.placements) {
                const t3 = this.placements[e3], a3 = o2[e3];
                a3 ? (this.opacities[e3] = new Ke2(a3, r2, t3.text, t3.icon), i2 = i2 || t3.text !== a3.text.placed || t3.icon !== a3.icon.placed) : (this.opacities[e3] = new Ke2(null, r2, t3.text, t3.icon, t3.skipFade), i2 = i2 || t3.text || t3.icon);
              }
              for (const e3 in o2) {
                const t3 = o2[e3];
                if (!this.opacities[e3]) {
                  const o3 = new Ke2(t3, r2, false, false);
                  o3.isHidden() || (this.opacities[e3] = o3, i2 = i2 || t3.text.placed || t3.icon.placed);
                }
              }
              for (const e3 in a2) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = a2[e3]);
              for (const e3 in s2) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = s2[e3]);
              if (t2 && void 0 === t2.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
              i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
            }
            updateLayerOpacities(e2, t2) {
              const i2 = {};
              for (const r2 of t2) {
                const t3 = r2.getBucket(e2);
                t3 && r2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, r2.tileID, i2, r2.collisionBoxArray);
              }
            }
            updateBucketOpacities(e2, i2, r2, o2) {
              e2.hasTextData() && (e2.text.opacityVertexArray.clear(), e2.text.hasVisibleVertices = false), e2.hasIconData() && (e2.icon.opacityVertexArray.clear(), e2.icon.hasVisibleVertices = false), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
              const a2 = e2.layers[0], s2 = a2.layout, n2 = new Ke2(null, 0, false, false, true), l2 = s2.get("text-allow-overlap"), c2 = s2.get("icon-allow-overlap"), h3 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u2 = "map" === s2.get("text-rotation-alignment"), d2 = "map" === s2.get("text-pitch-alignment"), _3 = "none" !== s2.get("icon-text-fit"), p2 = new Ke2(null, 0, l2 && (c2 || !e2.hasIconData() || s2.get("icon-optional")), c2 && (l2 || !e2.hasTextData() || s2.get("text-optional")), true);
              !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
              const m2 = (e3, t2, i3) => {
                for (let r3 = 0; r3 < t2 / 4; r3++) e3.opacityVertexArray.emplaceBack(i3);
                e3.hasVisibleVertices = e3.hasVisibleVertices || i3 !== ut;
              }, f2 = this.collisionBoxArrays.get(e2.bucketInstanceId);
              for (let i3 = 0; i3 < e2.symbolInstances.length; i3++) {
                const o3 = e2.symbolInstances.get(i3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: s3, crossTileID: l3 } = o3;
                let c3 = this.opacities[l3];
                r2[l3] ? c3 = n2 : c3 || (c3 = p2, this.opacities[l3] = c3), r2[l3] = true;
                const g3 = o3.numIconVertices > 0, v2 = this.placedOrientations[o3.crossTileID], x3 = v2 === t.al.vertical, b2 = v2 === t.al.horizontal || v2 === t.al.horizontalOnly;
                if (a3 > 0 || s3 > 0) {
                  const t2 = ht2(c3.text);
                  m2(e2.text, a3, x3 ? ut : t2), m2(e2.text, s3, b2 ? ut : t2);
                  const i4 = c3.text.isHidden();
                  [o3.rightJustifiedTextSymbolIndex, o3.centerJustifiedTextSymbolIndex, o3.leftJustifiedTextSymbolIndex].forEach((t3) => {
                    t3 >= 0 && (e2.text.placedSymbolArray.get(t3).hidden = i4 || x3 ? 1 : 0);
                  }), o3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(o3.verticalPlacedTextSymbolIndex).hidden = i4 || b2 ? 1 : 0);
                  const r3 = this.variableOffsets[o3.crossTileID];
                  r3 && this.markUsedJustification(e2, r3.anchor, o3, v2);
                  const n3 = this.placedOrientations[o3.crossTileID];
                  n3 && (this.markUsedJustification(e2, "left", o3, n3), this.markUsedOrientation(e2, n3, o3));
                }
                if (g3) {
                  const t2 = ht2(c3.icon), i4 = !(_3 && o3.verticalPlacedIconSymbolIndex && x3);
                  o3.placedIconSymbolIndex >= 0 && (m2(e2.icon, o3.numIconVertices, i4 ? t2 : ut), e2.icon.placedSymbolArray.get(o3.placedIconSymbolIndex).hidden = c3.icon.isHidden()), o3.verticalPlacedIconSymbolIndex >= 0 && (m2(e2.icon, o3.numVerticalIconVertices, i4 ? ut : t2), e2.icon.placedSymbolArray.get(o3.verticalPlacedIconSymbolIndex).hidden = c3.icon.isHidden());
                }
                const y2 = f2 && f2.has(i3) ? f2.get(i3) : { text: null, icon: null };
                if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                  const r3 = e2.collisionArrays[i3];
                  if (r3) {
                    let i4 = new t.P(0, 0);
                    if (r3.textBox || r3.verticalTextBox) {
                      let t2 = true;
                      if (h3) {
                        const e3 = this.variableOffsets[l3];
                        e3 ? (i4 = et(e3.anchor, e3.width, e3.height, e3.textOffset, e3.textBoxScale), u2 && i4._rotate(d2 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t2 = false;
                      }
                      if (r3.textBox || r3.verticalTextBox) {
                        let o4;
                        r3.textBox && (o4 = x3), r3.verticalTextBox && (o4 = b2), it2(e2.textCollisionBox.collisionVertexArray, c3.text.placed, !t2 || o4, y2.text, i4.x, i4.y);
                      }
                    }
                    if (r3.iconBox || r3.verticalIconBox) {
                      const t2 = Boolean(!b2 && r3.verticalIconBox);
                      let o4;
                      r3.iconBox && (o4 = t2), r3.verticalIconBox && (o4 = !t2), it2(e2.iconCollisionBox.collisionVertexArray, c3.icon.placed, o4, y2.icon, _3 ? i4.x : 0, _3 ? i4.y : 0);
                    }
                  }
                }
              }
              if (e2.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.text.opacityVertexArray.length !== e2.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e2.text.layoutVertexArray.length}) / 4`);
              if (e2.icon.opacityVertexArray.length !== e2.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e2.icon.layoutVertexArray.length}) / 4`);
              e2.bucketInstanceId in this.collisionCircleArrays && (e2.collisionCircleArray = this.collisionCircleArrays[e2.bucketInstanceId], delete this.collisionCircleArrays[e2.bucketInstanceId]);
            }
            symbolFadeChange(e2) {
              return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e2) {
              return Math.max(0, (this.transform.zoom - e2) / 1.5);
            }
            hasTransitions(e2) {
              return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e2, t2) {
              const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
              return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function it2(e2, t2, i2, r2, o2, a2) {
            r2 && 0 !== r2.length || (r2 = [0, 0, 0, 0]);
            const s2 = r2[0] - He2, n2 = r2[1] - He2, l2 = r2[2] - He2, c2 = r2[3] - He2;
            e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, s2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, l2, n2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, l2, c2), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0, s2, c2);
          }
          const rt = Math.pow(2, 25), ot2 = Math.pow(2, 24), at2 = Math.pow(2, 17), st2 = Math.pow(2, 16), nt = Math.pow(2, 9), lt2 = Math.pow(2, 8), ct2 = Math.pow(2, 1);
          function ht2(e2) {
            if (0 === e2.opacity && !e2.placed) return 0;
            if (1 === e2.opacity && e2.placed) return 4294967295;
            const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
            return i2 * rt + t2 * ot2 + i2 * at2 + t2 * st2 + i2 * nt + t2 * lt2 + i2 * ct2 + t2;
          }
          const ut = 0;
          class dt2 {
            constructor(e2) {
              this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && !e2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(e2, t2, i2, r2, o2) {
              const a2 = this._bucketParts;
              for (; this._currentTileIndex < e2.length; ) if (t2.getBucketParts(a2, r2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o2()) return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < a2.length; ) if (t2.placeLayerBucketPart(a2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, o2()) return true;
              return false;
            }
          }
          class _t2 {
            constructor(e2, t2, i2, r2, o2, a2, s2, n2) {
              this.placement = new tt(e2, t2, a2, s2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = r2, this._showCollisionBoxes = o2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e2, t2, i2) {
              const r2 = s.now(), o2 = () => !this._forceFullPlacement && s.now() - r2 > 2;
              for (; this._currentPlacementIndex >= 0; ) {
                const r3 = t2[e2[this._currentPlacementIndex]], a2 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === r3.type && (!r3.minzoom || r3.minzoom <= a2) && (!r3.maxzoom || r3.maxzoom > a2)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new dt2(r3)), this._inProgressLayer.continuePlacement(i2[r3.source], this.placement, this._showCollisionBoxes, r3, o2)) return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(e2) {
              return this.placement.commit(e2), this.placement;
            }
          }
          const pt2 = 512 / t.Z / 2;
          class mt2 {
            constructor(e2, i2, r2) {
              this.tileID = e2, this.bucketInstanceId = r2, this._symbolsByKey = {};
              const o2 = /* @__PURE__ */ new Map();
              for (let e3 = 0; e3 < i2.length; e3++) {
                const t2 = i2.get(e3), r3 = t2.key, a2 = o2.get(r3);
                a2 ? a2.push(t2) : o2.set(r3, [t2]);
              }
              for (const [e3, i3] of o2) {
                const r3 = { positions: i3.map((e4) => ({ x: Math.floor(e4.anchorX * pt2), y: Math.floor(e4.anchorY * pt2) })), crossTileIDs: i3.map((e4) => e4.crossTileID) };
                if (r3.positions.length > 128) {
                  const e4 = new t.aF(r3.positions.length, 16, Uint16Array);
                  for (const { x: t2, y: i4 } of r3.positions) e4.add(t2, i4);
                  e4.finish(), delete r3.positions, r3.index = e4;
                }
                this._symbolsByKey[e3] = r3;
              }
            }
            getScaledCoordinates(e2, i2) {
              const { x: r2, y: o2, z: a2 } = this.tileID.canonical, { x: s2, y: n2, z: l2 } = i2.canonical, c2 = pt2 / Math.pow(2, l2 - a2), h3 = (n2 * t.Z + e2.anchorY) * c2, u2 = o2 * t.Z * pt2;
              return { x: Math.floor((s2 * t.Z + e2.anchorX) * c2 - r2 * t.Z * pt2), y: Math.floor(h3 - u2) };
            }
            findMatches(e2, t2, i2) {
              const r2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
              for (let o2 = 0; o2 < e2.length; o2++) {
                const a2 = e2.get(o2);
                if (a2.crossTileID) continue;
                const s2 = this._symbolsByKey[a2.key];
                if (!s2) continue;
                const n2 = this.getScaledCoordinates(a2, t2);
                if (s2.index) {
                  const e3 = s2.index.range(n2.x - r2, n2.y - r2, n2.x + r2, n2.y + r2).sort();
                  for (const t3 of e3) {
                    const e4 = s2.crossTileIDs[t3];
                    if (!i2[e4]) {
                      i2[e4] = true, a2.crossTileID = e4;
                      break;
                    }
                  }
                } else if (s2.positions) for (let e3 = 0; e3 < s2.positions.length; e3++) {
                  const t3 = s2.positions[e3], o3 = s2.crossTileIDs[e3];
                  if (Math.abs(t3.x - n2.x) <= r2 && Math.abs(t3.y - n2.y) <= r2 && !i2[o3]) {
                    i2[o3] = true, a2.crossTileID = o3;
                    break;
                  }
                }
              }
            }
            getCrossTileIDsLists() {
              return Object.values(this._symbolsByKey).map(({ crossTileIDs: e2 }) => e2);
            }
          }
          class ft2 {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class gt2 {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - this.lng) / 360);
              if (0 !== t2) for (const e3 in this.indexes) {
                const i2 = this.indexes[e3], r2 = {};
                for (const e4 in i2) {
                  const o2 = i2[e4];
                  o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t2), r2[o2.tileID.key] = o2;
                }
                this.indexes[e3] = r2;
              }
              this.lng = e2;
            }
            addBucket(e2, t2, i2) {
              if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
                if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId) return false;
                this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) t2.symbolInstances.get(e3).crossTileID = 0;
              this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
              const r2 = this.usedCrossTileIDs[e2.overscaledZ];
              for (const i3 in this.indexes) {
                const o2 = this.indexes[i3];
                if (Number(i3) > e2.overscaledZ) for (const i4 in o2) {
                  const a2 = o2[i4];
                  a2.tileID.isChildOf(e2) && a2.findMatches(t2.symbolInstances, e2, r2);
                }
                else {
                  const a2 = o2[e2.scaledTo(Number(i3)).key];
                  a2 && a2.findMatches(t2.symbolInstances, e2, r2);
                }
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
                const o2 = t2.symbolInstances.get(e3);
                o2.crossTileID || (o2.crossTileID = i2.generate(), r2[o2.crossTileID] = true);
              }
              return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new mt2(e2, t2.symbolInstances, t2.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(e2, t2) {
              for (const i2 of t2.getCrossTileIDsLists()) for (const t3 of i2) delete this.usedCrossTileIDs[e2][t3];
            }
            removeStaleBuckets(e2) {
              let t2 = false;
              for (const i2 in this.indexes) {
                const r2 = this.indexes[i2];
                for (const o2 in r2) e2[r2[o2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, r2[o2]), delete r2[o2], t2 = true);
              }
              return t2;
            }
          }
          class vt {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new ft2(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e2, t2, i2) {
              let r2 = this.layerIndexes[e2.id];
              void 0 === r2 && (r2 = this.layerIndexes[e2.id] = new gt2());
              let o2 = false;
              const a2 = {};
              r2.handleWrapJump(i2);
              for (const i3 of t2) {
                const t3 = i3.getBucket(e2);
                t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), r2.addBucket(i3.tileID, t3, this.crossTileIDs) && (o2 = true), a2[t3.bucketInstanceId] = true);
              }
              return r2.removeStaleBuckets(a2) && (o2 = true), o2;
            }
            pruneUnusedLayers(e2) {
              const t2 = {};
              e2.forEach((e3) => {
                t2[e3] = true;
              });
              for (const e3 in this.layerIndexes) t2[e3] || delete this.layerIndexes[e3];
            }
          }
          var xt2 = "void main() {fragColor=vec4(1.0);}";
          const bt2 = { prelude: yt2("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"), projectionMercator: yt2("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: yt2("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"), background: yt2("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: yt2("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: yt2("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: yt2(xt2, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: yt2("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"), heatmapTexture: yt2("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: yt2("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: yt2("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: yt2("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: yt2(xt2, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"), fill: yt2("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"), fillOutline: yt2("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillOutlinePattern: yt2("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillPattern: yt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: yt2("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: yt2("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: yt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: yt2("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;switch(u_method){case BASIC:\nbasic_hillshade(deriv);break;case COMBINED:\ncombined_hillshade(deriv);break;case IGOR:\nigor_hillshade(deriv);break;case MULTIDIRECTIONAL:\nmultidirectional_hillshade(deriv);break;case STANDARD:\ndefault:\nstandard_hillshade(deriv);break;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: yt2("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: yt2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: yt2("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: yt2("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: yt2("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: yt2("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: yt2("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: yt2("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: yt2("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: yt2("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: yt2("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: yt2("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: yt2("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: yt2("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
          function yt2(e2, t2) {
            const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r2 = t2.match(/in ([\w]+) ([\w]+)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = a2 ? a2.concat(o2) : o2, n2 = {};
            return { fragmentSource: e2 = e2.replace(i2, (e3, t3, i3, r3, o3) => (n2[o3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${o3}
in ${i3} ${r3} ${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = u_${o3};
#endif
`)), vertexSource: t2 = t2.replace(i2, (e3, t3, i3, r3, o3) => {
              const a3 = "float" === r3 ? "vec2" : "vec4", s3 = o3.match(/color/) ? "color" : a3;
              return n2[o3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${o3}
uniform lowp float u_${o3}_t;
in ${i3} ${a3} a_${o3};
out ${i3} ${r3} ${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${o3}
    ${o3} = a_${o3};
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o3}
    ${o3} = unpack_mix_${s3}(a_${o3}, u_${o3}_t);
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${o3}
uniform lowp float u_${o3}_t;
in ${i3} ${a3} a_${o3};
#else
uniform ${i3} ${r3} u_${o3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = a_${o3};
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o3}
    ${i3} ${r3} ${o3} = unpack_mix_${s3}(a_${o3}, u_${o3}_t);
#else
    ${i3} ${r3} ${o3} = u_${o3};
#endif
`;
            }), staticAttributes: r2, staticUniforms: s2 };
          }
          class wt2 {
            constructor(e2, t2, i2) {
              this.vertexBuffer = e2, this.indexBuffer = t2, this.segments = i2;
            }
            destroy() {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
            }
          }
          var Tt2 = t.aG([{ name: "a_pos", type: "Int16", components: 2 }]);
          const Pt = "#define PROJECTION_MERCATOR", Ct2 = "mercator";
          class Mt2 {
            constructor() {
              this._cachedMesh = null;
            }
            get name() {
              return "mercator";
            }
            get useSubdivision() {
              return false;
            }
            get shaderVariantName() {
              return Ct2;
            }
            get shaderDefine() {
              return Pt;
            }
            get shaderPreludeCode() {
              return bt2.projectionMercator;
            }
            get vertexShaderPreludeCode() {
              return bt2.projectionMercator.vertexSource;
            }
            get subdivisionGranularity() {
              return t.aH.noSubdivision;
            }
            get useGlobeControls() {
              return false;
            }
            get transitionState() {
              return 0;
            }
            get latitudeErrorCorrectionRadians() {
              return 0;
            }
            destroy() {
            }
            updateGPUdependent(e2) {
            }
            getMeshFromTileID(e2, i2, r2, o2, a2) {
              if (this._cachedMesh) return this._cachedMesh;
              const s2 = new t.aI();
              s2.emplaceBack(0, 0), s2.emplaceBack(t.Z, 0), s2.emplaceBack(0, t.Z), s2.emplaceBack(t.Z, t.Z);
              const n2 = e2.createVertexBuffer(s2, Tt2.members), l2 = t.aJ.simpleSegment(0, 0, 4, 2), c2 = new t.aK();
              c2.emplaceBack(1, 0, 2), c2.emplaceBack(1, 2, 3);
              const h3 = e2.createIndexBuffer(c2);
              return this._cachedMesh = new wt2(n2, h3, l2), this._cachedMesh;
            }
            recalculate() {
            }
            hasTransition() {
              return false;
            }
            setErrorQueryLatitudeDegrees(e2) {
            }
          }
          class It2 {
            constructor(e2 = 0, t2 = 0, i2 = 0, r2 = 0) {
              if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(r2) || r2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = e2, this.bottom = t2, this.left = i2, this.right = r2;
            }
            interpolate(e2, i2, r2) {
              return null != i2.top && null != e2.top && (this.top = t.B.number(e2.top, i2.top, r2)), null != i2.bottom && null != e2.bottom && (this.bottom = t.B.number(e2.bottom, i2.bottom, r2)), null != i2.left && null != e2.left && (this.left = t.B.number(e2.left, i2.left, r2)), null != i2.right && null != e2.right && (this.right = t.B.number(e2.right, i2.right, r2)), this;
            }
            getCenter(e2, i2) {
              const r2 = t.ae((this.left + e2 - this.right) / 2, 0, e2), o2 = t.ae((this.top + i2 - this.bottom) / 2, 0, i2);
              return new t.P(r2, o2);
            }
            equals(e2) {
              return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
            }
            clone() {
              return new It2(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          function Et2(e2, t2) {
            if (!e2.renderWorldCopies || e2.lngRange) return;
            const i2 = t2.lng - e2.center.lng;
            t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
          }
          function St2(e2) {
            return Math.max(0, Math.floor(e2));
          }
          class Rt2 {
            constructor(e2, i2, r2, o2, a2, s2) {
              this._callbacks = e2, this._tileSize = 512, this._renderWorldCopies = void 0 === s2 || !!s2, this._minZoom = i2 || 0, this._maxZoom = r2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == a2 ? 60 : a2, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = St2(this._zoom), this._scale = t.ac(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new It2(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
            }
            apply(e2, i2, r2) {
              this._latRange = e2.latRange, this._lngRange = e2.lngRange, this._width = e2.width, this._height = e2.height, this._center = e2.center, this._elevation = e2.elevation, this._minElevationForCurrentTile = e2.minElevationForCurrentTile, this._zoom = e2.zoom, this._tileZoom = St2(this._zoom), this._scale = t.ac(this._zoom), this._bearingInRadians = e2.bearingInRadians, this._fovInRadians = e2.fovInRadians, this._pitchInRadians = e2.pitchInRadians, this._rollInRadians = e2.rollInRadians, this._unmodified = e2.unmodified, this._edgeInsets = new It2(e2.padding.top, e2.padding.bottom, e2.padding.left, e2.padding.right), this._minZoom = e2.minZoom, this._maxZoom = e2.maxZoom, this._minPitch = e2.minPitch, this._maxPitch = e2.maxPitch, this._renderWorldCopies = e2.renderWorldCopies, this._cameraToCenterDistance = e2.cameraToCenterDistance, this._nearZ = e2.nearZ, this._farZ = e2.farZ, this._autoCalculateNearFarZ = !r2 && e2.autoCalculateNearFarZ, i2 && this._constrain(), this._calcMatrices();
            }
            get pixelsToClipSpaceMatrix() {
              return this._pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._clipSpaceToPixelsMatrix;
            }
            get minElevationForCurrentTile() {
              return this._minElevationForCurrentTile;
            }
            setMinElevationForCurrentTile(e2) {
              this._minElevationForCurrentTile = e2;
            }
            get tileSize() {
              return this._tileSize;
            }
            get tileZoom() {
              return this._tileZoom;
            }
            get scale() {
              return this._scale;
            }
            get width() {
              return this._width;
            }
            get height() {
              return this._height;
            }
            get bearingInRadians() {
              return this._bearingInRadians;
            }
            get lngRange() {
              return this._lngRange;
            }
            get latRange() {
              return this._latRange;
            }
            get pixelsToGLUnits() {
              return this._pixelsToGLUnits;
            }
            get minZoom() {
              return this._minZoom;
            }
            setMinZoom(e2) {
              this._minZoom !== e2 && (this._minZoom = e2, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            setMaxZoom(e2) {
              this._maxZoom !== e2 && (this._maxZoom = e2, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
            }
            get minPitch() {
              return this._minPitch;
            }
            setMinPitch(e2) {
              this._minPitch !== e2 && (this._minPitch = e2, this.setPitch(Math.max(this.pitch, e2)));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            setMaxPitch(e2) {
              this._maxPitch !== e2 && (this._maxPitch = e2, this.setPitch(Math.min(this.pitch, e2)));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            setRenderWorldCopies(e2) {
              void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
            }
            get worldSize() {
              return this._tileSize * this._scale;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t.P(this._width, this._height);
            }
            get bearing() {
              return this._bearingInRadians / Math.PI * 180;
            }
            setBearing(e2) {
              const i2 = t.aL(e2, -180, 180) * Math.PI / 180;
              var o2, a2, s2, n2, l2, c2, h3, u2, d2;
              this._bearingInRadians !== i2 && (this._unmodified = false, this._bearingInRadians = i2, this._calcMatrices(), this._rotationMatrix = r(), o2 = this._rotationMatrix, s2 = -this._bearingInRadians, n2 = (a2 = this._rotationMatrix)[0], l2 = a2[1], c2 = a2[2], h3 = a2[3], u2 = Math.sin(s2), d2 = Math.cos(s2), o2[0] = n2 * d2 + c2 * u2, o2[1] = l2 * d2 + h3 * u2, o2[2] = n2 * -u2 + c2 * d2, o2[3] = l2 * -u2 + h3 * d2);
            }
            get rotationMatrix() {
              return this._rotationMatrix;
            }
            get pitchInRadians() {
              return this._pitchInRadians;
            }
            get pitch() {
              return this._pitchInRadians / Math.PI * 180;
            }
            setPitch(e2) {
              const i2 = t.ae(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitchInRadians !== i2 && (this._unmodified = false, this._pitchInRadians = i2, this._calcMatrices());
            }
            get rollInRadians() {
              return this._rollInRadians;
            }
            get roll() {
              return this._rollInRadians / Math.PI * 180;
            }
            setRoll(e2) {
              const t2 = e2 / 180 * Math.PI;
              this._rollInRadians !== t2 && (this._unmodified = false, this._rollInRadians = t2, this._calcMatrices());
            }
            get fovInRadians() {
              return this._fovInRadians;
            }
            get fov() {
              return t.aM(this._fovInRadians);
            }
            setFov(e2) {
              e2 = t.ae(e2, 0.1, 150), this.fov !== e2 && (this._unmodified = false, this._fovInRadians = t.ab(e2), this._calcMatrices());
            }
            get zoom() {
              return this._zoom;
            }
            setZoom(e2) {
              const i2 = this.getConstrained(this._center, e2).zoom;
              this._zoom !== i2 && (this._unmodified = false, this._zoom = i2, this._tileZoom = Math.max(0, Math.floor(i2)), this._scale = t.ac(i2), this._constrain(), this._calcMatrices());
            }
            get center() {
              return this._center;
            }
            setCenter(e2) {
              e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._constrain(), this._calcMatrices());
            }
            get elevation() {
              return this._elevation;
            }
            setElevation(e2) {
              e2 !== this._elevation && (this._elevation = e2, this._constrain(), this._calcMatrices());
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            setPadding(e2) {
              this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this._width, this._height);
            }
            get pixelsPerMeter() {
              return this._pixelPerMeter;
            }
            get unmodified() {
              return this._unmodified;
            }
            get cameraToCenterDistance() {
              return this._cameraToCenterDistance;
            }
            get nearZ() {
              return this._nearZ;
            }
            get farZ() {
              return this._farZ;
            }
            get autoCalculateNearFarZ() {
              return this._autoCalculateNearFarZ;
            }
            overrideNearFarZ(e2, t2) {
              this._autoCalculateNearFarZ = false, this._nearZ = e2, this._farZ = t2, this._calcMatrices();
            }
            clearNearFarZOverride() {
              this._autoCalculateNearFarZ = true, this._calcMatrices();
            }
            isPaddingEqual(e2) {
              return this._edgeInsets.equals(e2);
            }
            interpolatePadding(e2, t2, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
            }
            resize(e2, t2, i2 = true) {
              this._width = e2, this._height = t2, i2 && this._constrain(), this._calcMatrices();
            }
            getMaxBounds() {
              return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new V2([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
            }
            setMaxBounds(e2) {
              e2 ? (this._lngRange = [e2.getWest(), e2.getEast()], this._latRange = [e2.getSouth(), e2.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, t.af]);
            }
            getConstrained(e2, t2) {
              return this._callbacks.getConstrained(e2, t2);
            }
            getCameraQueryGeometry(e2, i2) {
              if (1 === i2.length) return [i2[0], e2];
              {
                let r2 = e2.x, o2 = e2.y, a2 = e2.x, s2 = e2.y;
                for (const e3 of i2) r2 = Math.min(r2, e3.x), o2 = Math.min(o2, e3.y), a2 = Math.max(a2, e3.x), s2 = Math.max(s2, e3.y);
                return [new t.P(r2, o2), new t.P(a2, o2), new t.P(a2, s2), new t.P(r2, s2), new t.P(r2, o2)];
              }
            }
            _constrain() {
              if (!this.center || !this._width || !this._height || this._constraining) return;
              this._constraining = true;
              const e2 = this._unmodified, { center: t2, zoom: i2 } = this.getConstrained(this.center, this.zoom);
              this.setCenter(t2), this.setZoom(i2), this._unmodified = e2, this._constraining = false;
            }
            _calcMatrices() {
              if (this._width && this._height) {
                this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                let e2 = t.ad(new Float64Array(16));
                t.M(e2, e2, [this._width / 2, -this._height / 2, 1]), t.L(e2, e2, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e2, e2 = t.ad(new Float64Array(16)), t.M(e2, e2, [1, -1, 1]), t.L(e2, e2, [-1, -1, 0]), t.M(e2, e2, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e2, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
              }
              this._callbacks.calcMatrices();
            }
            calculateCenterFromCameraLngLatAlt(e2, i2, r2, o2) {
              const a2 = void 0 !== r2 ? r2 : this.bearing, s2 = o2 = void 0 !== o2 ? o2 : this.pitch, n2 = t.$.fromLngLat(e2, i2), l2 = -Math.cos(t.ab(s2)), c2 = Math.sin(t.ab(s2)), h3 = c2 * Math.sin(t.ab(a2)), u2 = -c2 * Math.cos(t.ab(a2));
              let d2 = this.elevation;
              const _3 = i2 - d2;
              let p2;
              l2 * _3 >= 0 || Math.abs(l2) < 0.1 ? (p2 = 1e4, d2 = i2 + p2 * l2) : p2 = -_3 / l2;
              let m2, f2, g3 = t.aN(1, n2.y), v2 = 0;
              do {
                if (v2 += 1, v2 > 10) break;
                f2 = p2 / g3, m2 = new t.$(n2.x + h3 * f2, n2.y + u2 * f2), g3 = 1 / m2.meterInMercatorCoordinateUnits();
              } while (Math.abs(p2 - f2 * g3) > 1e-12);
              return { center: m2.toLngLat(), elevation: d2, zoom: t.ah(this.height / 2 / Math.tan(this.fovInRadians / 2) / f2 / this.tileSize) };
            }
            recalculateZoomAndCenter(e2) {
              if (this.elevation - e2 == 0) return;
              const i2 = t.ag(1, this.center.lat) * this.worldSize, r2 = this.cameraToCenterDistance / i2, o2 = t.$.fromLngLat(this.center, this.elevation), a2 = _e2(this.center, this.elevation, this.pitch, this.bearing, r2);
              this._elevation = e2;
              const s2 = this.calculateCenterFromCameraLngLatAlt(a2.toLngLat(), t.aN(a2.z, o2.y), this.bearing, this.pitch);
              this._elevation = s2.elevation, this._center = s2.center, this.setZoom(s2.zoom);
            }
            getCameraPoint() {
              const e2 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t.P(e2 * Math.sin(this.rollInRadians), e2 * Math.cos(this.rollInRadians)));
            }
            getCameraAltitude() {
              return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
            }
            getCameraLngLat() {
              const e2 = t.ag(1, this.center.lat) * this.worldSize;
              return _e2(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e2).toLngLat();
            }
            getMercatorTileCoordinates(e2) {
              if (!e2) return [0, 0, 1, 1];
              const i2 = e2.canonical.z >= 0 ? 1 << e2.canonical.z : Math.pow(2, e2.canonical.z);
              return [e2.canonical.x / i2, e2.canonical.y / i2, 1 / i2 / t.Z, 1 / i2 / t.Z];
            }
          }
          class zt2 {
            constructor(e2, i2) {
              this.min = e2, this.max = i2, this.center = t.aO([], t.aP([], this.min, this.max), 0.5);
            }
            quadrant(e2) {
              const i2 = [e2 % 2 == 0, e2 < 2], r2 = t.aQ(this.min), o2 = t.aQ(this.max);
              for (let e3 = 0; e3 < i2.length; e3++) r2[e3] = i2[e3] ? this.min[e3] : this.center[e3], o2[e3] = i2[e3] ? this.center[e3] : this.max[e3];
              return o2[2] = this.max[2], new zt2(r2, o2);
            }
            distanceX(e2) {
              return Math.max(Math.min(this.max[0], e2[0]), this.min[0]) - e2[0];
            }
            distanceY(e2) {
              return Math.max(Math.min(this.max[1], e2[1]), this.min[1]) - e2[1];
            }
            intersectsFrustum(e2) {
              let t2 = true;
              for (let i2 = 0; i2 < e2.planes.length; i2++) {
                const r2 = this.intersectsPlane(e2.planes[i2]);
                if (0 === r2) return 0;
                1 === r2 && (t2 = false);
              }
              return t2 ? 2 : e2.aabb.min[0] > this.max[0] || e2.aabb.min[1] > this.max[1] || e2.aabb.min[2] > this.max[2] || e2.aabb.max[0] < this.min[0] || e2.aabb.max[1] < this.min[1] || e2.aabb.max[2] < this.min[2] ? 0 : 1;
            }
            intersectsPlane(e2) {
              let t2 = e2[3], i2 = e2[3];
              for (let r2 = 0; r2 < 3; r2++) e2[r2] > 0 ? (t2 += e2[r2] * this.min[r2], i2 += e2[r2] * this.max[r2]) : (i2 += e2[r2] * this.min[r2], t2 += e2[r2] * this.max[r2]);
              return t2 >= 0 ? 2 : i2 < 0 ? 0 : 1;
            }
          }
          class Dt2 {
            distanceToTile2d(e2, t2, i2, r2) {
              const o2 = r2.distanceX([e2, t2]), a2 = r2.distanceY([e2, t2]);
              return Math.hypot(o2, a2);
            }
            getWrap(e2, t2, i2) {
              return i2;
            }
            getTileAABB(e2, i2, r2, o2) {
              var a2, s2;
              let n2 = r2, l2 = r2;
              if (o2.terrain) {
                const c3 = new t.Y(e2.z, i2, e2.z, e2.x, e2.y), h3 = o2.terrain.getMinMaxElevation(c3);
                n2 = null !== (a2 = h3.minElevation) && void 0 !== a2 ? a2 : r2, l2 = null !== (s2 = h3.maxElevation) && void 0 !== s2 ? s2 : r2;
              }
              const c2 = 1 << e2.z;
              return new zt2([i2 + e2.x / c2, e2.y / c2, n2], [i2 + (e2.x + 1) / c2, (e2.y + 1) / c2, l2]);
            }
            allowVariableZoom(e2, i2) {
              const r2 = e2.fov * (Math.abs(Math.cos(e2.rollInRadians)) * e2.height + Math.abs(Math.sin(e2.rollInRadians)) * e2.width) / e2.height, o2 = t.ae(78.5 - r2 / 2, 0, 60);
              return !!i2.terrain || e2.pitch > o2;
            }
            allowWorldCopies() {
              return true;
            }
            recalculateCache() {
            }
          }
          class At2 {
            constructor(e2, t2, i2) {
              this.points = e2, this.planes = t2, this.aabb = i2;
            }
            static fromInvProjectionMatrix(e2, i2 = 1, r2 = 0) {
              const o2 = Math.pow(2, r2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
                const a3 = 1 / (r3 = t.at([], r3, e2))[3] / i2 * o2;
                return t.aR(r3, r3, [a3, a3, 1 / r3[3], a3]);
              }), s2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e3) => {
                const i3 = t.aS([], a2[e3[0]], a2[e3[1]]), r3 = t.aS([], a2[e3[2]], a2[e3[1]]), o3 = t.aT([], t.aU([], i3, r3)), s3 = -t.aV(o3, a2[e3[1]]);
                return o3.concat(s3);
              }), n2 = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], l2 = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
              for (const e3 of a2) for (let t2 = 0; t2 < 3; t2++) n2[t2] = Math.min(n2[t2], e3[t2]), l2[t2] = Math.max(l2[t2], e3[t2]);
              return new At2(a2, s2, new zt2(n2, l2));
            }
          }
          class Lt2 {
            get pixelsToClipSpaceMatrix() {
              return this._helper.pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._helper.clipSpaceToPixelsMatrix;
            }
            get pixelsToGLUnits() {
              return this._helper.pixelsToGLUnits;
            }
            get centerOffset() {
              return this._helper.centerOffset;
            }
            get size() {
              return this._helper.size;
            }
            get rotationMatrix() {
              return this._helper.rotationMatrix;
            }
            get centerPoint() {
              return this._helper.centerPoint;
            }
            get pixelsPerMeter() {
              return this._helper.pixelsPerMeter;
            }
            setMinZoom(e2) {
              this._helper.setMinZoom(e2);
            }
            setMaxZoom(e2) {
              this._helper.setMaxZoom(e2);
            }
            setMinPitch(e2) {
              this._helper.setMinPitch(e2);
            }
            setMaxPitch(e2) {
              this._helper.setMaxPitch(e2);
            }
            setRenderWorldCopies(e2) {
              this._helper.setRenderWorldCopies(e2);
            }
            setBearing(e2) {
              this._helper.setBearing(e2);
            }
            setPitch(e2) {
              this._helper.setPitch(e2);
            }
            setRoll(e2) {
              this._helper.setRoll(e2);
            }
            setFov(e2) {
              this._helper.setFov(e2);
            }
            setZoom(e2) {
              this._helper.setZoom(e2);
            }
            setCenter(e2) {
              this._helper.setCenter(e2);
            }
            setElevation(e2) {
              this._helper.setElevation(e2);
            }
            setMinElevationForCurrentTile(e2) {
              this._helper.setMinElevationForCurrentTile(e2);
            }
            setPadding(e2) {
              this._helper.setPadding(e2);
            }
            interpolatePadding(e2, t2, i2) {
              return this._helper.interpolatePadding(e2, t2, i2);
            }
            isPaddingEqual(e2) {
              return this._helper.isPaddingEqual(e2);
            }
            resize(e2, t2, i2 = true) {
              this._helper.resize(e2, t2, i2);
            }
            getMaxBounds() {
              return this._helper.getMaxBounds();
            }
            setMaxBounds(e2) {
              this._helper.setMaxBounds(e2);
            }
            overrideNearFarZ(e2, t2) {
              this._helper.overrideNearFarZ(e2, t2);
            }
            clearNearFarZOverride() {
              this._helper.clearNearFarZOverride();
            }
            getCameraQueryGeometry(e2) {
              return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
            }
            get tileSize() {
              return this._helper.tileSize;
            }
            get tileZoom() {
              return this._helper.tileZoom;
            }
            get scale() {
              return this._helper.scale;
            }
            get worldSize() {
              return this._helper.worldSize;
            }
            get width() {
              return this._helper.width;
            }
            get height() {
              return this._helper.height;
            }
            get lngRange() {
              return this._helper.lngRange;
            }
            get latRange() {
              return this._helper.latRange;
            }
            get minZoom() {
              return this._helper.minZoom;
            }
            get maxZoom() {
              return this._helper.maxZoom;
            }
            get zoom() {
              return this._helper.zoom;
            }
            get center() {
              return this._helper.center;
            }
            get minPitch() {
              return this._helper.minPitch;
            }
            get maxPitch() {
              return this._helper.maxPitch;
            }
            get pitch() {
              return this._helper.pitch;
            }
            get pitchInRadians() {
              return this._helper.pitchInRadians;
            }
            get roll() {
              return this._helper.roll;
            }
            get rollInRadians() {
              return this._helper.rollInRadians;
            }
            get bearing() {
              return this._helper.bearing;
            }
            get bearingInRadians() {
              return this._helper.bearingInRadians;
            }
            get fov() {
              return this._helper.fov;
            }
            get fovInRadians() {
              return this._helper.fovInRadians;
            }
            get elevation() {
              return this._helper.elevation;
            }
            get minElevationForCurrentTile() {
              return this._helper.minElevationForCurrentTile;
            }
            get padding() {
              return this._helper.padding;
            }
            get unmodified() {
              return this._helper.unmodified;
            }
            get renderWorldCopies() {
              return this._helper.renderWorldCopies;
            }
            get cameraToCenterDistance() {
              return this._helper.cameraToCenterDistance;
            }
            get nearZ() {
              return this._helper.nearZ;
            }
            get farZ() {
              return this._helper.farZ;
            }
            get autoCalculateNearFarZ() {
              return this._helper.autoCalculateNearFarZ;
            }
            setTransitionState(e2, t2) {
            }
            constructor(e2, t2, i2, r2, o2) {
              this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Rt2({ calcMatrices: () => {
                this._calcMatrices();
              }, getConstrained: (e3, t3) => this.getConstrained(e3, t3) }, e2, t2, i2, r2, o2), this._coveringTilesDetailsProvider = new Dt2();
            }
            clone() {
              const e2 = new Lt2();
              return e2.apply(this), e2;
            }
            apply(e2, t2, i2) {
              this._helper.apply(e2, t2, i2);
            }
            get cameraPosition() {
              return this._cameraPosition;
            }
            get projectionMatrix() {
              return this._projectionMatrix;
            }
            get modelViewProjectionMatrix() {
              return this._viewProjMatrix;
            }
            get inverseProjectionMatrix() {
              return this._invProjMatrix;
            }
            get mercatorMatrix() {
              return this._mercatorMatrix;
            }
            getVisibleUnwrappedCoordinates(e2) {
              const i2 = [new t.aW(0, e2)];
              if (this._helper._renderWorldCopies) {
                const r2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), o2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), a2 = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s2 = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n2 = Math.floor(Math.min(r2.x, o2.x, a2.x, s2.x)), l2 = Math.floor(Math.max(r2.x, o2.x, a2.x, s2.x)), c2 = 1;
                for (let r3 = n2 - c2; r3 <= l2 + c2; r3++) 0 !== r3 && i2.push(new t.aW(r3, e2));
              }
              return i2;
            }
            getCameraFrustum() {
              return At2.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
            }
            getClippingPlane() {
              return null;
            }
            getCoveringTilesDetailsProvider() {
              return this._coveringTilesDetailsProvider;
            }
            recalculateZoomAndCenter(e2) {
              const t2 = this.screenPointToLocation(this.centerPoint, e2), i2 = e2 ? e2.getElevationForLngLatZoom(t2, this._helper._tileZoom) : 0;
              this._helper.recalculateZoomAndCenter(i2);
            }
            setLocationAtPoint(e2, i2) {
              const r2 = t.ag(this.elevation, this.center.lat), o2 = this.screenPointToMercatorCoordinateAtZ(i2, r2), a2 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r2), s2 = t.$.fromLngLat(e2), n2 = new t.$(s2.x - (o2.x - a2.x), s2.y - (o2.y - a2.y));
              this.setCenter(null == n2 ? void 0 : n2.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
            }
            locationToScreenPoint(e2, i2) {
              return i2 ? this.coordinatePoint(t.$.fromLngLat(e2), i2.getElevationForLngLatZoom(e2, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.$.fromLngLat(e2));
            }
            screenPointToLocation(e2, t2) {
              var i2;
              return null === (i2 = this.screenPointToMercatorCoordinate(e2, t2)) || void 0 === i2 ? void 0 : i2.toLngLat();
            }
            screenPointToMercatorCoordinate(e2, t2) {
              if (t2) {
                const i2 = t2.pointCoordinate(e2);
                if (null != i2) return i2;
              }
              return this.screenPointToMercatorCoordinateAtZ(e2);
            }
            screenPointToMercatorCoordinateAtZ(e2, i2) {
              const r2 = i2 || 0, o2 = [e2.x, e2.y, 0, 1], a2 = [e2.x, e2.y, 1, 1];
              t.at(o2, o2, this._pixelMatrixInverse), t.at(a2, a2, this._pixelMatrixInverse);
              const s2 = o2[3], n2 = a2[3], l2 = o2[1] / s2, c2 = a2[1] / n2, h3 = o2[2] / s2, u2 = a2[2] / n2, d2 = h3 === u2 ? 0 : (r2 - h3) / (u2 - h3);
              return new t.$(t.B.number(o2[0] / s2, a2[0] / n2, d2) / this.worldSize, t.B.number(l2, c2, d2) / this.worldSize, r2);
            }
            coordinatePoint(e2, i2 = 0, r2 = this._pixelMatrix) {
              const o2 = [e2.x * this.worldSize, e2.y * this.worldSize, i2, 1];
              return t.at(o2, o2, r2), new t.P(o2[0] / o2[3], o2[1] / o2[3]);
            }
            getBounds() {
              const e2 = Math.max(0, this._helper._height / 2 - ue2(this));
              return new V2().extend(this.screenPointToLocation(new t.P(0, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, e2))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
            }
            isPointOnMapSurface(e2, t2) {
              return t2 ? null != t2.pointCoordinate(e2) : e2.y > this.height / 2 - ue2(this);
            }
            calculatePosMatrix(e2, i2 = false, r2) {
              var o2;
              const a2 = null !== (o2 = e2.key) && void 0 !== o2 ? o2 : t.aX(e2.wrap, e2.canonical.z, e2.canonical.z, e2.canonical.x, e2.canonical.y), s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
              if (s2.has(a2)) {
                const e3 = s2.get(a2);
                return r2 ? e3.f32 : e3.f64;
              }
              const n2 = de2(e2, this.worldSize);
              t.N(n2, i2 ? this._alignedProjMatrix : this._viewProjMatrix, n2);
              const l2 = { f64: n2, f32: new Float32Array(n2) };
              return s2.set(a2, l2), r2 ? l2.f32 : l2.f64;
            }
            calculateFogMatrix(e2) {
              const i2 = e2.key, r2 = this._fogMatrixCacheF32;
              if (r2.has(i2)) return r2.get(i2);
              const o2 = de2(e2, this.worldSize);
              return t.N(o2, this._fogMatrix, o2), r2.set(i2, new Float32Array(o2)), r2.get(i2);
            }
            getConstrained(e2, i2) {
              i2 = t.ae(+i2, this.minZoom, this.maxZoom);
              const r2 = { center: new t.Q(e2.lng, e2.lat), zoom: i2 };
              let o2 = this._helper._lngRange;
              this._helper._renderWorldCopies || null !== o2 || (o2 = [-179.9999999999, 180 - 1e-10]);
              const a2 = this.tileSize * t.ac(r2.zoom);
              let s2 = 0, n2 = a2, l2 = 0, c2 = a2, h3 = 0, u2 = 0;
              const { x: d2, y: _3 } = this.size;
              if (this._helper._latRange) {
                const e3 = this._helper._latRange;
                s2 = t.S(e3[1]) * a2, n2 = t.S(e3[0]) * a2, n2 - s2 < _3 && (h3 = _3 / (n2 - s2));
              }
              o2 && (l2 = t.aL(t.U(o2[0]) * a2, 0, a2), c2 = t.aL(t.U(o2[1]) * a2, 0, a2), c2 < l2 && (c2 += a2), c2 - l2 < d2 && (u2 = d2 / (c2 - l2)));
              const { x: p2, y: m2 } = ce2(a2, e2);
              let f2, g3;
              const v2 = Math.max(u2 || 0, h3 || 0);
              if (v2) {
                const e3 = new t.P(u2 ? (c2 + l2) / 2 : p2, h3 ? (n2 + s2) / 2 : m2);
                return r2.center = he2(a2, e3).wrap(), r2.zoom += t.ah(v2), r2;
              }
              if (this._helper._latRange) {
                const e3 = _3 / 2;
                m2 - e3 < s2 && (g3 = s2 + e3), m2 + e3 > n2 && (g3 = n2 - e3);
              }
              if (o2) {
                const e3 = (l2 + c2) / 2;
                let i3 = p2;
                this._helper._renderWorldCopies && (i3 = t.aL(p2, e3 - a2 / 2, e3 + a2 / 2));
                const r3 = d2 / 2;
                i3 - r3 < l2 && (f2 = l2 + r3), i3 + r3 > c2 && (f2 = c2 - r3);
              }
              if (void 0 !== f2 || void 0 !== g3) {
                const e3 = new t.P(null != f2 ? f2 : p2, null != g3 ? g3 : m2);
                r2.center = he2(a2, e3).wrap();
              }
              return r2;
            }
            calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2) {
              return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
            }
            _calculateNearFarZIfNeeded(e2, i2, r2) {
              if (!this._helper.autoCalculateNearFarZ) return;
              const o2 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a2 = e2 - o2 * this._helper._pixelPerMeter / Math.cos(i2), s2 = o2 < 0 ? a2 : e2, n2 = Math.PI / 2 + this.pitchInRadians, l2 = t.ab(this.fov) * (Math.abs(Math.cos(t.ab(this.roll))) * this.height + Math.abs(Math.sin(t.ab(this.roll))) * this.width) / this.height * (0.5 + r2.y / this.height), c2 = Math.sin(l2) * s2 / Math.sin(t.ae(Math.PI - n2 - l2, 0.01, Math.PI - 0.01)), h3 = ue2(this), u2 = Math.atan(h3 / this._helper.cameraToCenterDistance), d2 = t.ab(0.75), _3 = u2 > d2 ? 2 * u2 * (0.5 + r2.y / (2 * h3)) : d2, p2 = Math.sin(_3) * s2 / Math.sin(t.ae(Math.PI - n2 - _3, 0.01, Math.PI - 0.01)), m2 = Math.min(c2, p2);
              this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i2) * m2 + s2), this._helper._nearZ = this._helper._height / 50;
            }
            _calcMatrices() {
              if (!this._helper._height) return;
              const e2 = this.centerOffset, i2 = ce2(this.worldSize, this.center), r2 = i2.x, o2 = i2.y;
              this._helper._pixelPerMeter = t.ag(1, this.center.lat) * this.worldSize;
              const a2 = t.ab(Math.min(this.pitch, le2)), s2 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a2));
              let n2;
              this._calculateNearFarZIfNeeded(s2, a2, e2), n2 = new Float64Array(16), t.aY(n2, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.an(this._invProjMatrix, n2), n2[8] = 2 * -e2.x / this._helper._width, n2[9] = 2 * e2.y / this._helper._height, this._projectionMatrix = t.aZ(n2), t.M(n2, n2, [1, -1, 1]), t.L(n2, n2, [0, 0, -this._helper.cameraToCenterDistance]), t.a_(n2, n2, -this.rollInRadians), t.a$(n2, n2, this.pitchInRadians), t.a_(n2, n2, -this.bearingInRadians), t.L(n2, n2, [-r2, -o2, 0]), this._mercatorMatrix = t.M([], n2, [this.worldSize, this.worldSize, this.worldSize]), t.M(n2, n2, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2), t.L(n2, n2, [0, 0, -this.elevation]), this._viewProjMatrix = n2, this._invViewProjMatrix = t.an([], n2);
              const l2 = [0, 0, -1, 1];
              t.at(l2, l2, this._invViewProjMatrix), this._cameraPosition = [l2[0] / l2[3], l2[1] / l2[3], l2[2] / l2[3]], this._fogMatrix = new Float64Array(16), t.aY(this._fogMatrix, this.fovInRadians, this.width / this.height, s2, this._helper._farZ), this._fogMatrix[8] = 2 * -e2.x / this.width, this._fogMatrix[9] = 2 * e2.y / this.height, t.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t.a_(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.a$(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.a_(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.L(this._fogMatrix, this._fogMatrix, [-r2, -o2, 0]), t.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n2);
              const c2 = this._helper._width % 2 / 2, h3 = this._helper._height % 2 / 2, u2 = Math.cos(this.bearingInRadians), d2 = Math.sin(-this.bearingInRadians), _3 = r2 - Math.round(r2) + u2 * c2 + d2 * h3, p2 = o2 - Math.round(o2) + u2 * h3 + d2 * c2, m2 = new Float64Array(n2);
              if (t.L(m2, m2, [_3 > 0.5 ? _3 - 1 : _3, p2 > 0.5 ? p2 - 1 : p2, 0]), this._alignedProjMatrix = m2, n2 = t.an(new Float64Array(16), this._pixelMatrix), !n2) throw new Error("failed to invert matrix");
              this._pixelMatrixInverse = n2, this._clearMatrixCaches();
            }
            _clearMatrixCaches() {
              this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
            }
            maxPitchScaleFactor() {
              if (!this._pixelMatrixInverse) return 1;
              const e2 = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
              return t.at(i2, i2, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
            }
            getCameraPoint() {
              return this._helper.getCameraPoint();
            }
            getCameraAltitude() {
              return this._helper.getCameraAltitude();
            }
            getCameraLngLat() {
              const e2 = t.ag(1, this.center.lat) * this.worldSize;
              return _e2(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e2).toLngLat();
            }
            lngLatToCameraDepth(e2, i2) {
              const r2 = t.$.fromLngLat(e2), o2 = [r2.x * this.worldSize, r2.y * this.worldSize, i2, 1];
              return t.at(o2, o2, this._viewProjMatrix), o2[2] / o2[3];
            }
            getProjectionData(e2) {
              const { overscaledTileID: i2, aligned: r2, applyTerrainMatrix: o2 } = e2, a2 = this._helper.getMercatorTileCoordinates(i2), s2 = i2 ? this.calculatePosMatrix(i2, r2, true) : null;
              let n2;
              return n2 = i2 && i2.terrainRttPosMatrix32f && o2 ? i2.terrainRttPosMatrix32f : s2 || t.b0(), { mainMatrix: n2, tileMercatorCoords: a2, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n2 };
            }
            isLocationOccluded(e2) {
              return false;
            }
            getPixelScale() {
              return 1;
            }
            getCircleRadiusCorrection() {
              return 1;
            }
            getPitchedTextCorrection(e2, t2, i2) {
              return 1;
            }
            transformLightDirection(e2) {
              return t.aQ(e2);
            }
            getRayDirectionFromPixel(e2) {
              throw new Error("Not implemented.");
            }
            projectTileCoordinates(e2, i2, r2, o2) {
              const a2 = this.calculatePosMatrix(r2);
              let s2;
              o2 ? (s2 = [e2, i2, o2(e2, i2), 1], t.at(s2, s2, a2)) : (s2 = [e2, i2, 0, 1], We2(s2, s2, a2));
              const n2 = s2[3];
              return { point: new t.P(s2[0] / n2, s2[1] / n2), signedDistanceFromCamera: n2, isOccluded: false };
            }
            populateCache(e2) {
              for (const t2 of e2) this.calculatePosMatrix(t2);
            }
            getMatrixForModel(e2, i2) {
              const r2 = t.$.fromLngLat(e2, i2), o2 = r2.meterInMercatorCoordinateUnits(), a2 = t.b1();
              return t.L(a2, a2, [r2.x, r2.y, r2.z]), t.a_(a2, a2, Math.PI), t.a$(a2, a2, Math.PI / 2), t.M(a2, a2, [-o2, o2, o2]), a2;
            }
            getProjectionDataForCustomLayer(e2 = true) {
              const i2 = new t.Y(0, 0, 0, 0, 0), r2 = this.getProjectionData({ overscaledTileID: i2, applyGlobeMatrix: e2 }), o2 = de2(i2, this.worldSize);
              t.N(o2, this._viewProjMatrix, o2), r2.tileMercatorCoords = [0, 0, 1, 1];
              const a2 = [t.Z, t.Z, this.worldSize / this._helper.pixelsPerMeter], s2 = t.b2();
              return t.M(s2, o2, a2), r2.fallbackMatrix = s2, r2.mainMatrix = s2, r2;
            }
            getFastPathSimpleProjectionMatrix(e2) {
              return this.calculatePosMatrix(e2);
            }
          }
          function kt2() {
            t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          }
          function Ft2(e2) {
            if (e2.useSlerp) if (e2.k < 1) {
              const i2 = t.b3(e2.startEulerAngles.roll, e2.startEulerAngles.pitch, e2.startEulerAngles.bearing), r2 = t.b3(e2.endEulerAngles.roll, e2.endEulerAngles.pitch, e2.endEulerAngles.bearing), o2 = new Float64Array(4);
              t.b4(o2, i2, r2, e2.k);
              const a2 = t.b5(o2);
              e2.tr.setRoll(a2.roll), e2.tr.setPitch(a2.pitch), e2.tr.setBearing(a2.bearing);
            } else e2.tr.setRoll(e2.endEulerAngles.roll), e2.tr.setPitch(e2.endEulerAngles.pitch), e2.tr.setBearing(e2.endEulerAngles.bearing);
            else e2.tr.setRoll(t.B.number(e2.startEulerAngles.roll, e2.endEulerAngles.roll, e2.k)), e2.tr.setPitch(t.B.number(e2.startEulerAngles.pitch, e2.endEulerAngles.pitch, e2.k)), e2.tr.setBearing(t.B.number(e2.startEulerAngles.bearing, e2.endEulerAngles.bearing, e2.k));
          }
          function Bt2(e2, i2, r2, o2, a2) {
            const s2 = a2.padding, n2 = ce2(a2.worldSize, r2.getNorthWest()), l2 = ce2(a2.worldSize, r2.getNorthEast()), c2 = ce2(a2.worldSize, r2.getSouthEast()), h3 = ce2(a2.worldSize, r2.getSouthWest()), u2 = t.ab(-o2), d2 = n2.rotate(u2), _3 = l2.rotate(u2), p2 = c2.rotate(u2), m2 = h3.rotate(u2), f2 = new t.P(Math.max(d2.x, _3.x, m2.x, p2.x), Math.max(d2.y, _3.y, m2.y, p2.y)), g3 = new t.P(Math.min(d2.x, _3.x, m2.x, p2.x), Math.min(d2.y, _3.y, m2.y, p2.y)), v2 = f2.sub(g3), x3 = (a2.width - (s2.left + s2.right + i2.left + i2.right)) / v2.x, b2 = (a2.height - (s2.top + s2.bottom + i2.top + i2.bottom)) / v2.y;
            if (b2 < 0 || x3 < 0) return void kt2();
            const y2 = Math.min(t.ah(a2.scale * Math.min(x3, b2)), e2.maxZoom), w2 = t.P.convert(e2.offset), T2 = new t.P((i2.left - i2.right) / 2, (i2.top - i2.bottom) / 2).rotate(t.ab(o2)), P2 = w2.add(T2).mult(a2.scale / t.ac(y2));
            return { center: he2(a2.worldSize, n2.add(c2).div(2).sub(P2)), zoom: y2, bearing: o2 };
          }
          class Ot2 {
            get useGlobeControls() {
              return false;
            }
            handlePanInertia(e2, t2) {
              return { easingOffset: e2, easingCenter: t2.center };
            }
            handleMapControlsRollPitchBearingZoom(e2, t2) {
              e2.bearingDelta && t2.setBearing(t2.bearing + e2.bearingDelta), e2.pitchDelta && t2.setPitch(t2.pitch + e2.pitchDelta), e2.rollDelta && t2.setRoll(t2.roll + e2.rollDelta), e2.zoomDelta && t2.setZoom(t2.zoom + e2.zoomDelta);
            }
            handleMapControlsPan(e2, t2, i2) {
              e2.around.distSqr(t2.centerPoint) < 0.01 || t2.setLocationAtPoint(i2, e2.around);
            }
            cameraForBoxAndBearing(e2, t2, i2, r2, o2) {
              return Bt2(e2, t2, i2, r2, o2);
            }
            handleJumpToCenterZoom(e2, i2) {
              e2.zoom !== (void 0 !== i2.zoom ? +i2.zoom : e2.zoom) && e2.setZoom(+i2.zoom), void 0 !== i2.center && e2.setCenter(t.Q.convert(i2.center));
            }
            handleEaseTo(e2, i2) {
              const r2 = e2.zoom, o2 = e2.padding, a2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, s2 = { roll: void 0 === i2.roll ? e2.roll : i2.roll, pitch: void 0 === i2.pitch ? e2.pitch : i2.pitch, bearing: void 0 === i2.bearing ? e2.bearing : i2.bearing }, n2 = void 0 !== i2.zoom, l2 = !e2.isPaddingEqual(i2.padding);
              let c2 = false;
              const h3 = n2 ? +i2.zoom : e2.zoom;
              let u2 = e2.centerPoint.add(i2.offsetAsPoint);
              const d2 = e2.screenPointToLocation(u2), { center: _3, zoom: p2 } = e2.getConstrained(t.Q.convert(i2.center || d2), null != h3 ? h3 : r2);
              Et2(e2, _3);
              const m2 = ce2(e2.worldSize, d2), f2 = ce2(e2.worldSize, _3).sub(m2), g3 = t.ac(p2 - r2);
              return c2 = p2 !== r2, { easeFunc: (n3) => {
                if (c2 && e2.setZoom(t.B.number(r2, p2, n3)), t.b6(a2, s2) || Ft2({ startEulerAngles: a2, endEulerAngles: s2, tr: e2, k: n3, useSlerp: a2.roll != s2.roll }), l2 && (e2.interpolatePadding(o2, i2.padding, n3), u2 = e2.centerPoint.add(i2.offsetAsPoint)), i2.around) e2.setLocationAtPoint(i2.around, i2.aroundPoint);
                else {
                  const i3 = t.ac(e2.zoom - r2), o3 = p2 > r2 ? Math.min(2, g3) : Math.max(0.5, g3), a3 = Math.pow(o3, 1 - n3), s3 = he2(e2.worldSize, m2.add(f2.mult(n3 * a3)).mult(i3));
                  e2.setLocationAtPoint(e2.renderWorldCopies ? s3.wrap() : s3, u2);
                }
              }, isZooming: c2, elevationCenter: _3 };
            }
            handleFlyTo(e2, i2) {
              const r2 = void 0 !== i2.zoom, o2 = e2.zoom, a2 = e2.getConstrained(t.Q.convert(i2.center || i2.locationAtOffset), r2 ? +i2.zoom : o2), s2 = a2.center, n2 = a2.zoom;
              Et2(e2, s2);
              const l2 = ce2(e2.worldSize, i2.locationAtOffset), c2 = ce2(e2.worldSize, s2).sub(l2), h3 = c2.mag(), u2 = t.ac(n2 - o2);
              let d2;
              if (void 0 !== i2.minZoom) {
                const r3 = Math.min(+i2.minZoom, o2, n2), a3 = e2.getConstrained(s2, r3).zoom;
                d2 = t.ac(a3 - o2);
              }
              return { easeFunc: (i3, r3, a3, h4) => {
                e2.setZoom(1 === i3 ? n2 : o2 + t.ah(r3));
                const u3 = 1 === i3 ? s2 : he2(e2.worldSize, l2.add(c2.mult(a3)).mult(r3));
                e2.setLocationAtPoint(e2.renderWorldCopies ? u3.wrap() : u3, h4);
              }, scaleOfZoom: u2, targetCenter: s2, scaleOfMinZoom: d2, pixelPathLength: h3 };
            }
          }
          class jt {
            constructor(e2, t2, i2) {
              this.blendFunction = e2, this.blendColor = t2, this.mask = i2;
            }
          }
          jt.Replace = [1, 0], jt.disabled = new jt(jt.Replace, t.b7.transparent, [false, false, false, false]), jt.unblended = new jt(jt.Replace, t.b7.transparent, [true, true, true, true]), jt.alphaBlended = new jt([1, 771], t.b7.transparent, [true, true, true, true]);
          const Zt2 = 2305;
          class Nt2 {
            constructor(e2, t2, i2) {
              this.enable = e2, this.mode = t2, this.frontFace = i2;
            }
          }
          Nt2.disabled = new Nt2(false, 1029, Zt2), Nt2.backCCW = new Nt2(true, 1029, Zt2), Nt2.frontCCW = new Nt2(true, 1028, Zt2);
          class Ut2 {
            constructor(e2, t2, i2) {
              this.func = e2, this.mask = t2, this.range = i2;
            }
          }
          Ut2.ReadOnly = false, Ut2.ReadWrite = true, Ut2.disabled = new Ut2(519, Ut2.ReadOnly, [0, 1]);
          const Gt2 = 7680;
          class Vt2 {
            constructor(e2, t2, i2, r2, o2, a2) {
              this.test = e2, this.ref = t2, this.mask = i2, this.fail = r2, this.depthFail = o2, this.pass = a2;
            }
          }
          Vt2.disabled = new Vt2({ func: 519, mask: 0 }, 0, 0, Gt2, Gt2, Gt2);
          const qt2 = /* @__PURE__ */ new WeakMap();
          function Wt2(e2) {
            var t2;
            if (qt2.has(e2)) return qt2.get(e2);
            {
              const i2 = null === (t2 = e2.getParameter(e2.VERSION)) || void 0 === t2 ? void 0 : t2.startsWith("WebGL 2.0");
              return qt2.set(e2, i2), i2;
            }
          }
          class Ht2 {
            get awaitingQuery() {
              return !!this._readbackQueue;
            }
            constructor(e2) {
              this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e2;
              const i2 = e2.context, r2 = i2.gl;
              this._texFormat = r2.RGBA, this._texType = r2.UNSIGNED_BYTE;
              const o2 = new t.aI();
              o2.emplaceBack(-1, -1), o2.emplaceBack(2, -1), o2.emplaceBack(-1, 2);
              const a2 = new t.aK();
              a2.emplaceBack(0, 1, 2), this._fullscreenTriangle = new wt2(i2.createVertexBuffer(o2, Tt2.members), i2.createIndexBuffer(a2), t.aJ.simpleSegment(0, 0, o2.length, a2.length)), this._resultBuffer = new Uint8Array(4), i2.activeTexture.set(r2.TEXTURE1);
              const s2 = r2.createTexture();
              r2.bindTexture(r2.TEXTURE_2D, s2), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_S, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_WRAP_T, r2.CLAMP_TO_EDGE), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MIN_FILTER, r2.NEAREST), r2.texParameteri(r2.TEXTURE_2D, r2.TEXTURE_MAG_FILTER, r2.NEAREST), r2.texImage2D(r2.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i2.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(s2), Wt2(r2) && (this._pbo = r2.createBuffer(), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, this._pbo), r2.bufferData(r2.PIXEL_PACK_BUFFER, 4, r2.STREAM_READ), r2.bindBuffer(r2.PIXEL_PACK_BUFFER, null));
            }
            destroy() {
              const e2 = this._cachedRenderContext.context.gl;
              this._fullscreenTriangle.destroy(), this._fbo.destroy(), e2.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
            }
            updateErrorLoop(e2, t2) {
              const i2 = this._updateCount;
              return this._readbackQueue ? i2 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i2 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e2, t2), this._updateCount++, this._measuredError;
            }
            _bindFramebuffer() {
              const e2 = this._cachedRenderContext.context, t2 = e2.gl;
              e2.activeTexture.set(t2.TEXTURE1), t2.bindTexture(t2.TEXTURE_2D, this._fbo.colorAttachment.get()), e2.bindFramebuffer.set(this._fbo.framebuffer);
            }
            _renderErrorTexture(e2, i2) {
              const r2 = this._cachedRenderContext.context, o2 = r2.gl;
              if (this._bindFramebuffer(), r2.viewport.set([0, 0, this._texWidth, this._texHeight]), r2.clear({ color: t.b7.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(r2, o2.TRIANGLES, Ut2.disabled, Vt2.disabled, jt.unblended, Nt2.disabled, /* @__PURE__ */ ((e3, t2) => ({ u_input: e3, u_output_expected: t2 }))(e2, i2), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Wt2(o2)) {
                o2.bindBuffer(o2.PIXEL_PACK_BUFFER, this._pbo), o2.readBuffer(o2.COLOR_ATTACHMENT0), o2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o2.bindBuffer(o2.PIXEL_PACK_BUFFER, null);
                const e3 = o2.fenceSync(o2.SYNC_GPU_COMMANDS_COMPLETE, 0);
                o2.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e3 };
              } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
            }
            _tryReadback() {
              const e2 = this._cachedRenderContext.context.gl;
              if (this._pbo && this._readbackQueue && Wt2(e2)) {
                const i2 = e2.clientWaitSync(this._readbackQueue.sync, 0, 0);
                if (i2 === e2.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
                if (i2 === e2.TIMEOUT_EXPIRED) return;
                e2.bindBuffer(e2.PIXEL_PACK_BUFFER, this._pbo), e2.getBufferSubData(e2.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e2.bindBuffer(e2.PIXEL_PACK_BUFFER, null);
              } else this._bindFramebuffer(), e2.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
              this._readbackQueue = null, this._measuredError = Ht2._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
            }
            static _parseRGBA8float(e2) {
              let t2 = 0;
              return t2 += e2[0] / 256, t2 += e2[1] / 65536, t2 += e2[2] / 16777216, e2[3] < 127 && (t2 = -t2), t2 / 128;
            }
          }
          const $t = t.Z / 128;
          function Xt2(e2, i2) {
            const r2 = void 0 !== e2.granularity ? Math.max(e2.granularity, 1) : 1, o2 = r2 + (e2.generateBorders ? 2 : 0), a2 = r2 + (e2.extendToNorthPole || e2.generateBorders ? 1 : 0) + (e2.extendToSouthPole || e2.generateBorders ? 1 : 0), s2 = o2 + 1, n2 = a2 + 1, l2 = e2.generateBorders ? -1 : 0, c2 = e2.generateBorders || e2.extendToNorthPole ? -1 : 0, h3 = r2 + (e2.generateBorders ? 1 : 0), u2 = r2 + (e2.generateBorders || e2.extendToSouthPole ? 1 : 0), d2 = s2 * n2, _3 = o2 * a2 * 6, p2 = s2 * n2 > 65536;
            if (p2 && "16bit" === i2) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
            const m2 = p2 || "32bit" === i2, f2 = new Int16Array(2 * d2);
            let g3 = 0;
            for (let i3 = c2; i3 <= u2; i3++) for (let o3 = l2; o3 <= h3; o3++) {
              let a3 = o3 / r2 * t.Z;
              -1 === o3 && (a3 = -64), o3 === r2 + 1 && (a3 = t.Z + $t);
              let s3 = i3 / r2 * t.Z;
              -1 === i3 && (s3 = e2.extendToNorthPole ? t.b9 : -64), i3 === r2 + 1 && (s3 = e2.extendToSouthPole ? t.ba : t.Z + $t), f2[g3++] = a3, f2[g3++] = s3;
            }
            const v2 = m2 ? new Uint32Array(_3) : new Uint16Array(_3);
            let x3 = 0;
            for (let e3 = 0; e3 < a2; e3++) for (let t2 = 0; t2 < o2; t2++) {
              const i3 = t2 + 1 + e3 * s2, r3 = t2 + (e3 + 1) * s2, o3 = t2 + 1 + (e3 + 1) * s2;
              v2[x3++] = t2 + e3 * s2, v2[x3++] = r3, v2[x3++] = i3, v2[x3++] = i3, v2[x3++] = r3, v2[x3++] = o3;
            }
            return { vertices: f2.buffer.slice(0), indices: v2.buffer.slice(0), uses32bitIndices: m2 };
          }
          const Kt2 = new t.aH({ fill: new t.bb(128, 2), line: new t.bb(512, 0), tile: new t.bb(128, 32), stencil: new t.bb(128, 1), circle: 3 });
          class Qt2 {
            constructor() {
              this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
            }
            get name() {
              return "vertical-perspective";
            }
            get transitionState() {
              return 1;
            }
            get useSubdivision() {
              return true;
            }
            get shaderVariantName() {
              return "globe";
            }
            get shaderDefine() {
              return "#define GLOBE";
            }
            get shaderPreludeCode() {
              return bt2.projectionGlobe;
            }
            get vertexShaderPreludeCode() {
              return bt2.projectionMercator.vertexSource;
            }
            get subdivisionGranularity() {
              return Kt2;
            }
            get useGlobeControls() {
              return true;
            }
            get latitudeErrorCorrectionRadians() {
              return this._errorCorrectionUsable;
            }
            destroy() {
              this._errorMeasurement && this._errorMeasurement.destroy();
            }
            updateGPUdependent(e2) {
              this._errorMeasurement || (this._errorMeasurement = new Ht2(e2));
              const i2 = t.S(this._errorQueryLatitudeDegrees), r2 = 2 * Math.atan(Math.exp(Math.PI - i2 * Math.PI * 2)) - 0.5 * Math.PI, o2 = this._errorMeasurement.updateErrorLoop(i2, r2), a2 = s.now();
              o2 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o2, this._errorMeasurementLastChangeTime = a2);
              const n2 = Math.min(Math.max((a2 - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
              this._errorCorrectionUsable = t.bc(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bd(n2));
            }
            _getMeshKey(e2) {
              return `${e2.granularity.toString(36)}_${e2.generateBorders ? "b" : ""}${e2.extendToNorthPole ? "n" : ""}${e2.extendToSouthPole ? "s" : ""}`;
            }
            getMeshFromTileID(e2, t2, i2, r2, o2) {
              const a2 = ("stencil" === o2 ? Kt2.stencil : Kt2.tile).getGranularityForZoomLevel(t2.z);
              return this._getMesh(e2, { granularity: a2, generateBorders: i2, extendToNorthPole: 0 === t2.y && r2, extendToSouthPole: t2.y === (1 << t2.z) - 1 && r2 });
            }
            _getMesh(e2, i2) {
              const r2 = this._getMeshKey(i2);
              if (r2 in this._tileMeshCache) return this._tileMeshCache[r2];
              const o2 = function(e3, i3) {
                const r3 = Xt2(i3, "16bit"), o3 = t.aI.deserialize({ arrayBuffer: r3.vertices, length: r3.vertices.byteLength / 2 / 2 }), a2 = t.aK.deserialize({ arrayBuffer: r3.indices, length: r3.indices.byteLength / 2 / 3 });
                return new wt2(e3.createVertexBuffer(o3, Tt2.members), e3.createIndexBuffer(a2), t.aJ.simpleSegment(0, 0, o3.length, a2.length));
              }(e2, i2);
              return this._tileMeshCache[r2] = o2, o2;
            }
            recalculate(e2) {
            }
            hasTransition() {
              const e2 = s.now();
              let t2 = false;
              return t2 = t2 || (e2 - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, t2 = t2 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t2;
            }
            setErrorQueryLatitudeDegrees(e2) {
              this._errorQueryLatitudeDegrees = e2;
            }
          }
          const Yt2 = new t.r({ type: new t.D(t.v.projection.type) });
          class Jt2 extends t.E {
            constructor(e2) {
              super(), this._transitionable = new t.T(Yt2), this.setProjection(e2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.C(0)), this._mercatorProjection = new Mt2(), this._verticalPerspectiveProjection = new Qt2();
            }
            get transitionState() {
              const e2 = this.properties.get("type");
              if ("string" == typeof e2 && "mercator" === e2) return 0;
              if ("string" == typeof e2 && "vertical-perspective" === e2) return 1;
              if (e2 instanceof t.be) {
                if ("vertical-perspective" === e2.from && "mercator" === e2.to) return 1 - e2.transition;
                if ("mercator" === e2.from && "vertical-perspective" === e2.to) return e2.transition;
              }
              return 1;
            }
            get useGlobeRendering() {
              return this.transitionState > 0;
            }
            get latitudeErrorCorrectionRadians() {
              return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
            }
            get currentProjection() {
              return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
            }
            get name() {
              return "globe";
            }
            get useSubdivision() {
              return this.currentProjection.useSubdivision;
            }
            get shaderVariantName() {
              return this.currentProjection.shaderVariantName;
            }
            get shaderDefine() {
              return this.currentProjection.shaderDefine;
            }
            get shaderPreludeCode() {
              return this.currentProjection.shaderPreludeCode;
            }
            get vertexShaderPreludeCode() {
              return this.currentProjection.vertexShaderPreludeCode;
            }
            get subdivisionGranularity() {
              return this.currentProjection.subdivisionGranularity;
            }
            get useGlobeControls() {
              return this.transitionState > 0;
            }
            destroy() {
              this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
            }
            updateGPUdependent(e2) {
              this._mercatorProjection.updateGPUdependent(e2), this._verticalPerspectiveProjection.updateGPUdependent(e2);
            }
            getMeshFromTileID(e2, t2, i2, r2, o2) {
              return this.currentProjection.getMeshFromTileID(e2, t2, i2, r2, o2);
            }
            setProjection(e2) {
              this._transitionable.setValue("type", (null == e2 ? void 0 : e2.type) || "mercator");
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            setErrorQueryLatitudeDegrees(e2) {
              this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e2), this._mercatorProjection.setErrorQueryLatitudeDegrees(e2);
            }
          }
          function ei2(e2) {
            const t2 = ri2(e2.worldSize, e2.center.lat);
            return 2 * Math.PI * t2;
          }
          function ti2(e2, i2, r2, o2, a2) {
            const s2 = 1 / (1 << a2), n2 = i2 / t.Z * s2 + o2 * s2, l2 = t.bg((e2 / t.Z * s2 + r2 * s2) * Math.PI * 2 + Math.PI, 2 * Math.PI), c2 = 2 * Math.atan(Math.exp(Math.PI - n2 * Math.PI * 2)) - 0.5 * Math.PI, h3 = Math.cos(c2), u2 = new Float64Array(3);
            return u2[0] = Math.sin(l2) * h3, u2[1] = Math.sin(c2), u2[2] = Math.cos(l2) * h3, u2;
          }
          function ii2(e2) {
            return function(e3, t2) {
              const i2 = Math.cos(t2), r2 = new Float64Array(3);
              return r2[0] = Math.sin(e3) * i2, r2[1] = Math.sin(t2), r2[2] = Math.cos(e3) * i2, r2;
            }(e2.lng * Math.PI / 180, e2.lat * Math.PI / 180);
          }
          function ri2(e2, t2) {
            return e2 / (2 * Math.PI) / Math.cos(t2 * Math.PI / 180);
          }
          function oi2(e2) {
            const i2 = Math.asin(e2[1]) / Math.PI * 180, r2 = Math.sqrt(e2[0] * e2[0] + e2[2] * e2[2]);
            if (r2 > 1e-6) {
              const o2 = e2[0] / r2, a2 = Math.acos(e2[2] / r2), s2 = (o2 > 0 ? a2 : -a2) / Math.PI * 180;
              return new t.Q(t.aL(s2, -180, 180), i2);
            }
            return new t.Q(0, i2);
          }
          function ai2(e2) {
            return Math.cos(e2 * Math.PI / 180);
          }
          function si2(e2, i2) {
            const r2 = ai2(e2), o2 = ai2(i2);
            return t.ah(o2 / r2);
          }
          function ni2(e2, i2) {
            const r2 = e2.rotate(i2.bearingInRadians), o2 = i2.zoom + si2(i2.center.lat, 0), a2 = t.bc(1 / ai2(i2.center.lat), 1 / ai2(Math.min(Math.abs(i2.center.lat), 60)), t.bf(o2, 7, 3, 0, 1)), s2 = 360 / ei2({ worldSize: i2.worldSize, center: { lat: i2.center.lat } });
            return new t.Q(i2.center.lng - r2.x * s2 * a2, t.ae(i2.center.lat + r2.y * s2, -85.051129, t.af));
          }
          function li2(e2) {
            const t2 = 0.5 * e2, i2 = Math.sin(t2), r2 = Math.cos(t2);
            return Math.log(i2 + r2) - Math.log(r2 - i2);
          }
          function ci2(e2, i2, r2, o2) {
            const a2 = e2.lat + r2 * o2;
            if (Math.abs(r2) > 1) {
              const s2 = (Math.sign(e2.lat + r2) !== Math.sign(e2.lat) ? -Math.abs(e2.lat) : Math.abs(e2.lat)) * Math.PI / 180, n2 = Math.abs(e2.lat + r2) * Math.PI / 180, l2 = li2(s2 + o2 * (n2 - s2)), c2 = li2(s2), h3 = li2(n2);
              return new t.Q(e2.lng + i2 * ((l2 - c2) / (h3 - c2)), a2);
            }
            return new t.Q(e2.lng + i2 * o2, a2);
          }
          class hi2 {
            constructor(e2) {
              this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._aabbFactory = e2;
            }
            recalculateCache() {
              if (!this._hadAnyChanges) return;
              const e2 = this._cachePrevious;
              this._cachePrevious = this._cache, this._cache = e2, this._cache.clear(), this._hadAnyChanges = false;
            }
            getTileAABB(e2, t2, i2, r2) {
              const o2 = `${e2.z}_${e2.x}_${e2.y}`, a2 = this._cache.get(o2);
              if (a2) return a2;
              const s2 = this._cachePrevious.get(o2);
              if (s2) return this._cache.set(o2, s2), s2;
              const n2 = this._aabbFactory(e2, t2, i2, r2);
              return this._cache.set(o2, n2), this._hadAnyChanges = true, n2;
            }
          }
          function ui2(e2, t2, i2) {
            const r2 = e2 - t2;
            return r2 < 0 ? -r2 : Math.max(0, r2 - i2);
          }
          function di2(e2, t2, i2, r2, o2) {
            const a2 = e2 - i2;
            let s2;
            return s2 = a2 < 0 ? Math.min(-a2, 1 + a2 - o2) : a2 > 1 ? Math.min(Math.max(a2 - o2, 0), 1 - a2) : 0, Math.max(s2, ui2(t2, r2, o2));
          }
          class _i2 {
            constructor() {
              this._aabbCache = new hi2(this._computeTileAABB);
            }
            recalculateCache() {
              this._aabbCache.recalculateCache();
            }
            distanceToTile2d(e2, t2, i2, r2) {
              const o2 = 1 << i2.z, a2 = 1 / o2, s2 = i2.x / o2, n2 = i2.y / o2;
              let l2 = 2;
              return l2 = Math.min(l2, di2(e2, t2, s2, n2, a2)), l2 = Math.min(l2, di2(e2, t2, s2 + 0.5, -n2 - a2, a2)), l2 = Math.min(l2, di2(e2, t2, s2 + 0.5, 2 - n2 - a2, a2)), l2;
            }
            getWrap(e2, t2, i2) {
              const r2 = 1 << t2.z, o2 = 1 / r2, a2 = t2.x / r2, s2 = ui2(e2.x, a2, o2), n2 = ui2(e2.x, a2 - 1, o2), l2 = ui2(e2.x, a2 + 1, o2), c2 = Math.min(s2, n2, l2);
              return c2 === l2 ? 1 : c2 === n2 ? -1 : 0;
            }
            allowVariableZoom(e2, t2) {
              return ve2(e2, t2) > 4;
            }
            allowWorldCopies() {
              return false;
            }
            getTileAABB(e2, t2, i2, r2) {
              return this._aabbCache.getTileAABB(e2, t2, i2, r2);
            }
            _computeTileAABB(e2, i2, r2, o2) {
              if (e2.z <= 0) return new zt2([-1, -1, -1], [1, 1, 1]);
              if (1 === e2.z) return new zt2([0 === e2.x ? -1 : 0, 0 === e2.y ? 0 : -1, -1], [0 === e2.x ? 0 : 1, 0 === e2.y ? 1 : 0, 1]);
              {
                const i3 = [ti2(0, 0, e2.x, e2.y, e2.z), ti2(t.Z, 0, e2.x, e2.y, e2.z), ti2(t.Z, t.Z, e2.x, e2.y, e2.z), ti2(0, t.Z, e2.x, e2.y, e2.z)], r3 = [1, 1, 1], o3 = [-1, -1, -1];
                for (const e3 of i3) for (let t2 = 0; t2 < 3; t2++) r3[t2] = Math.min(r3[t2], e3[t2]), o3[t2] = Math.max(o3[t2], e3[t2]);
                if (0 === e2.y || e2.y === (1 << e2.z) - 1) {
                  const t2 = [0, 0 === e2.y ? 1 : -1, 0];
                  for (let e3 = 0; e3 < 3; e3++) r3[e3] = Math.min(r3[e3], t2[e3]), o3[e3] = Math.max(o3[e3], t2[e3]);
                }
                return new zt2(r3, o3);
              }
            }
          }
          class pi2 {
            get pixelsToClipSpaceMatrix() {
              return this._helper.pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._helper.clipSpaceToPixelsMatrix;
            }
            get pixelsToGLUnits() {
              return this._helper.pixelsToGLUnits;
            }
            get centerOffset() {
              return this._helper.centerOffset;
            }
            get size() {
              return this._helper.size;
            }
            get rotationMatrix() {
              return this._helper.rotationMatrix;
            }
            get centerPoint() {
              return this._helper.centerPoint;
            }
            get pixelsPerMeter() {
              return this._helper.pixelsPerMeter;
            }
            setMinZoom(e2) {
              this._helper.setMinZoom(e2);
            }
            setMaxZoom(e2) {
              this._helper.setMaxZoom(e2);
            }
            setMinPitch(e2) {
              this._helper.setMinPitch(e2);
            }
            setMaxPitch(e2) {
              this._helper.setMaxPitch(e2);
            }
            setRenderWorldCopies(e2) {
              this._helper.setRenderWorldCopies(e2);
            }
            setBearing(e2) {
              this._helper.setBearing(e2);
            }
            setPitch(e2) {
              this._helper.setPitch(e2);
            }
            setRoll(e2) {
              this._helper.setRoll(e2);
            }
            setFov(e2) {
              this._helper.setFov(e2);
            }
            setZoom(e2) {
              this._helper.setZoom(e2);
            }
            setCenter(e2) {
              this._helper.setCenter(e2);
            }
            setElevation(e2) {
              this._helper.setElevation(e2);
            }
            setMinElevationForCurrentTile(e2) {
              this._helper.setMinElevationForCurrentTile(e2);
            }
            setPadding(e2) {
              this._helper.setPadding(e2);
            }
            interpolatePadding(e2, t2, i2) {
              return this._helper.interpolatePadding(e2, t2, i2);
            }
            isPaddingEqual(e2) {
              return this._helper.isPaddingEqual(e2);
            }
            resize(e2, t2) {
              this._helper.resize(e2, t2);
            }
            getMaxBounds() {
              return this._helper.getMaxBounds();
            }
            setMaxBounds(e2) {
              this._helper.setMaxBounds(e2);
            }
            overrideNearFarZ(e2, t2) {
              this._helper.overrideNearFarZ(e2, t2);
            }
            clearNearFarZOverride() {
              this._helper.clearNearFarZOverride();
            }
            getCameraQueryGeometry(e2) {
              return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
            }
            get tileSize() {
              return this._helper.tileSize;
            }
            get tileZoom() {
              return this._helper.tileZoom;
            }
            get scale() {
              return this._helper.scale;
            }
            get worldSize() {
              return this._helper.worldSize;
            }
            get width() {
              return this._helper.width;
            }
            get height() {
              return this._helper.height;
            }
            get lngRange() {
              return this._helper.lngRange;
            }
            get latRange() {
              return this._helper.latRange;
            }
            get minZoom() {
              return this._helper.minZoom;
            }
            get maxZoom() {
              return this._helper.maxZoom;
            }
            get zoom() {
              return this._helper.zoom;
            }
            get center() {
              return this._helper.center;
            }
            get minPitch() {
              return this._helper.minPitch;
            }
            get maxPitch() {
              return this._helper.maxPitch;
            }
            get pitch() {
              return this._helper.pitch;
            }
            get pitchInRadians() {
              return this._helper.pitchInRadians;
            }
            get roll() {
              return this._helper.roll;
            }
            get rollInRadians() {
              return this._helper.rollInRadians;
            }
            get bearing() {
              return this._helper.bearing;
            }
            get bearingInRadians() {
              return this._helper.bearingInRadians;
            }
            get fov() {
              return this._helper.fov;
            }
            get fovInRadians() {
              return this._helper.fovInRadians;
            }
            get elevation() {
              return this._helper.elevation;
            }
            get minElevationForCurrentTile() {
              return this._helper.minElevationForCurrentTile;
            }
            get padding() {
              return this._helper.padding;
            }
            get unmodified() {
              return this._helper.unmodified;
            }
            get renderWorldCopies() {
              return this._helper.renderWorldCopies;
            }
            get nearZ() {
              return this._helper.nearZ;
            }
            get farZ() {
              return this._helper.farZ;
            }
            get autoCalculateNearFarZ() {
              return this._helper.autoCalculateNearFarZ;
            }
            setTransitionState(e2) {
            }
            constructor() {
              this._cachedClippingPlane = t.bk(), this._projectionMatrix = t.b1(), this._globeViewProjMatrix32f = t.b0(), this._globeViewProjMatrixNoCorrection = t.b1(), this._globeViewProjMatrixNoCorrectionInverted = t.b1(), this._globeProjMatrixInverted = t.b1(), this._cameraPosition = t.bh(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Rt2({ calcMatrices: () => {
                this._calcMatrices();
              }, getConstrained: (e2, t2) => this.getConstrained(e2, t2) }), this._coveringTilesDetailsProvider = new _i2();
            }
            clone() {
              const e2 = new pi2();
              return e2.apply(this), e2;
            }
            apply(e2, t2) {
              this._globeLatitudeErrorCorrectionRadians = t2 || 0, this._helper.apply(e2);
            }
            get projectionMatrix() {
              return this._projectionMatrix;
            }
            get modelViewProjectionMatrix() {
              return this._globeViewProjMatrixNoCorrection;
            }
            get inverseProjectionMatrix() {
              return this._globeProjMatrixInverted;
            }
            get cameraPosition() {
              const e2 = t.bh();
              return e2[0] = this._cameraPosition[0], e2[1] = this._cameraPosition[1], e2[2] = this._cameraPosition[2], e2;
            }
            get cameraToCenterDistance() {
              return this._helper.cameraToCenterDistance;
            }
            getProjectionData(e2) {
              const { overscaledTileID: t2, applyGlobeMatrix: i2 } = e2, r2 = this._helper.getMercatorTileCoordinates(t2);
              return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: r2, clippingPlane: this._cachedClippingPlane, projectionTransition: i2 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
            }
            _computeClippingPlane(e2) {
              const i2 = this.pitchInRadians, r2 = this.cameraToCenterDistance / e2, o2 = Math.sin(i2) * r2, a2 = Math.cos(i2) * r2 + 1, s2 = 1 / Math.sqrt(o2 * o2 + a2 * a2) * 1;
              let n2 = -o2, l2 = a2;
              const c2 = Math.sqrt(n2 * n2 + l2 * l2);
              n2 /= c2, l2 /= c2;
              const h3 = [0, n2, l2];
              t.bl(h3, h3, [0, 0, 0], -this.bearingInRadians), t.bm(h3, h3, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t.bn(h3, h3, [0, 0, 0], this.center.lng * Math.PI / 180);
              const u2 = 1 / t.bo(h3);
              return t.aO(h3, h3, u2), [...h3, -s2 * u2];
            }
            isLocationOccluded(e2) {
              return !this.isSurfacePointVisible(ii2(e2));
            }
            transformLightDirection(e2) {
              const i2 = this._helper._center.lng * Math.PI / 180, r2 = this._helper._center.lat * Math.PI / 180, o2 = Math.cos(r2), a2 = [Math.sin(i2) * o2, Math.sin(r2), Math.cos(i2) * o2], s2 = [a2[2], 0, -a2[0]], n2 = [0, 0, 0];
              t.aU(n2, s2, a2), t.aT(s2, s2), t.aT(n2, n2);
              const l2 = [0, 0, 0];
              return t.aT(l2, [s2[0] * e2[0] + n2[0] * e2[1] + a2[0] * e2[2], s2[1] * e2[0] + n2[1] * e2[1] + a2[1] * e2[2], s2[2] * e2[0] + n2[2] * e2[1] + a2[2] * e2[2]]), l2;
            }
            getPixelScale() {
              return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
            }
            getCircleRadiusCorrection() {
              return Math.cos(this._helper._center.lat * Math.PI / 180);
            }
            getPitchedTextCorrection(e2, i2, r2) {
              const o2 = function(e3, i3, r3) {
                const o3 = 1 / (1 << r3.z);
                return new t.$(e3 / t.Z * o3 + r3.x * o3, i3 / t.Z * o3 + r3.y * o3);
              }(e2, i2, r2.canonical), a2 = (s2 = o2.y, [t.bg(o2.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s2 * Math.PI * 2)) - 0.5 * Math.PI]);
              var s2;
              return this.getCircleRadiusCorrection() / Math.cos(a2[1]);
            }
            projectTileCoordinates(e2, i2, r2, o2) {
              const a2 = r2.canonical, s2 = ti2(e2, i2, a2.x, a2.y, a2.z), n2 = 1 + (o2 ? o2(e2, i2) : 0) / t.bu, l2 = [s2[0] * n2, s2[1] * n2, s2[2] * n2, 1];
              t.at(l2, l2, this._globeViewProjMatrixNoCorrection);
              const c2 = this._cachedClippingPlane, h3 = c2[0] * s2[0] + c2[1] * s2[1] + c2[2] * s2[2] + c2[3] < 0;
              return { point: new t.P(l2[0] / l2[3], l2[1] / l2[3]), signedDistanceFromCamera: l2[3], isOccluded: h3 };
            }
            _calcMatrices() {
              if (!this._helper._width || !this._helper._height) return;
              const e2 = ri2(this.worldSize, this.center.lat), i2 = t.b2(), r2 = t.b2();
              this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e2), t.aY(i2, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
              const o2 = this.centerOffset;
              i2[8] = 2 * -o2.x / this._helper._width, i2[9] = 2 * o2.y / this._helper._height, this._projectionMatrix = t.aZ(i2), this._globeProjMatrixInverted = t.b2(), t.an(this._globeProjMatrixInverted, i2), t.L(i2, i2, [0, 0, -this.cameraToCenterDistance]), t.a_(i2, i2, this.rollInRadians), t.a$(i2, i2, -this.pitchInRadians), t.a_(i2, i2, this.bearingInRadians), t.L(i2, i2, [0, 0, -e2]);
              const a2 = t.bh();
              a2[0] = e2, a2[1] = e2, a2[2] = e2, t.a$(r2, i2, this.center.lat * Math.PI / 180), t.bp(r2, r2, -this.center.lng * Math.PI / 180), t.M(r2, r2, a2), this._globeViewProjMatrixNoCorrection = r2, t.a$(i2, i2, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bp(i2, i2, -this.center.lng * Math.PI / 180), t.M(i2, i2, a2), this._globeViewProjMatrix32f = new Float32Array(i2), this._globeViewProjMatrixNoCorrectionInverted = t.b2(), t.an(this._globeViewProjMatrixNoCorrectionInverted, r2);
              const s2 = t.bh();
              this._cameraPosition = t.bh(), this._cameraPosition[2] = this.cameraToCenterDistance / e2, t.bl(this._cameraPosition, this._cameraPosition, s2, -this.rollInRadians), t.bm(this._cameraPosition, this._cameraPosition, s2, this.pitchInRadians), t.bl(this._cameraPosition, this._cameraPosition, s2, -this.bearingInRadians), t.aP(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t.bm(this._cameraPosition, this._cameraPosition, s2, -this.center.lat * Math.PI / 180), t.bn(this._cameraPosition, this._cameraPosition, s2, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e2);
              const n2 = t.aZ(this._globeViewProjMatrixNoCorrectionInverted);
              t.M(n2, n2, [1, 1, -1]), this._cachedFrustum = At2.fromInvProjectionMatrix(n2);
            }
            calculateFogMatrix(e2) {
              t.w("calculateFogMatrix is not supported on globe projection.");
              const i2 = t.b2();
              return t.ad(i2), i2;
            }
            getVisibleUnwrappedCoordinates(e2) {
              return [new t.aW(0, e2)];
            }
            getCameraFrustum() {
              return this._cachedFrustum;
            }
            getClippingPlane() {
              return this._cachedClippingPlane;
            }
            getCoveringTilesDetailsProvider() {
              return this._coveringTilesDetailsProvider;
            }
            recalculateZoomAndCenter(e2) {
              e2 && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
            }
            maxPitchScaleFactor() {
              return 1;
            }
            getCameraPoint() {
              return this._helper.getCameraPoint();
            }
            getCameraAltitude() {
              return this._helper.getCameraAltitude();
            }
            getCameraLngLat() {
              return this._helper.getCameraLngLat();
            }
            lngLatToCameraDepth(e2, i2) {
              if (!this._globeViewProjMatrixNoCorrection) return 1;
              const r2 = ii2(e2);
              t.aO(r2, r2, 1 + i2 / t.bu);
              const o2 = t.bk();
              return t.at(o2, [r2[0], r2[1], r2[2], 1], this._globeViewProjMatrixNoCorrection), o2[2] / o2[3];
            }
            populateCache(e2) {
            }
            getBounds() {
              const e2 = 0.5 * this.width, i2 = 0.5 * this.height, r2 = [new t.P(0, 0), new t.P(e2, 0), new t.P(this.width, 0), new t.P(this.width, i2), new t.P(this.width, this.height), new t.P(e2, this.height), new t.P(0, this.height), new t.P(0, i2)], o2 = [];
              for (const e3 of r2) o2.push(this.unprojectScreenPoint(e3));
              let a2 = 0, s2 = 0, n2 = 0, l2 = 0;
              const c2 = this.center;
              for (const e3 of o2) {
                const i3 = t.bq(c2.lng, e3.lng), r3 = t.bq(c2.lat, e3.lat);
                i3 < s2 && (s2 = i3), i3 > a2 && (a2 = i3), r3 < l2 && (l2 = r3), r3 > n2 && (n2 = r3);
              }
              const h3 = [c2.lng + s2, c2.lat + l2, c2.lng + a2, c2.lat + n2];
              return this.isSurfacePointOnScreen([0, 1, 0]) && (h3[3] = 90, h3[0] = -180, h3[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h3[1] = -90, h3[0] = -180, h3[2] = 180), new V2(h3);
            }
            getConstrained(e2, i2) {
              const r2 = t.ae(e2.lat, -85.051129, t.af), o2 = t.ae(+i2, this.minZoom + si2(0, r2), this.maxZoom);
              return { center: new t.Q(e2.lng, r2), zoom: o2 };
            }
            calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2) {
              return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
            }
            setLocationAtPoint(e2, i2) {
              const r2 = ii2(this.unprojectScreenPoint(i2)), o2 = ii2(e2), a2 = t.bh();
              t.br(a2);
              const s2 = t.bh();
              t.bn(s2, r2, a2, -this.center.lng * Math.PI / 180), t.bm(s2, s2, a2, this.center.lat * Math.PI / 180);
              const n2 = o2[0] * o2[0] + o2[2] * o2[2], l2 = s2[0] * s2[0];
              if (n2 < l2) return;
              const c2 = Math.sqrt(n2 - l2), h3 = -c2, u2 = t.bs(o2[0], o2[2], s2[0], c2), d2 = t.bs(o2[0], o2[2], s2[0], h3), _3 = t.bh();
              t.bn(_3, o2, a2, -u2);
              const p2 = t.bs(_3[1], _3[2], s2[1], s2[2]), m2 = t.bh();
              t.bn(m2, o2, a2, -d2);
              const f2 = t.bs(m2[1], m2[2], s2[1], s2[2]), g3 = 0.5 * Math.PI, v2 = p2 >= -g3 && p2 <= g3, x3 = f2 >= -g3 && f2 <= g3;
              let b2, y2;
              if (v2 && x3) {
                const e3 = this.center.lng * Math.PI / 180, i3 = this.center.lat * Math.PI / 180;
                t.bv(u2, e3) + t.bv(p2, i3) < t.bv(d2, e3) + t.bv(f2, i3) ? (b2 = u2, y2 = p2) : (b2 = d2, y2 = f2);
              } else if (v2) b2 = u2, y2 = p2;
              else {
                if (!x3) return;
                b2 = d2, y2 = f2;
              }
              const w2 = b2 / Math.PI * 180, T2 = y2 / Math.PI * 180, P2 = this.center.lat;
              this.setCenter(new t.Q(w2, t.ae(T2, -90, 90))), this.setZoom(this.zoom + si2(P2, this.center.lat));
            }
            locationToScreenPoint(e2, i2) {
              const r2 = ii2(e2);
              if (i2) {
                const o2 = i2.getElevationForLngLatZoom(e2, this._helper._tileZoom);
                t.aO(r2, r2, 1 + o2 / t.bu);
              }
              return this._projectSurfacePointToScreen(r2);
            }
            _projectSurfacePointToScreen(e2) {
              const i2 = t.bk();
              return t.at(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], new t.P((0.5 * i2[0] + 0.5) * this.width, (0.5 * -i2[1] + 0.5) * this.height);
            }
            screenPointToMercatorCoordinate(e2, i2) {
              if (i2) {
                const t2 = i2.pointCoordinate(e2);
                if (t2) return t2;
              }
              return t.$.fromLngLat(this.unprojectScreenPoint(e2));
            }
            screenPointToLocation(e2, t2) {
              var i2;
              return null === (i2 = this.screenPointToMercatorCoordinate(e2, t2)) || void 0 === i2 ? void 0 : i2.toLngLat();
            }
            isPointOnMapSurface(e2, t2) {
              const i2 = this._cameraPosition, r2 = this.getRayDirectionFromPixel(e2);
              return !!this.rayPlanetIntersection(i2, r2);
            }
            getRayDirectionFromPixel(e2) {
              const i2 = t.bk();
              i2[0] = e2.x / this.width * 2 - 1, i2[1] = -1 * (e2.y / this.height * 2 - 1), i2[2] = 1, i2[3] = 1, t.at(i2, i2, this._globeViewProjMatrixNoCorrectionInverted), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3];
              const r2 = t.bh();
              r2[0] = i2[0] - this._cameraPosition[0], r2[1] = i2[1] - this._cameraPosition[1], r2[2] = i2[2] - this._cameraPosition[2];
              const o2 = t.bh();
              return t.aT(o2, r2), o2;
            }
            isSurfacePointVisible(e2) {
              const t2 = this._cachedClippingPlane;
              return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] >= 0;
            }
            isSurfacePointOnScreen(e2) {
              if (!this.isSurfacePointVisible(e2)) return false;
              const i2 = t.bk();
              return t.at(i2, [...e2, 1], this._globeViewProjMatrixNoCorrection), i2[0] /= i2[3], i2[1] /= i2[3], i2[2] /= i2[3], i2[0] > -1 && i2[0] < 1 && i2[1] > -1 && i2[1] < 1 && i2[2] > -1 && i2[2] < 1;
            }
            rayPlanetIntersection(e2, i2) {
              const r2 = t.aV(e2, i2), o2 = t.bh(), a2 = t.bh();
              t.aO(a2, i2, r2), t.aS(o2, e2, a2);
              const s2 = 1 - t.aV(o2, o2);
              if (s2 < 0) return null;
              const n2 = t.aV(e2, e2) - 1, l2 = -r2 + (r2 < 0 ? 1 : -1) * Math.sqrt(s2), c2 = n2 / l2, h3 = l2;
              return { tMin: Math.min(c2, h3), tMax: Math.max(c2, h3) };
            }
            unprojectScreenPoint(e2) {
              const i2 = this._cameraPosition, r2 = this.getRayDirectionFromPixel(e2), o2 = this.rayPlanetIntersection(i2, r2);
              if (o2) {
                const e3 = t.bh();
                t.aP(e3, i2, [r2[0] * o2.tMin, r2[1] * o2.tMin, r2[2] * o2.tMin]);
                const a3 = t.bh();
                return t.aT(a3, e3), oi2(a3);
              }
              const a2 = this._cachedClippingPlane, s2 = a2[0] * r2[0] + a2[1] * r2[1] + a2[2] * r2[2], n2 = -t.bt(a2, i2) / s2, l2 = t.bh();
              if (n2 > 0) t.aP(l2, i2, [r2[0] * n2, r2[1] * n2, r2[2] * n2]);
              else {
                const e3 = t.bh();
                t.aP(e3, i2, [2 * r2[0], 2 * r2[1], 2 * r2[2]]);
                const o3 = t.bt(this._cachedClippingPlane, e3);
                t.aS(l2, e3, [this._cachedClippingPlane[0] * o3, this._cachedClippingPlane[1] * o3, this._cachedClippingPlane[2] * o3]);
              }
              const c2 = function(e3) {
                const i3 = t.bh();
                return i3[0] = e3[0] * -e3[3], i3[1] = e3[1] * -e3[3], i3[2] = e3[2] * -e3[3], { center: i3, radius: Math.sqrt(1 - e3[3] * e3[3]) };
              }(a2);
              return oi2(function(e3, i3, r3) {
                const o3 = t.bh();
                t.aS(o3, r3, e3);
                const a3 = t.bh();
                return t.bi(a3, e3, o3, i3 / t.bj(o3)), a3;
              }(c2.center, c2.radius, l2));
            }
            getMatrixForModel(e2, i2) {
              const r2 = t.Q.convert(e2), o2 = 1 / t.bu, a2 = t.b1();
              return t.bp(a2, a2, r2.lng / 180 * Math.PI), t.a$(a2, a2, -r2.lat / 180 * Math.PI), t.L(a2, a2, [0, 0, 1 + i2 / t.bu]), t.a$(a2, a2, 0.5 * Math.PI), t.M(a2, a2, [o2, o2, o2]), a2;
            }
            getProjectionDataForCustomLayer(e2 = true) {
              const i2 = this.getProjectionData({ overscaledTileID: new t.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e2 });
              return i2.tileMercatorCoords = [0, 0, 1, 1], i2;
            }
            getFastPathSimpleProjectionMatrix(e2) {
            }
          }
          class mi2 {
            get pixelsToClipSpaceMatrix() {
              return this._helper.pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._helper.clipSpaceToPixelsMatrix;
            }
            get pixelsToGLUnits() {
              return this._helper.pixelsToGLUnits;
            }
            get centerOffset() {
              return this._helper.centerOffset;
            }
            get size() {
              return this._helper.size;
            }
            get rotationMatrix() {
              return this._helper.rotationMatrix;
            }
            get centerPoint() {
              return this._helper.centerPoint;
            }
            get pixelsPerMeter() {
              return this._helper.pixelsPerMeter;
            }
            setMinZoom(e2) {
              this._helper.setMinZoom(e2);
            }
            setMaxZoom(e2) {
              this._helper.setMaxZoom(e2);
            }
            setMinPitch(e2) {
              this._helper.setMinPitch(e2);
            }
            setMaxPitch(e2) {
              this._helper.setMaxPitch(e2);
            }
            setRenderWorldCopies(e2) {
              this._helper.setRenderWorldCopies(e2);
            }
            setBearing(e2) {
              this._helper.setBearing(e2);
            }
            setPitch(e2) {
              this._helper.setPitch(e2);
            }
            setRoll(e2) {
              this._helper.setRoll(e2);
            }
            setFov(e2) {
              this._helper.setFov(e2);
            }
            setZoom(e2) {
              this._helper.setZoom(e2);
            }
            setCenter(e2) {
              this._helper.setCenter(e2);
            }
            setElevation(e2) {
              this._helper.setElevation(e2);
            }
            setMinElevationForCurrentTile(e2) {
              this._helper.setMinElevationForCurrentTile(e2);
            }
            setPadding(e2) {
              this._helper.setPadding(e2);
            }
            interpolatePadding(e2, t2, i2) {
              return this._helper.interpolatePadding(e2, t2, i2);
            }
            isPaddingEqual(e2) {
              return this._helper.isPaddingEqual(e2);
            }
            resize(e2, t2, i2 = true) {
              this._helper.resize(e2, t2, i2);
            }
            getMaxBounds() {
              return this._helper.getMaxBounds();
            }
            setMaxBounds(e2) {
              this._helper.setMaxBounds(e2);
            }
            overrideNearFarZ(e2, t2) {
              this._helper.overrideNearFarZ(e2, t2);
            }
            clearNearFarZOverride() {
              this._helper.clearNearFarZOverride();
            }
            getCameraQueryGeometry(e2) {
              return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e2);
            }
            get tileSize() {
              return this._helper.tileSize;
            }
            get tileZoom() {
              return this._helper.tileZoom;
            }
            get scale() {
              return this._helper.scale;
            }
            get worldSize() {
              return this._helper.worldSize;
            }
            get width() {
              return this._helper.width;
            }
            get height() {
              return this._helper.height;
            }
            get lngRange() {
              return this._helper.lngRange;
            }
            get latRange() {
              return this._helper.latRange;
            }
            get minZoom() {
              return this._helper.minZoom;
            }
            get maxZoom() {
              return this._helper.maxZoom;
            }
            get zoom() {
              return this._helper.zoom;
            }
            get center() {
              return this._helper.center;
            }
            get minPitch() {
              return this._helper.minPitch;
            }
            get maxPitch() {
              return this._helper.maxPitch;
            }
            get pitch() {
              return this._helper.pitch;
            }
            get pitchInRadians() {
              return this._helper.pitchInRadians;
            }
            get roll() {
              return this._helper.roll;
            }
            get rollInRadians() {
              return this._helper.rollInRadians;
            }
            get bearing() {
              return this._helper.bearing;
            }
            get bearingInRadians() {
              return this._helper.bearingInRadians;
            }
            get fov() {
              return this._helper.fov;
            }
            get fovInRadians() {
              return this._helper.fovInRadians;
            }
            get elevation() {
              return this._helper.elevation;
            }
            get minElevationForCurrentTile() {
              return this._helper.minElevationForCurrentTile;
            }
            get padding() {
              return this._helper.padding;
            }
            get unmodified() {
              return this._helper.unmodified;
            }
            get renderWorldCopies() {
              return this._helper.renderWorldCopies;
            }
            get cameraToCenterDistance() {
              return this._helper.cameraToCenterDistance;
            }
            get nearZ() {
              return this._helper.nearZ;
            }
            get farZ() {
              return this._helper.farZ;
            }
            get autoCalculateNearFarZ() {
              return this._helper.autoCalculateNearFarZ;
            }
            get isGlobeRendering() {
              return this._globeness > 0;
            }
            setTransitionState(e2, t2) {
              this._globeness = e2, this._globeLatitudeErrorCorrectionRadians = t2, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
            }
            get currentTransform() {
              return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
            }
            constructor() {
              this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Rt2({ calcMatrices: () => {
                this._calcMatrices();
              }, getConstrained: (e2, t2) => this.getConstrained(e2, t2) }), this._globeness = 1, this._mercatorTransform = new Lt2(), this._verticalPerspectiveTransform = new pi2();
            }
            clone() {
              const e2 = new mi2();
              return e2._globeness = this._globeness, e2._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e2.apply(this), e2;
            }
            apply(e2) {
              this._helper.apply(e2), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
            }
            get projectionMatrix() {
              return this.currentTransform.projectionMatrix;
            }
            get modelViewProjectionMatrix() {
              return this.currentTransform.modelViewProjectionMatrix;
            }
            get inverseProjectionMatrix() {
              return this.currentTransform.inverseProjectionMatrix;
            }
            get cameraPosition() {
              return this.currentTransform.cameraPosition;
            }
            getProjectionData(e2) {
              const t2 = this._mercatorTransform.getProjectionData(e2), i2 = this._verticalPerspectiveTransform.getProjectionData(e2);
              return { mainMatrix: this.isGlobeRendering ? i2.mainMatrix : t2.mainMatrix, clippingPlane: i2.clippingPlane, tileMercatorCoords: i2.tileMercatorCoords, projectionTransition: e2.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t2.fallbackMatrix };
            }
            isLocationOccluded(e2) {
              return this.currentTransform.isLocationOccluded(e2);
            }
            transformLightDirection(e2) {
              return this.currentTransform.transformLightDirection(e2);
            }
            getPixelScale() {
              return t.bc(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
            }
            getCircleRadiusCorrection() {
              return t.bc(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
            }
            getPitchedTextCorrection(e2, i2, r2) {
              const o2 = this._mercatorTransform.getPitchedTextCorrection(e2, i2, r2), a2 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e2, i2, r2);
              return t.bc(o2, a2, this._globeness);
            }
            projectTileCoordinates(e2, t2, i2, r2) {
              return this.currentTransform.projectTileCoordinates(e2, t2, i2, r2);
            }
            _calcMatrices() {
              this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
            }
            calculateFogMatrix(e2) {
              return this.currentTransform.calculateFogMatrix(e2);
            }
            getVisibleUnwrappedCoordinates(e2) {
              return this.currentTransform.getVisibleUnwrappedCoordinates(e2);
            }
            getCameraFrustum() {
              return this.currentTransform.getCameraFrustum();
            }
            getClippingPlane() {
              return this.currentTransform.getClippingPlane();
            }
            getCoveringTilesDetailsProvider() {
              return this.currentTransform.getCoveringTilesDetailsProvider();
            }
            recalculateZoomAndCenter(e2) {
              this._mercatorTransform.recalculateZoomAndCenter(e2), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e2);
            }
            maxPitchScaleFactor() {
              return this._mercatorTransform.maxPitchScaleFactor();
            }
            getCameraPoint() {
              return this._helper.getCameraPoint();
            }
            getCameraAltitude() {
              return this._helper.getCameraAltitude();
            }
            getCameraLngLat() {
              return this._helper.getCameraLngLat();
            }
            lngLatToCameraDepth(e2, t2) {
              return this.currentTransform.lngLatToCameraDepth(e2, t2);
            }
            populateCache(e2) {
              this._mercatorTransform.populateCache(e2), this._verticalPerspectiveTransform.populateCache(e2);
            }
            getBounds() {
              return this.currentTransform.getBounds();
            }
            getConstrained(e2, t2) {
              return this.currentTransform.getConstrained(e2, t2);
            }
            calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2) {
              return this._helper.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
            }
            setLocationAtPoint(e2, t2) {
              if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e2, t2), void this.apply(this._mercatorTransform);
              this._verticalPerspectiveTransform.setLocationAtPoint(e2, t2), this.apply(this._verticalPerspectiveTransform);
            }
            locationToScreenPoint(e2, t2) {
              return this.currentTransform.locationToScreenPoint(e2, t2);
            }
            screenPointToMercatorCoordinate(e2, t2) {
              return this.currentTransform.screenPointToMercatorCoordinate(e2, t2);
            }
            screenPointToLocation(e2, t2) {
              return this.currentTransform.screenPointToLocation(e2, t2);
            }
            isPointOnMapSurface(e2, t2) {
              return this.currentTransform.isPointOnMapSurface(e2, t2);
            }
            getRayDirectionFromPixel(e2) {
              return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e2);
            }
            getMatrixForModel(e2, t2) {
              return this.currentTransform.getMatrixForModel(e2, t2);
            }
            getProjectionDataForCustomLayer(e2 = true) {
              const t2 = this._mercatorTransform.getProjectionDataForCustomLayer(e2);
              if (!this.isGlobeRendering) return t2;
              const i2 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e2);
              return i2.fallbackMatrix = t2.mainMatrix, i2;
            }
            getFastPathSimpleProjectionMatrix(e2) {
              return this.currentTransform.getFastPathSimpleProjectionMatrix(e2);
            }
          }
          class fi2 {
            get useGlobeControls() {
              return true;
            }
            handlePanInertia(e2, i2) {
              const r2 = ni2(e2, i2);
              return Math.abs(r2.lng - i2.center.lng) > 180 && (r2.lng = i2.center.lng + 179.5 * Math.sign(r2.lng - i2.center.lng)), { easingCenter: r2, easingOffset: new t.P(0, 0) };
            }
            handleMapControlsRollPitchBearingZoom(e2, i2) {
              const r2 = e2.around, o2 = i2.screenPointToLocation(r2);
              e2.bearingDelta && i2.setBearing(i2.bearing + e2.bearingDelta), e2.pitchDelta && i2.setPitch(i2.pitch + e2.pitchDelta), e2.rollDelta && i2.setRoll(i2.roll + e2.rollDelta);
              const a2 = i2.zoom;
              e2.zoomDelta && i2.setZoom(i2.zoom + e2.zoomDelta);
              const s2 = i2.zoom - a2;
              if (0 === s2) return;
              const n2 = t.bq(i2.center.lng, o2.lng), l2 = n2 / (Math.abs(n2 / 180) + 1), c2 = t.bq(i2.center.lat, o2.lat), h3 = i2.getRayDirectionFromPixel(r2), u2 = i2.cameraPosition, d2 = -1 * t.aV(u2, h3), _3 = t.bh();
              t.aP(_3, u2, [h3[0] * d2, h3[1] * d2, h3[2] * d2]);
              const p2 = t.bo(_3) - 1, m2 = Math.exp(0.5 * -Math.max(p2 - 0.3, 0)), f2 = ri2(i2.worldSize, i2.center.lat) / Math.min(i2.width, i2.height), g3 = t.bf(f2, 0.9, 0.5, 1, 0.25), v2 = (1 - t.ac(-s2)) * Math.min(m2, g3), x3 = i2.center.lat, b2 = i2.zoom, y2 = new t.Q(i2.center.lng + l2 * v2, t.ae(i2.center.lat + c2 * v2, -85.051129, t.af));
              i2.setLocationAtPoint(o2, r2);
              const w2 = i2.center, T2 = t.bf(Math.abs(n2), 45, 85, 0, 1), P2 = t.bf(f2, 0.75, 0.35, 0, 1), C3 = Math.pow(Math.max(T2, P2), 0.25), M3 = t.bq(w2.lng, y2.lng), I3 = t.bq(w2.lat, y2.lat);
              i2.setCenter(new t.Q(w2.lng + M3 * C3, w2.lat + I3 * C3).wrap()), i2.setZoom(b2 + si2(x3, i2.center.lat));
            }
            handleMapControlsPan(e2, t2, i2) {
              if (!e2.panDelta) return;
              const r2 = t2.center.lat, o2 = t2.zoom;
              t2.setCenter(ni2(e2.panDelta, t2).wrap()), t2.setZoom(o2 + si2(r2, t2.center.lat));
            }
            cameraForBoxAndBearing(e2, i2, r2, o2, a2) {
              const s2 = Bt2(e2, i2, r2, o2, a2), n2 = i2.left / a2.width * 2 - 1, l2 = (a2.width - i2.right) / a2.width * 2 - 1, c2 = i2.top / a2.height * -2 + 1, h3 = (a2.height - i2.bottom) / a2.height * -2 + 1, u2 = t.bq(r2.getWest(), r2.getEast()) < 0, d2 = u2 ? r2.getEast() : r2.getWest(), _3 = u2 ? r2.getWest() : r2.getEast(), p2 = Math.max(r2.getNorth(), r2.getSouth()), m2 = Math.min(r2.getNorth(), r2.getSouth()), f2 = d2 + 0.5 * t.bq(d2, _3), g3 = p2 + 0.5 * t.bq(p2, m2), v2 = a2.clone();
              v2.setCenter(s2.center), v2.setBearing(s2.bearing), v2.setPitch(0), v2.setRoll(0), v2.setZoom(s2.zoom);
              const x3 = v2.modelViewProjectionMatrix, b2 = [ii2(r2.getNorthWest()), ii2(r2.getNorthEast()), ii2(r2.getSouthWest()), ii2(r2.getSouthEast()), ii2(new t.Q(_3, g3)), ii2(new t.Q(d2, g3)), ii2(new t.Q(f2, p2)), ii2(new t.Q(f2, m2))], y2 = ii2(s2.center);
              let w2 = Number.POSITIVE_INFINITY;
              for (const e3 of b2) n2 < 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x3, "x", n2))), l2 > 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x3, "x", l2))), c2 > 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x3, "y", c2))), h3 < 0 && (w2 = fi2.getLesserNonNegativeNonNull(w2, fi2.solveVectorScale(e3, y2, x3, "y", h3)));
              if (Number.isFinite(w2) && 0 !== w2) return s2.zoom = v2.zoom + t.ah(w2), s2;
              kt2();
            }
            handleJumpToCenterZoom(e2, i2) {
              const r2 = e2.center.lat, o2 = e2.getConstrained(i2.center ? t.Q.convert(i2.center) : e2.center, e2.zoom).center;
              e2.setCenter(o2.wrap());
              const a2 = void 0 !== i2.zoom ? +i2.zoom : e2.zoom + si2(r2, o2.lat);
              e2.zoom !== a2 && e2.setZoom(a2);
            }
            handleEaseTo(e2, i2) {
              const r2 = e2.zoom, o2 = e2.center, a2 = e2.padding, s2 = { roll: e2.roll, pitch: e2.pitch, bearing: e2.bearing }, n2 = { roll: void 0 === i2.roll ? e2.roll : i2.roll, pitch: void 0 === i2.pitch ? e2.pitch : i2.pitch, bearing: void 0 === i2.bearing ? e2.bearing : i2.bearing }, l2 = void 0 !== i2.zoom, c2 = !e2.isPaddingEqual(i2.padding);
              let h3 = false;
              const u2 = i2.center ? t.Q.convert(i2.center) : o2, d2 = e2.getConstrained(u2, r2).center;
              Et2(e2, d2);
              const _3 = e2.clone();
              _3.setCenter(d2), _3.setZoom(l2 ? +i2.zoom : r2 + si2(o2.lat, u2.lat)), _3.setBearing(i2.bearing);
              const p2 = new t.P(t.ae(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.ae(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
              _3.setLocationAtPoint(d2, p2);
              const m2 = (i2.offset && i2.offsetAsPoint.mag()) > 0 ? _3.center : d2, f2 = l2 ? +i2.zoom : r2 + si2(o2.lat, m2.lat), g3 = r2 + si2(o2.lat, 0), v2 = f2 + si2(m2.lat, 0), x3 = t.bq(o2.lng, m2.lng), b2 = t.bq(o2.lat, m2.lat), y2 = t.ac(v2 - g3);
              return h3 = f2 !== r2, { easeFunc: (r3) => {
                if (t.b6(s2, n2) || Ft2({ startEulerAngles: s2, endEulerAngles: n2, tr: e2, k: r3, useSlerp: s2.roll != n2.roll }), c2 && e2.interpolatePadding(a2, i2.padding, r3), i2.around) t.w("Easing around a point is not supported under globe projection."), e2.setLocationAtPoint(i2.around, i2.aroundPoint);
                else {
                  const t2 = v2 > g3 ? Math.min(2, y2) : Math.max(0.5, y2), i3 = Math.pow(t2, 1 - r3), a3 = ci2(o2, x3, b2, r3 * i3);
                  e2.setCenter(a3.wrap());
                }
                if (h3) {
                  const i3 = t.B.number(g3, v2, r3) + si2(0, e2.center.lat);
                  e2.setZoom(i3);
                }
              }, isZooming: h3, elevationCenter: m2 };
            }
            handleFlyTo(e2, i2) {
              const r2 = void 0 !== i2.zoom, o2 = e2.center, a2 = e2.zoom, s2 = e2.padding, n2 = !e2.isPaddingEqual(i2.padding), l2 = e2.getConstrained(t.Q.convert(i2.center || i2.locationAtOffset), a2).center, c2 = r2 ? +i2.zoom : e2.zoom + si2(e2.center.lat, l2.lat), h3 = e2.clone();
              h3.setCenter(l2), h3.setZoom(c2), h3.setBearing(i2.bearing);
              const u2 = new t.P(t.ae(e2.centerPoint.x + i2.offsetAsPoint.x, 0, e2.width), t.ae(e2.centerPoint.y + i2.offsetAsPoint.y, 0, e2.height));
              h3.setLocationAtPoint(l2, u2);
              const d2 = h3.center;
              Et2(e2, d2);
              const _3 = function(e3, i3, r3) {
                const o3 = ii2(i3), a3 = ii2(r3), s3 = t.aV(o3, a3), n3 = Math.acos(s3), l3 = ei2(e3);
                return n3 / (2 * Math.PI) * l3;
              }(e2, o2, d2), p2 = a2 + si2(o2.lat, 0), m2 = c2 + si2(d2.lat, 0), f2 = t.ac(m2 - p2);
              let g3;
              if ("number" == typeof i2.minZoom) {
                const r3 = +i2.minZoom + si2(d2.lat, 0), o3 = Math.min(r3, p2, m2) + si2(0, d2.lat), a3 = e2.getConstrained(d2, o3).zoom + si2(d2.lat, 0);
                g3 = t.ac(a3 - p2);
              }
              const v2 = t.bq(o2.lng, d2.lng), x3 = t.bq(o2.lat, d2.lat);
              return { easeFunc: (r3, a3, l3, h4) => {
                const u3 = ci2(o2, v2, x3, l3);
                n2 && e2.interpolatePadding(s2, i2.padding, r3);
                const _4 = 1 === r3 ? d2 : u3;
                e2.setCenter(_4.wrap());
                const m3 = p2 + t.ah(a3);
                e2.setZoom(1 === r3 ? c2 : m3 + si2(0, _4.lat));
              }, scaleOfZoom: f2, targetCenter: d2, scaleOfMinZoom: g3, pixelPathLength: _3 };
            }
            static solveVectorScale(e2, t2, i2, r2, o2) {
              const a2 = "x" === r2 ? [i2[0], i2[4], i2[8], i2[12]] : [i2[1], i2[5], i2[9], i2[13]], s2 = [i2[3], i2[7], i2[11], i2[15]], n2 = e2[0] * a2[0] + e2[1] * a2[1] + e2[2] * a2[2], l2 = e2[0] * s2[0] + e2[1] * s2[1] + e2[2] * s2[2], c2 = t2[0] * a2[0] + t2[1] * a2[1] + t2[2] * a2[2], h3 = t2[0] * s2[0] + t2[1] * s2[1] + t2[2] * s2[2];
              return c2 + o2 * l2 === n2 + o2 * h3 || s2[3] * (n2 - c2) + a2[3] * (h3 - l2) + n2 * h3 == c2 * l2 ? null : (c2 + a2[3] - o2 * h3 - o2 * s2[3]) / (c2 - n2 - o2 * h3 + o2 * l2);
            }
            static getLesserNonNegativeNonNull(e2, t2) {
              return null !== t2 && t2 >= 0 && t2 < e2 ? t2 : e2;
            }
          }
          class gi2 {
            constructor(e2) {
              this._globe = e2, this._mercatorCameraHelper = new Ot2(), this._verticalPerspectiveCameraHelper = new fi2();
            }
            get useGlobeControls() {
              return this._globe.useGlobeRendering;
            }
            get currentHelper() {
              return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
            }
            handlePanInertia(e2, t2) {
              return this.currentHelper.handlePanInertia(e2, t2);
            }
            handleMapControlsRollPitchBearingZoom(e2, t2) {
              return this.currentHelper.handleMapControlsRollPitchBearingZoom(e2, t2);
            }
            handleMapControlsPan(e2, t2, i2) {
              this.currentHelper.handleMapControlsPan(e2, t2, i2);
            }
            cameraForBoxAndBearing(e2, t2, i2, r2, o2) {
              return this.currentHelper.cameraForBoxAndBearing(e2, t2, i2, r2, o2);
            }
            handleJumpToCenterZoom(e2, t2) {
              this.currentHelper.handleJumpToCenterZoom(e2, t2);
            }
            handleEaseTo(e2, t2) {
              return this.currentHelper.handleEaseTo(e2, t2);
            }
            handleFlyTo(e2, t2) {
              return this.currentHelper.handleFlyTo(e2, t2);
            }
          }
          const vi2 = (e2, i2) => t.x(e2, i2 && i2.filter((e3) => "source.canvas" !== e3.identifier)), xi2 = t.bw();
          class bi2 extends t.E {
            constructor(e2, i2 = {}) {
              super(), this._rtlPluginLoaded = () => {
                for (const e3 in this.sourceCaches) {
                  const t2 = this.sourceCaches[e3].getSource().type;
                  "vector" !== t2 && "geojson" !== t2 || this.sourceCaches[e3].reload();
                }
              }, this.map = e2, this.dispatcher = new B2(F2(), e2._getMapId()), this.dispatcher.registerMessageHandler("GG", (e3, t2) => this.getGlyphs(e3, t2)), this.dispatcher.registerMessageHandler("GI", (e3, t2) => this.getImages(e3, t2)), this.imageManager = new b(), this.imageManager.setEventedParent(this), this.glyphManager = new P(e2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new vt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.bx(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", t.by()), oe2().on(te2, this._rtlPluginLoaded), this.on("data", (e3) => {
                if ("source" !== e3.dataType || "metadata" !== e3.sourceDataType) return;
                const t2 = this.sourceCaches[e3.sourceId];
                if (!t2) return;
                const i3 = t2.getSource();
                if (i3 && i3.vectorLayerIds) for (const e4 in this._layers) {
                  const t3 = this._layers[e4];
                  t3.source === i3.id && this._validateLayer(t3);
                }
              });
            }
            loadURL(e2, i2 = {}, r2) {
              this.fire(new t.l("dataloading", { dataType: "style" })), i2.validate = "boolean" != typeof i2.validate || i2.validate;
              const o2 = this.map._requestManager.transformRequest(e2, "Style");
              this._loadStyleRequest = new AbortController();
              const a2 = this._loadStyleRequest;
              t.j(o2, this._loadStyleRequest).then((e3) => {
                this._loadStyleRequest = null, this._load(e3.data, i2, r2);
              }).catch((e3) => {
                this._loadStyleRequest = null, e3 && !a2.signal.aborted && this.fire(new t.k(e3));
              });
            }
            loadJSON(e2, i2 = {}, r2) {
              this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), s.frameAsync(this._frameRequest).then(() => {
                this._frameRequest = null, i2.validate = false !== i2.validate, this._load(e2, i2, r2);
              }).catch(() => {
              });
            }
            loadEmpty() {
              this.fire(new t.l("dataloading", { dataType: "style" })), this._load(xi2, { validate: false });
            }
            _load(e2, i2, r2) {
              var o2, a2;
              const s2 = i2.transformStyle ? i2.transformStyle(r2, e2) : e2;
              if (!i2.validate || !vi2(this, t.y(s2))) {
                this._loaded = true, this.stylesheet = s2;
                for (const e3 in s2.sources) this.addSource(e3, s2.sources[e3], { validate: false });
                s2.sprite ? this._loadSprite(s2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(s2.glyphs), this._createLayers(), this.light = new I2(this.stylesheet.light), this._setProjectionInternal((null === (o2 = this.stylesheet.projection) || void 0 === o2 ? void 0 : o2.type) || "mercator"), this.sky = new S2(this.stylesheet.sky), this.map.setTerrain(null !== (a2 = this.stylesheet.terrain) && void 0 !== a2 ? a2 : null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
              }
            }
            _createLayers() {
              const e2 = t.bz(this.stylesheet.layers);
              this.dispatcher.broadcast("SL", e2), this._order = e2.map((e3) => e3.id), this._layers = {}, this._serializedLayers = null;
              for (const i2 of e2) {
                const e3 = t.bA(i2);
                e3.setEventedParent(this, { layer: { id: i2.id } }), this._layers[i2.id] = e3;
              }
            }
            _loadSprite(e2, i2 = false, r2 = void 0) {
              let o2;
              this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(e3, i3, r3, o3) {
                return t._(this, void 0, void 0, function* () {
                  const a2 = f(e3), n2 = r3 > 1 ? "@2x" : "", l2 = {}, c2 = {};
                  for (const { id: e4, url: r4 } of a2) {
                    const a3 = i3.transformRequest(g2(r4, n2, ".json"), "SpriteJSON");
                    l2[e4] = t.j(a3, o3);
                    const s2 = i3.transformRequest(g2(r4, n2, ".png"), "SpriteImage");
                    c2[e4] = p.getImage(s2, o3);
                  }
                  return yield Promise.all([...Object.values(l2), ...Object.values(c2)]), function(e4, i4) {
                    return t._(this, void 0, void 0, function* () {
                      const t2 = {};
                      for (const r4 in e4) {
                        t2[r4] = {};
                        const o4 = s.getImageCanvasContext((yield i4[r4]).data), a3 = (yield e4[r4]).data;
                        for (const e5 in a3) {
                          const { width: i5, height: s2, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u2, stretchY: d2, content: _3, textFitWidth: p2, textFitHeight: m2 } = a3[e5];
                          t2[r4][e5] = { data: null, pixelRatio: h3, sdf: c3, stretchX: u2, stretchY: d2, content: _3, textFitWidth: p2, textFitHeight: m2, spriteData: { width: i5, height: s2, x: n3, y: l3, context: o4 } };
                        }
                      }
                      return t2;
                    });
                  }(l2, c2);
                });
              }(e2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((e3) => {
                if (this._spriteRequest = null, e3) for (const t2 in e3) {
                  this._spritesImagesIds[t2] = [];
                  const r3 = this._spritesImagesIds[t2] ? this._spritesImagesIds[t2].filter((t3) => !(t3 in e3)) : [];
                  for (const e4 of r3) this.imageManager.removeImage(e4), this._changedImages[e4] = true;
                  for (const r4 in e3[t2]) {
                    const o3 = "default" === t2 ? r4 : `${t2}:${r4}`;
                    this._spritesImagesIds[t2].push(o3), o3 in this.imageManager.images ? this.imageManager.updateImage(o3, e3[t2][r4], false) : this.imageManager.addImage(o3, e3[t2][r4]), i2 && (this._changedImages[o3] = true);
                  }
                }
              }).catch((e3) => {
                this._spriteRequest = null, o2 = e3, this.fire(new t.k(o2));
              }).finally(() => {
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), r2 && r2(o2);
              });
            }
            _unloadSprite() {
              for (const e2 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e2), this._changedImages[e2] = true;
              this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
            }
            _validateLayer(e2) {
              const i2 = this.sourceCaches[e2.source];
              if (!i2) return;
              const r2 = e2.sourceLayer;
              if (!r2) return;
              const o2 = i2.getSource();
              ("geojson" === o2.type || o2.vectorLayerIds && -1 === o2.vectorLayerIds.indexOf(r2)) && this.fire(new t.k(new Error(`Source layer "${r2}" does not exist on source "${o2.id}" as specified by style layer "${e2.id}".`)));
            }
            loaded() {
              if (!this._loaded) return false;
              if (Object.keys(this._updatedSources).length) return false;
              for (const e2 in this.sourceCaches) if (!this.sourceCaches[e2].loaded()) return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeByIds(e2, i2 = false) {
              const r2 = this._serializedAllLayers();
              if (!e2 || 0 === e2.length) return Object.values(i2 ? t.bB(r2) : r2);
              const o2 = [];
              for (const a2 of e2) if (r2[a2]) {
                const e3 = i2 ? t.bB(r2[a2]) : r2[a2];
                o2.push(e3);
              }
              return o2;
            }
            _serializedAllLayers() {
              let e2 = this._serializedLayers;
              if (e2) return e2;
              e2 = this._serializedLayers = {};
              const t2 = Object.keys(this._layers);
              for (const i2 of t2) {
                const t3 = this._layers[i2];
                "custom" !== t3.type && (e2[i2] = t3.serialize());
              }
              return e2;
            }
            hasTransitions() {
              var e2, t2, i2;
              if (null === (e2 = this.light) || void 0 === e2 ? void 0 : e2.hasTransition()) return true;
              if (null === (t2 = this.sky) || void 0 === t2 ? void 0 : t2.hasTransition()) return true;
              if (null === (i2 = this.projection) || void 0 === i2 ? void 0 : i2.hasTransition()) return true;
              for (const e3 in this.sourceCaches) if (this.sourceCaches[e3].hasTransition()) return true;
              for (const e3 in this._layers) if (this._layers[e3].hasTransition()) return true;
              return false;
            }
            _checkLoaded() {
              if (!this._loaded) throw new Error("Style is not done loading.");
            }
            update(e2) {
              if (!this._loaded) return;
              const i2 = this._changed;
              if (i2) {
                const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
                (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
                for (const e3 in this._updatedSources) {
                  const t3 = this._updatedSources[e3];
                  if ("reload" === t3) this._reloadSource(e3);
                  else {
                    if ("clear" !== t3) throw new Error(`Invalid action ${t3}`);
                    this._clearSource(e3);
                  }
                }
                this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                for (const t3 in this._updatedPaintProps) this._layers[t3].updateTransitions(e2);
                this.light.updateTransitions(e2), this.sky.updateTransitions(e2), this._resetUpdates();
              }
              const r2 = {};
              for (const e3 in this.sourceCaches) {
                const t2 = this.sourceCaches[e3];
                r2[e3] = t2.used, t2.used = false;
              }
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                i3.recalculate(e2, this._availableImages), !i3.isHidden(e2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
              }
              for (const e3 in r2) {
                const i3 = this.sourceCaches[e3];
                !!r2[e3] != !!i3.used && i3.fire(new t.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: e3 }));
              }
              this.light.recalculate(e2), this.sky.recalculate(e2), this.projection.recalculate(e2), this.z = e2.zoom, i2 && this.fire(new t.l("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const e2 = Object.keys(this._changedImages);
              if (e2.length) {
                for (const t2 in this.sourceCaches) this.sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
                this._changedImages = {};
              }
            }
            _updateTilesForChangedGlyphs() {
              if (this._glyphsDidChange) {
                for (const e2 in this.sourceCaches) this.sourceCaches[e2].reloadTilesForDependencies(["glyphs"], [""]);
                this._glyphsDidChange = false;
              }
            }
            _updateWorkerLayers(e2, t2) {
              this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e2, false), removedIds: t2 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
            }
            setState(e2, i2 = {}) {
              var r2;
              this._checkLoaded();
              const o2 = this.serialize();
              if (e2 = i2.transformStyle ? i2.transformStyle(o2, e2) : e2, (null === (r2 = i2.validate) || void 0 === r2 || r2) && vi2(this, t.y(e2))) return false;
              (e2 = t.bB(e2)).layers = t.bz(e2.layers);
              const a2 = t.bC(o2, e2), s2 = this._getOperationsToPerform(a2);
              if (s2.unimplemented.length > 0) throw new Error(`Unimplemented: ${s2.unimplemented.join(", ")}.`);
              if (0 === s2.operations.length) return false;
              for (const e3 of s2.operations) e3();
              return this.stylesheet = e2, this._serializedLayers = null, true;
            }
            _getOperationsToPerform(e2) {
              const t2 = [], i2 = [];
              for (const r2 of e2) switch (r2.command) {
                case "setCenter":
                case "setZoom":
                case "setBearing":
                case "setPitch":
                case "setRoll":
                  continue;
                case "addLayer":
                  t2.push(() => this.addLayer.apply(this, r2.args));
                  break;
                case "removeLayer":
                  t2.push(() => this.removeLayer.apply(this, r2.args));
                  break;
                case "setPaintProperty":
                  t2.push(() => this.setPaintProperty.apply(this, r2.args));
                  break;
                case "setLayoutProperty":
                  t2.push(() => this.setLayoutProperty.apply(this, r2.args));
                  break;
                case "setFilter":
                  t2.push(() => this.setFilter.apply(this, r2.args));
                  break;
                case "addSource":
                  t2.push(() => this.addSource.apply(this, r2.args));
                  break;
                case "removeSource":
                  t2.push(() => this.removeSource.apply(this, r2.args));
                  break;
                case "setLayerZoomRange":
                  t2.push(() => this.setLayerZoomRange.apply(this, r2.args));
                  break;
                case "setLight":
                  t2.push(() => this.setLight.apply(this, r2.args));
                  break;
                case "setGeoJSONSourceData":
                  t2.push(() => this.setGeoJSONSourceData.apply(this, r2.args));
                  break;
                case "setGlyphs":
                  t2.push(() => this.setGlyphs.apply(this, r2.args));
                  break;
                case "setSprite":
                  t2.push(() => this.setSprite.apply(this, r2.args));
                  break;
                case "setTerrain":
                  t2.push(() => this.map.setTerrain.apply(this, r2.args));
                  break;
                case "setSky":
                  t2.push(() => this.setSky.apply(this, r2.args));
                  break;
                case "setProjection":
                  this.setProjection.apply(this, r2.args);
                  break;
                case "setTransition":
                  t2.push(() => {
                  });
                  break;
                default:
                  i2.push(r2.command);
              }
              return { operations: t2, unimplemented: i2 };
            }
            addImage(e2, i2) {
              if (this.getImage(e2)) return this.fire(new t.k(new Error(`An image named "${e2}" already exists.`)));
              this.imageManager.addImage(e2, i2), this._afterImageUpdated(e2);
            }
            updateImage(e2, t2) {
              this.imageManager.updateImage(e2, t2);
            }
            getImage(e2) {
              return this.imageManager.getImage(e2);
            }
            removeImage(e2) {
              if (!this.getImage(e2)) return this.fire(new t.k(new Error(`An image named "${e2}" does not exist.`)));
              this.imageManager.removeImage(e2), this._afterImageUpdated(e2);
            }
            _afterImageUpdated(e2) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e2, i2, r2 = {}) {
              if (this._checkLoaded(), void 0 !== this.sourceCaches[e2]) throw new Error(`Source "${e2}" already exists.`);
              if (!i2.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.y.source, `sources.${e2}`, i2, null, r2)) return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const o2 = this.sourceCaches[e2] = new be(e2, i2, this.dispatcher);
              o2.style = this, o2.setEventedParent(this, () => ({ isSourceLoaded: o2.loaded(), source: o2.serialize(), sourceId: e2 })), o2.onAdd(this.map), this._changed = true;
            }
            removeSource(e2) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e2]) throw new Error("There is no source with this ID");
              for (const i3 in this._layers) if (this._layers[i3].source === e2) return this.fire(new t.k(new Error(`Source "${e2}" cannot be removed while layer "${i3}" is using it.`)));
              const i2 = this.sourceCaches[e2];
              delete this.sourceCaches[e2], delete this._updatedSources[e2], i2.fire(new t.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(e2, t2) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e2]) throw new Error(`There is no source with this ID=${e2}`);
              const i2 = this.sourceCaches[e2].getSource();
              if ("geojson" !== i2.type) throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
              i2.setData(t2), this._changed = true;
            }
            getSource(e2) {
              return this.sourceCaches[e2] && this.sourceCaches[e2].getSource();
            }
            addLayer(e2, i2, r2 = {}) {
              this._checkLoaded();
              const o2 = e2.id;
              if (this.getLayer(o2)) return void this.fire(new t.k(new Error(`Layer "${o2}" already exists on this map.`)));
              let a2;
              if ("custom" === e2.type) {
                if (vi2(this, t.bD(e2))) return;
                a2 = t.bA(e2);
              } else {
                if ("source" in e2 && "object" == typeof e2.source && (this.addSource(o2, e2.source), e2 = t.bB(e2), e2 = t.e(e2, { source: o2 })), this._validate(t.y.layer, `layers.${o2}`, e2, { arrayIndex: -1 }, r2)) return;
                a2 = t.bA(e2), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: o2 } });
              }
              const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
              if (i2 && -1 === s2) this.fire(new t.k(new Error(`Cannot add layer "${o2}" before non-existing layer "${i2}".`)));
              else {
                if (this._order.splice(s2, 0, o2), this._layerOrderChanged = true, this._layers[o2] = a2, this._removedLayers[o2] && a2.source && "custom" !== a2.type) {
                  const e3 = this._removedLayers[o2];
                  delete this._removedLayers[o2], e3.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", this.sourceCaches[a2.source].pause());
                }
                this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map);
              }
            }
            moveLayer(e2, i2) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e2]) return void this.fire(new t.k(new Error(`The layer '${e2}' does not exist in the map's style and cannot be moved.`)));
              if (e2 === i2) return;
              const r2 = this._order.indexOf(e2);
              this._order.splice(r2, 1);
              const o2 = i2 ? this._order.indexOf(i2) : this._order.length;
              i2 && -1 === o2 ? this.fire(new t.k(new Error(`Cannot move layer "${e2}" before non-existing layer "${i2}".`))) : (this._order.splice(o2, 0, e2), this._layerOrderChanged = true);
            }
            removeLayer(e2) {
              this._checkLoaded();
              const i2 = this._layers[e2];
              if (!i2) return void this.fire(new t.k(new Error(`Cannot remove non-existing layer "${e2}".`)));
              i2.setEventedParent(null);
              const r2 = this._order.indexOf(e2);
              this._order.splice(r2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e2] = i2, delete this._layers[e2], this._serializedLayers && delete this._serializedLayers[e2], delete this._updatedLayers[e2], delete this._updatedPaintProps[e2], i2.onRemove && i2.onRemove(this.map);
            }
            getLayer(e2) {
              return this._layers[e2];
            }
            getLayersOrder() {
              return [...this._order];
            }
            hasLayer(e2) {
              return e2 in this._layers;
            }
            setLayerZoomRange(e2, i2, r2) {
              this._checkLoaded();
              const o2 = this.getLayer(e2);
              o2 ? o2.minzoom === i2 && o2.maxzoom === r2 || (null != i2 && (o2.minzoom = i2), null != r2 && (o2.maxzoom = r2), this._updateLayer(o2)) : this.fire(new t.k(new Error(`Cannot set the zoom range of non-existing layer "${e2}".`)));
            }
            setFilter(e2, i2, r2 = {}) {
              this._checkLoaded();
              const o2 = this.getLayer(e2);
              if (o2) {
                if (!t.bE(o2.filter, i2)) return null == i2 ? (o2.filter = void 0, void this._updateLayer(o2)) : void (this._validate(t.y.filter, `layers.${o2.id}.filter`, i2, null, r2) || (o2.filter = t.bB(i2), this._updateLayer(o2)));
              } else this.fire(new t.k(new Error(`Cannot filter non-existing layer "${e2}".`)));
            }
            getFilter(e2) {
              return t.bB(this.getLayer(e2).filter);
            }
            setLayoutProperty(e2, i2, r2, o2 = {}) {
              this._checkLoaded();
              const a2 = this.getLayer(e2);
              a2 ? t.bE(a2.getLayoutProperty(i2), r2) || (a2.setLayoutProperty(i2, r2, o2), this._updateLayer(a2)) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
            }
            getLayoutProperty(e2, i2) {
              const r2 = this.getLayer(e2);
              if (r2) return r2.getLayoutProperty(i2);
              this.fire(new t.k(new Error(`Cannot get style of non-existing layer "${e2}".`)));
            }
            setPaintProperty(e2, i2, r2, o2 = {}) {
              this._checkLoaded();
              const a2 = this.getLayer(e2);
              a2 ? t.bE(a2.getPaintProperty(i2), r2) || (a2.setPaintProperty(i2, r2, o2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[e2] = true, this._serializedLayers = null) : this.fire(new t.k(new Error(`Cannot style non-existing layer "${e2}".`)));
            }
            getPaintProperty(e2, t2) {
              return this.getLayer(e2).getPaintProperty(t2);
            }
            setFeatureState(e2, i2) {
              this._checkLoaded();
              const r2 = e2.source, o2 = e2.sourceLayer, a2 = this.sourceCaches[r2];
              if (void 0 === a2) return void this.fire(new t.k(new Error(`The source '${r2}' does not exist in the map's style.`)));
              const s2 = a2.getSource().type;
              "geojson" === s2 && o2 ? this.fire(new t.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s2 || o2 ? (void 0 === e2.id && this.fire(new t.k(new Error("The feature id parameter must be provided."))), a2.setFeatureState(o2, e2.id, i2)) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e2, i2) {
              this._checkLoaded();
              const r2 = e2.source, o2 = this.sourceCaches[r2];
              if (void 0 === o2) return void this.fire(new t.k(new Error(`The source '${r2}' does not exist in the map's style.`)));
              const a2 = o2.getSource().type, s2 = "vector" === a2 ? e2.sourceLayer : void 0;
              "vector" !== a2 || s2 ? i2 && "string" != typeof e2.id && "number" != typeof e2.id ? this.fire(new t.k(new Error("A feature id is required to remove its specific state property."))) : o2.removeFeatureState(s2, e2.id, i2) : this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e2) {
              this._checkLoaded();
              const i2 = e2.source, r2 = e2.sourceLayer, o2 = this.sourceCaches[i2];
              if (void 0 !== o2) return "vector" !== o2.getSource().type || r2 ? (void 0 === e2.id && this.fire(new t.k(new Error("The feature id parameter must be provided."))), o2.getFeatureState(r2, e2.id)) : void this.fire(new t.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
              this.fire(new t.k(new Error(`The source '${i2}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              if (!this._loaded) return;
              const e2 = t.bF(this.sourceCaches, (e3) => e3.serialize()), i2 = this._serializeByIds(this._order, true), r2 = this.map.getTerrain() || void 0, o2 = this.stylesheet;
              return t.bG({ version: o2.version, name: o2.name, metadata: o2.metadata, light: o2.light, sky: o2.sky, center: o2.center, zoom: o2.zoom, bearing: o2.bearing, pitch: o2.pitch, sprite: o2.sprite, glyphs: o2.glyphs, transition: o2.transition, projection: o2.projection, sources: e2, layers: i2, terrain: r2 }, (e3) => void 0 !== e3);
            }
            _updateLayer(e2) {
              this._updatedLayers[e2.id] = true, e2.source && !this._updatedSources[e2.source] && "raster" !== this.sourceCaches[e2.source].getSource().type && (this._updatedSources[e2.source] = "reload", this.sourceCaches[e2.source].pause()), this._serializedLayers = null, this._changed = true;
            }
            _flattenAndSortRenderedFeatures(e2) {
              const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, r2 = [];
              for (let o3 = this._order.length - 1; o3 >= 0; o3--) {
                const a2 = this._order[o3];
                if (t2(a2)) {
                  i2[a2] = o3;
                  for (const t3 of e2) {
                    const e3 = t3[a2];
                    if (e3) for (const t4 of e3) r2.push(t4);
                  }
                }
              }
              r2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
              const o2 = [];
              for (let a2 = this._order.length - 1; a2 >= 0; a2--) {
                const s2 = this._order[a2];
                if (t2(s2)) for (let e3 = r2.length - 1; e3 >= 0; e3--) {
                  const t3 = r2[e3].feature;
                  if (i2[t3.layer.id] < a2) break;
                  o2.push(t3), r2.pop();
                }
                else for (const t3 of e2) {
                  const e3 = t3[s2];
                  if (e3) for (const t4 of e3) o2.push(t4.feature);
                }
              }
              return o2;
            }
            queryRenderedFeatures(e2, i2, r2) {
              i2 && i2.filter && this._validate(t.y.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
              const o2 = {};
              if (i2 && i2.layers) {
                if (!(Array.isArray(i2.layers) || i2.layers instanceof Set)) return this.fire(new t.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
                for (const e3 of i2.layers) {
                  const i3 = this._layers[e3];
                  if (!i3) return this.fire(new t.k(new Error(`The layer '${e3}' does not exist in the map's style and cannot be queried for features.`))), [];
                  o2[i3.source] = true;
                }
              }
              const a2 = [];
              i2.availableImages = this._availableImages;
              const s2 = this._serializedAllLayers(), n2 = i2.layers instanceof Set ? i2.layers : Array.isArray(i2.layers) ? new Set(i2.layers) : null, l2 = Object.assign(Object.assign({}, i2), { layers: n2 });
              for (const t2 in this.sourceCaches) i2.layers && !o2[t2] || a2.push(Z2(this.sourceCaches[t2], this._layers, s2, e2, l2, r2, this.map.terrain ? (e3, t3, i3) => this.map.terrain.getElevation(e3, t3, i3) : void 0));
              return this.placement && a2.push(function(e3, t2, i3, r3, o3, a3, s3) {
                const n3 = {}, l3 = a3.queryRenderedSymbols(r3), c2 = [];
                for (const e4 of Object.keys(l3).map(Number)) c2.push(s3[e4]);
                c2.sort(N2);
                for (const i4 of c2) {
                  const r4 = i4.featureIndex.lookupSymbolFeatures(l3[i4.bucketInstanceId], t2, i4.bucketIndex, i4.sourceLayerIndex, o3.filter, o3.layers, o3.availableImages, e3);
                  for (const e4 in r4) {
                    const t3 = n3[e4] = n3[e4] || [], o4 = r4[e4];
                    o4.sort((e5, t4) => {
                      const r5 = i4.featureSortOrder;
                      if (r5) {
                        const i5 = r5.indexOf(e5.featureIndex);
                        return r5.indexOf(t4.featureIndex) - i5;
                      }
                      return t4.featureIndex - e5.featureIndex;
                    });
                    for (const e5 of o4) t3.push(e5);
                  }
                }
                return function(e4, t3, i4) {
                  for (const r4 in e4) for (const o4 of e4[r4]) U(o4, i4[t3[r4].source]);
                  return e4;
                }(n3, e3, i3);
              }(this._layers, s2, this.sourceCaches, e2, l2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a2);
            }
            querySourceFeatures(e2, i2) {
              i2 && i2.filter && this._validate(t.y.filter, "querySourceFeatures.filter", i2.filter, null, i2);
              const r2 = this.sourceCaches[e2];
              return r2 ? function(e3, t2) {
                const i3 = e3.getRenderableIds().map((t3) => e3.getTileByID(t3)), r3 = [], o2 = {};
                for (let e4 = 0; e4 < i3.length; e4++) {
                  const a2 = i3[e4], s2 = a2.tileID.canonical.key;
                  o2[s2] || (o2[s2] = true, a2.querySourceFeatures(r3, t2));
                }
                return r3;
              }(r2, i2) : [];
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e2, i2 = {}) {
              this._checkLoaded();
              const r2 = this.light.getLight();
              let o2 = false;
              for (const i3 in e2) if (!t.bE(e2[i3], r2[i3])) {
                o2 = true;
                break;
              }
              if (!o2) return;
              const a2 = { now: s.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e2, i2), this.light.updateTransitions(a2);
            }
            getProjection() {
              var e2;
              return null === (e2 = this.stylesheet) || void 0 === e2 ? void 0 : e2.projection;
            }
            setProjection(e2) {
              if (this._checkLoaded(), this.projection) {
                if (this.projection.name === e2.type) return;
                this.projection.destroy(), delete this.projection;
              }
              this.stylesheet.projection = e2, this._setProjectionInternal(e2.type);
            }
            getSky() {
              var e2;
              return null === (e2 = this.stylesheet) || void 0 === e2 ? void 0 : e2.sky;
            }
            setSky(e2, i2 = {}) {
              this._checkLoaded();
              const r2 = this.getSky();
              let o2 = false;
              if (!e2 && !r2) return;
              if (e2 && !r2) o2 = true;
              else if (!e2 && r2) o2 = true;
              else for (const i3 in e2) if (!t.bE(e2[i3], r2[i3])) {
                o2 = true;
                break;
              }
              if (!o2) return;
              const a2 = { now: s.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.stylesheet.sky = e2, this.sky.setSky(e2, i2), this.sky.updateTransitions(a2);
            }
            _setProjectionInternal(e2) {
              const i2 = function(e3) {
                if (Array.isArray(e3)) {
                  const t2 = new Jt2({ type: e3 });
                  return { projection: t2, transform: new mi2(), cameraHelper: new gi2(t2) };
                }
                switch (e3) {
                  case "mercator":
                    return { projection: new Mt2(), transform: new Lt2(), cameraHelper: new Ot2() };
                  case "globe": {
                    const e4 = new Jt2({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                    return { projection: e4, transform: new mi2(), cameraHelper: new gi2(e4) };
                  }
                  case "vertical-perspective":
                    return { projection: new Qt2(), transform: new pi2(), cameraHelper: new fi2() };
                  default:
                    return t.w(`Unknown projection name: ${e3}. Falling back to mercator projection.`), { projection: new Mt2(), transform: new Lt2(), cameraHelper: new Ot2() };
                }
              }(e2);
              this.projection = i2.projection, this.map.migrateProjection(i2.transform, i2.cameraHelper);
              for (const e3 in this.sourceCaches) this.sourceCaches[e3].reload();
            }
            _validate(e2, i2, r2, o2, a2 = {}) {
              return (!a2 || false !== a2.validate) && vi2(this, e2.call(t.y, t.e({ key: i2, style: this.serialize(), value: r2, styleSpec: t.v }, o2)));
            }
            _remove(e2 = true) {
              this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe2().off(te2, this._rtlPluginLoaded);
              for (const e3 in this._layers) this._layers[e3].setEventedParent(null);
              for (const e3 in this.sourceCaches) {
                const t2 = this.sourceCaches[e3];
                t2.setEventedParent(null), t2.onRemove(this.map);
              }
              this.imageManager.setEventedParent(null), this.setEventedParent(null), e2 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e2);
            }
            _clearSource(e2) {
              this.sourceCaches[e2].clearTiles();
            }
            _reloadSource(e2) {
              this.sourceCaches[e2].resume(), this.sourceCaches[e2].reload();
            }
            _updateSources(e2) {
              for (const t2 in this.sourceCaches) this.sourceCaches[t2].update(e2, this.map.terrain);
            }
            _generateCollisionBoxes() {
              for (const e2 in this.sourceCaches) this._reloadSource(e2);
            }
            _updatePlacement(e2, t2, i2, r2, o2 = false) {
              let a2 = false, n2 = false;
              const l2 = {};
              for (const t3 of this._order) {
                const i3 = this._layers[t3];
                if ("symbol" !== i3.type) continue;
                if (!l2[i3.source]) {
                  const e3 = this.sourceCaches[i3.source];
                  l2[i3.source] = e3.getRenderableIds(true).map((t4) => e3.getTileByID(t4)).sort((e4, t4) => t4.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t4.tileID) ? -1 : 1));
                }
                const r3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], e2.center.lng);
                a2 = a2 || r3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o2 = o2 || this._layerOrderChanged || 0 === i2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s.now(), e2.zoom)) && (this.pauseablePlacement = new _t2(e2, this.map.terrain, this._order, o2, t2, i2, r2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s.now()), n2 = true), a2 && this.pauseablePlacement.placement.setStale()), n2 || a2) for (const e3 of this._order) {
                const t3 = this._layers[e3];
                "symbol" === t3.type && this.placement.updateLayerOpacities(t3, l2[t3.source]);
              }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s.now());
            }
            _releaseSymbolFadeTiles() {
              for (const e2 in this.sourceCaches) this.sourceCaches[e2].releaseSymbolFadeTiles();
            }
            getImages(e2, i2) {
              return t._(this, void 0, void 0, function* () {
                const e3 = yield this.imageManager.getImages(i2.icons);
                this._updateTilesForChangedImages();
                const t2 = this.sourceCaches[i2.source];
                return t2 && t2.setDependencies(i2.tileID.key, i2.type, i2.icons), e3;
              });
            }
            getGlyphs(e2, i2) {
              return t._(this, void 0, void 0, function* () {
                const e3 = yield this.glyphManager.getGlyphs(i2.stacks), t2 = this.sourceCaches[i2.source];
                return t2 && t2.setDependencies(i2.tileID.key, i2.type, [""]), e3;
              });
            }
            getGlyphsUrl() {
              return this.stylesheet.glyphs || null;
            }
            setGlyphs(e2, i2 = {}) {
              this._checkLoaded(), e2 && this._validate(t.y.glyphs, "glyphs", e2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e2, this.glyphManager.entries = {}, this.glyphManager.setURL(e2));
            }
            addSprite(e2, i2, r2 = {}, o2) {
              this._checkLoaded();
              const a2 = [{ id: e2, url: i2 }], s2 = [...f(this.stylesheet.sprite), ...a2];
              this._validate(t.y.sprite, "sprite", s2, null, r2) || (this.stylesheet.sprite = s2, this._loadSprite(a2, true, o2));
            }
            removeSprite(e2) {
              this._checkLoaded();
              const i2 = f(this.stylesheet.sprite);
              if (i2.find((t2) => t2.id === e2)) {
                if (this._spritesImagesIds[e2]) for (const t2 of this._spritesImagesIds[e2]) this.imageManager.removeImage(t2), this._changedImages[t2] = true;
                i2.splice(i2.findIndex((t2) => t2.id === e2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : void 0, delete this._spritesImagesIds[e2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
              } else this.fire(new t.k(new Error(`Sprite "${e2}" doesn't exists on this map.`)));
            }
            getSprite() {
              return f(this.stylesheet.sprite);
            }
            setSprite(e2, i2 = {}, r2) {
              this._checkLoaded(), e2 && this._validate(t.y.sprite, "sprite", e2, null, i2) || (this.stylesheet.sprite = e2, e2 ? this._loadSprite(e2, true, r2) : (this._unloadSprite(), r2 && r2(null)));
            }
          }
          var yi2 = t.aG([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class wi2 {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(e2, t2, i2, r2, o2, a2, s2, n2, l2) {
              this.context = e2;
              let c2 = this.boundPaintVertexBuffers.length !== r2.length;
              for (let e3 = 0; !c2 && e3 < r2.length; e3++) this.boundPaintVertexBuffers[e3] !== r2[e3] && (c2 = true);
              !this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || c2 || this.boundIndexBuffer !== o2 || this.boundVertexOffset !== a2 || this.boundDynamicVertexBuffer !== s2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(t2, i2, r2, o2, a2, s2, n2, l2) : (e2.bindVertexArray.set(this.vao), s2 && s2.bind(), o2 && o2.dynamicDraw && o2.bind(), n2 && n2.bind(), l2 && l2.bind());
            }
            freshBind(e2, t2, i2, r2, o2, a2, s2, n2) {
              const l2 = e2.numAttributes, c2 = this.context, h3 = c2.gl;
              this.vao && this.destroy(), this.vao = c2.createVertexArray(), c2.bindVertexArray.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = r2, this.boundVertexOffset = o2, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = s2, this.boundDynamicVertexBuffer3 = n2, t2.enableAttributes(h3, e2);
              for (const t3 of i2) t3.enableAttributes(h3, e2);
              a2 && a2.enableAttributes(h3, e2), s2 && s2.enableAttributes(h3, e2), n2 && n2.enableAttributes(h3, e2), t2.bind(), t2.setVertexAttribPointers(h3, e2, o2);
              for (const t3 of i2) t3.bind(), t3.setVertexAttribPointers(h3, e2, o2);
              a2 && (a2.bind(), a2.setVertexAttribPointers(h3, e2, o2)), r2 && r2.bind(), s2 && (s2.bind(), s2.setVertexAttribPointers(h3, e2, o2)), n2 && (n2.bind(), n2.setVertexAttribPointers(h3, e2, o2)), c2.currentNumAttributes = l2;
            }
            destroy() {
              this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
            }
          }
          const Ti2 = (e2, i2, r2, o2, a2) => ({ u_texture: 0, u_ele_delta: e2, u_fog_matrix: i2, u_fog_color: r2 ? r2.properties.get("fog-color") : t.b7.white, u_fog_ground_blend: r2 ? r2.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: a2 ? 0 : r2 ? r2.calculateFogBlendOpacity(o2) : 0, u_horizon_color: r2 ? r2.properties.get("horizon-color") : t.b7.white, u_horizon_fog_blend: r2 ? r2.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: a2 ? 1 : 0 }), Pi2 = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
          function Ci2(e2) {
            const t2 = [];
            for (let i2 = 0; i2 < e2.length; i2++) {
              if (null === e2[i2]) continue;
              const r2 = e2[i2].split(" ");
              t2.push(r2.pop());
            }
            return t2;
          }
          class Mi2 {
            constructor(e2, i2, r2, o2, a2, s2, n2, l2, c2 = []) {
              const h3 = e2.gl;
              this.program = h3.createProgram();
              const u2 = Ci2(i2.staticAttributes), d2 = r2 ? r2.getBinderAttributes() : [], _3 = u2.concat(d2), p2 = bt2.prelude.staticUniforms ? Ci2(bt2.prelude.staticUniforms) : [], m2 = n2.staticUniforms ? Ci2(n2.staticUniforms) : [], f2 = i2.staticUniforms ? Ci2(i2.staticUniforms) : [], g3 = r2 ? r2.getBinderUniforms() : [], v2 = p2.concat(m2).concat(f2).concat(g3), x3 = [];
              for (const e3 of v2) x3.indexOf(e3) < 0 && x3.push(e3);
              const b2 = r2 ? r2.defines() : [];
              Wt2(h3) && b2.unshift("#version 300 es"), a2 && b2.push("#define OVERDRAW_INSPECTOR;"), s2 && b2.push("#define TERRAIN3D;"), l2 && b2.push(l2), c2 && b2.push(...c2);
              let y2 = b2.concat(bt2.prelude.fragmentSource, n2.fragmentSource, i2.fragmentSource).join("\n"), w2 = b2.concat(bt2.prelude.vertexSource, n2.vertexSource, i2.vertexSource).join("\n");
              Wt2(h3) || (y2 = function(e3) {
                return e3.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
              }(y2), w2 = function(e3) {
                return e3.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
              }(w2));
              const T2 = h3.createShader(h3.FRAGMENT_SHADER);
              if (h3.isContextLost()) return void (this.failedToCreate = true);
              if (h3.shaderSource(T2, y2), h3.compileShader(T2), !h3.getShaderParameter(T2, h3.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${h3.getShaderInfoLog(T2)}`);
              h3.attachShader(this.program, T2);
              const P2 = h3.createShader(h3.VERTEX_SHADER);
              if (h3.isContextLost()) return void (this.failedToCreate = true);
              if (h3.shaderSource(P2, w2), h3.compileShader(P2), !h3.getShaderParameter(P2, h3.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${h3.getShaderInfoLog(P2)}`);
              h3.attachShader(this.program, P2), this.attributes = {};
              const C3 = {};
              this.numAttributes = _3.length;
              for (let e3 = 0; e3 < this.numAttributes; e3++) _3[e3] && (h3.bindAttribLocation(this.program, e3, _3[e3]), this.attributes[_3[e3]] = e3);
              if (h3.linkProgram(this.program), !h3.getProgramParameter(this.program, h3.LINK_STATUS)) throw new Error(`Program failed to link: ${h3.getProgramInfoLog(this.program)}`);
              h3.deleteShader(P2), h3.deleteShader(T2);
              for (let e3 = 0; e3 < x3.length; e3++) {
                const t2 = x3[e3];
                if (t2 && !C3[t2]) {
                  const e4 = h3.getUniformLocation(this.program, t2);
                  e4 && (C3[t2] = e4);
                }
              }
              this.fixedUniforms = o2(e2, C3), this.terrainUniforms = ((e3, i3) => ({ u_depth: new t.bH(e3, i3.u_depth), u_terrain: new t.bH(e3, i3.u_terrain), u_terrain_dim: new t.b8(e3, i3.u_terrain_dim), u_terrain_matrix: new t.bJ(e3, i3.u_terrain_matrix), u_terrain_unpack: new t.bK(e3, i3.u_terrain_unpack), u_terrain_exaggeration: new t.b8(e3, i3.u_terrain_exaggeration) }))(e2, C3), this.projectionUniforms = ((e3, i3) => ({ u_projection_matrix: new t.bJ(e3, i3.u_projection_matrix), u_projection_tile_mercator_coords: new t.bK(e3, i3.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t.bK(e3, i3.u_projection_clipping_plane), u_projection_transition: new t.b8(e3, i3.u_projection_transition), u_projection_fallback_matrix: new t.bJ(e3, i3.u_projection_fallback_matrix) }))(e2, C3), this.binderUniforms = r2 ? r2.getUniforms(e2, C3) : [];
            }
            draw(e2, t2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3, p2, m2, f2, g3, v2) {
              const x3 = e2.gl;
              if (this.failedToCreate) return;
              if (e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(r2), e2.setColorMode(o2), e2.setCullFace(a2), n2) {
                e2.activeTexture.set(x3.TEXTURE2), x3.bindTexture(x3.TEXTURE_2D, n2.depthTexture), e2.activeTexture.set(x3.TEXTURE3), x3.bindTexture(x3.TEXTURE_2D, n2.texture);
                for (const e3 in this.terrainUniforms) this.terrainUniforms[e3].set(n2[e3]);
              }
              if (l2) for (const e3 in l2) this.projectionUniforms[Pi2[e3]].set(l2[e3]);
              if (s2) for (const e3 in this.fixedUniforms) this.fixedUniforms[e3].set(s2[e3]);
              m2 && m2.setUniforms(e2, this.binderUniforms, _3, { zoom: p2 });
              let b2 = 0;
              switch (t2) {
                case x3.LINES:
                  b2 = 2;
                  break;
                case x3.TRIANGLES:
                  b2 = 3;
                  break;
                case x3.LINE_STRIP:
                  b2 = 1;
              }
              for (const i3 of d2.get()) {
                const r3 = i3.vaos || (i3.vaos = {});
                (r3[c2] || (r3[c2] = new wi2())).bind(e2, this, h3, m2 ? m2.getPaintVertexBuffers() : [], u2, i3.vertexOffset, f2, g3, v2), x3.drawElements(t2, i3.primitiveLength * b2, x3.UNSIGNED_SHORT, i3.primitiveOffset * b2 * 2);
              }
            }
          }
          function Ii2(e2, i2, r2) {
            const o2 = 1 / t.az(r2, 1, i2.transform.tileZoom), a2 = Math.pow(2, r2.tileID.overscaledZ), s2 = r2.tileSize * Math.pow(2, i2.transform.tileZoom) / a2, n2 = s2 * (r2.tileID.canonical.x + r2.tileID.wrap * a2), l2 = s2 * r2.tileID.canonical.y;
            return { u_image: 0, u_texsize: r2.imageAtlasTexture.size, u_scale: [o2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [n2 >> 16, l2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & l2] };
          }
          const Ei2 = (e2, i2, r2, o2) => {
            const a2 = e2.style.light, s2 = a2.properties.get("position"), n2 = [s2.x, s2.y, s2.z], l2 = t.bN();
            "viewport" === a2.properties.get("anchor") && t.bO(l2, e2.transform.bearingInRadians), t.bP(n2, n2, l2);
            const c2 = e2.transform.transformLightDirection(n2), h3 = a2.properties.get("color");
            return { u_lightpos: n2, u_lightpos_globe: c2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [h3.r, h3.g, h3.b], u_vertical_gradient: +i2, u_opacity: r2, u_fill_translate: o2 };
          }, Si2 = (e2, i2, r2, o2, a2, s2, n2) => t.e(Ei2(e2, i2, r2, o2), Ii2(s2, e2, n2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / n2.tileSize / 8 }), Ri2 = (e2, i2, r2, o2) => t.e(Ii2(i2, e2, r2), { u_fill_translate: o2 }), zi2 = (e2, t2) => ({ u_world: e2, u_fill_translate: t2 }), Di2 = (e2, i2, r2, o2, a2) => t.e(Ri2(e2, i2, r2, a2), { u_world: o2 }), Ai2 = (e2, i2, r2, o2, a2) => {
            const s2 = e2.transform;
            let n2, l2, c2 = 0;
            if ("map" === r2.paint.get("circle-pitch-alignment")) {
              const e3 = t.az(i2, 1, s2.zoom);
              n2 = true, l2 = [e3, e3], c2 = e3 / (t.Z * Math.pow(2, i2.tileID.overscaledZ)) * 2 * Math.PI * a2;
            } else n2 = false, l2 = s2.pixelsToGLUnits;
            return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === r2.paint.get("circle-pitch-scale")), u_pitch_with_map: +n2, u_device_pixel_ratio: e2.pixelRatio, u_extrude_scale: l2, u_globe_extrude_scale: c2, u_translate: o2 };
          }, Li2 = (e2) => ({ u_pixel_extrude_scale: [1 / e2.width, 1 / e2.height] }), ki2 = (e2) => ({ u_viewport_size: [e2.width, e2.height] }), Fi2 = (e2, t2 = 1) => ({ u_color: e2, u_overlay: 0, u_overlay_scale: t2 }), Bi2 = (e2, i2, r2, o2) => {
            const a2 = t.az(e2, 1, i2) / (t.Z * Math.pow(2, e2.tileID.overscaledZ)) * 2 * Math.PI * o2;
            return { u_extrude_scale: t.az(e2, 1, i2), u_intensity: r2, u_globe_extrude_scale: a2 };
          }, Oi2 = (e2, i2, r2, o2) => {
            const a2 = t.K();
            t.bQ(a2, 0, e2.width, e2.height, 0, 0, 1);
            const s2 = e2.context.gl;
            return { u_matrix: a2, u_world: [s2.drawingBufferWidth, s2.drawingBufferHeight], u_image: r2, u_color_ramp: o2, u_opacity: i2.paint.get("heatmap-opacity") };
          }, ji2 = (e2, t2, i2) => {
            const r2 = i2.paint.get("hillshade-accent-color");
            let o2;
            switch (i2.paint.get("hillshade-method")) {
              case "basic":
                o2 = 4;
                break;
              case "combined":
                o2 = 1;
                break;
              case "igor":
                o2 = 2;
                break;
              case "multidirectional":
                o2 = 3;
                break;
              default:
                o2 = 0;
            }
            const a2 = i2.getIlluminationProperties();
            for (let t3 = 0; t3 < a2.directionRadians.length; t3++) "viewport" === i2.paint.get("hillshade-illumination-anchor") && (a2.directionRadians[t3] += e2.transform.bearingInRadians);
            return { u_image: 0, u_latrange: Ni2(0, t2.tileID), u_exaggeration: i2.paint.get("hillshade-exaggeration"), u_altitudes: a2.altitudeRadians, u_azimuths: a2.directionRadians, u_accent: r2, u_method: o2, u_highlights: a2.highlightColor, u_shadows: a2.shadowColor };
          }, Zi2 = (e2, i2) => {
            const r2 = i2.stride, o2 = t.K();
            return t.bQ(o2, 0, t.Z, -8192, 0, 0, 1), t.L(o2, o2, [0, -8192, 0]), { u_matrix: o2, u_image: 1, u_dimension: [r2, r2], u_zoom: e2.overscaledZ, u_unpack: i2.getUnpackVector() };
          };
          function Ni2(e2, i2) {
            const r2 = Math.pow(2, i2.canonical.z), o2 = i2.canonical.y;
            return [new t.$(0, o2 / r2).toLngLat().lat, new t.$(0, (o2 + 1) / r2).toLngLat().lat];
          }
          const Ui2 = (e2, i2, r2, o2) => {
            const a2 = e2.transform;
            return { u_translation: Hi2(e2, i2, r2), u_ratio: o2 / t.az(i2, 1, a2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
          }, Gi2 = (e2, i2, r2, o2, a2) => t.e(Ui2(e2, i2, r2, o2), { u_image: 0, u_image_height: a2 }), Vi2 = (e2, i2, r2, o2, a2) => {
            const s2 = e2.transform, n2 = Wi2(i2, s2);
            return { u_translation: Hi2(e2, i2, r2), u_texsize: i2.imageAtlasTexture.size, u_ratio: o2 / t.az(i2, 1, s2.zoom), u_device_pixel_ratio: e2.pixelRatio, u_image: 0, u_scale: [n2, a2.fromScale, a2.toScale], u_fade: a2.t, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
          }, qi2 = (e2, i2, r2, o2, a2, s2) => {
            const n2 = e2.lineAtlas, l2 = Wi2(i2, e2.transform), c2 = "round" === r2.layout.get("line-cap"), h3 = n2.getDash(a2.from, c2), u2 = n2.getDash(a2.to, c2), d2 = h3.width * s2.fromScale, _3 = u2.width * s2.toScale;
            return t.e(Ui2(e2, i2, r2, o2), { u_patternscale_a: [l2 / d2, -h3.height / 2], u_patternscale_b: [l2 / _3, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _3) * e2.pixelRatio) / 2, u_image: 0, u_tex_y_a: h3.y, u_tex_y_b: u2.y, u_mix: s2.t });
          };
          function Wi2(e2, i2) {
            return 1 / t.az(e2, 1, i2.tileZoom);
          }
          function Hi2(e2, i2, r2) {
            return t.aA(e2.transform, i2, r2.paint.get("line-translate"), r2.paint.get("line-translate-anchor"));
          }
          const $i2 = (e2, t2, i2, r2, o2) => {
            return { u_tl_parent: e2, u_scale_parent: t2, u_buffer_scale: 1, u_fade_t: i2.mix, u_opacity: i2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = r2.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (a2 = r2.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: Xi2(r2.paint.get("raster-hue-rotate")), u_coords_top: [o2[0].x, o2[0].y, o2[1].x, o2[1].y], u_coords_bottom: [o2[3].x, o2[3].y, o2[2].x, o2[2].y] };
            var a2, s2;
          };
          function Xi2(e2) {
            e2 *= Math.PI / 180;
            const t2 = Math.sin(e2), i2 = Math.cos(e2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
          }
          const Ki2 = (e2, t2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2) => {
            const _3 = s2.transform;
            return { u_is_size_zoom_constant: +("constant" === e2 || "source" === e2), u_is_size_feature_constant: +("constant" === e2 || "camera" === e2), u_size_t: t2 ? t2.uSizeT : 0, u_size: t2 ? t2.uSize : 0, u_camera_to_center_distance: _3.cameraToCenterDistance, u_pitch: _3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: _3.width / _3.height, u_fade_change: s2.options.fadeDuration ? s2.symbolFadeChange : 1, u_label_plane_matrix: n2, u_coord_matrix: l2, u_is_text: +h3, u_pitch_with_map: +r2, u_is_along_line: o2, u_is_variable_anchor: a2, u_texsize: u2, u_texture: 0, u_translation: c2, u_pitched_scale: d2 };
          }, Qi2 = (e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3, p2) => {
            const m2 = n2.transform;
            return t.e(Ki2(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, p2), { u_gamma_scale: o2 ? Math.cos(m2.pitch * Math.PI / 180) * m2.cameraToCenterDistance : 1, u_device_pixel_ratio: n2.pixelRatio, u_is_halo: 1 });
          }, Yi2 = (e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3) => t.e(Qi2(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, true, u2, 0, _3), { u_texsize_icon: d2, u_texture_icon: 1 }), Ji2 = (e2, t2) => ({ u_opacity: e2, u_color: t2 }), er2 = (e2, i2, r2, o2, a2) => t.e(function(e3, i3, r3, o3) {
            const a3 = r3.imageManager.getPattern(e3.from.toString()), s2 = r3.imageManager.getPattern(e3.to.toString()), { width: n2, height: l2 } = r3.imageManager.getPixelSize(), c2 = Math.pow(2, o3.tileID.overscaledZ), h3 = o3.tileSize * Math.pow(2, r3.transform.tileZoom) / c2, u2 = h3 * (o3.tileID.canonical.x + o3.tileID.wrap * c2), d2 = h3 * o3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: s2.tl, u_pattern_br_b: s2.br, u_texsize: [n2, l2], u_mix: i3.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: s2.displaySize, u_scale_a: i3.fromScale, u_scale_b: i3.toScale, u_tile_units_to_pixels: 1 / t.az(o3, 1, r3.transform.tileZoom), u_pixel_coord_upper: [u2 >> 16, d2 >> 16], u_pixel_coord_lower: [65535 & u2, 65535 & d2] };
          }(r2, a2, i2, o2), { u_opacity: e2 }), tr2 = (e2, t2) => {
          }, ir = { fillExtrusion: (e2, i2) => ({ u_lightpos: new t.bL(e2, i2.u_lightpos), u_lightpos_globe: new t.bL(e2, i2.u_lightpos_globe), u_lightintensity: new t.b8(e2, i2.u_lightintensity), u_lightcolor: new t.bL(e2, i2.u_lightcolor), u_vertical_gradient: new t.b8(e2, i2.u_vertical_gradient), u_opacity: new t.b8(e2, i2.u_opacity), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillExtrusionPattern: (e2, i2) => ({ u_lightpos: new t.bL(e2, i2.u_lightpos), u_lightpos_globe: new t.bL(e2, i2.u_lightpos_globe), u_lightintensity: new t.b8(e2, i2.u_lightintensity), u_lightcolor: new t.bL(e2, i2.u_lightcolor), u_vertical_gradient: new t.b8(e2, i2.u_vertical_gradient), u_height_factor: new t.b8(e2, i2.u_height_factor), u_opacity: new t.b8(e2, i2.u_opacity), u_fill_translate: new t.bM(e2, i2.u_fill_translate), u_image: new t.bH(e2, i2.u_image), u_texsize: new t.bM(e2, i2.u_texsize), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade) }), fill: (e2, i2) => ({ u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillPattern: (e2, i2) => ({ u_image: new t.bH(e2, i2.u_image), u_texsize: new t.bM(e2, i2.u_texsize), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillOutline: (e2, i2) => ({ u_world: new t.bM(e2, i2.u_world), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), fillOutlinePattern: (e2, i2) => ({ u_world: new t.bM(e2, i2.u_world), u_image: new t.bH(e2, i2.u_image), u_texsize: new t.bM(e2, i2.u_texsize), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade), u_fill_translate: new t.bM(e2, i2.u_fill_translate) }), circle: (e2, i2) => ({ u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.bH(e2, i2.u_scale_with_map), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_extrude_scale: new t.bM(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_globe_extrude_scale: new t.b8(e2, i2.u_globe_extrude_scale), u_translate: new t.bM(e2, i2.u_translate) }), collisionBox: (e2, i2) => ({ u_pixel_extrude_scale: new t.bM(e2, i2.u_pixel_extrude_scale) }), collisionCircle: (e2, i2) => ({ u_viewport_size: new t.bM(e2, i2.u_viewport_size) }), debug: (e2, i2) => ({ u_color: new t.bI(e2, i2.u_color), u_overlay: new t.bH(e2, i2.u_overlay), u_overlay_scale: new t.b8(e2, i2.u_overlay_scale) }), depth: tr2, clippingMask: tr2, heatmap: (e2, i2) => ({ u_extrude_scale: new t.b8(e2, i2.u_extrude_scale), u_intensity: new t.b8(e2, i2.u_intensity), u_globe_extrude_scale: new t.b8(e2, i2.u_globe_extrude_scale) }), heatmapTexture: (e2, i2) => ({ u_matrix: new t.bJ(e2, i2.u_matrix), u_world: new t.bM(e2, i2.u_world), u_image: new t.bH(e2, i2.u_image), u_color_ramp: new t.bH(e2, i2.u_color_ramp), u_opacity: new t.b8(e2, i2.u_opacity) }), hillshade: (e2, i2) => ({ u_image: new t.bH(e2, i2.u_image), u_latrange: new t.bM(e2, i2.u_latrange), u_exaggeration: new t.b8(e2, i2.u_exaggeration), u_altitudes: new t.bS(e2, i2.u_altitudes), u_azimuths: new t.bS(e2, i2.u_azimuths), u_accent: new t.bI(e2, i2.u_accent), u_method: new t.bH(e2, i2.u_method), u_shadows: new t.bR(e2, i2.u_shadows), u_highlights: new t.bR(e2, i2.u_highlights) }), hillshadePrepare: (e2, i2) => ({ u_matrix: new t.bJ(e2, i2.u_matrix), u_image: new t.bH(e2, i2.u_image), u_dimension: new t.bM(e2, i2.u_dimension), u_zoom: new t.b8(e2, i2.u_zoom), u_unpack: new t.bK(e2, i2.u_unpack) }), line: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels) }), lineGradient: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels), u_image: new t.bH(e2, i2.u_image), u_image_height: new t.b8(e2, i2.u_image_height) }), linePattern: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_texsize: new t.bM(e2, i2.u_texsize), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_image: new t.bH(e2, i2.u_image), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels), u_scale: new t.bL(e2, i2.u_scale), u_fade: new t.b8(e2, i2.u_fade) }), lineSDF: (e2, i2) => ({ u_translation: new t.bM(e2, i2.u_translation), u_ratio: new t.b8(e2, i2.u_ratio), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.bM(e2, i2.u_units_to_pixels), u_patternscale_a: new t.bM(e2, i2.u_patternscale_a), u_patternscale_b: new t.bM(e2, i2.u_patternscale_b), u_sdfgamma: new t.b8(e2, i2.u_sdfgamma), u_image: new t.bH(e2, i2.u_image), u_tex_y_a: new t.b8(e2, i2.u_tex_y_a), u_tex_y_b: new t.b8(e2, i2.u_tex_y_b), u_mix: new t.b8(e2, i2.u_mix) }), raster: (e2, i2) => ({ u_tl_parent: new t.bM(e2, i2.u_tl_parent), u_scale_parent: new t.b8(e2, i2.u_scale_parent), u_buffer_scale: new t.b8(e2, i2.u_buffer_scale), u_fade_t: new t.b8(e2, i2.u_fade_t), u_opacity: new t.b8(e2, i2.u_opacity), u_image0: new t.bH(e2, i2.u_image0), u_image1: new t.bH(e2, i2.u_image1), u_brightness_low: new t.b8(e2, i2.u_brightness_low), u_brightness_high: new t.b8(e2, i2.u_brightness_high), u_saturation_factor: new t.b8(e2, i2.u_saturation_factor), u_contrast_factor: new t.b8(e2, i2.u_contrast_factor), u_spin_weights: new t.bL(e2, i2.u_spin_weights), u_coords_top: new t.bK(e2, i2.u_coords_top), u_coords_bottom: new t.bK(e2, i2.u_coords_bottom) }), symbolIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.bH(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bH(e2, i2.u_is_size_feature_constant), u_size_t: new t.b8(e2, i2.u_size_t), u_size: new t.b8(e2, i2.u_size), u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_pitch: new t.b8(e2, i2.u_pitch), u_rotate_symbol: new t.bH(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.b8(e2, i2.u_aspect_ratio), u_fade_change: new t.b8(e2, i2.u_fade_change), u_label_plane_matrix: new t.bJ(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.bJ(e2, i2.u_coord_matrix), u_is_text: new t.bH(e2, i2.u_is_text), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_is_along_line: new t.bH(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bH(e2, i2.u_is_variable_anchor), u_texsize: new t.bM(e2, i2.u_texsize), u_texture: new t.bH(e2, i2.u_texture), u_translation: new t.bM(e2, i2.u_translation), u_pitched_scale: new t.b8(e2, i2.u_pitched_scale) }), symbolSDF: (e2, i2) => ({ u_is_size_zoom_constant: new t.bH(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bH(e2, i2.u_is_size_feature_constant), u_size_t: new t.b8(e2, i2.u_size_t), u_size: new t.b8(e2, i2.u_size), u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_pitch: new t.b8(e2, i2.u_pitch), u_rotate_symbol: new t.bH(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.b8(e2, i2.u_aspect_ratio), u_fade_change: new t.b8(e2, i2.u_fade_change), u_label_plane_matrix: new t.bJ(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.bJ(e2, i2.u_coord_matrix), u_is_text: new t.bH(e2, i2.u_is_text), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_is_along_line: new t.bH(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bH(e2, i2.u_is_variable_anchor), u_texsize: new t.bM(e2, i2.u_texsize), u_texture: new t.bH(e2, i2.u_texture), u_gamma_scale: new t.b8(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_is_halo: new t.bH(e2, i2.u_is_halo), u_translation: new t.bM(e2, i2.u_translation), u_pitched_scale: new t.b8(e2, i2.u_pitched_scale) }), symbolTextAndIcon: (e2, i2) => ({ u_is_size_zoom_constant: new t.bH(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bH(e2, i2.u_is_size_feature_constant), u_size_t: new t.b8(e2, i2.u_size_t), u_size: new t.b8(e2, i2.u_size), u_camera_to_center_distance: new t.b8(e2, i2.u_camera_to_center_distance), u_pitch: new t.b8(e2, i2.u_pitch), u_rotate_symbol: new t.bH(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.b8(e2, i2.u_aspect_ratio), u_fade_change: new t.b8(e2, i2.u_fade_change), u_label_plane_matrix: new t.bJ(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.bJ(e2, i2.u_coord_matrix), u_is_text: new t.bH(e2, i2.u_is_text), u_pitch_with_map: new t.bH(e2, i2.u_pitch_with_map), u_is_along_line: new t.bH(e2, i2.u_is_along_line), u_is_variable_anchor: new t.bH(e2, i2.u_is_variable_anchor), u_texsize: new t.bM(e2, i2.u_texsize), u_texsize_icon: new t.bM(e2, i2.u_texsize_icon), u_texture: new t.bH(e2, i2.u_texture), u_texture_icon: new t.bH(e2, i2.u_texture_icon), u_gamma_scale: new t.b8(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.b8(e2, i2.u_device_pixel_ratio), u_is_halo: new t.bH(e2, i2.u_is_halo), u_translation: new t.bM(e2, i2.u_translation), u_pitched_scale: new t.b8(e2, i2.u_pitched_scale) }), background: (e2, i2) => ({ u_opacity: new t.b8(e2, i2.u_opacity), u_color: new t.bI(e2, i2.u_color) }), backgroundPattern: (e2, i2) => ({ u_opacity: new t.b8(e2, i2.u_opacity), u_image: new t.bH(e2, i2.u_image), u_pattern_tl_a: new t.bM(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.bM(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.bM(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.bM(e2, i2.u_pattern_br_b), u_texsize: new t.bM(e2, i2.u_texsize), u_mix: new t.b8(e2, i2.u_mix), u_pattern_size_a: new t.bM(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.bM(e2, i2.u_pattern_size_b), u_scale_a: new t.b8(e2, i2.u_scale_a), u_scale_b: new t.b8(e2, i2.u_scale_b), u_pixel_coord_upper: new t.bM(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.bM(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.b8(e2, i2.u_tile_units_to_pixels) }), terrain: (e2, i2) => ({ u_texture: new t.bH(e2, i2.u_texture), u_ele_delta: new t.b8(e2, i2.u_ele_delta), u_fog_matrix: new t.bJ(e2, i2.u_fog_matrix), u_fog_color: new t.bI(e2, i2.u_fog_color), u_fog_ground_blend: new t.b8(e2, i2.u_fog_ground_blend), u_fog_ground_blend_opacity: new t.b8(e2, i2.u_fog_ground_blend_opacity), u_horizon_color: new t.bI(e2, i2.u_horizon_color), u_horizon_fog_blend: new t.b8(e2, i2.u_horizon_fog_blend), u_is_globe_mode: new t.b8(e2, i2.u_is_globe_mode) }), terrainDepth: (e2, i2) => ({ u_ele_delta: new t.b8(e2, i2.u_ele_delta) }), terrainCoords: (e2, i2) => ({ u_texture: new t.bH(e2, i2.u_texture), u_terrain_coords_id: new t.b8(e2, i2.u_terrain_coords_id), u_ele_delta: new t.b8(e2, i2.u_ele_delta) }), projectionErrorMeasurement: (e2, i2) => ({ u_input: new t.b8(e2, i2.u_input), u_output_expected: new t.b8(e2, i2.u_output_expected) }), atmosphere: (e2, i2) => ({ u_sun_pos: new t.bL(e2, i2.u_sun_pos), u_atmosphere_blend: new t.b8(e2, i2.u_atmosphere_blend), u_globe_position: new t.bL(e2, i2.u_globe_position), u_globe_radius: new t.b8(e2, i2.u_globe_radius), u_inv_proj_matrix: new t.bJ(e2, i2.u_inv_proj_matrix) }), sky: (e2, i2) => ({ u_sky_color: new t.bI(e2, i2.u_sky_color), u_horizon_color: new t.bI(e2, i2.u_horizon_color), u_horizon: new t.bM(e2, i2.u_horizon), u_horizon_normal: new t.bM(e2, i2.u_horizon_normal), u_sky_horizon_blend: new t.b8(e2, i2.u_sky_horizon_blend), u_sky_blend: new t.b8(e2, i2.u_sky_blend) }) };
          class rr2 {
            constructor(e2, t2, i2) {
              this.context = e2;
              const r2 = e2.gl;
              this.buffer = r2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), r2.bufferData(r2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e2) {
              const t2 = this.context.gl;
              if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
              this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const or = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class ar {
            constructor(e2, t2, i2, r2) {
              this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = r2, this.context = e2;
              const o2 = e2.gl;
              this.buffer = o2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), o2.bufferData(o2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e2) {
              if (e2.length !== this.length) throw new Error(`Length of new data is ${e2.length}, which doesn't match current length of ${this.length}`);
              const t2 = this.context.gl;
              this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            enableAttributes(e2, t2) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const r2 = t2.attributes[this.attributes[i2].name];
                void 0 !== r2 && e2.enableVertexAttribArray(r2);
              }
            }
            setVertexAttribPointers(e2, t2, i2) {
              for (let r2 = 0; r2 < this.attributes.length; r2++) {
                const o2 = this.attributes[r2], a2 = t2.attributes[o2.name];
                void 0 !== a2 && e2.vertexAttribPointer(a2, o2.components, e2[or[o2.type]], false, this.itemSize, o2.offset + this.itemSize * (i2 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class sr {
            constructor(e2) {
              this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(e2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class nr extends sr {
            getDefault() {
              return t.b7.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class lr extends sr {
            getDefault() {
              return 1;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
            }
          }
          class cr2 extends sr {
            getDefault() {
              return 0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
            }
          }
          class hr2 extends sr {
            getDefault() {
              return [true, true, true, true];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class ur2 extends sr {
            getDefault() {
              return true;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class dr2 extends sr {
            getDefault() {
              return 255;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class _r2 extends sr {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(e2) {
              const t2 = this.current;
              (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
            }
          }
          class pr2 extends sr {
            getDefault() {
              const e2 = this.gl;
              return [e2.KEEP, e2.KEEP, e2.KEEP];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
            }
          }
          class mr2 extends sr {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
            }
          }
          class fr2 extends sr {
            getDefault() {
              return [0, 1];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
            }
          }
          class gr2 extends sr {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
            }
          }
          class vr2 extends sr {
            getDefault() {
              return this.gl.LESS;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
            }
          }
          class xr2 extends sr {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
            }
          }
          class br2 extends sr {
            getDefault() {
              const e2 = this.gl;
              return [e2.ONE, e2.ZERO];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
            }
          }
          class yr2 extends sr {
            getDefault() {
              return t.b7.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class wr2 extends sr {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
            }
          }
          class Tr2 extends sr {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
            }
          }
          class Pr extends sr {
            getDefault() {
              return this.gl.BACK;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
            }
          }
          class Cr2 extends sr {
            getDefault() {
              return this.gl.CCW;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
            }
          }
          class Mr2 extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
            }
          }
          class Ir2 extends sr {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
            }
          }
          class Er2 extends sr {
            getDefault() {
              const e2 = this.gl;
              return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class Sr2 extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class Rr extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class zr2 extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
            }
          }
          class Dr2 extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class Ar2 extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              const t2 = this.gl;
              t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class Lr2 extends sr {
            getDefault() {
              return null;
            }
            set(e2) {
              var t2;
              if (e2 === this.current && !this.dirty) return;
              const i2 = this.gl;
              Wt2(i2) ? i2.bindVertexArray(e2) : null === (t2 = i2.getExtension("OES_vertex_array_object")) || void 0 === t2 || t2.bindVertexArrayOES(e2), this.current = e2, this.dirty = false;
            }
          }
          class kr2 extends sr {
            getDefault() {
              return 4;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
            }
          }
          class Fr extends sr {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class Br2 extends sr {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class Or extends sr {
            constructor(e2, t2) {
              super(e2), this.context = e2, this.parent = t2;
            }
            getDefault() {
              return null;
            }
          }
          class jr2 extends Or {
            setDirty() {
              this.dirty = true;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
            }
          }
          class Zr2 extends Or {
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class Nr extends Or {
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferRenderbuffer(t2.FRAMEBUFFER, t2.DEPTH_STENCIL_ATTACHMENT, t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          const Ur2 = "Framebuffer is not complete";
          class Gr2 {
            constructor(e2, t2, i2, r2, o2) {
              this.context = e2, this.width = t2, this.height = i2;
              const a2 = e2.gl, s2 = this.framebuffer = a2.createFramebuffer();
              if (this.colorAttachment = new jr2(e2, s2), r2) this.depthAttachment = o2 ? new Nr(e2, s2) : new Zr2(e2, s2);
              else if (o2) throw new Error("Stencil cannot be set without depth");
              if (a2.checkFramebufferStatus(a2.FRAMEBUFFER) !== a2.FRAMEBUFFER_COMPLETE) throw new Error(Ur2);
            }
            destroy() {
              const e2 = this.context.gl, t2 = this.colorAttachment.get();
              if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
                const t3 = this.depthAttachment.get();
                t3 && e2.deleteRenderbuffer(t3);
              }
              e2.deleteFramebuffer(this.framebuffer);
            }
          }
          class Vr2 {
            constructor(e2) {
              var t2, i2;
              if (this.gl = e2, this.clearColor = new nr(this), this.clearDepth = new lr(this), this.clearStencil = new cr2(this), this.colorMask = new hr2(this), this.depthMask = new ur2(this), this.stencilMask = new dr2(this), this.stencilFunc = new _r2(this), this.stencilOp = new pr2(this), this.stencilTest = new mr2(this), this.depthRange = new fr2(this), this.depthTest = new gr2(this), this.depthFunc = new vr2(this), this.blend = new xr2(this), this.blendFunc = new br2(this), this.blendColor = new yr2(this), this.blendEquation = new wr2(this), this.cullFace = new Tr2(this), this.cullFaceSide = new Pr(this), this.frontFace = new Cr2(this), this.program = new Mr2(this), this.activeTexture = new Ir2(this), this.viewport = new Er2(this), this.bindFramebuffer = new Sr2(this), this.bindRenderbuffer = new Rr(this), this.bindTexture = new zr2(this), this.bindVertexBuffer = new Dr2(this), this.bindElementBuffer = new Ar2(this), this.bindVertexArray = new Lr2(this), this.pixelStoreUnpack = new kr2(this), this.pixelStoreUnpackPremultiplyAlpha = new Fr(this), this.pixelStoreUnpackFlipY = new Br2(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), Wt2(e2)) {
                this.HALF_FLOAT = e2.HALF_FLOAT;
                const r2 = e2.getExtension("EXT_color_buffer_half_float");
                this.RGBA16F = null !== (t2 = e2.RGBA16F) && void 0 !== t2 ? t2 : null == r2 ? void 0 : r2.RGBA16F_EXT, this.RGB16F = null !== (i2 = e2.RGB16F) && void 0 !== i2 ? i2 : null == r2 ? void 0 : r2.RGB16F_EXT, e2.getExtension("EXT_color_buffer_float");
              } else {
                e2.getExtension("EXT_color_buffer_half_float"), e2.getExtension("OES_texture_half_float_linear");
                const t3 = e2.getExtension("OES_texture_half_float");
                this.HALF_FLOAT = null == t3 ? void 0 : t3.HALF_FLOAT_OES;
              }
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(e2, t2) {
              return new rr2(this, e2, t2);
            }
            createVertexBuffer(e2, t2, i2) {
              return new ar(this, e2, t2, i2);
            }
            createRenderbuffer(e2, t2, i2) {
              const r2 = this.gl, o2 = r2.createRenderbuffer();
              return this.bindRenderbuffer.set(o2), r2.renderbufferStorage(r2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), o2;
            }
            createFramebuffer(e2, t2, i2, r2) {
              return new Gr2(this, e2, t2, i2, r2);
            }
            clear({ color: e2, depth: t2, stencil: i2 }) {
              const r2 = this.gl;
              let o2 = 0;
              e2 && (o2 |= r2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (o2 |= r2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (o2 |= r2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), r2.clear(o2);
            }
            setCullFace(e2) {
              false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
            }
            setDepthMode(e2) {
              e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
            }
            setStencilMode(e2) {
              e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(e2) {
              t.bE(e2.blendFunction, jt.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
            }
            createVertexArray() {
              var e2;
              return Wt2(this.gl) ? this.gl.createVertexArray() : null === (e2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e2 ? void 0 : e2.createVertexArrayOES();
            }
            deleteVertexArray(e2) {
              var t2;
              return Wt2(this.gl) ? this.gl.deleteVertexArray(e2) : null === (t2 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t2 ? void 0 : t2.deleteVertexArrayOES(e2);
            }
            unbindVAO() {
              this.bindVertexArray.set(null);
            }
          }
          let qr2;
          function Wr2(e2, i2, r2, o2, a2) {
            const s2 = e2.context, n2 = e2.transform, l2 = s2.gl, c2 = e2.useProgram("collisionBox"), h3 = [];
            let u2 = 0, d2 = 0;
            for (let t2 = 0; t2 < o2.length; t2++) {
              const _4 = o2[t2], p3 = i2.getTile(_4).getBucket(r2);
              if (!p3) continue;
              const m3 = a2 ? p3.textCollisionBox : p3.iconCollisionBox, f3 = p3.collisionCircleArray;
              f3.length > 0 && (h3.push({ circleArray: f3, circleOffset: d2, coord: _4 }), u2 += f3.length / 4, d2 = u2), m3 && c2.draw(s2, l2.LINES, Ut2.disabled, Vt2.disabled, e2.colorModeForRenderPass(), Nt2.disabled, Li2(e2.transform), e2.style.map.terrain && e2.style.map.terrain.getTerrainData(_4), n2.getProjectionData({ overscaledTileID: _4, applyGlobeMatrix: true, applyTerrainMatrix: true }), r2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, null, e2.transform.zoom, null, null, m3.collisionVertexBuffer);
            }
            if (!a2 || !h3.length) return;
            const _3 = e2.useProgram("collisionCircle"), p2 = new t.bT();
            p2.resize(4 * u2), p2._trim();
            let m2 = 0;
            for (const e3 of h3) for (let t2 = 0; t2 < e3.circleArray.length / 4; t2++) {
              const i3 = 4 * t2, r3 = e3.circleArray[i3 + 0], o3 = e3.circleArray[i3 + 1], a3 = e3.circleArray[i3 + 2], s3 = e3.circleArray[i3 + 3];
              p2.emplace(m2++, r3, o3, a3, s3, 0), p2.emplace(m2++, r3, o3, a3, s3, 1), p2.emplace(m2++, r3, o3, a3, s3, 2), p2.emplace(m2++, r3, o3, a3, s3, 3);
            }
            (!qr2 || qr2.length < 2 * u2) && (qr2 = function(e3) {
              const i3 = 2 * e3, r3 = new t.bV();
              r3.resize(i3), r3._trim();
              for (let e4 = 0; e4 < i3; e4++) {
                const t2 = 6 * e4;
                r3.uint16[t2 + 0] = 4 * e4 + 0, r3.uint16[t2 + 1] = 4 * e4 + 1, r3.uint16[t2 + 2] = 4 * e4 + 2, r3.uint16[t2 + 3] = 4 * e4 + 2, r3.uint16[t2 + 4] = 4 * e4 + 3, r3.uint16[t2 + 5] = 4 * e4 + 0;
              }
              return r3;
            }(u2));
            const f2 = s2.createIndexBuffer(qr2, true), g3 = s2.createVertexBuffer(p2, t.bU.members, true);
            for (const i3 of h3) {
              const o3 = ki2(e2.transform);
              _3.draw(s2, l2.TRIANGLES, Ut2.disabled, Vt2.disabled, e2.colorModeForRenderPass(), Nt2.disabled, o3, e2.style.map.terrain && e2.style.map.terrain.getTerrainData(i3.coord), null, r2.id, g3, f2, t.aJ.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
            }
            g3.destroy(), f2.destroy();
          }
          const Hr2 = t.ad(new Float32Array(16));
          function $r(e2, i2, r2, o2, a2, s2) {
            const { horizontalAlign: n2, verticalAlign: l2 } = t.aE(e2);
            return new t.P((-(n2 - 0.5) * i2 / a2 + o2[0]) * s2, (-(l2 - 0.5) * r2 / a2 + o2[1]) * s2);
          }
          function Xr2(e2, i2, r2, o2, a2, s2) {
            const n2 = i2.tileAnchorPoint.add(new t.P(i2.translation[0], i2.translation[1]));
            if (i2.pitchWithMap) {
              let e3 = o2.mult(s2);
              r2 || (e3 = e3.rotate(-a2));
              const t2 = n2.add(e3);
              return Se(t2.x, t2.y, i2.pitchedLabelPlaneMatrix, i2.getElevation).point;
            }
            if (r2) {
              const t2 = Oe2(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(e2), r3 = Math.atan(t2.y / t2.x) + (t2.x < 0 ? Math.PI : 0);
              return e2.add(o2.rotate(r3));
            }
            return e2.add(o2);
          }
          function Kr2(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2) {
            const _3 = e2.text.placedSymbolArray, p2 = e2.text.dynamicLayoutVertexArray, m2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
            p2.clear();
            for (let m3 = 0; m3 < _3.length; m3++) {
              const g3 = _3.get(m3), v2 = g3.hidden || !g3.crossTileID || e2.allowVerticalPlacement && !g3.placedOrientation ? null : o2[g3.crossTileID];
              if (v2) {
                const o3 = new t.P(g3.anchorX, g3.anchorY), _4 = { getElevation: d2, width: a2.width, height: a2.height, pitchedLabelPlaneMatrix: s2, pitchWithMap: r2, transform: a2, tileAnchorPoint: o3, translation: h3, unwrappedTileID: u2 }, m4 = r2 ? Ze2(o3.x, o3.y, _4) : Oe2(o3.x, o3.y, _4), x3 = Re2(a2.cameraToCenterDistance, m4.signedDistanceFromCamera);
                let b2 = t.am(e2.textSizeData, l2, g3) * x3 / t.ay;
                r2 && (b2 *= e2.tilePixelRatio / n2);
                const { width: y2, height: w2, anchor: T2, textOffset: P2, textBoxScale: C3 } = v2, M3 = $r(T2, y2, w2, P2, C3, b2), I3 = a2.getPitchedTextCorrection(o3.x + h3[0], o3.y + h3[1], u2), E3 = Xr2(m4.point, _4, i2, M3, -a2.bearingInRadians, I3), S3 = e2.allowVerticalPlacement && g3.placedOrientation === t.al.vertical ? Math.PI / 2 : 0;
                for (let e3 = 0; e3 < g3.numGlyphs; e3++) t.as(p2, E3, S3);
                c2 && g3.associatedIconIndex >= 0 && (f2[g3.associatedIconIndex] = { shiftedAnchor: E3, angle: S3 });
              } else qe(g3.numGlyphs, p2);
            }
            if (c2) {
              m2.clear();
              const i3 = e2.icon.placedSymbolArray;
              for (let e3 = 0; e3 < i3.length; e3++) {
                const r3 = i3.get(e3);
                if (r3.hidden) qe(r3.numGlyphs, m2);
                else {
                  const i4 = f2[e3];
                  if (i4) for (let e4 = 0; e4 < r3.numGlyphs; e4++) t.as(m2, i4.shiftedAnchor, i4.angle);
                  else qe(r3.numGlyphs, m2);
                }
              }
              e2.icon.dynamicLayoutVertexBuffer.updateData(m2);
            }
            e2.text.dynamicLayoutVertexBuffer.updateData(p2);
          }
          function Qr2(e2, t2, i2) {
            return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
          }
          function Yr2(e2, i2, r2, o2, a2, s2, n2, l2, c2, h3, u2, d2, _3) {
            const p2 = e2.context, m2 = p2.gl, f2 = e2.transform, g3 = "map" === l2, v2 = "map" === c2, x3 = "viewport" !== l2 && "point" !== r2.layout.get("symbol-placement"), b2 = g3 && !v2 && !x3, y2 = !r2.layout.get("symbol-sort-key").isConstant();
            let w2 = false;
            const T2 = e2.getDepthModeForSublayer(0, Ut2.ReadOnly), P2 = r2._unevaluatedLayout.hasValue("text-variable-anchor") || r2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C3 = [], M3 = f2.getCircleRadiusCorrection();
            for (const l3 of o2) {
              const o3 = i2.getTile(l3), c3 = o3.getBucket(r2);
              if (!c3) continue;
              const u3 = a2 ? c3.text : c3.icon;
              if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices) continue;
              const d3 = u3.programConfigurations.get(r2.id), p3 = a2 || c3.sdfIcons, T3 = a2 ? c3.textSizeData : c3.iconSizeData, I3 = v2 || 0 !== f2.pitch, E3 = e2.useProgram(Qr2(p3, a2, c3), d3), S3 = t.ak(T3, f2.zoom), R2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(l3);
              let z2, D3, A3, L3, k2 = [0, 0], F3 = null;
              if (a2) D3 = o3.glyphAtlasTexture, A3 = m2.LINEAR, z2 = o3.glyphAtlasTexture.size, c3.iconsInText && (k2 = o3.imageAtlasTexture.size, F3 = o3.imageAtlasTexture, L3 = I3 || e2.options.rotating || e2.options.zooming || "composite" === T3.kind || "camera" === T3.kind ? m2.LINEAR : m2.NEAREST);
              else {
                const t2 = 1 !== r2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
                D3 = o3.imageAtlasTexture, A3 = p3 || e2.options.rotating || e2.options.zooming || t2 || I3 ? m2.LINEAR : m2.NEAREST, z2 = o3.imageAtlasTexture.size;
              }
              const B3 = t.az(o3, 1, e2.transform.zoom), O3 = Me2(g3, e2.transform, B3), j2 = t.K();
              t.an(j2, O3);
              const Z3 = Ie(v2, g3, e2.transform, B3), N3 = t.aA(f2, o3, s2, n2), U2 = f2.getProjectionData({ overscaledTileID: l3, applyGlobeMatrix: !_3, applyTerrainMatrix: true }), G3 = P2 && c3.hasTextData(), V3 = "none" !== r2.layout.get("icon-text-fit") && G3 && c3.hasIconData();
              if (x3) {
                const t2 = e2.style.map.terrain ? (t3, i4) => e2.style.map.terrain.getElevation(l3, t3, i4) : null, i3 = "map" === r2.layout.get("text-rotation-alignment");
                De(c3, e2, a2, O3, j2, v2, h3, i3, l3.toUnwrapped(), f2.width, f2.height, N3, t2);
              }
              const q3 = a2 && P2 || V3, W3 = x3 || q3 ? Hr2 : v2 ? O3 : e2.transform.clipSpaceToPixelsMatrix, H3 = p3 && 0 !== r2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
              let $3;
              $3 = p3 ? c3.iconsInText ? Yi2(T3.kind, S3, b2, v2, x3, q3, e2, W3, Z3, N3, z2, k2, M3) : Qi2(T3.kind, S3, b2, v2, x3, q3, e2, W3, Z3, N3, a2, z2, 0, M3) : Ki2(T3.kind, S3, b2, v2, x3, q3, e2, W3, Z3, N3, a2, z2, M3);
              const X3 = { program: E3, buffers: u3, uniformValues: $3, projectionData: U2, atlasTexture: D3, atlasTextureIcon: F3, atlasInterpolation: A3, atlasInterpolationIcon: L3, isSDF: p3, hasHalo: H3 };
              if (y2 && c3.canOverlap) {
                w2 = true;
                const e3 = u3.segments.get();
                for (const i3 of e3) C3.push({ segments: new t.aJ([i3]), sortKey: i3.sortKey, state: X3, terrainData: R2 });
              } else C3.push({ segments: u3.segments, sortKey: 0, state: X3, terrainData: R2 });
            }
            w2 && C3.sort((e3, t2) => e3.sortKey - t2.sortKey);
            for (const t2 of C3) {
              const i3 = t2.state;
              if (p2.activeTexture.set(m2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, m2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (p2.activeTexture.set(m2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, m2.CLAMP_TO_EDGE)), i3.isSDF) {
                const o3 = i3.uniformValues;
                i3.hasHalo && (o3.u_is_halo = 1, Jr2(i3.buffers, t2.segments, r2, e2, i3.program, T2, u2, d2, o3, i3.projectionData, t2.terrainData)), o3.u_is_halo = 0;
              }
              Jr2(i3.buffers, t2.segments, r2, e2, i3.program, T2, u2, d2, i3.uniformValues, i3.projectionData, t2.terrainData);
            }
          }
          function Jr2(e2, t2, i2, r2, o2, a2, s2, n2, l2, c2, h3) {
            const u2 = r2.context;
            o2.draw(u2, u2.gl.TRIANGLES, a2, s2, n2, Nt2.backCCW, l2, h3, c2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, r2.transform.zoom, e2.programConfigurations.get(i2.id), e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer);
          }
          function eo2(e2, i2, r2, o2, a2) {
            const s2 = e2.context, n2 = s2.gl, l2 = Vt2.disabled, c2 = new jt([n2.ONE, n2.ONE], t.b7.transparent, [true, true, true, true]), h3 = i2.getBucket(r2);
            if (!h3) return;
            const u2 = o2.key;
            let d2 = r2.heatmapFbos.get(u2);
            d2 || (d2 = io2(s2, i2.tileSize, i2.tileSize), r2.heatmapFbos.set(u2, d2)), s2.bindFramebuffer.set(d2.framebuffer), s2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), s2.clear({ color: t.b7.transparent });
            const _3 = h3.programConfigurations.get(r2.id), p2 = e2.useProgram("heatmap", _3, !a2), m2 = e2.transform.getProjectionData({ overscaledTileID: i2.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), f2 = e2.style.map.terrain.getTerrainData(o2);
            p2.draw(s2, n2.TRIANGLES, Ut2.disabled, l2, c2, Nt2.disabled, Bi2(i2, e2.transform.zoom, r2.paint.get("heatmap-intensity"), 1), f2, m2, r2.id, h3.layoutVertexBuffer, h3.indexBuffer, h3.segments, r2.paint, e2.transform.zoom, _3);
          }
          function to2(e2, t2, i2, r2, o2) {
            const a2 = e2.context, s2 = a2.gl, n2 = e2.transform;
            a2.setColorMode(e2.colorModeForRenderPass());
            const l2 = ro2(a2, t2), c2 = i2.key, h3 = t2.heatmapFbos.get(c2);
            if (!h3) return;
            a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, h3.colorAttachment.get()), a2.activeTexture.set(s2.TEXTURE1), l2.bind(s2.LINEAR, s2.CLAMP_TO_EDGE);
            const u2 = n2.getProjectionData({ overscaledTileID: i2, applyTerrainMatrix: o2, applyGlobeMatrix: !r2 });
            e2.useProgram("heatmapTexture").draw(a2, s2.TRIANGLES, Ut2.disabled, Vt2.disabled, e2.colorModeForRenderPass(), Nt2.disabled, Oi2(e2, t2, 0, 1), null, u2, t2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments, t2.paint, n2.zoom), h3.destroy(), t2.heatmapFbos.delete(c2);
          }
          function io2(e2, t2, i2) {
            var r2, o2;
            const a2 = e2.gl, s2 = a2.createTexture();
            a2.bindTexture(a2.TEXTURE_2D, s2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, a2.CLAMP_TO_EDGE), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, a2.LINEAR), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, a2.LINEAR);
            const n2 = null !== (r2 = e2.HALF_FLOAT) && void 0 !== r2 ? r2 : a2.UNSIGNED_BYTE, l2 = null !== (o2 = e2.RGBA16F) && void 0 !== o2 ? o2 : a2.RGBA;
            a2.texImage2D(a2.TEXTURE_2D, 0, l2, t2, i2, 0, a2.RGBA, n2, null);
            const c2 = e2.createFramebuffer(t2, i2, false, false);
            return c2.colorAttachment.set(s2), c2;
          }
          function ro2(e2, t2) {
            return t2.colorRampTexture || (t2.colorRampTexture = new v(e2, t2.colorRamp, e2.gl.RGBA)), t2.colorRampTexture;
          }
          function oo2(e2, t2, i2, r2, o2) {
            if (!i2 || !r2 || !r2.imageAtlas) return;
            const a2 = r2.imageAtlas.patternPositions;
            let s2 = a2[i2.to.toString()], n2 = a2[i2.from.toString()];
            if (!s2 && n2 && (s2 = n2), !n2 && s2 && (n2 = s2), !s2 || !n2) {
              const e3 = o2.getPaintProperty(t2);
              s2 = a2[e3], n2 = a2[e3];
            }
            s2 && n2 && e2.setConstantPatternPositions(s2, n2);
          }
          function ao2(e2, i2, r2, o2, a2, s2, n2, l2) {
            const c2 = e2.context.gl, h3 = "fill-pattern", u2 = r2.paint.get(h3), d2 = u2 && u2.constantOr(1), _3 = r2.getCrossfadeParameters();
            let p2, m2, f2, g3, v2;
            const x3 = e2.transform, b2 = r2.paint.get("fill-translate"), y2 = r2.paint.get("fill-translate-anchor");
            n2 ? (m2 = d2 && !r2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p2 = c2.LINES) : (m2 = d2 ? "fillPattern" : "fill", p2 = c2.TRIANGLES);
            const w2 = u2.constantOr(null);
            for (const u3 of o2) {
              const o3 = i2.getTile(u3);
              if (d2 && !o3.patternsLoaded()) continue;
              const T2 = o3.getBucket(r2);
              if (!T2) continue;
              const P2 = T2.programConfigurations.get(r2.id), C3 = e2.useProgram(m2, P2), M3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(u3);
              d2 && (e2.context.activeTexture.set(c2.TEXTURE0), o3.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), P2.updatePaintBuffers(_3)), oo2(P2, h3, w2, o3, r2);
              const I3 = x3.getProjectionData({ overscaledTileID: u3, applyGlobeMatrix: !l2, applyTerrainMatrix: true }), E3 = t.aA(x3, o3, b2, y2);
              if (n2) {
                g3 = T2.indexBuffer2, v2 = T2.segments2;
                const t2 = [c2.drawingBufferWidth, c2.drawingBufferHeight];
                f2 = "fillOutlinePattern" === m2 && d2 ? Di2(e2, _3, o3, t2, E3) : zi2(t2, E3);
              } else g3 = T2.indexBuffer, v2 = T2.segments, f2 = d2 ? Ri2(e2, _3, o3, E3) : { u_fill_translate: E3 };
              const S3 = e2.stencilModeForClipping(u3);
              C3.draw(e2.context, p2, a2, S3, s2, Nt2.backCCW, f2, M3, I3, r2.id, T2.layoutVertexBuffer, g3, v2, r2.paint, e2.transform.zoom, P2);
            }
          }
          function so2(e2, i2, r2, o2, a2, s2, n2, l2) {
            const c2 = e2.context, h3 = c2.gl, u2 = "fill-extrusion-pattern", d2 = r2.paint.get(u2), _3 = d2.constantOr(1), p2 = r2.getCrossfadeParameters(), m2 = r2.paint.get("fill-extrusion-opacity"), f2 = d2.constantOr(null), g3 = e2.transform;
            for (const d3 of o2) {
              const o3 = i2.getTile(d3), v2 = o3.getBucket(r2);
              if (!v2) continue;
              const x3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(d3), b2 = v2.programConfigurations.get(r2.id), y2 = e2.useProgram(_3 ? "fillExtrusionPattern" : "fillExtrusion", b2);
              _3 && (e2.context.activeTexture.set(h3.TEXTURE0), o3.imageAtlasTexture.bind(h3.LINEAR, h3.CLAMP_TO_EDGE), b2.updatePaintBuffers(p2));
              const w2 = g3.getProjectionData({ overscaledTileID: d3, applyGlobeMatrix: !l2, applyTerrainMatrix: true });
              oo2(b2, u2, f2, o3, r2);
              const T2 = t.aA(g3, o3, r2.paint.get("fill-extrusion-translate"), r2.paint.get("fill-extrusion-translate-anchor")), P2 = r2.paint.get("fill-extrusion-vertical-gradient"), C3 = _3 ? Si2(e2, P2, m2, T2, d3, p2, o3) : Ei2(e2, P2, m2, T2);
              y2.draw(c2, c2.gl.TRIANGLES, a2, s2, n2, Nt2.backCCW, C3, x3, w2, r2.id, v2.layoutVertexBuffer, v2.indexBuffer, v2.segments, r2.paint, e2.transform.zoom, b2, e2.style.map.terrain && v2.centroidVertexBuffer);
            }
          }
          function no2(e2, t2, i2, r2, o2, a2, s2, n2, l2) {
            var c2;
            const h3 = e2.style.projection, u2 = e2.context, d2 = e2.transform, _3 = u2.gl, p2 = [`#define NUM_ILLUMINATION_SOURCES ${i2.paint.get("hillshade-highlight-color").values.length}`], m2 = e2.useProgram("hillshade", null, false, p2), f2 = !e2.options.moving;
            for (const p3 of r2) {
              const r3 = t2.getTile(p3), g3 = r3.fbo;
              if (!g3) continue;
              const v2 = h3.getMeshFromTileID(u2, p3.canonical, n2, true, "raster"), x3 = null === (c2 = e2.style.map.terrain) || void 0 === c2 ? void 0 : c2.getTerrainData(p3);
              u2.activeTexture.set(_3.TEXTURE0), _3.bindTexture(_3.TEXTURE_2D, g3.colorAttachment.get());
              const b2 = d2.getProjectionData({ overscaledTileID: p3, aligned: f2, applyGlobeMatrix: !l2, applyTerrainMatrix: true });
              m2.draw(u2, _3.TRIANGLES, a2, o2[p3.overscaledZ], s2, Nt2.backCCW, ji2(e2, r3, i2), x3, b2, i2.id, v2.vertexBuffer, v2.indexBuffer, v2.segments);
            }
          }
          const lo2 = [new t.P(0, 0), new t.P(t.Z, 0), new t.P(t.Z, t.Z), new t.P(0, t.Z)];
          function co2(e2, t2, i2, r2, o2, a2, s2, n2, l2 = false, c2 = false) {
            const h3 = r2[r2.length - 1].overscaledZ, u2 = e2.context, d2 = u2.gl, _3 = e2.useProgram("raster"), p2 = e2.transform, m2 = e2.style.projection, f2 = e2.colorModeForRenderPass(), g3 = !e2.options.moving;
            for (const v2 of r2) {
              const r3 = e2.getDepthModeForSublayer(v2.overscaledZ - h3, 1 === i2.paint.get("raster-opacity") ? Ut2.ReadWrite : Ut2.ReadOnly, d2.LESS), x3 = t2.getTile(v2);
              x3.registerFadeDuration(i2.paint.get("raster-fade-duration"));
              const b2 = t2.findLoadedParent(v2, 0), y2 = t2.findLoadedSibling(v2), w2 = ho2(x3, b2 || y2 || null, t2, i2, e2.transform, e2.style.map.terrain);
              let T2, P2;
              const C3 = "nearest" === i2.paint.get("raster-resampling") ? d2.NEAREST : d2.LINEAR;
              u2.activeTexture.set(d2.TEXTURE0), x3.texture.bind(C3, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), u2.activeTexture.set(d2.TEXTURE1), b2 ? (b2.texture.bind(C3, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), T2 = Math.pow(2, b2.tileID.overscaledZ - x3.tileID.overscaledZ), P2 = [x3.tileID.canonical.x * T2 % 1, x3.tileID.canonical.y * T2 % 1]) : x3.texture.bind(C3, d2.CLAMP_TO_EDGE, d2.LINEAR_MIPMAP_NEAREST), x3.texture.useMipmap && u2.extTextureFilterAnisotropic && e2.transform.pitch > 20 && d2.texParameterf(d2.TEXTURE_2D, u2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u2.extTextureFilterAnisotropicMax);
              const M3 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(v2), I3 = p2.getProjectionData({ overscaledTileID: v2, aligned: g3, applyGlobeMatrix: !c2, applyTerrainMatrix: true }), E3 = $i2(P2 || [0, 0], T2 || 1, w2, i2, n2), S3 = m2.getMeshFromTileID(u2, v2.canonical, a2, s2, "raster");
              _3.draw(u2, d2.TRIANGLES, r3, o2 ? o2[v2.overscaledZ] : Vt2.disabled, f2, l2 ? Nt2.frontCCW : Nt2.backCCW, E3, M3, I3, i2.id, S3.vertexBuffer, S3.indexBuffer, S3.segments);
            }
          }
          function ho2(e2, i2, r2, o2, a2, n2) {
            const l2 = o2.paint.get("raster-fade-duration");
            if (!n2 && l2 > 0) {
              const o3 = s.now(), n3 = (o3 - e2.timeAdded) / l2, c2 = i2 ? (o3 - i2.timeAdded) / l2 : -1, h3 = r2.getSource(), u2 = ve2(a2, { tileSize: h3.tileSize, roundZoom: h3.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - u2) > Math.abs(e2.tileID.overscaledZ - u2), _3 = d2 && e2.refreshedUponExpiration ? 1 : t.ae(d2 ? n3 : 1 - c2, 0, 1);
              return e2.refreshedUponExpiration && n3 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _3 } : { opacity: _3, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          const uo2 = new t.b7(1, 0, 0, 1), _o2 = new t.b7(0, 1, 0, 1), po2 = new t.b7(0, 0, 1, 1), mo2 = new t.b7(1, 0, 1, 1), fo2 = new t.b7(0, 1, 1, 1);
          function go2(e2, t2, i2, r2) {
            xo2(e2, 0, t2 + i2 / 2, e2.transform.width, i2, r2);
          }
          function vo2(e2, t2, i2, r2) {
            xo2(e2, t2 - i2 / 2, 0, i2, e2.transform.height, r2);
          }
          function xo2(e2, t2, i2, r2, o2, a2) {
            const s2 = e2.context, n2 = s2.gl;
            n2.enable(n2.SCISSOR_TEST), n2.scissor(t2 * e2.pixelRatio, i2 * e2.pixelRatio, r2 * e2.pixelRatio, o2 * e2.pixelRatio), s2.clear({ color: a2 }), n2.disable(n2.SCISSOR_TEST);
          }
          function bo2(e2, i2, r2) {
            const o2 = e2.context, a2 = o2.gl, s2 = e2.useProgram("debug"), n2 = Ut2.disabled, l2 = Vt2.disabled, c2 = e2.colorModeForRenderPass(), h3 = "$debug", u2 = e2.style.map.terrain && e2.style.map.terrain.getTerrainData(r2);
            o2.activeTexture.set(a2.TEXTURE0);
            const d2 = i2.getTileByID(r2.key).latestRawTileData, _3 = Math.floor((d2 && d2.byteLength || 0) / 1024), p2 = i2.getTile(r2).tileSize, m2 = 512 / Math.min(p2, 512) * (r2.overscaledZ / e2.transform.zoom) * 0.5;
            let f2 = r2.canonical.toString();
            r2.overscaledZ !== r2.canonical.z && (f2 += ` => ${r2.overscaledZ}`), function(e3, t2) {
              e3.initDebugOverlayCanvas();
              const i3 = e3.debugOverlayCanvas, r3 = e3.context.gl, o3 = e3.debugOverlayCanvas.getContext("2d");
              o3.clearRect(0, 0, i3.width, i3.height), o3.shadowColor = "white", o3.shadowBlur = 2, o3.lineWidth = 1.5, o3.strokeStyle = "white", o3.textBaseline = "top", o3.font = "bold 36px Open Sans, sans-serif", o3.fillText(t2, 5, 5), o3.strokeText(t2, 5, 5), e3.debugOverlayTexture.update(i3), e3.debugOverlayTexture.bind(r3.LINEAR, r3.CLAMP_TO_EDGE);
            }(e2, `${f2} ${_3}kB`);
            const g3 = e2.transform.getProjectionData({ overscaledTileID: r2, applyGlobeMatrix: true, applyTerrainMatrix: true });
            s2.draw(o2, a2.TRIANGLES, n2, l2, jt.alphaBlended, Nt2.disabled, Fi2(t.b7.transparent, m2), null, g3, h3, e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments), s2.draw(o2, a2.LINE_STRIP, n2, l2, c2, Nt2.disabled, Fi2(t.b7.red), u2, g3, h3, e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
          }
          function yo2(e2, t2, i2, r2) {
            const { isRenderingGlobe: o2 } = r2, a2 = e2.context, s2 = a2.gl, n2 = e2.transform, l2 = e2.colorModeForRenderPass(), c2 = e2.getDepthModeFor3D(), h3 = e2.useProgram("terrain");
            a2.bindFramebuffer.set(null), a2.viewport.set([0, 0, e2.width, e2.height]);
            for (const r3 of i2) {
              const i3 = t2.getTerrainMesh(r3.tileID), u2 = e2.renderToTexture.getTexture(r3), d2 = t2.getTerrainData(r3.tileID);
              a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, u2.texture);
              const _3 = t2.getMeshFrameDelta(n2.zoom), p2 = n2.calculateFogMatrix(r3.tileID.toUnwrapped()), m2 = Ti2(_3, p2, e2.style.sky, n2.pitch, o2), f2 = n2.getProjectionData({ overscaledTileID: r3.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
              h3.draw(a2, s2.TRIANGLES, c2, Vt2.disabled, l2, Nt2.backCCW, m2, d2, f2, "terrain", i3.vertexBuffer, i3.indexBuffer, i3.segments);
            }
          }
          function wo2(e2, i2) {
            if (!i2.mesh) {
              const r2 = new t.aI();
              r2.emplaceBack(-1, -1), r2.emplaceBack(1, -1), r2.emplaceBack(1, 1), r2.emplaceBack(-1, 1);
              const o2 = new t.aK();
              o2.emplaceBack(0, 1, 2), o2.emplaceBack(0, 2, 3), i2.mesh = new wt2(e2.createVertexBuffer(r2, Tt2.members), e2.createIndexBuffer(o2), t.aJ.simpleSegment(0, 0, r2.length, o2.length));
            }
            return i2.mesh;
          }
          class To2 {
            constructor(e2, i2) {
              this.context = new Vr2(e2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.ad(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = be.maxUnderzooming + be.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new vt();
            }
            resize(e2, t2, i2) {
              if (this.width = Math.floor(e2 * i2), this.height = Math.floor(t2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e3 of this.style._order) this.style._layers[e3].resize();
            }
            setup() {
              const e2 = this.context, i2 = new t.aI();
              i2.emplaceBack(0, 0), i2.emplaceBack(t.Z, 0), i2.emplaceBack(0, t.Z), i2.emplaceBack(t.Z, t.Z), this.tileExtentBuffer = e2.createVertexBuffer(i2, Tt2.members), this.tileExtentSegments = t.aJ.simpleSegment(0, 0, 4, 2);
              const r2 = new t.aI();
              r2.emplaceBack(0, 0), r2.emplaceBack(t.Z, 0), r2.emplaceBack(0, t.Z), r2.emplaceBack(t.Z, t.Z), this.debugBuffer = e2.createVertexBuffer(r2, Tt2.members), this.debugSegments = t.aJ.simpleSegment(0, 0, 4, 5);
              const o2 = new t.b_();
              o2.emplaceBack(0, 0, 0, 0), o2.emplaceBack(t.Z, 0, t.Z, 0), o2.emplaceBack(0, t.Z, 0, t.Z), o2.emplaceBack(t.Z, t.Z, t.Z, t.Z), this.rasterBoundsBuffer = e2.createVertexBuffer(o2, yi2.members), this.rasterBoundsSegments = t.aJ.simpleSegment(0, 0, 4, 2);
              const a2 = new t.aI();
              a2.emplaceBack(0, 0), a2.emplaceBack(t.Z, 0), a2.emplaceBack(0, t.Z), a2.emplaceBack(t.Z, t.Z), this.rasterBoundsBufferPosOnly = e2.createVertexBuffer(a2, Tt2.members), this.rasterBoundsSegmentsPosOnly = t.aJ.simpleSegment(0, 0, 4, 5);
              const s2 = new t.aI();
              s2.emplaceBack(0, 0), s2.emplaceBack(1, 0), s2.emplaceBack(0, 1), s2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(s2, Tt2.members), this.viewportSegments = t.aJ.simpleSegment(0, 0, 4, 2);
              const n2 = new t.b$();
              n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
              const l2 = new t.aK();
              l2.emplaceBack(1, 0, 2), l2.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(l2);
              const c2 = this.context.gl;
              this.stencilClearMode = new Vt2({ func: c2.ALWAYS, mask: 0 }, 0, 255, c2.ZERO, c2.ZERO, c2.ZERO), this.tileExtentMesh = new wt2(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
            clearStencil() {
              const e2 = this.context, i2 = e2.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0;
              const r2 = t.K();
              t.bQ(r2, 0, this.width, this.height, 0, 0, 1), t.M(r2, r2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]);
              const o2 = { mainMatrix: r2, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: r2 };
              this.useProgram("clippingMask", null, true).draw(e2, i2.TRIANGLES, Ut2.disabled, this.stencilClearMode, jt.disabled, Nt2.disabled, null, null, o2, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(e2, t2, i2) {
              if (this.currentStencilSource === e2.source || !e2.isTileClipped() || !t2 || !t2.length) return;
              this.currentStencilSource = e2.source, this.nextStencilID + t2.length > 256 && this.clearStencil();
              const r2 = this.context;
              r2.setColorMode(jt.disabled), r2.setDepthMode(Ut2.disabled);
              const o2 = {};
              for (const e3 of t2) o2[e3.key] = this.nextStencilID++;
              this._renderTileMasks(o2, t2, i2, true), this._renderTileMasks(o2, t2, i2, false), this._tileClippingMaskIDs = o2;
            }
            _renderTileMasks(e2, t2, i2, r2) {
              const o2 = this.context, a2 = o2.gl, s2 = this.style.projection, n2 = this.transform, l2 = this.useProgram("clippingMask");
              for (const c2 of t2) {
                const t3 = e2[c2.key], h3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c2), u2 = s2.getMeshFromTileID(this.context, c2.canonical, r2, true, "stencil"), d2 = n2.getProjectionData({ overscaledTileID: c2, applyGlobeMatrix: !i2, applyTerrainMatrix: true });
                l2.draw(o2, a2.TRIANGLES, Ut2.disabled, new Vt2({ func: a2.ALWAYS, mask: 0 }, t3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), jt.disabled, i2 ? Nt2.disabled : Nt2.backCCW, null, h3, d2, "$clipping", u2.vertexBuffer, u2.indexBuffer, u2.segments);
              }
            }
            _renderTilesDepthBuffer() {
              const e2 = this.context, t2 = e2.gl, i2 = this.style.projection, r2 = this.transform, o2 = this.useProgram("depth"), a2 = this.getDepthModeFor3D(), s2 = xe2(r2, { tileSize: r2.tileSize });
              for (const n2 of s2) {
                const s3 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n2), l2 = i2.getMeshFromTileID(this.context, n2.canonical, true, true, "raster"), c2 = r2.getProjectionData({ overscaledTileID: n2, applyGlobeMatrix: true, applyTerrainMatrix: true });
                o2.draw(e2, t2.TRIANGLES, a2, Vt2.disabled, jt.disabled, Nt2.backCCW, null, s3, c2, "$clipping", l2.vertexBuffer, l2.indexBuffer, l2.segments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const e2 = this.nextStencilID++, t2 = this.context.gl;
              return new Vt2({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
            }
            stencilModeForClipping(e2) {
              const t2 = this.context.gl;
              return new Vt2({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
            }
            getStencilConfigForOverlapAndUpdateStencilID(e2) {
              const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), r2 = i2[i2.length - 1].overscaledZ, o2 = i2[0].overscaledZ - r2 + 1;
              if (o2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + o2 > 256 && this.clearStencil();
                const e3 = {};
                for (let i3 = 0; i3 < o2; i3++) e3[i3 + r2] = new Vt2({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
                return this.nextStencilID += o2, [e3, i2];
              }
              return [{ [r2]: Vt2.disabled }, i2];
            }
            stencilConfigForOverlapTwoPass(e2) {
              const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), r2 = i2[i2.length - 1].overscaledZ, o2 = i2[0].overscaledZ - r2 + 1;
              if (this.clearStencil(), o2 > 1) {
                const e3 = {}, a2 = {};
                for (let i3 = 0; i3 < o2; i3++) e3[i3 + r2] = new Vt2({ func: t2.GREATER, mask: 255 }, o2 + 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE), a2[i3 + r2] = new Vt2({ func: t2.GREATER, mask: 255 }, 1 + i3, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
                return this.nextStencilID = 2 * o2 + 1, [e3, a2, i2];
              }
              return this.nextStencilID = 3, [{ [r2]: new Vt2({ func: t2.GREATER, mask: 255 }, 2, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, { [r2]: new Vt2({ func: t2.GREATER, mask: 255 }, 1, 255, t2.KEEP, t2.KEEP, t2.REPLACE) }, i2];
            }
            colorModeForRenderPass() {
              const e2 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new jt([e2.CONSTANT_COLOR, e2.ONE], new t.b7(i2, i2, i2, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? jt.unblended : jt.alphaBlended;
            }
            getDepthModeForSublayer(e2, t2, i2) {
              if (!this.opaquePassEnabledForLayer()) return Ut2.disabled;
              const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
              return new Ut2(i2 || this.context.gl.LEQUAL, t2, [r2, r2]);
            }
            getDepthModeFor3D() {
              return new Ut2(this.context.gl.LEQUAL, Ut2.ReadWrite, this.depthRangeFor3D);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e2, i2) {
              var r2, o2;
              this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(s.now()), this.imageManager.beginFrame();
              const a2 = this.style._order, n2 = this.style.sourceCaches, l2 = {}, c2 = {}, h3 = {}, u2 = { isRenderingToTexture: false, isRenderingGlobe: (null === (r2 = e2.projection) || void 0 === r2 ? void 0 : r2.transitionState) > 0 };
              for (const e3 in n2) {
                const t2 = n2[e3];
                t2.used && t2.prepare(this.context), l2[e3] = t2.getVisibleCoordinates(false), c2[e3] = l2[e3].slice().reverse(), h3[e3] = t2.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let e3 = 0; e3 < a2.length; e3++) if (this.style._layers[a2[e3]].is3D()) {
                this.opaquePassCutoff = e3;
                break;
              }
              this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
              for (const e3 of a2) {
                const t2 = this.style._layers[e3];
                if (!t2.hasOffscreenPass() || t2.isHidden(this.transform.zoom)) continue;
                const i3 = c2[t2.source];
                ("custom" === t2.type || i3.length) && this.renderLayer(this, n2[t2.source], t2, i3, u2);
              }
              if (null === (o2 = this.style.projection) || void 0 === o2 || o2.updateGPUdependent({ context: this.context, useProgram: (e3) => this.useProgram(e3) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.b7.black : t.b7.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(e3, t2) {
                const i3 = e3.context, r3 = i3.gl, o3 = ((e4, t3, i4) => {
                  const r4 = Math.cos(t3.rollInRadians), o4 = Math.sin(t3.rollInRadians), a4 = ue2(t3), s3 = t3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                  return { u_sky_color: e4.properties.get("sky-color"), u_horizon_color: e4.properties.get("horizon-color"), u_horizon: [(t3.width / 2 - a4 * o4) * i4, (t3.height / 2 + a4 * r4) * i4], u_horizon_normal: [-o4, r4], u_sky_horizon_blend: e4.properties.get("sky-horizon-blend") * t3.height / 2 * i4, u_sky_blend: s3 };
                })(t2, e3.style.map.transform, e3.pixelRatio), a3 = new Ut2(r3.LEQUAL, Ut2.ReadWrite, [0, 1]), s2 = Vt2.disabled, n3 = e3.colorModeForRenderPass(), l3 = e3.useProgram("sky"), c3 = wo2(i3, t2);
                l3.draw(i3, r3.TRIANGLES, a3, s2, n3, Nt2.disabled, o3, null, void 0, "sky", c3.vertexBuffer, c3.indexBuffer, c3.segments);
              }(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e3 = this.style._layers[a2[this.currentLayer]], t2 = n2[e3.source], i3 = l2[e3.source];
                this._renderTileClippingMasks(e3, i3, false), this.renderLayer(this, t2, e3, i3, u2);
              }
              this.renderPass = "translucent";
              let d2 = false;
              for (this.currentLayer = 0; this.currentLayer < a2.length; this.currentLayer++) {
                const e3 = this.style._layers[a2[this.currentLayer]], t2 = n2[e3.source];
                if (this.renderToTexture && this.renderToTexture.renderLayer(e3, u2)) continue;
                this.opaquePassEnabledForLayer() || d2 || (d2 = true, u2.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                const i3 = ("symbol" === e3.type ? h3 : c2)[e3.source];
                this._renderTileClippingMasks(e3, l2[e3.source], !!this.renderToTexture), this.renderLayer(this, t2, e3, i3, u2);
              }
              if (u2.isRenderingGlobe && function(e3, i3, r3) {
                const o3 = e3.context, a3 = o3.gl, s2 = e3.useProgram("atmosphere"), n3 = new Ut2(a3.LEQUAL, Ut2.ReadOnly, [0, 1]), l3 = e3.transform, c3 = function(e4, i4) {
                  const r4 = e4.properties.get("position"), o4 = [-r4.x, -r4.y, -r4.z], a4 = t.ad(new Float64Array(16));
                  return "map" === e4.properties.get("anchor") && (t.a_(a4, a4, i4.rollInRadians), t.a$(a4, a4, -i4.pitchInRadians), t.a_(a4, a4, i4.bearingInRadians), t.a$(a4, a4, i4.center.lat * Math.PI / 180), t.bp(a4, a4, -i4.center.lng * Math.PI / 180)), t.bZ(o4, o4, a4), o4;
                }(r3, e3.transform), h4 = l3.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), u3 = i3.properties.get("atmosphere-blend") * h4.projectionTransition;
                if (0 === u3) return;
                const d3 = ri2(l3.worldSize, l3.center.lat), _3 = l3.inverseProjectionMatrix, p2 = new Float64Array(4);
                p2[3] = 1, t.at(p2, p2, l3.modelViewProjectionMatrix), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1, t.at(p2, p2, _3), p2[0] /= p2[3], p2[1] /= p2[3], p2[2] /= p2[3], p2[3] = 1;
                const m2 = /* @__PURE__ */ ((e4, t2, i4, r4, o4) => ({ u_sun_pos: e4, u_atmosphere_blend: t2, u_globe_position: i4, u_globe_radius: r4, u_inv_proj_matrix: o4 }))(c3, u3, [p2[0], p2[1], p2[2]], d3, _3), f2 = wo2(o3, i3);
                s2.draw(o3, a3.TRIANGLES, n3, Vt2.disabled, jt.alphaBlended, Nt2.disabled, m2, null, null, "atmosphere", f2.vertexBuffer, f2.indexBuffer, f2.segments);
              }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
                const e3 = function(e4, t2) {
                  let i3 = null;
                  const r3 = Object.values(e4._layers).flatMap((i4) => i4.source && !i4.isHidden(t2) ? [e4.sourceCaches[i4.source]] : []), o3 = r3.filter((e5) => "vector" === e5.getSource().type), a3 = r3.filter((e5) => "vector" !== e5.getSource().type), s2 = (e5) => {
                    (!i3 || i3.getSource().maxzoom < e5.getSource().maxzoom) && (i3 = e5);
                  };
                  return o3.forEach((e5) => s2(e5)), i3 || a3.forEach((e5) => s2(e5)), i3;
                }(this.style, this.transform.zoom);
                e3 && function(e4, t2, i3) {
                  for (let r3 = 0; r3 < i3.length; r3++) bo2(e4, t2, i3[r3]);
                }(this, e3, e3.getVisibleCoordinates());
              }
              this.options.showPadding && function(e3) {
                const t2 = e3.transform.padding;
                go2(e3, e3.transform.height - (t2.top || 0), 3, uo2), go2(e3, t2.bottom || 0, 3, _o2), vo2(e3, t2.left || 0, 3, po2), vo2(e3, e3.transform.width - (t2.right || 0), 3, mo2);
                const i3 = e3.transform.centerPoint;
                !function(e4, t3, i4, r3) {
                  xo2(e4, t3 - 1, i4 - 10, 2, 20, r3), xo2(e4, t3 - 10, i4 - 1, 20, 2, r3);
                }(e3, i3.x, e3.transform.height - i3.y, fo2);
              }(this), this.context.setDefault();
            }
            maybeDrawDepthAndCoords(e2) {
              if (!this.style || !this.style.map || !this.style.map.terrain) return;
              const i2 = this.terrainFacilitator.matrix, r2 = this.transform.modelViewProjectionMatrix;
              let o2 = this.terrainFacilitator.dirty;
              o2 || (o2 = e2 ? !t.c0(i2, r2) : !t.c1(i2, r2)), o2 || (o2 = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o2 && (t.c2(i2, r2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e3, i3) {
                const r3 = e3.context, o3 = r3.gl, a2 = e3.transform, s2 = jt.unblended, n2 = new Ut2(o3.LEQUAL, Ut2.ReadWrite, [0, 1]), l2 = i3.sourceCache.getRenderableTiles(), c2 = e3.useProgram("terrainDepth");
                r3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), r3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), r3.clear({ color: t.b7.transparent, depth: 1 });
                for (const e4 of l2) {
                  const t2 = i3.getTerrainMesh(e4.tileID), l3 = i3.getTerrainData(e4.tileID), h3 = a2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), u2 = { u_ele_delta: i3.getMeshFrameDelta(a2.zoom) };
                  c2.draw(r3, o3.TRIANGLES, n2, Vt2.disabled, s2, Nt2.backCCW, u2, l3, h3, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments);
                }
                r3.bindFramebuffer.set(null), r3.viewport.set([0, 0, e3.width, e3.height]);
              }(this, this.style.map.terrain), function(e3, i3) {
                const r3 = e3.context, o3 = r3.gl, a2 = e3.transform, s2 = jt.unblended, n2 = new Ut2(o3.LEQUAL, Ut2.ReadWrite, [0, 1]), l2 = i3.getCoordsTexture(), c2 = i3.sourceCache.getRenderableTiles(), h3 = e3.useProgram("terrainCoords");
                r3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), r3.viewport.set([0, 0, e3.width / devicePixelRatio, e3.height / devicePixelRatio]), r3.clear({ color: t.b7.transparent, depth: 1 }), i3.coordsIndex = [];
                for (const e4 of c2) {
                  const t2 = i3.getTerrainMesh(e4.tileID), c3 = i3.getTerrainData(e4.tileID);
                  r3.activeTexture.set(o3.TEXTURE0), o3.bindTexture(o3.TEXTURE_2D, l2.texture);
                  const u2 = { u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(a2.zoom) }, d2 = a2.getProjectionData({ overscaledTileID: e4.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                  h3.draw(r3, o3.TRIANGLES, n2, Vt2.disabled, s2, Nt2.backCCW, u2, c3, d2, "terrain", t2.vertexBuffer, t2.indexBuffer, t2.segments), i3.coordsIndex.push(e4.tileID.key);
                }
                r3.bindFramebuffer.set(null), r3.viewport.set([0, 0, e3.width, e3.height]);
              }(this, this.style.map.terrain));
            }
            renderLayer(e2, i2, r2, o2, a2) {
              r2.isHidden(this.transform.zoom) || ("background" === r2.type || "custom" === r2.type || (o2 || []).length) && (this.id = r2.id, t.c3(r2) ? function(e3, i3, r3, o3, a3, s2) {
                if ("translucent" !== e3.renderPass) return;
                const { isRenderingToTexture: n2 } = s2, l2 = Vt2.disabled, c2 = e3.colorModeForRenderPass();
                (r3._unevaluatedLayout.hasValue("text-variable-anchor") || r3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e4, i4, r4, o4, a4, s3, n3, l3, c3) {
                  const h3 = i4.transform, u2 = i4.style.map.terrain, d2 = "map" === a4, _3 = "map" === s3;
                  for (const a5 of e4) {
                    const e5 = o4.getTile(a5), s4 = e5.getBucket(r4);
                    if (!s4 || !s4.text || !s4.text.segments.get().length) continue;
                    const p2 = t.ak(s4.textSizeData, h3.zoom), m2 = t.az(e5, 1, i4.transform.zoom), f2 = Me2(d2, i4.transform, m2), g3 = "none" !== r4.layout.get("icon-text-fit") && s4.hasIconData();
                    if (p2) {
                      const i5 = Math.pow(2, h3.zoom - e5.tileID.overscaledZ), r5 = u2 ? (e6, t2) => u2.getElevation(a5, e6, t2) : null;
                      Kr2(s4, d2, _3, c3, h3, f2, i5, p2, g3, t.aA(h3, e5, n3, l3), a5.toUnwrapped(), r5);
                    }
                  }
                }(o3, e3, r3, i3, r3.layout.get("text-rotation-alignment"), r3.layout.get("text-pitch-alignment"), r3.paint.get("text-translate"), r3.paint.get("text-translate-anchor"), a3), 0 !== r3.paint.get("icon-opacity").constantOr(1) && Yr2(e3, i3, r3, o3, false, r3.paint.get("icon-translate"), r3.paint.get("icon-translate-anchor"), r3.layout.get("icon-rotation-alignment"), r3.layout.get("icon-pitch-alignment"), r3.layout.get("icon-keep-upright"), l2, c2, n2), 0 !== r3.paint.get("text-opacity").constantOr(1) && Yr2(e3, i3, r3, o3, true, r3.paint.get("text-translate"), r3.paint.get("text-translate-anchor"), r3.layout.get("text-rotation-alignment"), r3.layout.get("text-pitch-alignment"), r3.layout.get("text-keep-upright"), l2, c2, n2), i3.map.showCollisionBoxes && (Wr2(e3, i3, r3, o3, true), Wr2(e3, i3, r3, o3, false));
              }(e2, i2, r2, o2, this.style.placement.variableOffsets, a2) : t.c4(r2) ? function(e3, i3, r3, o3, a3) {
                if ("translucent" !== e3.renderPass) return;
                const { isRenderingToTexture: s2 } = a3, n2 = r3.paint.get("circle-opacity"), l2 = r3.paint.get("circle-stroke-width"), c2 = r3.paint.get("circle-stroke-opacity"), h3 = !r3.layout.get("circle-sort-key").isConstant();
                if (0 === n2.constantOr(1) && (0 === l2.constantOr(1) || 0 === c2.constantOr(1))) return;
                const u2 = e3.context, d2 = u2.gl, _3 = e3.transform, p2 = e3.getDepthModeForSublayer(0, Ut2.ReadOnly), m2 = Vt2.disabled, f2 = e3.colorModeForRenderPass(), g3 = [], v2 = _3.getCircleRadiusCorrection();
                for (let a4 = 0; a4 < o3.length; a4++) {
                  const n3 = o3[a4], l3 = i3.getTile(n3), c3 = l3.getBucket(r3);
                  if (!c3) continue;
                  const u3 = r3.paint.get("circle-translate"), d3 = r3.paint.get("circle-translate-anchor"), p3 = t.aA(_3, l3, u3, d3), m3 = c3.programConfigurations.get(r3.id), f3 = e3.useProgram("circle", m3), x3 = c3.layoutVertexBuffer, b2 = c3.indexBuffer, y2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(n3), w2 = { programConfiguration: m3, program: f3, layoutVertexBuffer: x3, indexBuffer: b2, uniformValues: Ai2(e3, l3, r3, p3, v2), terrainData: y2, projectionData: _3.getProjectionData({ overscaledTileID: n3, applyGlobeMatrix: !s2, applyTerrainMatrix: true }) };
                  if (h3) {
                    const e4 = c3.segments.get();
                    for (const i4 of e4) g3.push({ segments: new t.aJ([i4]), sortKey: i4.sortKey, state: w2 });
                  } else g3.push({ segments: c3.segments, sortKey: 0, state: w2 });
                }
                h3 && g3.sort((e4, t2) => e4.sortKey - t2.sortKey);
                for (const t2 of g3) {
                  const { programConfiguration: i4, program: o4, layoutVertexBuffer: a4, indexBuffer: s3, uniformValues: n3, terrainData: l3, projectionData: c3 } = t2.state;
                  o4.draw(u2, d2.TRIANGLES, p2, m2, f2, Nt2.backCCW, n3, l3, c3, r3.id, a4, s3, t2.segments, r3.paint, e3.transform.zoom, i4);
                }
              }(e2, i2, r2, o2, a2) : t.c5(r2) ? function(e3, i3, r3, o3, a3) {
                if (0 === r3.paint.get("heatmap-opacity")) return;
                const s2 = e3.context, { isRenderingToTexture: n2, isRenderingGlobe: l2 } = a3;
                if (e3.style.map.terrain) {
                  for (const t2 of o3) {
                    const o4 = i3.getTile(t2);
                    i3.hasRenderableParent(t2) || ("offscreen" === e3.renderPass ? eo2(e3, o4, r3, t2, l2) : "translucent" === e3.renderPass && to2(e3, r3, t2, n2, l2));
                  }
                  s2.viewport.set([0, 0, e3.width, e3.height]);
                } else "offscreen" === e3.renderPass ? function(e4, i4, r4, o4) {
                  const a4 = e4.context, s3 = a4.gl, n3 = e4.transform, l3 = Vt2.disabled, c2 = new jt([s3.ONE, s3.ONE], t.b7.transparent, [true, true, true, true]);
                  (function(e5, i5, r5) {
                    const o5 = e5.gl;
                    e5.activeTexture.set(o5.TEXTURE1), e5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
                    let a5 = r5.heatmapFbos.get(t.bW);
                    a5 ? (o5.bindTexture(o5.TEXTURE_2D, a5.colorAttachment.get()), e5.bindFramebuffer.set(a5.framebuffer)) : (a5 = io2(e5, i5.width / 4, i5.height / 4), r5.heatmapFbos.set(t.bW, a5));
                  })(a4, e4, r4), a4.clear({ color: t.b7.transparent });
                  for (let t2 = 0; t2 < o4.length; t2++) {
                    const h3 = o4[t2];
                    if (i4.hasRenderableParent(h3)) continue;
                    const u2 = i4.getTile(h3), d2 = u2.getBucket(r4);
                    if (!d2) continue;
                    const _3 = d2.programConfigurations.get(r4.id), p2 = e4.useProgram("heatmap", _3), m2 = n3.getProjectionData({ overscaledTileID: h3, applyGlobeMatrix: true, applyTerrainMatrix: false }), f2 = n3.getCircleRadiusCorrection();
                    p2.draw(a4, s3.TRIANGLES, Ut2.disabled, l3, c2, Nt2.backCCW, Bi2(u2, n3.zoom, r4.paint.get("heatmap-intensity"), f2), null, m2, r4.id, d2.layoutVertexBuffer, d2.indexBuffer, d2.segments, r4.paint, n3.zoom, _3);
                  }
                  a4.viewport.set([0, 0, e4.width, e4.height]);
                }(e3, i3, r3, o3) : "translucent" === e3.renderPass && function(e4, i4) {
                  const r4 = e4.context, o4 = r4.gl;
                  r4.setColorMode(e4.colorModeForRenderPass());
                  const a4 = i4.heatmapFbos.get(t.bW);
                  a4 && (r4.activeTexture.set(o4.TEXTURE0), o4.bindTexture(o4.TEXTURE_2D, a4.colorAttachment.get()), r4.activeTexture.set(o4.TEXTURE1), ro2(r4, i4).bind(o4.LINEAR, o4.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(r4, o4.TRIANGLES, Ut2.disabled, Vt2.disabled, e4.colorModeForRenderPass(), Nt2.disabled, Oi2(e4, i4, 0, 1), null, null, i4.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i4.paint, e4.transform.zoom));
                }(e3, r3);
              }(e2, i2, r2, o2, a2) : t.c6(r2) ? function(e3, i3, r3, o3, a3) {
                if ("translucent" !== e3.renderPass) return;
                const { isRenderingToTexture: s2 } = a3, n2 = r3.paint.get("line-opacity"), l2 = r3.paint.get("line-width");
                if (0 === n2.constantOr(1) || 0 === l2.constantOr(1)) return;
                const c2 = e3.getDepthModeForSublayer(0, Ut2.ReadOnly), h3 = e3.colorModeForRenderPass(), u2 = r3.paint.get("line-dasharray"), d2 = r3.paint.get("line-pattern"), _3 = d2.constantOr(1), p2 = r3.paint.get("line-gradient"), m2 = r3.getCrossfadeParameters(), f2 = _3 ? "linePattern" : u2 ? "lineSDF" : p2 ? "lineGradient" : "line", g3 = e3.context, x3 = g3.gl, b2 = e3.transform;
                let y2 = true;
                for (const a4 of o3) {
                  const o4 = i3.getTile(a4);
                  if (_3 && !o4.patternsLoaded()) continue;
                  const n3 = o4.getBucket(r3);
                  if (!n3) continue;
                  const l3 = n3.programConfigurations.get(r3.id), w2 = e3.context.program.get(), T2 = e3.useProgram(f2, l3), P2 = y2 || T2.program !== w2, C3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(a4), M3 = d2.constantOr(null);
                  if (M3 && o4.imageAtlas) {
                    const e4 = o4.imageAtlas, t2 = e4.patternPositions[M3.to.toString()], i4 = e4.patternPositions[M3.from.toString()];
                    t2 && i4 && l3.setConstantPatternPositions(t2, i4);
                  }
                  const I3 = b2.getProjectionData({ overscaledTileID: a4, applyGlobeMatrix: !s2, applyTerrainMatrix: true }), E3 = b2.getPixelScale(), S3 = _3 ? Vi2(e3, o4, r3, E3, m2) : u2 ? qi2(e3, o4, r3, E3, u2, m2) : p2 ? Gi2(e3, o4, r3, E3, n3.lineClipsArray.length) : Ui2(e3, o4, r3, E3);
                  if (_3) g3.activeTexture.set(x3.TEXTURE0), o4.imageAtlasTexture.bind(x3.LINEAR, x3.CLAMP_TO_EDGE), l3.updatePaintBuffers(m2);
                  else if (u2 && (P2 || e3.lineAtlas.dirty)) g3.activeTexture.set(x3.TEXTURE0), e3.lineAtlas.bind(g3);
                  else if (p2) {
                    const o5 = n3.gradients[r3.id];
                    let s3 = o5.texture;
                    if (r3.gradientVersion !== o5.version) {
                      let l4 = 256;
                      if (r3.stepInterpolant) {
                        const r4 = i3.getSource().maxzoom, o6 = a4.canonical.z === r4 ? Math.ceil(1 << e3.transform.maxZoom - a4.canonical.z) : 1;
                        l4 = t.ae(t.bX(n3.maxLineLength / t.Z * 1024 * o6), 256, g3.maxTextureSize);
                      }
                      o5.gradient = t.bY({ expression: r3.gradientExpression(), evaluationKey: "lineProgress", resolution: l4, image: o5.gradient || void 0, clips: n3.lineClipsArray }), o5.texture ? o5.texture.update(o5.gradient) : o5.texture = new v(g3, o5.gradient, x3.RGBA), o5.version = r3.gradientVersion, s3 = o5.texture;
                    }
                    g3.activeTexture.set(x3.TEXTURE0), s3.bind(r3.stepInterpolant ? x3.NEAREST : x3.LINEAR, x3.CLAMP_TO_EDGE);
                  }
                  const R2 = e3.stencilModeForClipping(a4);
                  T2.draw(g3, x3.TRIANGLES, c2, R2, h3, Nt2.disabled, S3, C3, I3, r3.id, n3.layoutVertexBuffer, n3.indexBuffer, n3.segments, r3.paint, e3.transform.zoom, l3, n3.layoutVertexBuffer2), y2 = false;
                }
              }(e2, i2, r2, o2, a2) : t.c7(r2) ? function(e3, i3, r3, o3, a3) {
                const s2 = r3.paint.get("fill-color"), n2 = r3.paint.get("fill-opacity");
                if (0 === n2.constantOr(1)) return;
                const { isRenderingToTexture: l2 } = a3, c2 = e3.colorModeForRenderPass(), h3 = r3.paint.get("fill-pattern"), u2 = e3.opaquePassEnabledForLayer() && !h3.constantOr(1) && 1 === s2.constantOr(t.b7.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
                if (e3.renderPass === u2) {
                  const t2 = e3.getDepthModeForSublayer(1, "opaque" === e3.renderPass ? Ut2.ReadWrite : Ut2.ReadOnly);
                  ao2(e3, i3, r3, o3, t2, c2, false, l2);
                }
                if ("translucent" === e3.renderPass && r3.paint.get("fill-antialias")) {
                  const t2 = e3.getDepthModeForSublayer(r3.getPaintProperty("fill-outline-color") ? 2 : 0, Ut2.ReadOnly);
                  ao2(e3, i3, r3, o3, t2, c2, true, l2);
                }
              }(e2, i2, r2, o2, a2) : t.c8(r2) ? function(e3, t2, i3, r3, o3) {
                const a3 = i3.paint.get("fill-extrusion-opacity");
                if (0 === a3) return;
                const { isRenderingToTexture: s2 } = o3;
                if ("translucent" === e3.renderPass) {
                  const o4 = new Ut2(e3.context.gl.LEQUAL, Ut2.ReadWrite, e3.depthRangeFor3D);
                  if (1 !== a3 || i3.paint.get("fill-extrusion-pattern").constantOr(1)) so2(e3, t2, i3, r3, o4, Vt2.disabled, jt.disabled, s2), so2(e3, t2, i3, r3, o4, e3.stencilModeFor3D(), e3.colorModeForRenderPass(), s2);
                  else {
                    const a4 = e3.colorModeForRenderPass();
                    so2(e3, t2, i3, r3, o4, Vt2.disabled, a4, s2);
                  }
                }
              }(e2, i2, r2, o2, a2) : t.c9(r2) ? function(e3, t2, i3, r3, o3) {
                if ("offscreen" !== e3.renderPass && "translucent" !== e3.renderPass) return;
                const { isRenderingToTexture: a3 } = o3, s2 = e3.context, n2 = e3.style.projection.useSubdivision, l2 = e3.getDepthModeForSublayer(0, Ut2.ReadOnly), c2 = e3.colorModeForRenderPass();
                if ("offscreen" === e3.renderPass) !function(e4, t3, i4, r4, o4, a4, s3) {
                  const n3 = e4.context, l3 = n3.gl;
                  for (const c3 of i4) {
                    const i5 = t3.getTile(c3), h3 = i5.dem;
                    if (!h3 || !h3.data) continue;
                    if (!i5.needsHillshadePrepare) continue;
                    const u2 = h3.dim, d2 = h3.stride, _3 = h3.getPixels();
                    if (n3.activeTexture.set(l3.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i5.demTexture = i5.demTexture || e4.getTileTexture(d2), i5.demTexture) {
                      const e5 = i5.demTexture;
                      e5.update(_3, { premultiply: false }), e5.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
                    } else i5.demTexture = new v(n3, _3, l3.RGBA, { premultiply: false }), i5.demTexture.bind(l3.NEAREST, l3.CLAMP_TO_EDGE);
                    n3.activeTexture.set(l3.TEXTURE0);
                    let p2 = i5.fbo;
                    if (!p2) {
                      const e5 = new v(n3, { width: u2, height: u2, data: null }, l3.RGBA);
                      e5.bind(l3.LINEAR, l3.CLAMP_TO_EDGE), p2 = i5.fbo = n3.createFramebuffer(u2, u2, true, false), p2.colorAttachment.set(e5.texture);
                    }
                    n3.bindFramebuffer.set(p2.framebuffer), n3.viewport.set([0, 0, u2, u2]), e4.useProgram("hillshadePrepare").draw(n3, l3.TRIANGLES, o4, a4, s3, Nt2.disabled, Zi2(i5.tileID, h3), null, null, r4.id, e4.rasterBoundsBuffer, e4.quadTriangleIndexBuffer, e4.rasterBoundsSegments), i5.needsHillshadePrepare = false;
                  }
                }(e3, t2, r3, i3, l2, Vt2.disabled, c2), s2.viewport.set([0, 0, e3.width, e3.height]);
                else if ("translucent" === e3.renderPass) if (n2) {
                  const [o4, s3, n3] = e3.stencilConfigForOverlapTwoPass(r3);
                  no2(e3, t2, i3, n3, o4, l2, c2, false, a3), no2(e3, t2, i3, n3, s3, l2, c2, true, a3);
                } else {
                  const [o4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(r3);
                  no2(e3, t2, i3, s3, o4, l2, c2, false, a3);
                }
              }(e2, i2, r2, o2, a2) : t.ca(r2) ? function(e3, t2, i3, r3, o3) {
                if ("translucent" !== e3.renderPass) return;
                if (0 === i3.paint.get("raster-opacity")) return;
                if (!r3.length) return;
                const { isRenderingToTexture: a3 } = o3, s2 = t2.getSource(), n2 = e3.style.projection.useSubdivision;
                if (s2 instanceof K2) co2(e3, t2, i3, r3, null, false, false, s2.tileCoords, s2.flippedWindingOrder, a3);
                else if (n2) {
                  const [o4, s3, n3] = e3.stencilConfigForOverlapTwoPass(r3);
                  co2(e3, t2, i3, n3, o4, false, true, lo2, false, a3), co2(e3, t2, i3, n3, s3, true, true, lo2, false, a3);
                } else {
                  const [o4, s3] = e3.getStencilConfigForOverlapAndUpdateStencilID(r3);
                  co2(e3, t2, i3, s3, o4, false, true, lo2, false, a3);
                }
              }(e2, i2, r2, o2, a2) : t.cb(r2) ? function(e3, t2, i3, r3, o3) {
                const a3 = i3.paint.get("background-color"), s2 = i3.paint.get("background-opacity");
                if (0 === s2) return;
                const { isRenderingToTexture: n2 } = o3, l2 = e3.context, c2 = l2.gl, h3 = e3.style.projection, u2 = e3.transform, d2 = u2.tileSize, _3 = i3.paint.get("background-pattern");
                if (e3.isPatternMissing(_3)) return;
                const p2 = !_3 && 1 === a3.a && 1 === s2 && e3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (e3.renderPass !== p2) return;
                const m2 = Vt2.disabled, f2 = e3.getDepthModeForSublayer(0, "opaque" === p2 ? Ut2.ReadWrite : Ut2.ReadOnly), g3 = e3.colorModeForRenderPass(), v2 = e3.useProgram(_3 ? "backgroundPattern" : "background"), x3 = r3 || xe2(u2, { tileSize: d2, terrain: e3.style.map.terrain });
                _3 && (l2.activeTexture.set(c2.TEXTURE0), e3.imageManager.bind(e3.context));
                const b2 = i3.getCrossfadeParameters();
                for (const t3 of x3) {
                  const r4 = u2.getProjectionData({ overscaledTileID: t3, applyGlobeMatrix: !n2, applyTerrainMatrix: true }), o4 = _3 ? er2(s2, e3, _3, { tileID: t3, tileSize: d2 }, b2) : Ji2(s2, a3), p3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(t3), x4 = h3.getMeshFromTileID(l2, t3.canonical, false, true, "raster");
                  v2.draw(l2, c2.TRIANGLES, f2, m2, g3, Nt2.backCCW, o4, p3, r4, i3.id, x4.vertexBuffer, x4.indexBuffer, x4.segments);
                }
              }(e2, 0, r2, o2, a2) : t.cc(r2) && function(e3, t2, i3, r3) {
                const { isRenderingGlobe: o3 } = r3, a3 = e3.context, s2 = i3.implementation, n2 = e3.style.projection, l2 = e3.transform, c2 = l2.getProjectionDataForCustomLayer(o3), h3 = { farZ: l2.farZ, nearZ: l2.nearZ, fov: l2.fov * Math.PI / 180, modelViewProjectionMatrix: l2.modelViewProjectionMatrix, projectionMatrix: l2.projectionMatrix, shaderData: { variantName: n2.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${n2.shaderPreludeCode.vertexSource}`, define: n2.shaderDefine }, defaultProjectionData: c2 }, u2 = s2.renderingMode ? s2.renderingMode : "2d";
                if ("offscreen" === e3.renderPass) {
                  const t3 = s2.prerender;
                  t3 && (e3.setCustomLayerDefaults(), a3.setColorMode(e3.colorModeForRenderPass()), t3.call(s2, a3.gl, h3), a3.setDirty(), e3.setBaseState());
                } else if ("translucent" === e3.renderPass) {
                  e3.setCustomLayerDefaults(), a3.setColorMode(e3.colorModeForRenderPass()), a3.setStencilMode(Vt2.disabled);
                  const t3 = "3d" === u2 ? e3.getDepthModeFor3D() : e3.getDepthModeForSublayer(0, Ut2.ReadOnly);
                  a3.setDepthMode(t3), s2.render(a3.gl, h3), a3.setDirty(), e3.setBaseState(), a3.bindFramebuffer.set(null);
                }
              }(e2, 0, r2, a2));
            }
            saveTileTexture(e2) {
              const t2 = this._tileTextures[e2.size[0]];
              t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
            }
            getTileTexture(e2) {
              const t2 = this._tileTextures[e2];
              return t2 && t2.length > 0 ? t2.pop() : null;
            }
            isPatternMissing(e2) {
              if (!e2) return false;
              if (!e2.from || !e2.to) return true;
              const t2 = this.imageManager.getPattern(e2.from.toString()), i2 = this.imageManager.getPattern(e2.to.toString());
              return !t2 || !i2;
            }
            useProgram(e2, t2, i2 = false, r2 = []) {
              this.cache = this.cache || {};
              const o2 = !!this.style.map.terrain, a2 = this.style.projection, s2 = i2 ? bt2.projectionMercator : a2.shaderPreludeCode, n2 = i2 ? Pt : a2.shaderDefine, l2 = e2 + (t2 ? t2.cacheKey : "") + `/${i2 ? Ct2 : a2.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (o2 ? "/terrain" : "") + (r2 ? `/${r2.join("/")}` : "");
              return this.cache[l2] || (this.cache[l2] = new Mi2(this.context, bt2[e2], t2, ir[e2], this._showOverdrawInspector, o2, s2, n2, r2)), this.cache[l2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const e2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new v(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
            overLimit() {
              const { drawingBufferWidth: e2, drawingBufferHeight: t2 } = this.context.gl;
              return this.width !== e2 || this.height !== t2;
            }
          }
          function Po2(e2, t2) {
            let i2, r2 = false, o2 = null, a2 = null;
            const s2 = () => {
              o2 = null, r2 && (e2.apply(a2, i2), o2 = setTimeout(s2, t2), r2 = false);
            };
            return (...e3) => (r2 = true, a2 = this, i2 = e3, o2 || s2(), o2);
          }
          class Co2 {
            constructor(e2) {
              this._getCurrentHash = () => {
                const e3 = window.location.hash.replace("#", "");
                if (this._hashName) {
                  let t2;
                  return e3.split("&").map((e4) => e4.split("=")).forEach((e4) => {
                    e4[0] === this._hashName && (t2 = e4);
                  }), (t2 && t2[1] || "").split("/");
                }
                return e3.split("/");
              }, this._onHashChange = () => {
                const e3 = this._getCurrentHash();
                if (!this._isValidHash(e3)) return false;
                const t2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e3[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+e3[2], +e3[1]], zoom: +e3[0], bearing: t2, pitch: +(e3[4] || 0) }), true;
              }, this._updateHashUnthrottled = () => {
                const e3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
                window.history.replaceState(window.history.state, null, e3);
              }, this._removeHash = () => {
                const e3 = this._getCurrentHash();
                if (0 === e3.length) return;
                const t2 = e3.join("/");
                let i2 = t2;
                i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = `${this._hashName}=${t2}`);
                let r2 = window.location.hash.replace(i2, "");
                r2.startsWith("#&") ? r2 = r2.slice(0, 1) + r2.slice(2) : "#" === r2 && (r2 = "");
                let o2 = window.location.href.replace(/(#.+)?$/, r2);
                o2 = o2.replace("&&", "&"), window.history.replaceState(window.history.state, null, o2);
              }, this._updateHash = Po2(this._updateHashUnthrottled, 300), this._hashName = e2 && encodeURIComponent(e2);
            }
            addTo(e2) {
              return this._map = e2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
            }
            getHashString(e2) {
              const t2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o2 = Math.pow(10, r2), a2 = Math.round(t2.lng * o2) / o2, s2 = Math.round(t2.lat * o2) / o2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
              let c2 = "";
              if (c2 += e2 ? `/${a2}/${s2}/${i2}` : `${i2}/${s2}/${a2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
                const e3 = this._hashName;
                let t3 = false;
                const i3 = window.location.hash.slice(1).split("&").map((i4) => {
                  const r3 = i4.split("=")[0];
                  return r3 === e3 ? (t3 = true, `${r3}=${c2}`) : i4;
                }).filter((e4) => e4);
                return t3 || i3.push(`${e3}=${c2}`), `#${i3.join("&")}`;
              }
              return `#${c2}`;
            }
            _isValidHash(e2) {
              if (e2.length < 3 || e2.some(isNaN)) return false;
              try {
                new t.Q(+e2[2], +e2[1]);
              } catch (e3) {
                return false;
              }
              const i2 = +e2[0], r2 = +(e2[3] || 0), o2 = +(e2[4] || 0);
              return i2 >= this._map.getMinZoom() && i2 <= this._map.getMaxZoom() && r2 >= -180 && r2 <= 180 && o2 >= this._map.getMinPitch() && o2 <= this._map.getMaxPitch();
            }
          }
          const Mo2 = { linearity: 0.3, easing: t.cd(0, 0, 0.3, 1) }, Io2 = t.e({ deceleration: 2500, maxSpeed: 1400 }, Mo2), Eo2 = t.e({ deceleration: 20, maxSpeed: 1400 }, Mo2), So2 = t.e({ deceleration: 1e3, maxSpeed: 360 }, Mo2), Ro2 = t.e({ deceleration: 1e3, maxSpeed: 90 }, Mo2), zo2 = t.e({ deceleration: 1e3, maxSpeed: 360 }, Mo2);
          class Do2 {
            constructor(e2) {
              this._map = e2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e2) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s.now(), settings: e2 });
            }
            _drainInertiaBuffer() {
              const e2 = this._inertiaBuffer, t2 = s.now();
              for (; e2.length > 0 && t2 - e2[0].time > 160; ) e2.shift();
            }
            _onMoveEnd(e2) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t.P(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: e3 } of this._inertiaBuffer) i2.zoom += e3.zoomDelta || 0, i2.bearing += e3.bearingDelta || 0, i2.pitch += e3.pitchDelta || 0, i2.roll += e3.rollDelta || 0, e3.panDelta && i2.pan._add(e3.panDelta), e3.around && (i2.around = e3.around), e3.pinchAround && (i2.pinchAround = e3.pinchAround);
              const r2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o2 = {};
              if (i2.pan.mag()) {
                const a2 = Lo2(i2.pan.mag(), r2, t.e({}, Io2, e2 || {})), s2 = i2.pan.mult(a2.amount / i2.pan.mag()), n2 = this._map.cameraHelper.handlePanInertia(s2, this._map.transform);
                o2.center = n2.easingCenter, o2.offset = n2.easingOffset, Ao2(o2, a2);
              }
              if (i2.zoom) {
                const e3 = Lo2(i2.zoom, r2, Eo2);
                o2.zoom = this._map.transform.zoom + e3.amount, Ao2(o2, e3);
              }
              if (i2.bearing) {
                const e3 = Lo2(i2.bearing, r2, So2);
                o2.bearing = this._map.transform.bearing + t.ae(e3.amount, -179, 179), Ao2(o2, e3);
              }
              if (i2.pitch) {
                const e3 = Lo2(i2.pitch, r2, Ro2);
                o2.pitch = this._map.transform.pitch + e3.amount, Ao2(o2, e3);
              }
              if (i2.roll) {
                const e3 = Lo2(i2.roll, r2, zo2);
                o2.roll = this._map.transform.roll + t.ae(e3.amount, -179, 179), Ao2(o2, e3);
              }
              if (o2.zoom || o2.bearing) {
                const e3 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
                o2.around = e3 ? this._map.unproject(e3) : this._map.getCenter();
              }
              return this.clear(), t.e(o2, { noMoveStart: true });
            }
          }
          function Ao2(e2, t2) {
            (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
          }
          function Lo2(e2, i2, r2) {
            const { maxSpeed: o2, linearity: a2, deceleration: s2 } = r2, n2 = t.ae(e2 * a2 / (i2 / 1e3), -o2, o2), l2 = Math.abs(n2) / (s2 * a2);
            return { easing: r2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
          }
          class ko2 extends t.l {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, i2, r2, o2 = {}) {
              r2 = r2 instanceof MouseEvent ? r2 : new MouseEvent(e2, r2);
              const a2 = n.mousePos(i2.getCanvas(), r2), s2 = i2.unproject(a2);
              super(e2, t.e({ point: a2, lngLat: s2, originalEvent: r2 }, o2)), this._defaultPrevented = false, this.target = i2;
            }
          }
          class Fo2 extends t.l {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, i2, r2) {
              const o2 = "touchend" === e2 ? r2.changedTouches : r2.touches, a2 = n.touchPos(i2.getCanvasContainer(), o2), s2 = a2.map((e3) => i2.unproject(e3)), l2 = a2.reduce((e3, t2, i3, r3) => e3.add(t2.div(r3.length)), new t.P(0, 0));
              super(e2, { points: a2, point: l2, lngLats: s2, lngLat: i2.unproject(l2), originalEvent: r2 }), this._defaultPrevented = false;
            }
          }
          class Bo2 extends t.l {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, t2, i2) {
              super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
            }
          }
          class Oo2 {
            constructor(e2, t2) {
              this._map = e2, this._clickTolerance = t2.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(e2) {
              return this._firePreventable(new Bo2(e2.type, this._map, e2));
            }
            mousedown(e2, t2) {
              return this._mousedownPos = t2, this._firePreventable(new ko2(e2.type, this._map, e2));
            }
            mouseup(e2) {
              this._map.fire(new ko2(e2.type, this._map, e2));
            }
            click(e2, t2) {
              this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || this._map.fire(new ko2(e2.type, this._map, e2));
            }
            dblclick(e2) {
              return this._firePreventable(new ko2(e2.type, this._map, e2));
            }
            mouseover(e2) {
              this._map.fire(new ko2(e2.type, this._map, e2));
            }
            mouseout(e2) {
              this._map.fire(new ko2(e2.type, this._map, e2));
            }
            touchstart(e2) {
              return this._firePreventable(new Fo2(e2.type, this._map, e2));
            }
            touchmove(e2) {
              this._map.fire(new Fo2(e2.type, this._map, e2));
            }
            touchend(e2) {
              this._map.fire(new Fo2(e2.type, this._map, e2));
            }
            touchcancel(e2) {
              this._map.fire(new Fo2(e2.type, this._map, e2));
            }
            _firePreventable(e2) {
              if (this._map.fire(e2), e2.defaultPrevented) return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class jo2 {
            constructor(e2) {
              this._map = e2;
            }
            reset() {
              this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
            }
            mousemove(e2) {
              this._map.fire(new ko2(e2.type, this._map, e2));
            }
            mousedown() {
              this._delayContextMenu = true, this._ignoreContextMenu = false;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ko2("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e2) {
              this._delayContextMenu ? this._contextMenuEvent = e2 : this._ignoreContextMenu || this._map.fire(new ko2(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Zo2 {
            constructor(e2) {
              this._map = e2;
            }
            get transform() {
              return this._map._requestedCameraState || this._map.transform;
            }
            get center() {
              return { lng: this.transform.center.lng, lat: this.transform.center.lat };
            }
            get zoom() {
              return this.transform.zoom;
            }
            get pitch() {
              return this.transform.pitch;
            }
            get bearing() {
              return this.transform.bearing;
            }
            unproject(e2) {
              return this.transform.screenPointToLocation(t.P.convert(e2), this._map.terrain);
            }
          }
          class No2 {
            constructor(e2, t2) {
              this._map = e2, this._tr = new Zo2(e2), this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(e2, t2) {
              this.isEnabled() && e2.shiftKey && 0 === e2.button && (n.disableDrag(), this._startPos = this._lastPos = t2, this._active = true);
            }
            mousemoveWindow(e2, t2) {
              if (!this._active) return;
              const i2 = t2;
              if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance) return;
              const r2 = this._startPos;
              this._lastPos = i2, this._box || (this._box = n.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e2));
              const o2 = Math.min(r2.x, i2.x), a2 = Math.max(r2.x, i2.x), s2 = Math.min(r2.y, i2.y), l2 = Math.max(r2.y, i2.y);
              n.setTransform(this._box, `translate(${o2}px,${s2}px)`), this._box.style.width = a2 - o2 + "px", this._box.style.height = l2 - s2 + "px";
            }
            mouseupWindow(e2, i2) {
              if (!this._active) return;
              if (0 !== e2.button) return;
              const r2 = this._startPos, o2 = i2;
              if (this.reset(), n.suppressClick(), r2.x !== o2.x || r2.y !== o2.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e2 })), { cameraAnimation: (e3) => e3.fitScreenCoordinates(r2, o2, this._tr.bearing, { linear: true }) };
              this._fireEvent("boxzoomcancel", e2);
            }
            keydown(e2) {
              this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
            }
            reset() {
              this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e2, i2) {
              return this._map.fire(new t.l(e2, { originalEvent: i2 }));
            }
          }
          function Uo2(e2, t2) {
            if (e2.length !== t2.length) throw new Error(`The number of touches and points are not equal - touches ${e2.length}, points ${t2.length}`);
            const i2 = {};
            for (let r2 = 0; r2 < e2.length; r2++) i2[e2[r2].identifier] = t2[r2];
            return i2;
          }
          class Go2 {
            constructor(e2) {
              this.reset(), this.numTouches = e2.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e2, i2, r2) {
              (this.centroid || r2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), r2.length === this.numTouches && (this.centroid = function(e3) {
                const i3 = new t.P(0, 0);
                for (const t2 of e3) i3._add(t2);
                return i3.div(e3.length);
              }(i2), this.touches = Uo2(r2, i2)));
            }
            touchmove(e2, t2, i2) {
              if (this.aborted || !this.centroid) return;
              const r2 = Uo2(i2, t2);
              for (const e3 in this.touches) {
                const t3 = r2[e3];
                (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
              }
            }
            touchend(e2, t2, i2) {
              if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
                const e3 = !this.aborted && this.centroid;
                if (this.reset(), e3) return e3;
              }
            }
          }
          class Vo2 {
            constructor(e2) {
              this.singleTap = new Go2(e2), this.numTaps = e2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(e2, t2, i2) {
              this.singleTap.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this.singleTap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const r2 = this.singleTap.touchend(e2, t2, i2);
              if (r2) {
                const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(r2) < 30;
                if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = r2, this.count === this.numTaps) return this.reset(), r2;
              }
            }
          }
          class qo2 {
            constructor(e2) {
              this._tr = new Zo2(e2), this._zoomIn = new Vo2({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vo2({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e2, t2, i2) {
              this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const r2 = this._zoomIn.touchend(e2, t2, i2), o2 = this._zoomOut.touchend(e2, t2, i2), a2 = this._tr;
              return r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: a2.zoom + 1, around: a2.unproject(r2) }, { originalEvent: e2 }) }) : o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: a2.zoom - 1, around: a2.unproject(o2) }, { originalEvent: e2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Wo2 {
            constructor(e2) {
              this._enabled = !!e2.enable, this._moveStateManager = e2.moveStateManager, this._clickTolerance = e2.clickTolerance || 1, this._moveFunction = e2.move, this._activateOnStart = !!e2.activateOnStart, e2.assignEvents(this), this.reset();
            }
            reset(e2) {
              this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e2);
            }
            _move(...e2) {
              const t2 = this._moveFunction(...e2);
              if (t2.bearingDelta || t2.pitchDelta || t2.rollDelta || t2.around || t2.panDelta) return this._active = true, t2;
            }
            dragStart(e2, t2) {
              this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e2) && (this._moveStateManager.startMove(e2), this._lastPoint = Array.isArray(t2) ? t2[0] : t2, this._activateOnStart && this._lastPoint && (this._active = true));
            }
            dragMove(e2, t2) {
              if (!this.isEnabled()) return;
              const i2 = this._lastPoint;
              if (!i2) return;
              if (e2.preventDefault(), !this._moveStateManager.isValidMoveEvent(e2)) return void this.reset(e2);
              const r2 = Array.isArray(t2) ? t2[0] : t2;
              return !this._moved && r2.dist(i2) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = r2, this._move(i2, r2));
            }
            dragEnd(e2) {
              this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e2) && (this._moved && n.suppressClick(), this.reset(e2));
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            getClickTolerance() {
              return this._clickTolerance;
            }
          }
          const Ho2 = { 0: 1, 2: 2 };
          class $o2 {
            constructor(e2) {
              this._correctEvent = e2.checkCorrectEvent;
            }
            startMove(e2) {
              const t2 = n.mouseButton(e2);
              this._eventButton = t2;
            }
            endMove(e2) {
              delete this._eventButton;
            }
            isValidStartEvent(e2) {
              return this._correctEvent(e2);
            }
            isValidMoveEvent(e2) {
              return !function(e3, t2) {
                const i2 = Ho2[t2];
                return void 0 === e3.buttons || (e3.buttons & i2) !== i2;
              }(e2, this._eventButton);
            }
            isValidEndEvent(e2) {
              return n.mouseButton(e2) === this._eventButton;
            }
          }
          class Xo2 {
            constructor() {
              this._firstTouch = void 0;
            }
            _isOneFingerTouch(e2) {
              return 1 === e2.targetTouches.length;
            }
            _isSameTouchEvent(e2) {
              return e2.targetTouches[0].identifier === this._firstTouch;
            }
            startMove(e2) {
              this._firstTouch = e2.targetTouches[0].identifier;
            }
            endMove(e2) {
              delete this._firstTouch;
            }
            isValidStartEvent(e2) {
              return this._isOneFingerTouch(e2);
            }
            isValidMoveEvent(e2) {
              return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
            }
            isValidEndEvent(e2) {
              return this._isOneFingerTouch(e2) && this._isSameTouchEvent(e2);
            }
          }
          class Ko2 {
            constructor(e2 = new $o2({ checkCorrectEvent: () => true }), t2 = new Xo2()) {
              this.mouseMoveStateManager = e2, this.oneFingerTouchMoveStateManager = t2;
            }
            _executeRelevantHandler(e2, t2, i2) {
              return e2 instanceof MouseEvent ? t2(e2) : "undefined" != typeof TouchEvent && e2 instanceof TouchEvent ? i2(e2) : void 0;
            }
            startMove(e2) {
              this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.startMove(e3), (e3) => this.oneFingerTouchMoveStateManager.startMove(e3));
            }
            endMove(e2) {
              this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.endMove(e3), (e3) => this.oneFingerTouchMoveStateManager.endMove(e3));
            }
            isValidStartEvent(e2) {
              return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidStartEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e3));
            }
            isValidMoveEvent(e2) {
              return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidMoveEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e3));
            }
            isValidEndEvent(e2) {
              return this._executeRelevantHandler(e2, (e3) => this.mouseMoveStateManager.isValidEndEvent(e3), (e3) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e3));
            }
          }
          const Qo2 = (e2) => {
            e2.mousedown = e2.dragStart, e2.mousemoveWindow = e2.dragMove, e2.mouseup = e2.dragEnd, e2.contextmenu = (e3) => {
              e3.preventDefault();
            };
          };
          class Yo2 {
            constructor(e2, t2) {
              this._clickTolerance = e2.clickTolerance || 1, this._map = t2, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t.P(0, 0);
            }
            _shouldBePrevented(e2) {
              return e2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
            }
            touchstart(e2, t2, i2) {
              return this._calculateTransform(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              if (this._active) {
                if (!this._shouldBePrevented(i2.length)) return e2.preventDefault(), this._calculateTransform(e2, t2, i2);
                this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e2);
              }
            }
            touchend(e2, t2, i2) {
              this._calculateTransform(e2, t2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e2, i2, r2) {
              r2.length > 0 && (this._active = true);
              const o2 = Uo2(r2, i2), a2 = new t.P(0, 0), s2 = new t.P(0, 0);
              let n2 = 0;
              for (const e3 in o2) {
                const t2 = o2[e3], i3 = this._touches[e3];
                i3 && (a2._add(t2), s2._add(t2.sub(i3)), n2++, o2[e3] = t2);
              }
              if (this._touches = o2, this._shouldBePrevented(n2) || !s2.mag()) return;
              const l2 = s2.div(n2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: a2.div(n2), panDelta: l2 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Jo2 {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            touchstart(e2, t2, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
            }
            touchmove(e2, t2, i2) {
              if (!this._firstTwoTouches) return;
              e2.preventDefault();
              const [r2, o2] = this._firstTwoTouches, a2 = ea2(i2, t2, r2), s2 = ea2(i2, t2, o2);
              if (!a2 || !s2) return;
              const n2 = this._aroundCenter ? null : a2.add(s2).div(2);
              return this._move([a2, s2], n2, e2);
            }
            touchend(e2, t2, i2) {
              if (!this._firstTwoTouches) return;
              const [r2, o2] = this._firstTwoTouches, a2 = ea2(i2, t2, r2), s2 = ea2(i2, t2, o2);
              a2 && s2 || (this._active && n.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(e2) {
              this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
          }
          function ea2(e2, t2, i2) {
            for (let r2 = 0; r2 < e2.length; r2++) if (e2[r2].identifier === i2) return t2[r2];
          }
          function ta2(e2, t2) {
            return Math.log(e2 / t2) / Math.LN2;
          }
          class ia2 extends Jo2 {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(e2) {
              this._startDistance = this._distance = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._distance;
              if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(ta2(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: ta2(this._distance, i2), pinchAround: t2 };
            }
          }
          function ra2(e2, t2) {
            return 180 * e2.angleWith(t2) / Math.PI;
          }
          class oa2 extends Jo2 {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(e2) {
              this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
            }
            _move(e2, t2, i2) {
              const r2 = this._vector;
              if (this._vector = e2[0].sub(e2[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: ra2(this._vector, r2), pinchAround: t2 };
            }
            _isBelowThreshold(e2) {
              this._minDiameter = Math.min(this._minDiameter, e2.mag());
              const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = ra2(e2, this._startVector);
              return Math.abs(i2) < t2;
            }
          }
          function aa2(e2) {
            return Math.abs(e2.y) > Math.abs(e2.x);
          }
          class sa2 extends Jo2 {
            constructor(e2) {
              super(), this._currentTouchCount = 0, this._map = e2;
            }
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            touchstart(e2, t2, i2) {
              super.touchstart(e2, t2, i2), this._currentTouchCount = i2.length;
            }
            _start(e2) {
              this._lastPoints = e2, aa2(e2[0].sub(e2[1])) && (this._valid = false);
            }
            _move(e2, t2, i2) {
              if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
              const r2 = e2[0].sub(this._lastPoints[0]), o2 = e2[1].sub(this._lastPoints[1]);
              return this._valid = this.gestureBeginsVertically(r2, o2, i2.timeStamp), this._valid ? (this._lastPoints = e2, this._active = true, { pitchDelta: (r2.y + o2.y) / 2 * -0.5 }) : void 0;
            }
            gestureBeginsVertically(e2, t2, i2) {
              if (void 0 !== this._valid) return this._valid;
              const r2 = e2.mag() >= 2, o2 = t2.mag() >= 2;
              if (!r2 && !o2) return;
              if (!r2 || !o2) return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const a2 = e2.y > 0 == t2.y > 0;
              return aa2(e2) && aa2(t2) && a2;
            }
          }
          const na2 = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class la2 {
            constructor(e2) {
              this._tr = new Zo2(e2);
              const t2 = na2;
              this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(e2) {
              if (e2.altKey || e2.ctrlKey || e2.metaKey) return;
              let t2 = 0, i2 = 0, r2 = 0, o2 = 0, a2 = 0;
              switch (e2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  t2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  t2 = -1;
                  break;
                case 37:
                  e2.shiftKey ? i2 = -1 : (e2.preventDefault(), o2 = -1);
                  break;
                case 39:
                  e2.shiftKey ? i2 = 1 : (e2.preventDefault(), o2 = 1);
                  break;
                case 38:
                  e2.shiftKey ? r2 = 1 : (e2.preventDefault(), a2 = -1);
                  break;
                case 40:
                  e2.shiftKey ? r2 = -1 : (e2.preventDefault(), a2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, r2 = 0), { cameraAnimation: (s2) => {
                const n2 = this._tr;
                s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ca, zoom: t2 ? Math.round(n2.zoom) + t2 * (e2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + r2 * this._pitchStep, offset: [-o2 * this._panStep, -a2 * this._panStep], center: n2.center }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function ca(e2) {
            return e2 * (2 - e2);
          }
          const ha = 4.000244140625;
          class ua {
            constructor(e2, t2) {
              this._onTimeout = (e3) => {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e3);
              }, this._map = e2, this._tr = new Zo2(e2), this._triggerRenderFrame = t2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
            }
            setZoomRate(e2) {
              this._defaultZoomRate = e2;
            }
            setWheelZoomRate(e2) {
              this._wheelZoomRate = e2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(e2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            _shouldBePrevented(e2) {
              return !!this._map.cooperativeGestures.isEnabled() && !(e2.ctrlKey || this._map.cooperativeGestures.isBypassed(e2));
            }
            wheel(e2) {
              if (!this.isEnabled()) return;
              if (this._shouldBePrevented(e2)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e2);
              let t2 = e2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY;
              const i2 = s.now(), r2 = i2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = i2, 0 !== t2 && t2 % ha == 0 ? this._type = "wheel" : 0 !== t2 && Math.abs(t2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = t2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r2 * t2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t2 += this._lastValue)), e2.shiftKey && t2 && (t2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= t2, this._active || this._start(e2)), e2.preventDefault();
            }
            _start(e2) {
              if (!this._delta) return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const i2 = n.mousePos(this._map.getCanvas(), e2), r2 = this._tr;
              this._aroundPoint = this._aroundCenter ? r2.transform.locationToScreenPoint(t.Q.convert(r2.center)) : i2, this._frameId || (this._frameId = true, this._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId) return;
              if (this._frameId = null, !this.isActive()) return;
              const e2 = this._tr.transform;
              if ("number" == typeof this._lastExpectedZoom) {
                const t2 = e2.zoom - this._lastExpectedZoom;
                "number" == typeof this._startZoom && (this._startZoom += t2), "number" == typeof this._targetZoom && (this._targetZoom += t2);
              }
              if (0 !== this._delta) {
                const i3 = "wheel" === this._type && Math.abs(this._delta) > ha ? this._wheelZoomRate : this._defaultZoomRate;
                let r3 = 2 / (1 + Math.exp(-Math.abs(this._delta * i3)));
                this._delta < 0 && 0 !== r3 && (r3 = 1 / r3);
                const o3 = "number" != typeof this._targetZoom ? e2.scale : t.ac(this._targetZoom);
                this._targetZoom = e2.getConstrained(e2.getCameraLngLat(), t.ah(o3 * r3)).zoom, "wheel" === this._type && (this._startZoom = e2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const i2 = "number" != typeof this._targetZoom ? e2.zoom : this._targetZoom, r2 = this._startZoom, o2 = this._easing;
              let a2, n2 = false;
              if ("wheel" === this._type && r2 && o2) {
                const e3 = s.now() - this._lastWheelEventTime, l2 = Math.min((e3 + 5) / 200, 1), c2 = o2(l2);
                a2 = t.B.number(r2, i2, c2), l2 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
              } else a2 = i2, n2 = true;
              return this._active = true, n2 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
              }, 200)), this._lastExpectedZoom = a2, { noInertia: true, needsRenderFrame: !n2, zoomDelta: a2 - e2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e2) {
              let i2 = t.cf;
              if (this._prevEase) {
                const e3 = this._prevEase, r2 = (s.now() - e3.start) / e3.duration, o2 = e3.easing(r2 + 0.01) - e3.easing(r2), a2 = 0.27 / Math.sqrt(o2 * o2 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - a2 * a2);
                i2 = t.cd(a2, n2, 0.25, 1);
              }
              return this._prevEase = { start: s.now(), duration: e2, easing: i2 }, i2;
            }
            reset() {
              this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            }
          }
          class da {
            constructor(e2, t2) {
              this._clickZoom = e2, this._tapZoom = t2;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class _a2 {
            constructor(e2) {
              this._tr = new Zo2(e2), this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(e2, t2) {
              return e2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: this._tr.zoom + (e2.shiftKey ? -1 : 1), around: this._tr.unproject(t2) }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class pa {
            constructor() {
              this._tap = new Vo2({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
            }
            touchstart(e2, t2, i2) {
              if (!this._swipePoint) if (this._tapTime) {
                const r2 = t2[0], o2 = e2.timeStamp - this._tapTime < 500, a2 = this._tapPoint.dist(r2) < 30;
                o2 && a2 ? i2.length > 0 && (this._swipePoint = r2, this._swipeTouch = i2[0].identifier) : this.reset();
              } else this._tap.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch) return;
                  const r2 = t2[0], o2 = r2.y - this._swipePoint.y;
                  return this._swipePoint = r2, e2.preventDefault(), this._active = true, { zoomDelta: o2 / 128 };
                }
              } else this._tap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              if (this._tapTime) this._swipePoint && 0 === i2.length && this.reset();
              else {
                const r2 = this._tap.touchend(e2, t2, i2);
                r2 && (this._tapTime = e2.timeStamp, this._tapPoint = r2);
              }
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class ma {
            constructor(e2, t2, i2) {
              this._el = e2, this._mousePan = t2, this._touchPan = i2;
            }
            enable(e2) {
              this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class fa {
            constructor(e2, t2, i2, r2) {
              this._pitchWithRotate = e2.pitchWithRotate, this._rollEnabled = e2.rollEnabled, this._mouseRotate = t2, this._mousePitch = i2, this._mouseRoll = r2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
            }
          }
          class ga {
            constructor(e2, t2, i2, r2) {
              this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = r2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(e2) {
              this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          class va {
            constructor(e2, t2) {
              this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e2, this._options = t2, this._enabled = false;
            }
            isActive() {
              return false;
            }
            reset() {
            }
            _setupUI() {
              if (this._container) return;
              const e2 = this._map.getCanvasContainer();
              e2.classList.add("maplibregl-cooperative-gestures"), this._container = n.create("div", "maplibregl-cooperative-gesture-screen", e2);
              let t2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
              "metaKey" === this._bypassKey && (t2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
              const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), r2 = document.createElement("div");
              r2.className = "maplibregl-desktop-message", r2.textContent = t2, this._container.appendChild(r2);
              const o2 = document.createElement("div");
              o2.className = "maplibregl-mobile-message", o2.textContent = i2, this._container.appendChild(o2), this._container.setAttribute("aria-hidden", "true");
            }
            _destroyUI() {
              this._container && (n.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
            }
            enable() {
              this._setupUI(), this._enabled = true;
            }
            disable() {
              this._enabled = false, this._destroyUI();
            }
            isEnabled() {
              return this._enabled;
            }
            isBypassed(e2) {
              return e2[this._bypassKey];
            }
            notifyGestureBlocked(e2, i2) {
              this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", { gestureType: e2, originalEvent: i2 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
                this._container.classList.remove("maplibregl-show");
              }, 100));
            }
          }
          const xa = (e2) => e2.zoom || e2.drag || e2.roll || e2.pitch || e2.rotate;
          class ba extends t.l {
          }
          function ya(e2) {
            return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta || e2.rollDelta;
          }
          class wa {
            constructor(e2, i2) {
              this.handleWindowEvent = (e3) => {
                this.handleEvent(e3, `${e3.type}Window`);
              }, this.handleEvent = (e3, i3) => {
                if ("blur" === e3.type) return void this.stop(true);
                this._updatingCamera = true;
                const r3 = "renderFrame" === e3.type ? void 0 : e3, o2 = { needsRenderFrame: false }, a2 = {}, s2 = {};
                for (const { handlerName: l3, handler: c3, allowed: h3 } of this._handlers) {
                  if (!c3.isEnabled()) continue;
                  let u2;
                  if (this._blockedByActive(s2, h3, l3)) c3.reset();
                  else if (c3[i3 || e3.type]) {
                    if (t.cg(e3, i3 || e3.type)) {
                      const t2 = n.mousePos(this._map.getCanvas(), e3);
                      u2 = c3[i3 || e3.type](e3, t2);
                    } else if (t.ch(e3, i3 || e3.type)) {
                      const t2 = this._getMapTouches(e3.touches), r4 = n.touchPos(this._map.getCanvas(), t2);
                      u2 = c3[i3 || e3.type](e3, r4, t2);
                    } else t.ci(i3 || e3.type) || (u2 = c3[i3 || e3.type](e3));
                    this.mergeHandlerResult(o2, a2, u2, l3, r3), u2 && u2.needsRenderFrame && this._triggerRenderFrame();
                  }
                  (u2 || c3.isActive()) && (s2[l3] = c3);
                }
                const l2 = {};
                for (const e4 in this._previousActiveHandlers) s2[e4] || (l2[e4] = r3);
                this._previousActiveHandlers = s2, (Object.keys(l2).length || ya(o2)) && (this._changes.push([o2, a2, l2]), this._triggerRenderFrame()), (Object.keys(s2).length || ya(o2)) && this._map._stop(true), this._updatingCamera = false;
                const { cameraAnimation: c2 } = o2;
                c2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], c2(this._map));
              }, this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Do2(e2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2);
              const r2 = this._el;
              this._listeners = [[r2, "touchstart", { passive: true }], [r2, "touchmove", { passive: false }], [r2, "touchend", void 0], [r2, "touchcancel", void 0], [r2, "mousedown", void 0], [r2, "mousemove", void 0], [r2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [r2, "mouseover", void 0], [r2, "mouseout", void 0], [r2, "dblclick", void 0], [r2, "click", void 0], [r2, "keydown", { capture: false }], [r2, "keyup", void 0], [r2, "wheel", { passive: false }], [r2, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [e3, t2, i3] of this._listeners) n.addEventListener(e3, t2, e3 === document ? this.handleWindowEvent : this.handleEvent, i3);
            }
            destroy() {
              for (const [e2, t2, i2] of this._listeners) n.removeEventListener(e2, t2, e2 === document ? this.handleWindowEvent : this.handleEvent, i2);
            }
            _addDefaultHandlers(e2) {
              const i2 = this._map, r2 = i2.getCanvasContainer();
              this._add("mapEvent", new Oo2(i2, e2));
              const o2 = i2.boxZoom = new No2(i2, e2);
              this._add("boxZoom", o2), e2.interactive && e2.boxZoom && o2.enable();
              const a2 = i2.cooperativeGestures = new va(i2, e2.cooperativeGestures);
              this._add("cooperativeGestures", a2), e2.cooperativeGestures && a2.enable();
              const s2 = new qo2(i2), l2 = new _a2(i2);
              i2.doubleClickZoom = new da(l2, s2), this._add("tapZoom", s2), this._add("clickZoom", l2), e2.interactive && e2.doubleClickZoom && i2.doubleClickZoom.enable();
              const c2 = new pa();
              this._add("tapDragZoom", c2);
              const h3 = i2.touchPitch = new sa2(i2);
              this._add("touchPitch", h3), e2.interactive && e2.touchPitch && i2.touchPitch.enable(e2.touchPitch);
              const u2 = () => i2.project(i2.getCenter()), d2 = function({ enable: e3, clickTolerance: i3, aroundCenter: r3 = true, minPixelCenterThreshold: o3 = 100, rotateDegreesPerPixelMoved: a3 = 0.8 }, s3) {
                const l3 = new $o2({ checkCorrectEvent: (e4) => 0 === n.mouseButton(e4) && e4.ctrlKey || 2 === n.mouseButton(e4) && !e4.ctrlKey });
                return new Wo2({ clickTolerance: i3, move: (e4, i4) => {
                  const n2 = s3();
                  if (r3 && Math.abs(n2.y - e4.y) > o3) return { bearingDelta: t.ce(new t.P(e4.x, i4.y), i4, n2) };
                  let l4 = (i4.x - e4.x) * a3;
                  return r3 && i4.y < n2.y && (l4 = -l4), { bearingDelta: l4 };
                }, moveStateManager: l3, enable: e3, assignEvents: Qo2 });
              }(e2, u2), _3 = function({ enable: e3, clickTolerance: t2, pitchDegreesPerPixelMoved: i3 = -0.5 }) {
                const r3 = new $o2({ checkCorrectEvent: (e4) => 0 === n.mouseButton(e4) && e4.ctrlKey || 2 === n.mouseButton(e4) });
                return new Wo2({ clickTolerance: t2, move: (e4, t3) => ({ pitchDelta: (t3.y - e4.y) * i3 }), moveStateManager: r3, enable: e3, assignEvents: Qo2 });
              }(e2), p2 = function({ enable: e3, clickTolerance: t2, rollDegreesPerPixelMoved: i3 = 0.3 }, r3) {
                const o3 = new $o2({ checkCorrectEvent: (e4) => 2 === n.mouseButton(e4) && e4.ctrlKey });
                return new Wo2({ clickTolerance: t2, move: (e4, t3) => {
                  const o4 = r3();
                  let a3 = (t3.x - e4.x) * i3;
                  return t3.y < o4.y && (a3 = -a3), { rollDelta: a3 };
                }, moveStateManager: o3, enable: e3, assignEvents: Qo2 });
              }(e2, u2);
              i2.dragRotate = new fa(e2, d2, _3, p2), this._add("mouseRotate", d2, ["mousePitch"]), this._add("mousePitch", _3, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p2, ["mousePitch"]), e2.interactive && e2.dragRotate && i2.dragRotate.enable();
              const m2 = function({ enable: e3, clickTolerance: t2 }) {
                const i3 = new $o2({ checkCorrectEvent: (e4) => 0 === n.mouseButton(e4) && !e4.ctrlKey });
                return new Wo2({ clickTolerance: t2, move: (e4, t3) => ({ around: t3, panDelta: t3.sub(e4) }), activateOnStart: true, moveStateManager: i3, enable: e3, assignEvents: Qo2 });
              }(e2), f2 = new Yo2(e2, i2);
              i2.dragPan = new ma(r2, m2, f2), this._add("mousePan", m2), this._add("touchPan", f2, ["touchZoom", "touchRotate"]), e2.interactive && e2.dragPan && i2.dragPan.enable(e2.dragPan);
              const g3 = new oa2(), v2 = new ia2();
              i2.touchZoomRotate = new ga(r2, v2, g3, c2), this._add("touchRotate", g3, ["touchPan", "touchZoom"]), this._add("touchZoom", v2, ["touchPan", "touchRotate"]), e2.interactive && e2.touchZoomRotate && i2.touchZoomRotate.enable(e2.touchZoomRotate);
              const x3 = i2.scrollZoom = new ua(i2, () => this._triggerRenderFrame());
              this._add("scrollZoom", x3, ["mousePan"]), e2.interactive && e2.scrollZoom && i2.scrollZoom.enable(e2.scrollZoom);
              const b2 = i2.keyboard = new la2(i2);
              this._add("keyboard", b2), e2.interactive && e2.keyboard && i2.keyboard.enable(), this._add("blockableMapEvent", new jo2(i2));
            }
            _add(e2, t2, i2) {
              this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
            }
            stop(e2) {
              if (!this._updatingCamera) {
                for (const { handler: e3 } of this._handlers) e3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: e2 } of this._handlers) if (e2.isActive()) return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(xa(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(e2, t2, i2) {
              for (const r2 in e2) if (r2 !== i2 && (!t2 || t2.indexOf(r2) < 0)) return true;
              return false;
            }
            _getMapTouches(e2) {
              const t2 = [];
              for (const i2 of e2) this._el.contains(i2.target) && t2.push(i2);
              return t2;
            }
            mergeHandlerResult(e2, i2, r2, o2, a2) {
              if (!r2) return;
              t.e(e2, r2);
              const s2 = { handlerName: o2, originalEvent: r2.originalEvent || a2 };
              void 0 !== r2.zoomDelta && (i2.zoom = s2), void 0 !== r2.panDelta && (i2.drag = s2), void 0 !== r2.rollDelta && (i2.roll = s2), void 0 !== r2.pitchDelta && (i2.pitch = s2), void 0 !== r2.bearingDelta && (i2.rotate = s2);
            }
            _applyChanges() {
              const e2 = {}, i2 = {}, r2 = {};
              for (const [o2, a2, s2] of this._changes) o2.panDelta && (e2.panDelta = (e2.panDelta || new t.P(0, 0))._add(o2.panDelta)), o2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + o2.zoomDelta), o2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + o2.bearingDelta), o2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + o2.pitchDelta), o2.rollDelta && (e2.rollDelta = (e2.rollDelta || 0) + o2.rollDelta), void 0 !== o2.around && (e2.around = o2.around), void 0 !== o2.pinchAround && (e2.pinchAround = o2.pinchAround), o2.noInertia && (e2.noInertia = o2.noInertia), t.e(i2, a2), t.e(r2, s2);
              this._updateMapTransform(e2, i2, r2), this._changes = [];
            }
            _updateMapTransform(e2, t2, i2) {
              const r2 = this._map, o2 = r2._getTransformForUpdate(), a2 = r2.terrain;
              if (!(ya(e2) || a2 && this._terrainMovement)) return this._fireEvents(t2, i2, true);
              r2._stop(true);
              let { panDelta: s2, zoomDelta: n2, bearingDelta: l2, pitchDelta: c2, rollDelta: h3, around: u2, pinchAround: d2 } = e2;
              void 0 !== d2 && (u2 = d2), u2 = u2 || r2.transform.centerPoint, a2 && !o2.isPointOnMapSurface(u2) && (u2 = o2.centerPoint);
              const _3 = { panDelta: s2, zoomDelta: n2, rollDelta: h3, pitchDelta: c2, bearingDelta: l2, around: u2 };
              this._map.cameraHelper.useGlobeControls && !o2.isPointOnMapSurface(u2) && (u2 = o2.centerPoint);
              const p2 = u2.distSqr(o2.centerPoint) < 0.01 ? o2.center : o2.screenPointToLocation(s2 ? u2.sub(s2) : u2);
              a2 ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_3, o2), this._terrainMovement || !t2.drag && !t2.zoom ? t2.drag && this._terrainMovement ? o2.setCenter(o2.screenPointToLocation(o2.centerPoint.sub(s2))) : this._map.cameraHelper.handleMapControlsPan(_3, o2, p2) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(_3, o2, p2))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_3, o2), this._map.cameraHelper.handleMapControlsPan(_3, o2, p2)), r2._applyUpdatedTransform(o2), this._map._update(), e2.noInertia || this._inertia.record(e2), this._fireEvents(t2, i2, true);
            }
            _fireEvents(e2, i2, r2) {
              const o2 = xa(this._eventsInProgress), a2 = xa(e2), n2 = {};
              for (const t2 in e2) {
                const { originalEvent: i3 } = e2[t2];
                this._eventsInProgress[t2] || (n2[`${t2}start`] = i3), this._eventsInProgress[t2] = e2[t2];
              }
              !o2 && a2 && this._fireEvent("movestart", a2.originalEvent);
              for (const e3 in n2) this._fireEvent(e3, n2[e3]);
              a2 && this._fireEvent("move", a2.originalEvent);
              for (const t2 in e2) {
                const { originalEvent: i3 } = e2[t2];
                this._fireEvent(t2, i3);
              }
              const l2 = {};
              let c2;
              for (const e3 in this._eventsInProgress) {
                const { handlerName: t2, originalEvent: r3 } = this._eventsInProgress[e3];
                this._handlersById[t2].isActive() || (delete this._eventsInProgress[e3], c2 = i2[t2] || r3, l2[`${e3}end`] = c2);
              }
              for (const e3 in l2) this._fireEvent(e3, l2[e3]);
              const h3 = xa(this._eventsInProgress), u2 = (o2 || a2) && !h3;
              if (u2 && this._terrainMovement) {
                this._map._elevationFreeze = false, this._terrainMovement = false;
                const e3 = this._map._getTransformForUpdate();
                this._map.getCenterClampedToGround() && e3.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e3);
              }
              if (r2 && u2) {
                this._updatingCamera = true;
                const e3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e4) => 0 !== e4 && -this._bearingSnap < e4 && e4 < this._bearingSnap;
                !e3 || !e3.essential && s.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: c2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(e3.bearing || this._map.getBearing()) && (e3.bearing = 0), e3.freezeElevation = true, this._map.easeTo(e3, { originalEvent: c2 })), this._updatingCamera = false;
              }
            }
            _fireEvent(e2, i2) {
              this._map.fire(new t.l(e2, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
                delete this._frameId, this.handleEvent(new ba("renderFrame", { timeStamp: e2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          class Ta extends t.E {
            constructor(e2, t2, i2) {
              super(), this._renderFrameCallback = () => {
                const e3 = Math.min((s.now() - this._easeStart) / this._easeOptions.duration, 1);
                this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
              }, this._moving = false, this._zooming = false, this.transform = e2, this._bearingSnap = i2.bearingSnap, this.cameraHelper = t2, this.on("moveend", () => {
                delete this._requestedCameraState;
              });
            }
            migrateProjection(e2, t2) {
              e2.apply(this.transform), this.transform = e2, this.cameraHelper = t2;
            }
            getCenter() {
              return new t.Q(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e2, t2) {
              return this.jumpTo({ center: e2 }, t2);
            }
            getCenterElevation() {
              return this.transform.elevation;
            }
            setCenterElevation(e2, t2) {
              return this.jumpTo({ elevation: e2 }, t2), this;
            }
            getCenterClampedToGround() {
              return this._centerClampedToGround;
            }
            setCenterClampedToGround(e2) {
              this._centerClampedToGround = e2;
            }
            panBy(e2, i2, r2) {
              return e2 = t.P.convert(e2).mult(-1), this.panTo(this.transform.center, t.e({ offset: e2 }, i2), r2);
            }
            panTo(e2, i2, r2) {
              return this.easeTo(t.e({ center: e2 }, i2), r2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(e2, t2) {
              return this.jumpTo({ zoom: e2 }, t2), this;
            }
            zoomTo(e2, i2, r2) {
              return this.easeTo(t.e({ zoom: e2 }, i2), r2);
            }
            zoomIn(e2, t2) {
              return this.zoomTo(this.getZoom() + 1, e2, t2), this;
            }
            zoomOut(e2, t2) {
              return this.zoomTo(this.getZoom() - 1, e2, t2), this;
            }
            getVerticalFieldOfView() {
              return this.transform.fov;
            }
            setVerticalFieldOfView(e2, i2) {
              return e2 != this.transform.fov && (this.transform.setFov(e2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)).fire(new t.l("moveend", i2))), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(e2, t2) {
              return this.jumpTo({ bearing: e2 }, t2), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(e2, t2) {
              return this.jumpTo({ padding: e2 }, t2), this;
            }
            rotateTo(e2, i2, r2) {
              return this.easeTo(t.e({ bearing: e2 }, i2), r2);
            }
            resetNorth(e2, i2) {
              return this.rotateTo(0, t.e({ duration: 1e3 }, e2), i2), this;
            }
            resetNorthPitch(e2, i2) {
              return this.easeTo(t.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e2), i2), this;
            }
            snapToNorth(e2, t2) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(e2, t2) {
              return this.jumpTo({ pitch: e2 }, t2), this;
            }
            getRoll() {
              return this.transform.roll;
            }
            setRoll(e2, t2) {
              return this.jumpTo({ roll: e2 }, t2), this;
            }
            cameraForBounds(e2, t2) {
              e2 = V2.convert(e2).adjustAntiMeridian();
              const i2 = t2 && t2.bearing || 0;
              return this._cameraForBoxAndBearing(e2.getNorthWest(), e2.getSouthEast(), i2, t2);
            }
            _cameraForBoxAndBearing(e2, i2, r2, o2) {
              const a2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (o2 = t.e({ padding: a2, offset: [0, 0], maxZoom: this.transform.maxZoom }, o2)).padding) {
                const e3 = o2.padding;
                o2.padding = { top: e3, bottom: e3, right: e3, left: e3 };
              }
              const s2 = t.e(a2, o2.padding);
              o2.padding = s2;
              const n2 = this.transform, l2 = new V2(e2, i2);
              return this.cameraHelper.cameraForBoxAndBearing(o2, s2, l2, r2, n2);
            }
            fitBounds(e2, t2, i2) {
              return this._fitInternal(this.cameraForBounds(e2, t2), t2, i2);
            }
            fitScreenCoordinates(e2, i2, r2, o2, a2) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e2)), this.transform.screenPointToLocation(t.P.convert(i2)), r2, o2), o2, a2);
            }
            _fitInternal(e2, i2, r2) {
              return e2 ? (delete (i2 = t.e(e2, i2)).padding, i2.linear ? this.easeTo(i2, r2) : this.flyTo(i2, r2)) : this;
            }
            jumpTo(e2, i2) {
              this.stop();
              const r2 = this._getTransformForUpdate();
              let o2 = false, a2 = false, s2 = false;
              const n2 = r2.zoom;
              this.cameraHelper.handleJumpToCenterZoom(r2, e2);
              const l2 = r2.zoom !== n2;
              return "elevation" in e2 && r2.elevation !== +e2.elevation && r2.setElevation(+e2.elevation), "bearing" in e2 && r2.bearing !== +e2.bearing && (o2 = true, r2.setBearing(+e2.bearing)), "pitch" in e2 && r2.pitch !== +e2.pitch && (a2 = true, r2.setPitch(+e2.pitch)), "roll" in e2 && r2.roll !== +e2.roll && (s2 = true, r2.setRoll(+e2.roll)), null == e2.padding || r2.isPaddingEqual(e2.padding) || r2.setPadding(e2.padding), this._applyUpdatedTransform(r2), this.fire(new t.l("movestart", i2)).fire(new t.l("move", i2)), l2 && this.fire(new t.l("zoomstart", i2)).fire(new t.l("zoom", i2)).fire(new t.l("zoomend", i2)), o2 && this.fire(new t.l("rotatestart", i2)).fire(new t.l("rotate", i2)).fire(new t.l("rotateend", i2)), a2 && this.fire(new t.l("pitchstart", i2)).fire(new t.l("pitch", i2)).fire(new t.l("pitchend", i2)), s2 && this.fire(new t.l("rollstart", i2)).fire(new t.l("roll", i2)).fire(new t.l("rollend", i2)), this.fire(new t.l("moveend", i2));
            }
            calculateCameraOptionsFromTo(e2, i2, r2, o2 = 0) {
              const a2 = t.$.fromLngLat(e2, i2), s2 = t.$.fromLngLat(r2, o2), n2 = s2.x - a2.x, l2 = s2.y - a2.y, c2 = s2.z - a2.z, h3 = Math.hypot(n2, l2, c2);
              if (0 === h3) throw new Error("Can't calculate camera options with same From and To");
              const u2 = Math.hypot(n2, l2), d2 = t.ah(this.transform.cameraToCenterDistance / h3 / this.transform.tileSize), _3 = 180 * Math.atan2(n2, -l2) / Math.PI;
              let p2 = 180 * Math.acos(u2 / h3) / Math.PI;
              return p2 = c2 < 0 ? 90 - p2 : 90 + p2, { center: s2.toLngLat(), elevation: o2, zoom: d2, pitch: p2, bearing: _3 };
            }
            calculateCameraOptionsFromCameraLngLatAltRotation(e2, t2, i2, r2, o2) {
              const a2 = this.transform.calculateCenterFromCameraLngLatAlt(e2, t2, i2, r2);
              return { center: a2.center, elevation: a2.elevation, zoom: a2.zoom, bearing: i2, pitch: r2, roll: o2 };
            }
            easeTo(e2, i2) {
              this._stop(false, e2.easeId), (false === (e2 = t.e({ offset: [0, 0], duration: 500, easing: t.cf }, e2)).animate || !e2.essential && s.prefersReducedMotion) && (e2.duration = 0);
              const r2 = this._getTransformForUpdate(), o2 = this.getBearing(), a2 = r2.pitch, n2 = r2.roll, l2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o2) : o2, c2 = "pitch" in e2 ? +e2.pitch : a2, h3 = "roll" in e2 ? this._normalizeBearing(e2.roll, n2) : n2, u2 = "padding" in e2 ? e2.padding : r2.padding, d2 = t.P.convert(e2.offset);
              let _3, p2;
              e2.around && (_3 = t.Q.convert(e2.around), p2 = r2.locationToScreenPoint(_3));
              const m2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f2 = this.cameraHelper.handleEaseTo(r2, { bearing: l2, pitch: c2, roll: h3, padding: u2, around: _3, aroundPoint: p2, offsetAsPoint: d2, offset: e2.offset, zoom: e2.zoom, center: e2.center });
              return this._rotating = this._rotating || o2 !== l2, this._pitching = this._pitching || c2 !== a2, this._rolling = this._rolling || h3 !== n2, this._padding = !r2.isPaddingEqual(u2), this._zooming = this._zooming || f2.isZooming, this._easeId = e2.easeId, this._prepareEase(i2, e2.noMoveStart, m2), this.terrain && this._prepareElevation(f2.elevationCenter), this._ease((t2) => {
                f2.easeFunc(t2), this.terrain && !e2.freezeElevation && this._updateElevation(t2), this._applyUpdatedTransform(r2), this._fireMoveEvents(i2);
              }, (t2) => {
                this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, t2);
              }, e2), this;
            }
            _prepareEase(e2, i2, r2 = {}) {
              this._moving = true, i2 || r2.moving || this.fire(new t.l("movestart", e2)), this._zooming && !r2.zooming && this.fire(new t.l("zoomstart", e2)), this._rotating && !r2.rotating && this.fire(new t.l("rotatestart", e2)), this._pitching && !r2.pitching && this.fire(new t.l("pitchstart", e2)), this._rolling && !r2.rolling && this.fire(new t.l("rollstart", e2));
            }
            _prepareElevation(e2) {
              this._elevationCenter = e2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e2, this.transform.tileZoom), this._elevationFreeze = true;
            }
            _updateElevation(e2) {
              this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
              const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
              if (e2 < 1 && i2 !== this._elevationTarget) {
                const t2 = this._elevationTarget - this._elevationStart;
                this._elevationStart += e2 * (t2 - (i2 - (t2 * e2 + this._elevationStart)) / (1 - e2)), this._elevationTarget = i2;
              }
              this.transform.setElevation(t.B.number(this._elevationStart, this._elevationTarget, e2));
            }
            _finalizeElevation() {
              this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
            }
            _getTransformForUpdate() {
              return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
            }
            _elevateCameraIfInsideTerrain(e2) {
              if (!this.terrain && e2.elevation >= 0 && e2.pitch <= 90) return {};
              const t2 = e2.getCameraLngLat(), i2 = e2.getCameraAltitude(), r2 = this.terrain ? this.terrain.getElevationForLngLatZoom(t2, e2.zoom) : 0;
              if (i2 < r2) {
                const i3 = this.calculateCameraOptionsFromTo(t2, r2, e2.center, e2.elevation);
                return { pitch: i3.pitch, zoom: i3.zoom };
              }
              return {};
            }
            _applyUpdatedTransform(e2) {
              const t2 = [];
              if (t2.push((e3) => this._elevateCameraIfInsideTerrain(e3)), this.transformCameraUpdate && t2.push((e3) => this.transformCameraUpdate(e3)), !t2.length) return;
              const i2 = e2.clone();
              for (const e3 of t2) {
                const t3 = i2.clone(), { center: r2, zoom: o2, roll: a2, pitch: s2, bearing: n2, elevation: l2 } = e3(t3);
                r2 && t3.setCenter(r2), void 0 !== l2 && t3.setElevation(l2), void 0 !== o2 && t3.setZoom(o2), void 0 !== a2 && t3.setRoll(a2), void 0 !== s2 && t3.setPitch(s2), void 0 !== n2 && t3.setBearing(n2), i2.apply(t3);
              }
              this.transform.apply(i2);
            }
            _fireMoveEvents(e2) {
              this.fire(new t.l("move", e2)), this._zooming && this.fire(new t.l("zoom", e2)), this._rotating && this.fire(new t.l("rotate", e2)), this._pitching && this.fire(new t.l("pitch", e2)), this._rolling && this.fire(new t.l("roll", e2));
            }
            _afterEase(e2, i2) {
              if (this._easeId && i2 && this._easeId === i2) return;
              delete this._easeId;
              const r2 = this._zooming, o2 = this._rotating, a2 = this._pitching, s2 = this._rolling;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, r2 && this.fire(new t.l("zoomend", e2)), o2 && this.fire(new t.l("rotateend", e2)), a2 && this.fire(new t.l("pitchend", e2)), s2 && this.fire(new t.l("rollend", e2)), this.fire(new t.l("moveend", e2));
            }
            flyTo(e2, i2) {
              if (!e2.essential && s.prefersReducedMotion) {
                const r3 = t.O(e2, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                return this.jumpTo(r3, i2);
              }
              this.stop(), e2 = t.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.cf }, e2);
              const r2 = this._getTransformForUpdate(), o2 = r2.bearing, a2 = r2.pitch, n2 = r2.roll, l2 = r2.padding, c2 = "bearing" in e2 ? this._normalizeBearing(e2.bearing, o2) : o2, h3 = "pitch" in e2 ? +e2.pitch : a2, u2 = "roll" in e2 ? this._normalizeBearing(e2.roll, n2) : n2, d2 = "padding" in e2 ? e2.padding : r2.padding, _3 = t.P.convert(e2.offset);
              let p2 = r2.centerPoint.add(_3);
              const m2 = r2.screenPointToLocation(p2), f2 = this.cameraHelper.handleFlyTo(r2, { bearing: c2, pitch: h3, roll: u2, padding: d2, locationAtOffset: m2, offsetAsPoint: _3, center: e2.center, minZoom: e2.minZoom, zoom: e2.zoom });
              let g3 = e2.curve;
              const v2 = Math.max(r2.width, r2.height), x3 = v2 / f2.scaleOfZoom, b2 = f2.pixelPathLength;
              "number" == typeof f2.scaleOfMinZoom && (g3 = Math.sqrt(v2 / f2.scaleOfMinZoom / b2 * 2));
              const y2 = g3 * g3;
              function w2(e3) {
                const t2 = (x3 * x3 - v2 * v2 + (e3 ? -1 : 1) * y2 * y2 * b2 * b2) / (2 * (e3 ? x3 : v2) * y2 * b2);
                return Math.log(Math.sqrt(t2 * t2 + 1) - t2);
              }
              function T2(e3) {
                return (Math.exp(e3) - Math.exp(-e3)) / 2;
              }
              function P2(e3) {
                return (Math.exp(e3) + Math.exp(-e3)) / 2;
              }
              const C3 = w2(false);
              let M3 = function(e3) {
                return P2(C3) / P2(C3 + g3 * e3);
              }, I3 = function(e3) {
                return v2 * ((P2(C3) * (T2(t2 = C3 + g3 * e3) / P2(t2)) - T2(C3)) / y2) / b2;
                var t2;
              }, E3 = (w2(true) - C3) / g3;
              if (Math.abs(b2) < 2e-6 || !isFinite(E3)) {
                if (Math.abs(v2 - x3) < 1e-6) return this.easeTo(e2, i2);
                const t2 = x3 < v2 ? -1 : 1;
                E3 = Math.abs(Math.log(x3 / v2)) / g3, I3 = () => 0, M3 = (e3) => Math.exp(t2 * g3 * e3);
              }
              return e2.duration = "duration" in e2 ? +e2.duration : 1e3 * E3 / ("screenSpeed" in e2 ? +e2.screenSpeed / g3 : +e2.speed), e2.maxDuration && e2.duration > e2.maxDuration && (e2.duration = 0), this._zooming = true, this._rotating = o2 !== c2, this._pitching = h3 !== a2, this._rolling = u2 !== n2, this._padding = !r2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2.targetCenter), this._ease((s2) => {
                const m3 = s2 * E3, g4 = 1 / M3(m3), v3 = I3(m3);
                this._rotating && r2.setBearing(t.B.number(o2, c2, s2)), this._pitching && r2.setPitch(t.B.number(a2, h3, s2)), this._rolling && r2.setRoll(t.B.number(n2, u2, s2)), this._padding && (r2.interpolatePadding(l2, d2, s2), p2 = r2.centerPoint.add(_3)), f2.easeFunc(s2, g4, v3, p2), this.terrain && !e2.freezeElevation && this._updateElevation(s2), this._applyUpdatedTransform(r2), this._fireMoveEvents(i2);
              }, () => {
                this.terrain && e2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
              }, e2), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(e2, t2) {
              var i2;
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const e3 = this._onEaseEnd;
                delete this._onEaseEnd, e3.call(this, t2);
              }
              return e2 || null === (i2 = this.handlers) || void 0 === i2 || i2.stop(false), this;
            }
            _ease(e2, t2, i2) {
              false === i2.animate || 0 === i2.duration ? (e2(1), t2()) : (this._easeStart = s.now(), this._easeOptions = i2, this._onEaseFrame = e2, this._onEaseEnd = t2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _normalizeBearing(e2, i2) {
              e2 = t.aL(e2, -180, 180);
              const r2 = Math.abs(e2 - i2);
              return Math.abs(e2 - 360 - i2) < r2 && (e2 -= 360), Math.abs(e2 + 360 - i2) < r2 && (e2 += 360), e2;
            }
            queryTerrainElevation(e2) {
              return this.terrain ? this.terrain.getElevationForLngLatZoom(t.Q.convert(e2), this.transform.tileZoom) : null;
            }
          }
          const Pa = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
          class Ca {
            constructor(e2 = Pa) {
              this._toggleAttribution = () => {
                this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
              }, this._updateData = (e3) => {
                !e3 || "metadata" !== e3.sourceDataType && "visibility" !== e3.sourceDataType && "style" !== e3.dataType && "terrain" !== e3.type || this._updateAttributions();
              }, this._updateCompact = () => {
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
              }, this._updateCompactMinimize = () => {
                this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
              }, this.options = e2;
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(e2) {
              return this._map = e2, this._compact = this.options.compact, this._container = n.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
              n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e2, t2) {
              const i2 = this._map._getUIString(`AttributionControl.${t2}`);
              e2.title = i2, e2.setAttribute("aria-label", i2);
            }
            _updateAttributions() {
              if (!this._map.style) return;
              let e2 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = e2.concat(this.options.customAttribution.map((e3) => "string" != typeof e3 ? "" : e3)) : "string" == typeof this.options.customAttribution && e2.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const e3 = this._map.style.stylesheet;
                this.styleOwner = e3.owner, this.styleId = e3.id;
              }
              const t2 = this._map.style.sourceCaches;
              for (const i3 in t2) {
                const r2 = t2[i3];
                if (r2.used || r2.usedForTerrain) {
                  const t3 = r2.getSource();
                  t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
                }
              }
              e2 = e2.filter((e3) => String(e3).trim()), e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
                for (let r2 = i3 + 1; r2 < e2.length; r2++) if (e2[r2].indexOf(t3) >= 0) return false;
                return true;
              });
              const i2 = e2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = n.sanitize(i2), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
          }
          class Ma {
            constructor(e2 = {}) {
              this._updateCompact = () => {
                const e3 = this._container.children;
                if (e3.length) {
                  const t2 = e3[0];
                  this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t2.classList.add("maplibregl-compact") : t2.classList.remove("maplibregl-compact");
                }
              }, this.options = e2;
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(e2) {
              this._map = e2, this._compact = this.options && this.options.compact, this._container = n.create("div", "maplibregl-ctrl");
              const t2 = n.create("a", "maplibregl-ctrl-logo");
              return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://maplibre.org/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              n.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
          }
          class Ia {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(e2) {
              const t2 = ++this._id;
              return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
            }
            remove(e2) {
              const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
              for (const t3 of i2) if (t3.id === e2) return void (t3.cancelled = true);
            }
            run(e2 = 0) {
              if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
              const t2 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of t2) if (!i2.cancelled && (i2.callback(e2), this._cleared)) break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          var Ea = t.aG([{ name: "a_pos3d", type: "Int16", components: 3 }]);
          class Sa2 extends t.E {
            constructor(e2) {
              super(), this._lastTilesetChange = s.now(), this.sourceCache = e2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e2._source.tileSize * 2 ** this.deltaZoom, e2.usedForTerrain = true, e2.tileSize = this.tileSize;
            }
            destruct() {
              this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
            }
            update(e2, i2) {
              this.sourceCache.update(e2, i2), this._renderableTilesKeys = [];
              const r2 = {};
              for (const o2 of xe2(e2, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) r2[o2.key] = true, this._renderableTilesKeys.push(o2.key), this._tiles[o2.key] || (o2.terrainRttPosMatrix32f = new Float64Array(16), t.bQ(o2.terrainRttPosMatrix32f, 0, t.Z, t.Z, 0, 0, 1), this._tiles[o2.key] = new ae(o2, this.tileSize), this._lastTilesetChange = s.now());
              for (const e3 in this._tiles) r2[e3] || delete this._tiles[e3];
            }
            freeRtt(e2) {
              for (const t2 in this._tiles) {
                const i2 = this._tiles[t2];
                (!e2 || i2.tileID.equals(e2) || i2.tileID.isChildOf(e2) || e2.isChildOf(i2.tileID)) && (i2.rtt = []);
              }
            }
            getRenderableTiles() {
              return this._renderableTilesKeys.map((e2) => this.getTileByID(e2));
            }
            getTileByID(e2) {
              return this._tiles[e2];
            }
            getTerrainCoords(e2, t2) {
              return t2 ? this._getTerrainCoordsForTileRanges(e2, t2) : this._getTerrainCoordsForRegularTile(e2);
            }
            _getTerrainCoordsForRegularTile(e2) {
              const i2 = {};
              for (const r2 of this._renderableTilesKeys) {
                const o2 = this._tiles[r2].tileID, a2 = e2.clone(), s2 = t.b2();
                if (o2.canonical.equals(e2.canonical)) t.bQ(s2, 0, t.Z, t.Z, 0, 0, 1);
                else if (o2.canonical.isChildOf(e2.canonical)) {
                  const i3 = o2.canonical.z - e2.canonical.z, r3 = o2.canonical.x - (o2.canonical.x >> i3 << i3), a3 = o2.canonical.y - (o2.canonical.y >> i3 << i3), n2 = t.Z >> i3;
                  t.bQ(s2, 0, n2, n2, 0, 0, 1), t.L(s2, s2, [-r3 * n2, -a3 * n2, 0]);
                } else {
                  if (!e2.canonical.isChildOf(o2.canonical)) continue;
                  {
                    const i3 = e2.canonical.z - o2.canonical.z, r3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), a3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), n2 = t.Z >> i3;
                    t.bQ(s2, 0, t.Z, t.Z, 0, 0, 1), t.L(s2, s2, [r3 * n2, a3 * n2, 0]), t.M(s2, s2, [1 / 2 ** i3, 1 / 2 ** i3, 0]);
                  }
                }
                a2.terrainRttPosMatrix32f = new Float32Array(s2), i2[r2] = a2;
              }
              return i2;
            }
            _getTerrainCoordsForTileRanges(e2, i2) {
              const r2 = {};
              for (const o2 of this._renderableTilesKeys) {
                const a2 = this._tiles[o2].tileID;
                if (!this._isWithinTileRanges(a2, i2)) continue;
                const s2 = e2.clone(), n2 = t.b2();
                if (a2.canonical.z === e2.canonical.z) {
                  const i3 = e2.canonical.x - a2.canonical.x, r3 = e2.canonical.y - a2.canonical.y;
                  t.bQ(n2, 0, t.Z, t.Z, 0, 0, 1), t.L(n2, n2, [i3 * t.Z, r3 * t.Z, 0]);
                } else if (a2.canonical.z > e2.canonical.z) {
                  const i3 = a2.canonical.z - e2.canonical.z, r3 = a2.canonical.x - (a2.canonical.x >> i3 << i3), o3 = a2.canonical.y - (a2.canonical.y >> i3 << i3), s3 = e2.canonical.x - (a2.canonical.x >> i3), l2 = e2.canonical.y - (a2.canonical.y >> i3), c2 = t.Z >> i3;
                  t.bQ(n2, 0, c2, c2, 0, 0, 1), t.L(n2, n2, [-r3 * c2 + s3 * t.Z, -o3 * c2 + l2 * t.Z, 0]);
                } else {
                  const i3 = e2.canonical.z - a2.canonical.z, r3 = e2.canonical.x - (e2.canonical.x >> i3 << i3), o3 = e2.canonical.y - (e2.canonical.y >> i3 << i3), s3 = (e2.canonical.x >> i3) - a2.canonical.x, l2 = (e2.canonical.y >> i3) - a2.canonical.y, c2 = t.Z << i3;
                  t.bQ(n2, 0, c2, c2, 0, 0, 1), t.L(n2, n2, [r3 * t.Z + s3 * c2, o3 * t.Z + l2 * c2, 0]);
                }
                s2.terrainRttPosMatrix32f = new Float32Array(n2), r2[o2] = s2;
              }
              return r2;
            }
            getSourceTile(e2, t2) {
              const i2 = this.sourceCache._source;
              let r2 = e2.overscaledZ - this.deltaZoom;
              if (r2 > i2.maxzoom && (r2 = i2.maxzoom), r2 < i2.minzoom) return null;
              this._sourceTileCache[e2.key] || (this._sourceTileCache[e2.key] = e2.scaledTo(r2).key);
              let o2 = this.sourceCache.getTileByID(this._sourceTileCache[e2.key]);
              if ((!o2 || !o2.dem) && t2) for (; r2 >= i2.minzoom && (!o2 || !o2.dem); ) o2 = this.sourceCache.getTileByID(e2.scaledTo(r2--).key);
              return o2;
            }
            anyTilesAfterTime(e2 = Date.now()) {
              return this._lastTilesetChange >= e2;
            }
            _isWithinTileRanges(e2, t2) {
              return t2[e2.canonical.z] && e2.canonical.x >= t2[e2.canonical.z].minTileX && e2.canonical.x <= t2[e2.canonical.z].maxTileX && e2.canonical.y >= t2[e2.canonical.z].minTileY && e2.canonical.y <= t2[e2.canonical.z].maxTileY;
            }
          }
          class Ra {
            constructor(e2, t2, i2) {
              this._meshCache = {}, this.painter = e2, this.sourceCache = new Sa2(t2), this.options = i2, this.exaggeration = "number" == typeof i2.exaggeration ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
            }
            getDEMElevation(e2, i2, r2, o2 = t.Z) {
              var a2;
              if (!(i2 >= 0 && i2 < o2 && r2 >= 0 && r2 < o2)) return 0;
              const s2 = this.getTerrainData(e2), n2 = null === (a2 = s2.tile) || void 0 === a2 ? void 0 : a2.dem;
              if (!n2) return 0;
              const l2 = t.cj([], [i2 / o2 * t.Z, r2 / o2 * t.Z], s2.u_terrain_matrix), c2 = [l2[0] * n2.dim, l2[1] * n2.dim], h3 = Math.floor(c2[0]), u2 = Math.floor(c2[1]), d2 = c2[0] - h3, _3 = c2[1] - u2;
              return n2.get(h3, u2) * (1 - d2) * (1 - _3) + n2.get(h3 + 1, u2) * d2 * (1 - _3) + n2.get(h3, u2 + 1) * (1 - d2) * _3 + n2.get(h3 + 1, u2 + 1) * d2 * _3;
            }
            getElevationForLngLatZoom(e2, i2) {
              if (!t.ck(i2, e2.wrap())) return 0;
              const { tileID: r2, mercatorX: o2, mercatorY: a2 } = this._getOverscaledTileIDFromLngLatZoom(e2, i2);
              return this.getElevation(r2, o2 % t.Z, a2 % t.Z, t.Z);
            }
            getElevation(e2, i2, r2, o2 = t.Z) {
              return this.getDEMElevation(e2, i2, r2, o2) * this.exaggeration;
            }
            getTerrainData(e2) {
              if (!this._emptyDemTexture) {
                const e3 = this.painter.context, i3 = new t.R({ width: 1, height: 1 }, new Uint8Array(4));
                this._emptyDepthTexture = new v(e3, i3, e3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new v(e3, new t.R({ width: 1, height: 1 }), e3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ad([]);
              }
              const i2 = this.sourceCache.getSourceTile(e2, true);
              if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
                const e3 = this.painter.context;
                i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new v(e3, i2.dem.getPixels(), e3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
              }
              const r2 = i2 && i2 + i2.tileID.key + e2.key;
              if (r2 && !this._demMatrixCache[r2]) {
                const r3 = this.sourceCache.sourceCache._source.maxzoom;
                let o2 = e2.canonical.z - i2.tileID.canonical.z;
                e2.overscaledZ > e2.canonical.z && (e2.canonical.z >= r3 ? o2 = e2.canonical.z - r3 : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                const a2 = e2.canonical.x - (e2.canonical.x >> o2 << o2), s2 = e2.canonical.y - (e2.canonical.y >> o2 << o2), n2 = t.cl(new Float64Array(16), [1 / (t.Z << o2), 1 / (t.Z << o2), 0]);
                t.L(n2, n2, [a2 * t.Z, s2 * t.Z, 0]), this._demMatrixCache[e2.key] = { matrix: n2, coord: e2 };
              }
              return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: r2 ? this._demMatrixCache[e2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
            }
            getFramebuffer(e2) {
              const t2 = this.painter, i2 = t2.width / devicePixelRatio, r2 = t2.height / devicePixelRatio;
              return !this._fbo || this._fbo.width === i2 && this._fbo.height === r2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new v(t2.context, { width: i2, height: r2, data: null }, t2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t2.context.gl.NEAREST, t2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new v(t2.context, { width: i2, height: r2, data: null }, t2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t2.context.gl.NEAREST, t2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t2.context.createFramebuffer(i2, r2, true, false), this._fbo.depthAttachment.set(t2.context.createRenderbuffer(t2.context.gl.DEPTH_COMPONENT16, i2, r2))), this._fbo.colorAttachment.set("coords" === e2 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
              const e2 = this.painter.context;
              if (this._coordsTexture) return this._coordsTexture;
              const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
              for (let e3 = 0, t2 = 0; e3 < this._coordsTextureSize; e3++) for (let r3 = 0; r3 < this._coordsTextureSize; r3++, t2 += 4) i2[t2 + 0] = 255 & r3, i2[t2 + 1] = 255 & e3, i2[t2 + 2] = r3 >> 8 << 4 | e3 >> 8, i2[t2 + 3] = 0;
              const r2 = new t.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), o2 = new v(e2, r2, e2.gl.RGBA, { premultiply: false });
              return o2.bind(e2.gl.NEAREST, e2.gl.CLAMP_TO_EDGE), this._coordsTexture = o2, o2;
            }
            pointCoordinate(e2) {
              this.painter.maybeDrawDepthAndCoords(true);
              const i2 = new Uint8Array(4), r2 = this.painter.context, o2 = r2.gl, a2 = Math.round(e2.x * this.painter.pixelRatio / devicePixelRatio), s2 = Math.round(e2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
              r2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o2.readPixels(a2, n2 - s2 - 1, 1, 1, o2.RGBA, o2.UNSIGNED_BYTE, i2), r2.bindFramebuffer.set(null);
              const l2 = i2[0] + (i2[2] >> 4 << 8), c2 = i2[1] + ((15 & i2[2]) << 8), h3 = this.coordsIndex[255 - i2[3]], u2 = h3 && this.sourceCache.getTileByID(h3);
              if (!u2) return null;
              const d2 = this._coordsTextureSize, _3 = (1 << u2.tileID.canonical.z) * d2;
              return new t.$((u2.tileID.canonical.x * d2 + l2) / _3 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + c2) / _3, this.getElevation(u2.tileID, l2, c2, d2));
            }
            depthAtPoint(e2) {
              const t2 = new Uint8Array(4), i2 = this.painter.context, r2 = i2.gl;
              return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), r2.readPixels(e2.x, this.painter.height / devicePixelRatio - e2.y - 1, 1, 1, r2.RGBA, r2.UNSIGNED_BYTE, t2), i2.bindFramebuffer.set(null), (t2[0] / 16777216 + t2[1] / 65536 + t2[2] / 256 + t2[3]) / 256;
            }
            getTerrainMesh(e2) {
              var i2;
              const r2 = (null === (i2 = this.painter.style.projection) || void 0 === i2 ? void 0 : i2.transitionState) > 0, o2 = r2 && 0 === e2.canonical.y, a2 = r2 && e2.canonical.y === (1 << e2.canonical.z) - 1, s2 = `m_${o2 ? "n" : ""}_${a2 ? "s" : ""}`;
              if (this._meshCache[s2]) return this._meshCache[s2];
              const n2 = this.painter.context, l2 = new t.cm(), c2 = new t.aK(), h3 = this.meshSize, u2 = t.Z / h3, d2 = h3 * h3;
              for (let e3 = 0; e3 <= h3; e3++) for (let t2 = 0; t2 <= h3; t2++) l2.emplaceBack(t2 * u2, e3 * u2, 0);
              for (let e3 = 0; e3 < d2; e3 += h3 + 1) for (let t2 = 0; t2 < h3; t2++) c2.emplaceBack(t2 + e3, h3 + t2 + e3 + 1, h3 + t2 + e3 + 2), c2.emplaceBack(t2 + e3, h3 + t2 + e3 + 2, t2 + e3 + 1);
              const _3 = l2.length, p2 = _3 + (h3 + 1), m2 = (h3 + 1) * h3, f2 = o2 ? t.b9 : 0, g3 = o2 ? 0 : 1, v2 = a2 ? t.ba : t.Z, x3 = a2 ? 0 : 1;
              for (let e3 = 0; e3 <= h3; e3++) l2.emplaceBack(e3 * u2, f2, g3);
              for (let e3 = 0; e3 <= h3; e3++) l2.emplaceBack(e3 * u2, v2, x3);
              for (let e3 = 0; e3 < h3; e3++) c2.emplaceBack(m2 + e3, p2 + e3, p2 + e3 + 1), c2.emplaceBack(m2 + e3, p2 + e3 + 1, m2 + e3 + 1), c2.emplaceBack(0 + e3, _3 + e3 + 1, _3 + e3), c2.emplaceBack(0 + e3, 0 + e3 + 1, _3 + e3 + 1);
              const b2 = l2.length, y2 = b2 + 2 * (h3 + 1);
              for (const e3 of [0, 1]) for (let i3 = 0; i3 <= h3; i3++) for (const r3 of [0, 1]) l2.emplaceBack(e3 * t.Z, i3 * u2, r3);
              for (let e3 = 0; e3 < 2 * h3; e3 += 2) c2.emplaceBack(b2 + e3, b2 + e3 + 1, b2 + e3 + 3), c2.emplaceBack(b2 + e3, b2 + e3 + 3, b2 + e3 + 2), c2.emplaceBack(y2 + e3, y2 + e3 + 3, y2 + e3 + 1), c2.emplaceBack(y2 + e3, y2 + e3 + 2, y2 + e3 + 3);
              const w2 = new wt2(n2.createVertexBuffer(l2, Ea.members), n2.createIndexBuffer(c2), t.aJ.simpleSegment(0, 0, l2.length, c2.length));
              return this._meshCache[s2] = w2, w2;
            }
            getMeshFrameDelta(e2) {
              return 2 * Math.PI * t.bu / Math.pow(2, Math.max(e2, 0)) / 5;
            }
            getMinTileElevationForLngLatZoom(e2, t2) {
              var i2;
              const { tileID: r2 } = this._getOverscaledTileIDFromLngLatZoom(e2, t2);
              return null !== (i2 = this.getMinMaxElevation(r2).minElevation) && void 0 !== i2 ? i2 : 0;
            }
            getMinMaxElevation(e2) {
              const t2 = this.getTerrainData(e2).tile, i2 = { minElevation: null, maxElevation: null };
              return t2 && t2.dem && (i2.minElevation = t2.dem.min * this.exaggeration, i2.maxElevation = t2.dem.max * this.exaggeration), i2;
            }
            _getOverscaledTileIDFromLngLatZoom(e2, i2) {
              const r2 = t.$.fromLngLat(e2.wrap()), o2 = (1 << i2) * t.Z, a2 = r2.x * o2, s2 = r2.y * o2, n2 = Math.floor(a2 / t.Z), l2 = Math.floor(s2 / t.Z);
              return { tileID: new t.Y(i2, 0, i2, n2, l2), mercatorX: a2, mercatorY: s2 };
            }
          }
          class za2 {
            constructor(e2, t2, i2) {
              this._context = e2, this._size = t2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
            }
            destruct() {
              for (const e2 of this._objects) e2.texture.destroy(), e2.fbo.destroy();
            }
            _createObject(e2) {
              const t2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i2 = new v(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
              return i2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), t2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t2.colorAttachment.set(i2.texture), { id: e2, fbo: t2, texture: i2, stamp: -1, inUse: false };
            }
            getObjectForId(e2) {
              return this._objects[e2];
            }
            useObject(e2) {
              e2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t2) => e2.id !== t2), this._recentlyUsed.push(e2.id);
            }
            stampObject(e2) {
              e2.stamp = ++this._stamp;
            }
            getOrCreateFreeObject() {
              for (const e3 of this._recentlyUsed) if (!this._objects[e3].inUse) return this._objects[e3];
              if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
              const e2 = this._createObject(this._objects.length);
              return this._objects.push(e2), e2;
            }
            freeObject(e2) {
              e2.inUse = false;
            }
            freeAllObjects() {
              for (const e2 of this._objects) this.freeObject(e2);
            }
            isFull() {
              return !(this._objects.length < this._size) && false === this._objects.some((e2) => !e2.inUse);
            }
          }
          const Da = { background: true, fill: true, line: true, raster: true, hillshade: true };
          class Aa {
            constructor(e2, t2) {
              this.painter = e2, this.terrain = t2, this.pool = new za2(e2.context, 30, t2.sourceCache.tileSize * t2.qualityFactor);
            }
            destruct() {
              this.pool.destruct();
            }
            getTexture(e2) {
              return this.pool.getObjectForId(e2.rtt[this._stacks.length - 1].id).texture;
            }
            prepareForRender(e2, t2) {
              this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e2._order.filter((i2) => !e2._layers[i2].isHidden(t2)), this._coordsAscending = {};
              for (const t3 in e2.sourceCaches) {
                this._coordsAscending[t3] = {};
                const i2 = e2.sourceCaches[t3].getVisibleCoordinates(), r2 = e2.sourceCaches[t3].getSource(), o2 = r2 instanceof K2 ? r2.terrainTileRanges : null;
                for (const e3 of i2) {
                  const i3 = this.terrain.sourceCache.getTerrainCoords(e3, o2);
                  for (const e4 in i3) this._coordsAscending[t3][e4] || (this._coordsAscending[t3][e4] = []), this._coordsAscending[t3][e4].push(i3[e4]);
                }
              }
              this._coordsAscendingStr = {};
              for (const t3 of e2._order) {
                const i2 = e2._layers[t3], r2 = i2.source;
                if (Da[i2.type] && !this._coordsAscendingStr[r2]) {
                  this._coordsAscendingStr[r2] = {};
                  for (const e3 in this._coordsAscending[r2]) this._coordsAscendingStr[r2][e3] = this._coordsAscending[r2][e3].map((e4) => e4.key).sort().join();
                }
              }
              for (const e3 of this._renderableTiles) for (const t3 in this._coordsAscendingStr) {
                const i2 = this._coordsAscendingStr[t3][e3.tileID.key];
                i2 && i2 !== e3.rttCoords[t3] && (e3.rtt = []);
              }
            }
            renderLayer(e2, i2) {
              if (e2.isHidden(this.painter.transform.zoom)) return false;
              const r2 = Object.assign(Object.assign({}, i2), { isRenderingToTexture: true }), o2 = e2.type, a2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e2.id;
              if (Da[o2] && (this._prevType && Da[this._prevType] || this._stacks.push([]), this._prevType = o2, this._stacks[this._stacks.length - 1].push(e2.id), !s2)) return true;
              if (Da[this._prevType] || Da[o2] && s2) {
                this._prevType = o2;
                const e3 = this._stacks.length - 1, i3 = this._stacks[e3] || [];
                for (const o3 of this._renderableTiles) {
                  if (this.pool.isFull() && (yo2(this.painter, this.terrain, this._rttTiles, r2), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(o3), o3.rtt[e3]) {
                    const t2 = this.pool.getObjectForId(o3.rtt[e3].id);
                    if (t2.stamp === o3.rtt[e3].stamp) {
                      this.pool.useObject(t2);
                      continue;
                    }
                  }
                  const s3 = this.pool.getOrCreateFreeObject();
                  this.pool.useObject(s3), this.pool.stampObject(s3), o3.rtt[e3] = { id: s3.id, stamp: s3.stamp }, a2.context.bindFramebuffer.set(s3.fbo.framebuffer), a2.context.clear({ color: t.b7.transparent, stencil: 0 }), a2.currentStencilSource = void 0;
                  for (let e4 = 0; e4 < i3.length; e4++) {
                    const t2 = a2.style._layers[i3[e4]], n2 = t2.source ? this._coordsAscending[t2.source][o3.tileID.key] : [o3.tileID];
                    a2.context.viewport.set([0, 0, s3.fbo.width, s3.fbo.height]), a2._renderTileClippingMasks(t2, n2, true), a2.renderLayer(a2, a2.style.sourceCaches[t2.source], t2, n2, r2), t2.source && (o3.rttCoords[t2.source] = this._coordsAscendingStr[t2.source][o3.tileID.key]);
                  }
                }
                return yo2(this.painter, this.terrain, this._rttTiles, r2), this._rttTiles = [], this.pool.freeAllObjects(), Da[o2];
              }
              return false;
            }
          }
          const La = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, ka = i, Fa = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Pa, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, Ba2 = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
          class Oa2 {
            constructor(e2, i2, r2 = false) {
              this.mousedown = (e3) => {
                this.startMove(e3, n.mousePos(this.element, e3)), n.addEventListener(window, "mousemove", this.mousemove), n.addEventListener(window, "mouseup", this.mouseup);
              }, this.mousemove = (e3) => {
                this.move(e3, n.mousePos(this.element, e3));
              }, this.mouseup = (e3) => {
                this._rotatePitchHanlder.dragEnd(e3), this.offTemp();
              }, this.touchstart = (e3) => {
                1 !== e3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, e3.targetTouches)[0], this.startMove(e3, this._startPos), n.addEventListener(window, "touchmove", this.touchmove, { passive: false }), n.addEventListener(window, "touchend", this.touchend));
              }, this.touchmove = (e3) => {
                1 !== e3.targetTouches.length ? this.reset() : (this._lastPos = n.touchPos(this.element, e3.targetTouches)[0], this.move(e3, this._lastPos));
              }, this.touchend = (e3) => {
                0 === e3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this.reset = () => {
                this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this._clickTolerance = 10, this.element = i2;
              const o2 = new Ko2();
              this._rotatePitchHanlder = new Wo2({ clickTolerance: 3, move: (e3, o3) => {
                const a2 = i2.getBoundingClientRect(), s2 = new t.P((a2.bottom - a2.top) / 2, (a2.right - a2.left) / 2);
                return { bearingDelta: t.ce(new t.P(e3.x, o3.y), o3, s2), pitchDelta: r2 ? -0.5 * (o3.y - e3.y) : void 0 };
              }, moveStateManager: o2, enable: true, assignEvents: () => {
              } }), this.map = e2, n.addEventListener(i2, "mousedown", this.mousedown), n.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), n.addEventListener(i2, "touchcancel", this.reset);
            }
            startMove(e2, t2) {
              this._rotatePitchHanlder.dragStart(e2, t2), n.disableDrag();
            }
            move(e2, t2) {
              const i2 = this.map, { bearingDelta: r2, pitchDelta: o2 } = this._rotatePitchHanlder.dragMove(e2, t2) || {};
              r2 && i2.setBearing(i2.getBearing() + r2), o2 && i2.setPitch(i2.getPitch() + o2);
            }
            off() {
              const e2 = this.element;
              n.removeEventListener(e2, "mousedown", this.mousedown), n.removeEventListener(e2, "touchstart", this.touchstart, { passive: false }), n.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n.removeEventListener(window, "touchend", this.touchend), n.removeEventListener(e2, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              n.enableDrag(), n.removeEventListener(window, "mousemove", this.mousemove), n.removeEventListener(window, "mouseup", this.mouseup), n.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n.removeEventListener(window, "touchend", this.touchend);
            }
          }
          let ja;
          function Za2(e2, i2, r2, o2 = false) {
            if (o2 || !r2.getCoveringTilesDetailsProvider().allowWorldCopies()) return null == e2 ? void 0 : e2.wrap();
            const a2 = new t.Q(e2.lng, e2.lat);
            if (e2 = new t.Q(e2.lng, e2.lat), i2) {
              const o3 = new t.Q(e2.lng - 360, e2.lat), a3 = new t.Q(e2.lng + 360, e2.lat), s2 = r2.locationToScreenPoint(e2).distSqr(i2);
              r2.locationToScreenPoint(o3).distSqr(i2) < s2 ? e2 = o3 : r2.locationToScreenPoint(a3).distSqr(i2) < s2 && (e2 = a3);
            }
            for (; Math.abs(e2.lng - r2.center.lng) > 180; ) {
              const t2 = r2.locationToScreenPoint(e2);
              if (t2.x >= 0 && t2.y >= 0 && t2.x <= r2.width && t2.y <= r2.height) break;
              e2.lng > r2.center.lng ? e2.lng -= 360 : e2.lng += 360;
            }
            return e2.lng !== a2.lng && r2.isPointOnMapSurface(r2.locationToScreenPoint(e2)) ? e2 : a2;
          }
          const Na = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function Ua2(e2, t2, i2) {
            const r2 = e2.classList;
            for (const e3 in Na) r2.remove(`maplibregl-${i2}-anchor-${e3}`);
            r2.add(`maplibregl-${i2}-anchor-${t2}`);
          }
          class Ga2 extends t.E {
            constructor(e2) {
              if (super(), this._onKeyPress = (e3) => {
                const t2 = e3.code, i2 = e3.charCode || e3.keyCode;
                "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
              }, this._onMapClick = (e3) => {
                const t2 = e3.originalEvent.target, i2 = this._element;
                this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
              }, this._update = (e3) => {
                if (!this._map) return;
                const t2 = this._map.loaded() && !this._map.isMoving();
                ("terrain" === (null == e3 ? void 0 : e3.type) || "render" === (null == e3 ? void 0 : e3.type) && !t2) && this._map.once("render", this._update), this._lngLat = Za2(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let i2 = "";
                "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? i2 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (i2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                let r2 = "";
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? r2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (r2 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e3 && "moveend" !== e3.type || (this._pos = this._pos.round()), n.setTransform(this._element, `${Na[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${r2} ${i2}`), s.frameAsync(new AbortController()).then(() => {
                  this._updateOpacity(e3 && "moveend" === e3.type);
                }).catch(() => {
                });
              }, this._onMove = (e3) => {
                if (!this._isDragging) {
                  const t2 = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = e3.point.dist(this._pointerdownPos) >= t2;
                }
                this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.l("dragend")), this._state = "inactive";
              }, this._addDragHandler = (e3) => {
                this._element.contains(e3.originalEvent.target) && (e3.preventDefault(), this._positionDelta = e3.point.sub(this._pos).add(this._offset), this._pointerdownPos = e3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
              }, this._anchor = e2 && e2.anchor || "center", this._color = e2 && e2.color || "#3FB1CE", this._scale = e2 && e2.scale || 1, this._draggable = e2 && e2.draggable || false, this._clickTolerance = e2 && e2.clickTolerance || 0, this._subpixelPositioning = e2 && e2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e2 && e2.rotation || 0, this._rotationAlignment = e2 && e2.rotationAlignment || "auto", this._pitchAlignment = e2 && e2.pitchAlignment && "auto" !== e2.pitchAlignment ? e2.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e2 ? void 0 : e2.opacity, null == e2 ? void 0 : e2.opacityWhenCovered), e2 && e2.element) this._element = e2.element, this._offset = t.P.convert(e2 && e2.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = n.create("div");
                const i2 = n.createNS("http://www.w3.org/2000/svg", "svg"), r2 = 41, o2 = 27;
                i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${r2}px`), i2.setAttributeNS(null, "width", `${o2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${o2} ${r2}`);
                const a2 = n.createNS("http://www.w3.org/2000/svg", "g");
                a2.setAttributeNS(null, "stroke", "none"), a2.setAttributeNS(null, "stroke-width", "1"), a2.setAttributeNS(null, "fill", "none"), a2.setAttributeNS(null, "fill-rule", "evenodd");
                const s2 = n.createNS("http://www.w3.org/2000/svg", "g");
                s2.setAttributeNS(null, "fill-rule", "nonzero");
                const l2 = n.createNS("http://www.w3.org/2000/svg", "g");
                l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
                const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const e3 of c2) {
                  const t2 = n.createNS("http://www.w3.org/2000/svg", "ellipse");
                  t2.setAttributeNS(null, "opacity", "0.04"), t2.setAttributeNS(null, "cx", "10.5"), t2.setAttributeNS(null, "cy", "5.80029008"), t2.setAttributeNS(null, "rx", e3.rx), t2.setAttributeNS(null, "ry", e3.ry), l2.appendChild(t2);
                }
                const h3 = n.createNS("http://www.w3.org/2000/svg", "g");
                h3.setAttributeNS(null, "fill", this._color);
                const u2 = n.createNS("http://www.w3.org/2000/svg", "path");
                u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h3.appendChild(u2);
                const d2 = n.createNS("http://www.w3.org/2000/svg", "g");
                d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
                const _3 = n.createNS("http://www.w3.org/2000/svg", "path");
                _3.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_3);
                const p2 = n.createNS("http://www.w3.org/2000/svg", "g");
                p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
                const m2 = n.createNS("http://www.w3.org/2000/svg", "g");
                m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f2 = n.createNS("http://www.w3.org/2000/svg", "circle");
                f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
                const g3 = n.createNS("http://www.w3.org/2000/svg", "circle");
                g3.setAttributeNS(null, "fill", "#FFFFFF"), g3.setAttributeNS(null, "cx", "5.5"), g3.setAttributeNS(null, "cy", "5.5"), g3.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g3), s2.appendChild(l2), s2.appendChild(h3), s2.appendChild(d2), s2.appendChild(p2), s2.appendChild(m2), i2.appendChild(s2), i2.setAttributeNS(null, "height", r2 * this._scale + "px"), i2.setAttributeNS(null, "width", o2 * this._scale + "px"), this._element.appendChild(i2), this._offset = t.P.convert(e2 && e2.offset || [0, -14]);
              }
              if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e3) => {
                e3.preventDefault();
              }), this._element.addEventListener("mousedown", (e3) => {
                e3.preventDefault();
              }), Ua2(this._element, this._anchor, "marker"), e2 && e2.className) for (const t2 of e2.className.split(" ")) this._element.classList.add(t2);
              this._popup = null;
            }
            addTo(e2) {
              return this.remove(), this._map = e2, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e2._getUIString("Marker.Title")), e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._update), e2.on("moveend", this._update), e2.on("terrain", this._update), e2.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e2) {
              return this._lngLat = t.Q.convert(e2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(e2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
                if (!("offset" in e2.options)) {
                  const t2 = 38.1, i2 = 13.5, r2 = Math.abs(i2) / Math.SQRT2;
                  e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [r2, -1 * (t2 - i2 + r2)], "bottom-right": [-r2, -1 * (t2 - i2 + r2)], left: [i2, -1 * (t2 - i2)], right: [-13.5, -1 * (t2 - i2)] } : this._offset;
                }
                this._popup = e2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            setSubpixelPositioning(e2) {
              return this._subpixelPositioning = e2, this;
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const e2 = this._popup;
              return this._element.style.opacity === this._opacityWhenCovered ? this : e2 ? (e2.isOpen() ? e2.remove() : (e2.setLngLat(this._lngLat), e2.addTo(this._map)), this) : this;
            }
            _updateOpacity(e2 = false) {
              var i2, r2;
              const o2 = null === (i2 = this._map) || void 0 === i2 ? void 0 : i2.terrain, a2 = this._map.transform.isLocationOccluded(this._lngLat);
              if (!o2 || a2) {
                const e3 = a2 ? this._opacityWhenCovered : this._opacity;
                return void (this._element.style.opacity !== e3 && (this._element.style.opacity = e3));
              }
              if (e2) this._opacityTimeout = null;
              else {
                if (this._opacityTimeout) return;
                this._opacityTimeout = setTimeout(() => {
                  this._opacityTimeout = null;
                }, 100);
              }
              const s2 = this._map, n2 = s2.terrain.depthAtPoint(this._pos), l2 = s2.terrain.getElevationForLngLatZoom(this._lngLat, s2.transform.tileZoom);
              if (s2.transform.lngLatToCameraDepth(this._lngLat, l2) - n2 < 6e-3) return void (this._element.style.opacity = this._opacity);
              const c2 = -this._offset.y / s2.transform.pixelsPerMeter, h3 = Math.sin(s2.getPitch() * Math.PI / 180) * c2, u2 = s2.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), d2 = s2.transform.lngLatToCameraDepth(this._lngLat, l2 + h3) - u2 > 6e-3;
              (null === (r2 = this._popup) || void 0 === r2 ? void 0 : r2.isOpen()) && d2 && this._popup.remove(), this._element.style.opacity = d2 ? this._opacityWhenCovered : this._opacity;
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e2) {
              return this._offset = t.P.convert(e2), this._update(), this;
            }
            addClassName(e2) {
              this._element.classList.add(e2);
            }
            removeClassName(e2) {
              this._element.classList.remove(e2);
            }
            toggleClassName(e2) {
              return this._element.classList.toggle(e2);
            }
            setDraggable(e2) {
              return this._draggable = !!e2, this._map && (e2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(e2) {
              return this._rotation = e2 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(e2) {
              return this._rotationAlignment = e2 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(e2) {
              return this._pitchAlignment = e2 && "auto" !== e2 ? e2 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
            setOpacity(e2, t2) {
              return (void 0 === this._opacity || void 0 === e2 && void 0 === t2) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e2 && (this._opacity = e2), void 0 !== t2 && (this._opacityWhenCovered = t2), this._map && this._updateOpacity(true), this;
            }
          }
          const Va2 = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
          let qa2 = 0, Wa2 = false;
          const Ha2 = { maxWidth: 100, unit: "metric" };
          function $a(e2, t2, i2) {
            const r2 = i2 && i2.maxWidth || 100, o2 = e2._container.clientHeight / 2, a2 = e2._container.clientWidth / 2, s2 = e2.unproject([a2 - r2 / 2, o2]), n2 = e2.unproject([a2 + r2 / 2, o2]), l2 = Math.round(e2.project(n2).x - e2.project(s2).x), c2 = Math.min(r2, l2, e2._container.clientWidth), h3 = s2.distanceTo(n2);
            if (i2 && "imperial" === i2.unit) {
              const i3 = 3.2808 * h3;
              i3 > 5280 ? Xa2(t2, c2, i3 / 5280, e2._getUIString("ScaleControl.Miles")) : Xa2(t2, c2, i3, e2._getUIString("ScaleControl.Feet"));
            } else i2 && "nautical" === i2.unit ? Xa2(t2, c2, h3 / 1852, e2._getUIString("ScaleControl.NauticalMiles")) : h3 >= 1e3 ? Xa2(t2, c2, h3 / 1e3, e2._getUIString("ScaleControl.Kilometers")) : Xa2(t2, c2, h3, e2._getUIString("ScaleControl.Meters"));
          }
          function Xa2(e2, t2, i2, r2) {
            const o2 = function(e3) {
              const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
              let i3 = e3 / t3;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                return Math.round(e4 * t4) / t4;
              }(i3), t3 * i3;
            }(i2);
            e2.style.width = t2 * (o2 / i2) + "px", e2.innerHTML = `${o2}&nbsp;${r2}`;
          }
          const Ka2 = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Qa2 = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function Ya2(e2) {
            if (e2) {
              if ("number" == typeof e2) {
                const i2 = Math.round(Math.abs(e2) / Math.SQRT2);
                return { center: new t.P(0, 0), top: new t.P(0, e2), "top-left": new t.P(i2, i2), "top-right": new t.P(-i2, i2), bottom: new t.P(0, -e2), "bottom-left": new t.P(i2, -i2), "bottom-right": new t.P(-i2, -i2), left: new t.P(e2, 0), right: new t.P(-e2, 0) };
              }
              if (e2 instanceof t.P || Array.isArray(e2)) {
                const i2 = t.P.convert(e2);
                return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
              }
              return { center: t.P.convert(e2.center || [0, 0]), top: t.P.convert(e2.top || [0, 0]), "top-left": t.P.convert(e2["top-left"] || [0, 0]), "top-right": t.P.convert(e2["top-right"] || [0, 0]), bottom: t.P.convert(e2.bottom || [0, 0]), "bottom-left": t.P.convert(e2["bottom-left"] || [0, 0]), "bottom-right": t.P.convert(e2["bottom-right"] || [0, 0]), left: t.P.convert(e2.left || [0, 0]), right: t.P.convert(e2.right || [0, 0]) };
            }
            return Ya2(new t.P(0, 0));
          }
          const Ja = i;
          e.AJAXError = t.cq, e.Event = t.l, e.Evented = t.E, e.LngLat = t.Q, e.MercatorCoordinate = t.$, e.Point = t.P, e.addProtocol = t.cr, e.config = t.a, e.removeProtocol = t.cs, e.AttributionControl = Ca, e.BoxZoomHandler = No2, e.CanvasSource = Y2, e.CooperativeGesturesHandler = va, e.DoubleClickZoomHandler = da, e.DragPanHandler = ma, e.DragRotateHandler = fa, e.EdgeInsets = It2, e.FullscreenControl = class extends t.E {
            constructor(e2 = {}) {
              super(), this._onFullscreenChange = () => {
                var e3;
                let t2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                for (; null === (e3 = null == t2 ? void 0 : t2.shadowRoot) || void 0 === e3 ? void 0 : e3.fullscreenElement; ) t2 = t2.shadowRoot.fullscreenElement;
                t2 === this._container !== this._fullscreen && this._handleFullscreenChange();
              }, this._onClickFullscreen = () => {
                this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
              }, this._fullscreen = false, e2 && e2.container && (e2.container instanceof HTMLElement ? this._container = e2.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
            }
            onAdd(e2) {
              return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
            }
            onRemove() {
              n.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _setupUI() {
              const e2 = this._fullscreenButton = n.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
              n.create("span", "maplibregl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _updateTitle() {
              const e2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.title = e2;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _handleFullscreenChange() {
              this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
            }
            _exitFullscreen() {
              window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
            }
            _requestFullscreen() {
              this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
            }
            _togglePseudoFullScreen() {
              this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
            }
          }, e.GeoJSONSource = X2, e.GeolocateControl = class extends t.E {
            constructor(e2) {
              super(), this._onSuccess = (e3) => {
                if (this._map) {
                  if (this._isOutOfMapMaxBounds(e3)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
                  if (this.options.trackUserLocation) switch (this._lastKnownPosition = e3, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error(`Unexpected watchState ${this._watchState}`);
                  }
                  this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e3)), this._finish();
                }
              }, this._updateCamera = (e3) => {
                const i2 = new t.Q(e3.coords.longitude, e3.coords.latitude), r2 = e3.coords.accuracy, o2 = this._map.getBearing(), a2 = t.e({ bearing: o2 }, this.options.fitBoundsOptions), s2 = V2.fromLngLat(i2, r2);
                this._map.fitBounds(s2, a2, { geolocateSource: true });
              }, this._updateMarker = (e3) => {
                if (e3) {
                  const i2 = new t.Q(e3.coords.longitude, e3.coords.latitude);
                  this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
              }, this._onZoom = () => {
                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              }, this._onError = (e3) => {
                if (this._map) {
                  if (1 === e3.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === e3.code && Wa2) return;
                    this.options.trackUserLocation && this._setErrorState();
                  }
                  "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e3)), this._finish();
                }
              }, this._finish = () => {
                this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
              }, this._setupUI = () => {
                this._map && (this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this._geolocateButton = n.create("button", "maplibregl-ctrl-geolocate", this._container), n.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
              }, this._finishSetupUI = (e3) => {
                if (this._map) {
                  if (false === e3) {
                    t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                    const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
                  } else {
                    const e4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                    this._geolocateButton.disabled = false, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
                  }
                  this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ga2({ element: this._dotElement }), this._circleElement = n.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ga2({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
                    e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
                  });
                }
              }, this.options = t.e({}, Va2, e2);
            }
            onAdd(e2) {
              return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
                return t._(this, arguments, void 0, function* (e3 = false) {
                  if (void 0 !== ja && !e3) return ja;
                  if (void 0 === window.navigator.permissions) return ja = !!window.navigator.geolocation, ja;
                  try {
                    const e4 = yield window.navigator.permissions.query({ name: "geolocation" });
                    ja = "denied" !== e4.state;
                  } catch (e4) {
                    ja = !!window.navigator.geolocation;
                  }
                  return ja;
                });
              }().then((e3) => this._finishSetupUI(e3)), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, qa2 = 0, Wa2 = false;
            }
            _isOutOfMapMaxBounds(e2) {
              const t2 = this._map.getMaxBounds(), i2 = e2.coords;
              return t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "ACTIVE_ERROR":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _updateCircleRadius() {
              const e2 = this._map.getBounds(), t2 = e2.getSouthEast(), i2 = e2.getNorthEast(), r2 = t2.distanceTo(i2), o2 = Math.ceil(this._accuracy / (r2 / this._map._container.clientHeight) * 2);
              this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
            }
            trigger() {
              if (!this._setup) return t.w("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    qa2--, Wa2 = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "OFF":
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let e2;
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), qa2++, qa2 > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, Wa2 = true) : (e2 = this.options.positionOptions, Wa2 = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e2);
                }
              } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, e.GlobeControl = class {
            constructor() {
              this._toggleProjection = () => {
                var e2;
                const t2 = null === (e2 = this._map.getProjection()) || void 0 === e2 ? void 0 : e2.type;
                this._map.setProjection("mercator" !== t2 && t2 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
              }, this._updateGlobeIcon = () => {
                var e2;
                this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e2 = this._map.getProjection()) || void 0 === e2 ? void 0 : e2.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
              };
            }
            onAdd(e2) {
              return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n.create("button", "maplibregl-ctrl-globe", this._container), n.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
            }
            onRemove() {
              n.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
            }
          }, e.Hash = Co2, e.ImageSource = K2, e.KeyboardHandler = la2, e.LngLatBounds = V2, e.LogoControl = Ma, e.Map = class extends Ta {
            constructor(e2) {
              var i2, r2;
              t.cn.mark(t.co.create);
              const o2 = Object.assign(Object.assign(Object.assign({}, Fa), e2), { canvasContextAttributes: Object.assign(Object.assign({}, Fa.canvasContextAttributes), e2.canvasContextAttributes) });
              if (null != o2.minZoom && null != o2.maxZoom && o2.minZoom > o2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != o2.minPitch && null != o2.maxPitch && o2.minPitch > o2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != o2.minPitch && o2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
              if (null != o2.maxPitch && o2.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
              const a2 = new Lt2(), s2 = new Ot2();
              if (void 0 !== o2.minZoom && a2.setMinZoom(o2.minZoom), void 0 !== o2.maxZoom && a2.setMaxZoom(o2.maxZoom), void 0 !== o2.minPitch && a2.setMinPitch(o2.minPitch), void 0 !== o2.maxPitch && a2.setMaxPitch(o2.maxPitch), void 0 !== o2.renderWorldCopies && a2.setRenderWorldCopies(o2.renderWorldCopies), super(a2, s2, { bearingSnap: o2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Ia(), this._controls = [], this._mapId = t.a4(), this._contextLost = (e3) => {
                e3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t.l("webglcontextlost", { originalEvent: e3 }));
              }, this._contextRestored = (e3) => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e3 }));
              }, this._onMapScroll = (e3) => {
                if (e3.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
              }, this._onWindowOnline = () => {
                this._update();
              }, this._interactive = o2.interactive, this._maxTileCacheSize = o2.maxTileCacheSize, this._maxTileCacheZoomLevels = o2.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o2.canvasContextAttributes), this._trackResize = true === o2.trackResize, this._bearingSnap = o2.bearingSnap, this._centerClampedToGround = o2.centerClampedToGround, this._refreshExpiredTiles = true === o2.refreshExpiredTiles, this._fadeDuration = o2.fadeDuration, this._crossSourceCollisions = true === o2.crossSourceCollisions, this._collectResourceTiming = true === o2.collectResourceTiming, this._locale = Object.assign(Object.assign({}, La), o2.locale), this._clickTolerance = o2.clickTolerance, this._overridePixelRatio = o2.pixelRatio, this._maxCanvasSize = o2.maxCanvasSize, this.transformCameraUpdate = o2.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = true === o2.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = p.addThrottleControl(() => this.isMoving()), this._requestManager = new m(o2.transformRequest), "string" == typeof o2.container) {
                if (this._container = document.getElementById(o2.container), !this._container) throw new Error(`Container '${o2.container}' not found.`);
              } else {
                if (!(o2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = o2.container;
              }
              if (o2.maxBounds && this.setMaxBounds(o2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
                this.painter.terrainFacilitator.dirty = true, this._update(true);
              }), this.once("idle", () => {
                this._idleTriggered = true;
              }), "undefined" != typeof window) {
                addEventListener("online", this._onWindowOnline, false);
                let e3 = false;
                const t2 = Po2((e4) => {
                  this._trackResize && !this._removed && (this.resize(e4), this.redraw());
                }, 50);
                this._resizeObserver = new ResizeObserver((i3) => {
                  e3 ? t2(i3) : e3 = true;
                }), this._resizeObserver.observe(this._container);
              }
              this.handlers = new wa(this, o2), this._hash = o2.hash && new Co2("string" == typeof o2.hash && o2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o2.center, elevation: o2.elevation, zoom: o2.zoom, bearing: o2.bearing, pitch: o2.pitch, roll: o2.roll }), o2.bounds && (this.resize(), this.fitBounds(o2.bounds, t.e({}, o2.fitBoundsOptions, { duration: 0 }))));
              const n2 = "string" == typeof o2.style || !("globe" === (null === (r2 = null === (i2 = o2.style) || void 0 === i2 ? void 0 : i2.projection) || void 0 === r2 ? void 0 : r2.type));
              this.resize(null, n2), this._localIdeographFontFamily = o2.localIdeographFontFamily, this._validateStyle = o2.validateStyle, o2.style && this.setStyle(o2.style, { localIdeographFontFamily: o2.localIdeographFontFamily }), o2.attributionControl && this.addControl(new Ca("boolean" == typeof o2.attributionControl ? void 0 : o2.attributionControl)), o2.maplibreLogo && this.addControl(new Ma(), o2.logoPosition), this.on("style.load", () => {
                if (n2 || this._resizeTransform(), this.transform.unmodified) {
                  const e3 = t.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                  this.jumpTo(e3);
                }
              }), this.on("data", (e3) => {
                this._update("style" === e3.dataType), this.fire(new t.l(`${e3.dataType}data`, e3));
              }), this.on("dataloading", (e3) => {
                this.fire(new t.l(`${e3.dataType}dataloading`, e3));
              }), this.on("dataabort", (e3) => {
                this.fire(new t.l("sourcedataabort", e3));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e2, i2) {
              if (void 0 === i2 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd) return this.fire(new t.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const r2 = e2.onAdd(this);
              this._controls.push(e2);
              const o2 = this._controlPositions[i2];
              return -1 !== i2.indexOf("bottom") ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), this;
            }
            removeControl(e2) {
              if (!e2 || !e2.onRemove) return this.fire(new t.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(e2);
              return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
            }
            hasControl(e2) {
              return this._controls.indexOf(e2) > -1;
            }
            calculateCameraOptionsFromTo(e2, t2, i2, r2) {
              return null == r2 && this.terrain && (r2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e2, t2, i2, r2);
            }
            resize(e2, i2 = true) {
              const [r2, o2] = this._containerDimensions(), a2 = this._getClampedPixelRatio(r2, o2);
              if (this._resizeCanvas(r2, o2, a2), this.painter.resize(r2, o2, a2), this.painter.overLimit()) {
                const e3 = this.painter.context.gl;
                this._maxCanvasSize = [e3.drawingBufferWidth, e3.drawingBufferHeight];
                const t2 = this._getClampedPixelRatio(r2, o2);
                this._resizeCanvas(r2, o2, t2), this.painter.resize(r2, o2, t2);
              }
              this._resizeTransform(i2);
              const s2 = !this._moving;
              return s2 && (this.stop(), this.fire(new t.l("movestart", e2)).fire(new t.l("move", e2))), this.fire(new t.l("resize", e2)), s2 && this.fire(new t.l("moveend", e2)), this;
            }
            _resizeTransform(e2 = true) {
              var t2;
              const [i2, r2] = this._containerDimensions();
              this.transform.resize(i2, r2, e2), null === (t2 = this._requestedCameraState) || void 0 === t2 || t2.resize(i2, r2, e2);
            }
            _getClampedPixelRatio(e2, t2) {
              const { 0: i2, 1: r2 } = this._maxCanvasSize, o2 = this.getPixelRatio(), a2 = e2 * o2, s2 = t2 * o2;
              return Math.min(a2 > i2 ? i2 / a2 : 1, s2 > r2 ? r2 / s2 : 1) * o2;
            }
            getPixelRatio() {
              var e2;
              return null !== (e2 = this._overridePixelRatio) && void 0 !== e2 ? e2 : devicePixelRatio;
            }
            setPixelRatio(e2) {
              this._overridePixelRatio = e2, this.resize();
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(e2) {
              return this.transform.setMaxBounds(V2.convert(e2)), this._update();
            }
            setMinZoom(e2) {
              if ((e2 = null == e2 ? -2 : e2) >= -2 && e2 <= this.transform.maxZoom) return this.transform.setMinZoom(e2), this._update(), this.getZoom() < e2 && this.setZoom(e2), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(e2) {
              if ((e2 = null == e2 ? 22 : e2) >= this.transform.minZoom) return this.transform.setMaxZoom(e2), this._update(), this.getZoom() > e2 && this.setZoom(e2), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(e2) {
              if ((e2 = null == e2 ? 0 : e2) < 0) throw new Error("minPitch must be greater than or equal to 0");
              if (e2 >= 0 && e2 <= this.transform.maxPitch) return this.transform.setMinPitch(e2), this._update(), this.getPitch() < e2 && this.setPitch(e2), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(e2) {
              if ((e2 = null == e2 ? 60 : e2) > 180) throw new Error("maxPitch must be less than or equal to 180");
              if (e2 >= this.transform.minPitch) return this.transform.setMaxPitch(e2), this._update(), this.getPitch() > e2 && this.setPitch(e2), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(e2) {
              return this.transform.setRenderWorldCopies(e2), this._update();
            }
            project(e2) {
              return this.transform.locationToScreenPoint(t.Q.convert(e2), this.style && this.terrain);
            }
            unproject(e2) {
              return this.transform.screenPointToLocation(t.P.convert(e2), this.terrain);
            }
            isMoving() {
              var e2;
              return this._moving || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isMoving());
            }
            isZooming() {
              var e2;
              return this._zooming || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isZooming());
            }
            isRotating() {
              var e2;
              return this._rotating || (null === (e2 = this.handlers) || void 0 === e2 ? void 0 : e2.isRotating());
            }
            _createDelegatedListener(e2, t2, i2) {
              if ("mouseenter" === e2 || "mouseover" === e2) {
                let r2 = false;
                const o2 = (o3) => {
                  const a2 = t2.filter((e3) => this.getLayer(e3)), s2 = 0 !== a2.length ? this.queryRenderedFeatures(o3.point, { layers: a2 }) : [];
                  s2.length ? r2 || (r2 = true, i2.call(this, new ko2(e2, this, o3.originalEvent, { features: s2 }))) : r2 = false;
                };
                return { layers: t2, listener: i2, delegates: { mousemove: o2, mouseout: () => {
                  r2 = false;
                } } };
              }
              if ("mouseleave" === e2 || "mouseout" === e2) {
                let r2 = false;
                const o2 = (o3) => {
                  const a3 = t2.filter((e3) => this.getLayer(e3));
                  (0 !== a3.length ? this.queryRenderedFeatures(o3.point, { layers: a3 }) : []).length ? r2 = true : r2 && (r2 = false, i2.call(this, new ko2(e2, this, o3.originalEvent)));
                }, a2 = (t3) => {
                  r2 && (r2 = false, i2.call(this, new ko2(e2, this, t3.originalEvent)));
                };
                return { layers: t2, listener: i2, delegates: { mousemove: o2, mouseout: a2 } };
              }
              {
                const r2 = (e3) => {
                  const r3 = t2.filter((e4) => this.getLayer(e4)), o2 = 0 !== r3.length ? this.queryRenderedFeatures(e3.point, { layers: r3 }) : [];
                  o2.length && (e3.features = o2, i2.call(this, e3), delete e3.features);
                };
                return { layers: t2, listener: i2, delegates: { [e2]: r2 } };
              }
            }
            _saveDelegatedListener(e2, t2) {
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(t2);
            }
            _removeDelegatedListener(e2, t2, i2) {
              if (!this._delegatedListeners || !this._delegatedListeners[e2]) return;
              const r2 = this._delegatedListeners[e2];
              for (let e3 = 0; e3 < r2.length; e3++) {
                const o2 = r2[e3];
                if (o2.listener === i2 && o2.layers.length === t2.length && o2.layers.every((e4) => t2.includes(e4))) {
                  for (const e4 in o2.delegates) this.off(e4, o2.delegates[e4]);
                  return void r2.splice(e3, 1);
                }
              }
            }
            on(e2, t2, i2) {
              if (void 0 === i2) return super.on(e2, t2);
              const r2 = "string" == typeof t2 ? [t2] : t2, o2 = this._createDelegatedListener(e2, r2, i2);
              this._saveDelegatedListener(e2, o2);
              for (const e3 in o2.delegates) this.on(e3, o2.delegates[e3]);
              return { unsubscribe: () => {
                this._removeDelegatedListener(e2, r2, i2);
              } };
            }
            once(e2, t2, i2) {
              if (void 0 === i2) return super.once(e2, t2);
              const r2 = "string" == typeof t2 ? [t2] : t2, o2 = this._createDelegatedListener(e2, r2, i2);
              for (const t3 in o2.delegates) {
                const a2 = o2.delegates[t3];
                o2.delegates[t3] = (...t4) => {
                  this._removeDelegatedListener(e2, r2, i2), a2(...t4);
                };
              }
              this._saveDelegatedListener(e2, o2);
              for (const e3 in o2.delegates) this.once(e3, o2.delegates[e3]);
              return this;
            }
            off(e2, t2, i2) {
              return void 0 === i2 ? super.off(e2, t2) : (this._removeDelegatedListener(e2, "string" == typeof t2 ? [t2] : t2, i2), this);
            }
            queryRenderedFeatures(e2, i2) {
              if (!this.style) return [];
              let r2;
              const o2 = e2 instanceof t.P || Array.isArray(e2), a2 = o2 ? e2 : [[0, 0], [this.transform.width, this.transform.height]];
              if (i2 = i2 || (o2 ? {} : e2) || {}, a2 instanceof t.P || "number" == typeof a2[0]) r2 = [t.P.convert(a2)];
              else {
                const e3 = t.P.convert(a2[0]), i3 = t.P.convert(a2[1]);
                r2 = [e3, new t.P(i3.x, e3.y), i3, new t.P(e3.x, i3.y), e3];
              }
              return this.style.queryRenderedFeatures(r2, i2, this.transform);
            }
            querySourceFeatures(e2, t2) {
              return this.style.querySourceFeatures(e2, t2);
            }
            setStyle(e2, i2) {
              return false !== (i2 = t.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
            }
            setTransformRequest(e2) {
              return this._requestManager.setTransformRequest(e2), this;
            }
            _getUIString(e2) {
              const t2 = this._locale[e2];
              if (null == t2) throw new Error(`Missing UI string '${e2}'`);
              return t2;
            }
            _updateStyle(e2, t2) {
              var i2, r2;
              if (t2.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(e2, t2));
              const o2 = this.style && t2.transformStyle ? this.style.serialize() : void 0;
              return this.style && (this.style.setEventedParent(null), this.style._remove(!e2)), e2 ? (this.style = new bi2(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2, t2, o2) : this.style.loadJSON(e2, t2, o2), this) : (null === (r2 = null === (i2 = this.style) || void 0 === i2 ? void 0 : i2.projection) || void 0 === r2 || r2.destroy(), delete this.style, this);
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new bi2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e2, i2) {
              if ("string" == typeof e2) {
                const r2 = this._requestManager.transformRequest(e2, "Style");
                t.j(r2, new AbortController()).then((e3) => {
                  this._updateDiff(e3.data, i2);
                }).catch((e3) => {
                  e3 && this.fire(new t.k(e3));
                });
              } else "object" == typeof e2 && this._updateDiff(e2, i2);
            }
            _updateDiff(e2, i2) {
              try {
                this.style.setState(e2, i2) && this._update(true);
              } catch (r2) {
                t.w(`Unable to perform style diff: ${r2.message || r2.error || r2}.  Rebuilding the style from scratch.`), this._updateStyle(e2, i2);
              }
            }
            getStyle() {
              if (this.style) return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
            }
            addSource(e2, t2) {
              return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
            }
            isSourceLoaded(e2) {
              const i2 = this.style && this.style.sourceCaches[e2];
              if (void 0 !== i2) return i2.loaded();
              this.fire(new t.k(new Error(`There is no source with ID '${e2}'`)));
            }
            setTerrain(e2) {
              if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e2) {
                const i2 = this.style.sourceCaches[e2.source];
                if (!i2) throw new Error(`cannot load terrain, because there exists no source with ID: ${e2.source}`);
                null === this.terrain && i2.reload();
                for (const i3 in this.style._layers) {
                  const r2 = this.style._layers[i3];
                  "hillshade" === r2.type && r2.source === e2.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
                }
                this.terrain = new Ra(this.painter, i2, e2), this.painter.renderToTexture = new Aa(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t2) => {
                  var i3;
                  "style" === t2.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t2.dataType && t2.tile && (t2.sourceId !== e2.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i3 = t2.source) || void 0 === i3 ? void 0 : i3.type) ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t2.tile.tileID));
                }, this.style.on("data", this._terrainDataCallback);
              } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
              return this.fire(new t.l("terrain", { terrain: e2 })), this;
            }
            getTerrain() {
              var e2, t2;
              return null !== (t2 = null === (e2 = this.terrain) || void 0 === e2 ? void 0 : e2.options) && void 0 !== t2 ? t2 : null;
            }
            areTilesLoaded() {
              const e2 = this.style && this.style.sourceCaches;
              for (const t2 in e2) {
                const i2 = e2[t2]._tiles;
                for (const e3 in i2) {
                  const t3 = i2[e3];
                  if ("loaded" !== t3.state && "errored" !== t3.state) return false;
                }
              }
              return true;
            }
            removeSource(e2) {
              return this.style.removeSource(e2), this._update(true);
            }
            getSource(e2) {
              return this.style.getSource(e2);
            }
            setSourceTileLodParams(e2, t2, i2) {
              if (i2) {
                const r2 = this.getSource(i2);
                if (!r2) throw new Error(`There is no source with ID "${i2}", cannot set LOD parameters`);
                r2.calculateTileZoom = fe2(Math.max(1, e2), Math.max(1, t2));
              } else for (const i3 in this.style.sourceCaches) this.style.sourceCaches[i3].getSource().calculateTileZoom = fe2(Math.max(1, e2), Math.max(1, t2));
              return this._update(true), this;
            }
            refreshTiles(e2, i2) {
              const r2 = this.style.sourceCaches[e2];
              if (!r2) throw new Error(`There is no source cache with ID "${e2}", cannot refresh tile`);
              void 0 === i2 ? r2.reload() : r2.refreshTiles(i2.map((e3) => new t.a1(e3.z, e3.x, e3.y)));
            }
            addImage(e2, i2, r2 = {}) {
              const { pixelRatio: o2 = 1, sdf: a2 = false, stretchX: n2, stretchY: l2, content: c2, textFitWidth: h3, textFitHeight: u2 } = r2;
              if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || t.b(i2))) {
                if (void 0 === i2.width || void 0 === i2.height) return this.fire(new t.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: r3, height: s2, data: d2 } = i2, _3 = i2;
                  return this.style.addImage(e2, { data: new t.R({ width: r3, height: s2 }, new Uint8Array(d2)), pixelRatio: o2, stretchX: n2, stretchY: l2, content: c2, textFitWidth: h3, textFitHeight: u2, sdf: a2, version: 0, userImage: _3 }), _3.onAdd && _3.onAdd(this, e2), this;
                }
              }
              {
                const { width: r3, height: d2, data: _3 } = s.getImageData(i2);
                this.style.addImage(e2, { data: new t.R({ width: r3, height: d2 }, _3), pixelRatio: o2, stretchX: n2, stretchY: l2, content: c2, textFitWidth: h3, textFitHeight: u2, sdf: a2, version: 0 });
              }
            }
            updateImage(e2, i2) {
              const r2 = this.style.getImage(e2);
              if (!r2) return this.fire(new t.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const o2 = i2 instanceof HTMLImageElement || t.b(i2) ? s.getImageData(i2) : i2, { width: a2, height: n2, data: l2 } = o2;
              if (void 0 === a2 || void 0 === n2) return this.fire(new t.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (a2 !== r2.data.width || n2 !== r2.data.height) return this.fire(new t.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
              const c2 = !(i2 instanceof HTMLImageElement || t.b(i2));
              return r2.data.replace(l2, c2), this.style.updateImage(e2, r2), this;
            }
            getImage(e2) {
              return this.style.getImage(e2);
            }
            hasImage(e2) {
              return e2 ? !!this.style.getImage(e2) : (this.fire(new t.k(new Error("Missing required image id"))), false);
            }
            removeImage(e2) {
              this.style.removeImage(e2);
            }
            loadImage(e2) {
              return p.getImage(this._requestManager.transformRequest(e2, "Image"), new AbortController());
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(e2, t2) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
            }
            moveLayer(e2, t2) {
              return this.style.moveLayer(e2, t2), this._update(true);
            }
            removeLayer(e2) {
              return this.style.removeLayer(e2), this._update(true);
            }
            getLayer(e2) {
              return this.style.getLayer(e2);
            }
            getLayersOrder() {
              return this.style.getLayersOrder();
            }
            setLayerZoomRange(e2, t2, i2) {
              return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
            }
            setFilter(e2, t2, i2 = {}) {
              return this.style.setFilter(e2, t2, i2), this._update(true);
            }
            getFilter(e2) {
              return this.style.getFilter(e2);
            }
            setPaintProperty(e2, t2, i2, r2 = {}) {
              return this.style.setPaintProperty(e2, t2, i2, r2), this._update(true);
            }
            getPaintProperty(e2, t2) {
              return this.style.getPaintProperty(e2, t2);
            }
            setLayoutProperty(e2, t2, i2, r2 = {}) {
              return this.style.setLayoutProperty(e2, t2, i2, r2), this._update(true);
            }
            getLayoutProperty(e2, t2) {
              return this.style.getLayoutProperty(e2, t2);
            }
            setGlyphs(e2, t2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setGlyphs(e2, t2), this._update(true);
            }
            getGlyphs() {
              return this.style.getGlyphsUrl();
            }
            addSprite(e2, t2, i2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.addSprite(e2, t2, i2, (e3) => {
                e3 || this._update(true);
              }), this;
            }
            removeSprite(e2) {
              return this._lazyInitEmptyStyle(), this.style.removeSprite(e2), this._update(true);
            }
            getSprite() {
              return this.style.getSprite();
            }
            setSprite(e2, t2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setSprite(e2, t2, (e3) => {
                e3 || this._update(true);
              }), this;
            }
            setLight(e2, t2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setSky(e2, t2 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setSky(e2, t2), this._update(true);
            }
            getSky() {
              return this.style.getSky();
            }
            setFeatureState(e2, t2) {
              return this.style.setFeatureState(e2, t2), this._update();
            }
            removeFeatureState(e2, t2) {
              return this.style.removeFeatureState(e2, t2), this._update();
            }
            getFeatureState(e2) {
              return this.style.getFeatureState(e2);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let e2 = 0, t2 = 0;
              return this._container && (e2 = this._container.clientWidth || 400, t2 = this._container.clientHeight || 300), [e2, t2];
            }
            _setupContainer() {
              const e2 = this._container;
              e2.classList.add("maplibregl-map");
              const t2 = this._canvasContainer = n.create("div", "maplibregl-canvas-container", e2);
              this._interactive && t2.classList.add("maplibregl-interactive"), this._canvas = n.create("canvas", "maplibregl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
              const i2 = this._containerDimensions(), r2 = this._getClampedPixelRatio(i2[0], i2[1]);
              this._resizeCanvas(i2[0], i2[1], r2);
              const o2 = this._controlContainer = n.create("div", "maplibregl-control-container", e2), a2 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
                a2[e3] = n.create("div", `maplibregl-ctrl-${e3} `, o2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(e2, t2, i2) {
              this._canvas.width = Math.floor(i2 * e2), this._canvas.height = Math.floor(i2 * t2), this._canvas.style.width = `${e2}px`, this._canvas.style.height = `${t2}px`;
            }
            _setupPainter() {
              const e2 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
              let t2 = null;
              this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
                t2 = { requestedAttributes: e2 }, i3 && (t2.statusMessage = i3.statusMessage, t2.type = i3.type);
              }, { once: true });
              let i2 = null;
              if (i2 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e2) : this._canvas.getContext("webgl2", e2) || this._canvas.getContext("webgl", e2), !i2) {
                const e3 = "Failed to initialize WebGL";
                throw t2 ? (t2.message = e3, new Error(JSON.stringify(t2))) : new Error(e3);
              }
              this.painter = new To2(i2, this.transform), l.testSupport(i2);
            }
            migrateProjection(e2, i2) {
              super.migrateProjection(e2, i2), this.painter.transform = e2, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(e2) {
              return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(e2) {
              return this._update(), this._renderTaskQueue.add(e2);
            }
            _cancelRenderFrame(e2) {
              this._renderTaskQueue.remove(e2);
            }
            _render(e2) {
              var i2, r2, o2, a2, n2;
              const l2 = this._idleTriggered ? this._fadeDuration : 0, c2 = (null === (i2 = this.style.projection) || void 0 === i2 ? void 0 : i2.transitionState) > 0;
              if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), this._removed) return;
              let h3 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e3 = this.transform.zoom, i3 = s.now();
                this.style.zoomHistory.update(e3, i3);
                const r3 = new t.C(e3, { now: i3, fadeDuration: l2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), o3 = r3.crossFadingFactor();
                1 === o3 && o3 === this._crossFadingFactor || (h3 = true, this._crossFadingFactor = o3), this.style.update(r3);
              }
              const u2 = (null === (r2 = this.style.projection) || void 0 === r2 ? void 0 : r2.transitionState) > 0 !== c2;
              null === (o2 = this.style.projection) || void 0 === o2 || o2.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (a2 = this.style.projection) || void 0 === a2 ? void 0 : a2.transitionState, null === (n2 = this.style.projection) || void 0 === n2 ? void 0 : n2.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u2) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l2, this._crossSourceCollisions, u2), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l2, showPadding: this.showPadding }), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = true, t.cn.mark(t.co.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || h3) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
              const d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true, t.cn.mark(t.co.fullLoad)), this;
            }
            redraw() {
              return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
            }
            remove() {
              var e2;
              this._hash && this._hash.remove();
              for (const e3 of this._controls) e3.onRemove(this);
              this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), p.removeThrottleControl(this._imageQueueHandle), null === (e2 = this._resizeObserver) || void 0 === e2 || e2.disconnect();
              const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              (null == i2 ? void 0 : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), n.remove(this._canvasContainer), n.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), t.cn.clearMetrics(), this._removed = true, this.fire(new t.l("remove"));
            }
            triggerRepaint() {
              this.style && !this._frameRequest && (this._frameRequest = new AbortController(), s.frame(this._frameRequest, (e2) => {
                t.cn.frame(e2), this._frameRequest = null;
                try {
                  this._render(e2);
                } catch (e3) {
                  if (!t.cp(e3) && !function(e4) {
                    return e4.message === Ur2;
                  }(e3)) throw e3;
                }
              }, () => {
              }));
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(e2) {
              this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(e2) {
              this._showPadding !== e2 && (this._showPadding = e2, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(e2) {
              this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(e2) {
              this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(e2) {
              this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(e2) {
              this._vertices = e2, this._update();
            }
            get version() {
              return ka;
            }
            getCameraTargetElevation() {
              return this.transform.elevation;
            }
            getProjection() {
              return this.style.getProjection();
            }
            setProjection(e2) {
              return this._lazyInitEmptyStyle(), this.style.setProjection(e2), this._update(true);
            }
          }, e.MapMouseEvent = ko2, e.MapTouchEvent = Fo2, e.MapWheelEvent = Bo2, e.Marker = Ga2, e.NavigationControl = class {
            constructor(e2) {
              this._updateZoomButtons = () => {
                const e3 = this._map.getZoom(), t2 = e3 === this._map.getMaxZoom(), i2 = e3 === this._map.getMinZoom();
                this._zoomInButton.disabled = t2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", t2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
              }, this._rotateCompassArrow = () => {
                this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
              }, this._setButtonTitle = (e3, t2) => {
                const i2 = this._map._getUIString(`NavigationControl.${t2}`);
                e3.title = i2, e3.setAttribute("aria-label", i2);
              }, this.options = t.e({}, Ba2, e2), this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e3) => e3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e3) => this._map.zoomIn({}, { originalEvent: e3 })), n.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e3) => this._map.zoomOut({}, { originalEvent: e3 })), n.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e3) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e3 }) : this._map.resetNorth({}, { originalEvent: e3 });
              }), this._compassIcon = n.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            onAdd(e2) {
              return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Oa2(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(e2, t2) {
              const i2 = n.create("button", e2, this._container);
              return i2.type = "button", i2.addEventListener("click", t2), i2;
            }
          }, e.Popup = class extends t.E {
            constructor(e2) {
              super(), this._updateOpacity = () => {
                void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0);
              }, this.remove = () => (this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e3) => {
                this._update(e3.point);
              }, this._onMouseMove = (e3) => {
                this._update(e3.point);
              }, this._onDrag = (e3) => {
                this._update(e3.point);
              }, this._update = (e3) => {
                if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
                if (!this._container) {
                  if (this._container = n.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e4 of this.options.className.split(" ")) this._container.classList.add(e4);
                  this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
                }
                if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = Za2(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e3) return;
                const t2 = this._flatPos = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat);
                this._map.terrain && (this._flatPos = this._trackPointer && e3 ? e3 : this._map.transform.locationToScreenPoint(this._lngLat));
                let i2 = this.options.anchor;
                const r2 = Ya2(this.options.offset);
                if (!i2) {
                  const e4 = this._container.offsetWidth, o3 = this._container.offsetHeight;
                  let a2;
                  a2 = t2.y + r2.bottom.y < o3 ? ["top"] : t2.y > this._map.transform.height - o3 ? ["bottom"] : [], t2.x < e4 / 2 ? a2.push("left") : t2.x > this._map.transform.width - e4 / 2 && a2.push("right"), i2 = 0 === a2.length ? "bottom" : a2.join("-");
                }
                let o2 = t2.add(r2[i2]);
                this.options.subpixelPositioning || (o2 = o2.round()), n.setTransform(this._container, `${Na[i2]} translate(${o2.x}px,${o2.y}px)`), Ua2(this._container, i2, "popup"), this._updateOpacity();
              }, this._onClose = () => {
                this.remove();
              }, this.options = t.e(Object.create(Ka2), e2);
            }
            addTo(e2) {
              return this._map && this.remove(), this._map = e2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e2) {
              return this._lngLat = t.Q.convert(e2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(e2) {
              return this.setDOMContent(document.createTextNode(e2));
            }
            setHTML(e2) {
              const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
              let r2;
              for (i2.innerHTML = e2; r2 = i2.firstChild, r2; ) t2.appendChild(r2);
              return this.setDOMContent(t2);
            }
            getMaxWidth() {
              var e2;
              return null === (e2 = this._container) || void 0 === e2 ? void 0 : e2.style.maxWidth;
            }
            setMaxWidth(e2) {
              return this.options.maxWidth = e2, this._update(), this;
            }
            setDOMContent(e2) {
              if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else this._content = n.create("div", "maplibregl-popup-content", this._container);
              return this._content.appendChild(e2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(e2) {
              return this._container && this._container.classList.add(e2), this;
            }
            removeClassName(e2) {
              return this._container && this._container.classList.remove(e2), this;
            }
            setOffset(e2) {
              return this.options.offset = e2, this._update(), this;
            }
            toggleClassName(e2) {
              if (this._container) return this._container.classList.toggle(e2);
            }
            setSubpixelPositioning(e2) {
              this.options.subpixelPositioning = e2;
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = n.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container) return;
              const e2 = this._container.querySelector(Qa2);
              e2 && e2.focus();
            }
          }, e.RasterDEMTileSource = $2, e.RasterTileSource = H2, e.ScaleControl = class {
            constructor(e2) {
              this._onMove = () => {
                $a(this._map, this._container, this.options);
              }, this.setUnit = (e3) => {
                this.options.unit = e3, $a(this._map, this._container, this.options);
              }, this.options = Object.assign(Object.assign({}, Ha2), e2);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(e2) {
              return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              n.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
          }, e.ScrollZoomHandler = ua, e.Style = bi2, e.TerrainControl = class {
            constructor(e2) {
              this._toggleTerrain = () => {
                this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
              }, this._updateTerrainIcon = () => {
                this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
              }, this.options = e2;
            }
            onAdd(e2) {
              return this._map = e2, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n.create("button", "maplibregl-ctrl-terrain", this._container), n.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
            }
            onRemove() {
              n.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
            }
          }, e.TwoFingersTouchPitchHandler = sa2, e.TwoFingersTouchRotateHandler = oa2, e.TwoFingersTouchZoomHandler = ia2, e.TwoFingersTouchZoomRotateHandler = ga, e.VectorTileSource = W2, e.VideoSource = Q2, e.addSourceType = (e2, i2) => t._(void 0, void 0, void 0, function* () {
            if (ee2(e2)) throw new Error(`A source type called "${e2}" already exists.`);
            ((e3, t2) => {
              J2[e3] = t2;
            })(e2, i2);
          }), e.clearPrewarmedResources = function() {
            const e2 = L2;
            e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(z), L2 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, e.createTileMesh = Xt2, e.getMaxParallelImageRequests = function() {
            return t.a.MAX_PARALLEL_IMAGE_REQUESTS;
          }, e.getRTLTextPluginStatus = function() {
            return oe2().getRTLTextPluginStatus();
          }, e.getVersion = function() {
            return Ja;
          }, e.getWorkerCount = function() {
            return D2.workerCount;
          }, e.getWorkerUrl = function() {
            return t.a.WORKER_URL;
          }, e.importScriptInWorkers = function(e2) {
            return O2().broadcast("IS", e2);
          }, e.prewarm = function() {
            F2().acquire(z);
          }, e.setMaxParallelImageRequests = function(e2) {
            t.a.MAX_PARALLEL_IMAGE_REQUESTS = e2;
          }, e.setRTLTextPlugin = function(e2, t2) {
            return oe2().setRTLTextPlugin(e2, t2);
          }, e.setWorkerCount = function(e2) {
            D2.workerCount = e2;
          }, e.setWorkerUrl = function(e2) {
            t.a.WORKER_URL = e2;
          };
        });
        var maplibregl$1 = maplibregl;
        return maplibregl$1;
      });
    }
  });

  // node_modules/@maptiler/client/dist/maptiler-client.mjs
  function tryGettingFetch() {
    if (typeof self !== "undefined") {
      return fetch.bind(self);
    }
    if (typeof global !== "undefined" && global.fetch) {
      return global.fetch;
    }
    return null;
  }
  function getLanguageInfoFromKey(languageKey, languageDictionary = Language) {
    if (languageKey in languageDictionary) {
      return languageKey[languageKey];
    }
    return null;
  }
  function getLanguageInfoFromCode(languageCode, languageDictionary = Language) {
    for (const lang of Object.values(languageDictionary)) {
      if (lang.code === languageCode) {
        return lang;
      }
    }
    return null;
  }
  function getLanguageInfoFromFlag(languageFlag, languageDictionary = Language) {
    for (const lang of Object.values(languageDictionary)) {
      if (lang.flag === languageFlag) {
        return lang;
      }
    }
    return null;
  }
  function isLanguageInfo(obj) {
    return obj !== null && typeof obj === "object" && "code" in obj && "flag" in obj && "name" in obj && "latin" in obj && "isMode" in obj && "geocoding" in obj && (typeof obj.code === "string" || obj.code === null) && typeof obj.flag === "string" && typeof obj.name === "string" && typeof obj.latin === "boolean" && typeof obj.isMode === "boolean" && typeof obj.geocoding === "boolean";
  }
  function toLanguageInfo(lang, languageDictionary = Language) {
    if (isLanguageInfo(lang)) {
      return getLanguageInfoFromFlag(lang.flag, languageDictionary);
    }
    if (typeof lang !== "string") {
      return null;
    }
    return getLanguageInfoFromKey(lang, languageDictionary) || getLanguageInfoFromCode(lang, languageDictionary) || getLanguageInfoFromFlag(lang, languageDictionary) || null;
  }
  async function callFetch(resource, options = {}) {
    if (config.fetch === null) {
      throw new Error(
        "The fetch function was not found. If on NodeJS < 18 please specify the fetch function with config.fetch"
      );
    }
    if (new URL(resource).searchParams.get("key").trim() === "") {
      throw new Error(
        "The MapTiler Cloud API key is missing. Set it in `config.apiKey` or get one for free at https://maptiler.com"
      );
    }
    return config.fetch(resource, options);
  }
  async function info(options = {}) {
    const endpoint = new URL(`geolocation/ip.json`, defaults2.maptilerApiURL);
    endpoint.searchParams.set("key", options.apiKey ?? config.apiKey);
    const urlWithParams = endpoint.toString();
    const res = await callFetch(urlWithParams);
    if (!res.ok) {
      throw new ServiceError(
        res,
        res.status in customMessages$3 ? customMessages$3[res.status] : ""
      );
    }
    const obj = await res.json();
    return obj;
  }
  function expandMapStyle(style) {
    const maptilerDomainRegex = /^maptiler:\/\/(.*)/;
    let match;
    const trimmed = style.trim();
    let expandedStyle;
    if (trimmed.startsWith("http://") || trimmed.startsWith("https://")) {
      expandedStyle = trimmed;
    } else if ((match = maptilerDomainRegex.exec(trimmed)) !== null) {
      expandedStyle = `https://api.maptiler.com/maps/${match[1]}/style.json`;
    } else {
      expandedStyle = `https://api.maptiler.com/maps/${trimmed}/style.json`;
    }
    return expandedStyle;
  }
  function makeReferenceStyleProxy(referenceStyle) {
    return new Proxy(referenceStyle, {
      get(target, prop, receiver) {
        if (target.hasVariant(prop)) {
          return target.getVariant(prop);
        }
        if (prop.toString().toUpperCase() === prop) {
          return referenceStyle.getDefaultVariant();
        }
        const style = Reflect.get(target, prop, receiver);
        return style;
      }
    });
  }
  function buildMapStyles() {
    const mapStyle = {};
    for (let i = 0; i < mapStylePresetList.length; i += 1) {
      const refStyleInfo = mapStylePresetList[i];
      const refStyle = makeReferenceStyleProxy(
        new ReferenceMapStyle(refStyleInfo.name, refStyleInfo.referenceStyleID)
      );
      for (let j = 0; j < refStyleInfo.variants.length; j += 1) {
        const variantInfo = refStyleInfo.variants[j];
        const variant = new MapStyleVariant(
          variantInfo.name,
          // name
          variantInfo.variantType,
          // variantType
          variantInfo.id,
          // id
          refStyle,
          // referenceStyle
          variantInfo.description,
          variantInfo.imageURL,
          // imageURL
          variantInfo.deprecated
          // deprecated
        );
        refStyle.addVariant(variant);
      }
      mapStyle[refStyleInfo.referenceStyleID] = refStyle;
    }
    return mapStyle;
  }
  var ClientConfig, config, NonISOLanguage, ISOLanguage, Language, defaults2, ServiceError, customMessages$3, geolocation, MapStyleVariant, ReferenceMapStyle, mapStylePresetList, MapStyle, EARTH_RADIUS, EARTH_CIRCUMFERENCE;
  var init_maptiler_client = __esm({
    "node_modules/@maptiler/client/dist/maptiler-client.mjs"() {
      ClientConfig = class {
        constructor() {
          this._apiKey = "";
          this._fetch = tryGettingFetch();
          this.tileCacheSize = 200;
        }
        /**
         * Set the MapTiler Cloud API key
         */
        set apiKey(k) {
          this._apiKey = k;
        }
        /**
         * Get the MapTiler Cloud API key
         */
        get apiKey() {
          return this._apiKey;
        }
        /**
         * Set a the custom fetch function to replace the default one
         */
        set fetch(f) {
          this._fetch = f;
        }
        /**
         * Get the fetch fucntion
         */
        get fetch() {
          return this._fetch;
        }
      };
      config = new ClientConfig();
      NonISOLanguage = {
        /**
         * Language mode to display the labels in the end user's device language.
         */
        AUTO: {
          code: null,
          flag: "auto",
          name: "Auto",
          latin: false,
          isMode: true,
          geocoding: true
        },
        /**
         * The OSM language using latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
         * though it can be an handy fallback. This is not to be confused with the "Classical Latin" language, which is available under the tag `.CLASSICAL_LATIN`.
         */
        LATIN: {
          code: "latin",
          flag: "name:latin",
          name: "Latin",
          latin: true,
          isMode: false,
          geocoding: false
        },
        /**
         * The OSM language using non-latin script. MapTiler discourages its use as a primary language setting due to the lack of actual linguistic specificity,
         * though it can be an handy fallback.
         */
        NON_LATIN: {
          code: "nonlatin",
          flag: "name:nonlatin",
          name: "Non Latin",
          latin: false,
          isMode: false,
          geocoding: false
        },
        /**
         * Using the local language generaly (but not always) means that every labels of a given region will use the dominant local language.
         */
        LOCAL: {
          code: null,
          flag: "name",
          name: "Local",
          latin: true,
          isMode: false,
          geocoding: false
        }
      };
      ISOLanguage = {
        /**
         * Albanian language
         */
        ALBANIAN: {
          code: "sq",
          flag: "name:sq",
          name: "Albanian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Amharic language
         */
        AMHARIC: {
          code: "am",
          flag: "name:am",
          name: "Amharic",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Arabic language (right-to-left script)
         */
        ARABIC: {
          code: "ar",
          flag: "name:ar",
          name: "Arabic",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Armenian language
         */
        ARMENIAN: {
          code: "hy",
          flag: "name:hy",
          name: "Armenian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Azerbaijani language
         */
        AZERBAIJANI: {
          code: "az",
          flag: "name:az",
          name: "Azerbaijani",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Basque language
         */
        BASQUE: {
          code: "eu",
          flag: "name:eu",
          name: "Basque",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Belarusian langauge
         */
        BELARUSIAN: {
          code: "be",
          flag: "name:be",
          name: "Belarusian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Bengali language
         */
        BENGALI: {
          code: "bn",
          flag: "name:bn",
          name: "Bengali",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Bosnian language
         */
        BOSNIAN: {
          code: "bs",
          flag: "name:bs",
          name: "Bosnian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Breton language
         */
        BRETON: {
          code: "br",
          flag: "name:br",
          name: "Breton",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Bulgarian language
         */
        BULGARIAN: {
          code: "bg",
          flag: "bg",
          name: "Bulgarian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Catalan language
         */
        CATALAN: {
          code: "ca",
          flag: "name:ca",
          name: "Catalan",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Chinese language
         */
        CHINESE: {
          code: "zh",
          flag: "name:zh",
          name: "Chinese",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Traditional Chinese language
         */
        TRADITIONAL_CHINESE: {
          code: "zh-Hant",
          flag: "name:zh-Hant",
          name: "Chinese (traditional)",
          latin: false,
          isMode: false,
          geocoding: false
        },
        /**
         * Simplified Chinese language
         */
        SIMPLIFIED_CHINESE: {
          code: "zh-Hans",
          flag: "name:zh-Hans",
          name: "Chinese (simplified)",
          latin: false,
          isMode: false,
          geocoding: false
        },
        /**
         * Corsican language
         */
        CORSICAN: {
          code: "co",
          flag: "name:co",
          name: "Corsican",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Croatian language
         */
        CROATIAN: {
          code: "hr",
          flag: "name:hr",
          name: "Croatian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Czech language
         */
        CZECH: {
          code: "cs",
          flag: "name:cs",
          name: "Czech",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Danish language
         */
        DANISH: {
          code: "da",
          flag: "name:da",
          name: "Danish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Dutch language
         */
        DUTCH: {
          code: "nl",
          flag: "name:nl",
          name: "Dutch",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * German language
         */
        GERMAN: {
          code: "de",
          flag: "name:de",
          name: "German",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Greek language
         */
        GREEK: {
          code: "el",
          flag: "name:el",
          name: "Greek",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * English language
         */
        ENGLISH: {
          code: "en",
          flag: "name:en",
          name: "English",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Esperanto language
         */
        ESPERANTO: {
          code: "eo",
          flag: "name:eo",
          name: "Esperanto",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Estonian language
         */
        ESTONIAN: {
          code: "et",
          flag: "name:et",
          name: "Estonian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Finnish language
         */
        FINNISH: {
          code: "fi",
          flag: "name:fi",
          name: "Finnish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * French language
         */
        FRENCH: {
          code: "fr",
          flag: "name:fr",
          name: "French",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Frisian language
         */
        FRISIAN: {
          code: "fy",
          flag: "name:fy",
          name: "Frisian (West)",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Georgian language
         */
        GEORGIAN: {
          code: "ka",
          flag: "name:ka",
          name: "Georgian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Hebrew language (right-to-left non-latin script)
         */
        HEBREW: {
          code: "he",
          flag: "name:he",
          name: "Hebrew",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Hindi language
         */
        HINDI: {
          code: "hi",
          flag: "name:hi",
          name: "Hindi",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Hungarian language
         */
        HUNGARIAN: {
          code: "hu",
          flag: "name:hu",
          name: "Hungarian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Icelandic language
         */
        ICELANDIC: {
          code: "is",
          flag: "name:is",
          name: "Icelandic",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Indonesian language
         */
        INDONESIAN: {
          code: "id",
          flag: "name:id",
          name: "Indonesian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Irish language
         */
        IRISH: {
          code: "ga",
          flag: "name:ga",
          name: "Irish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Italian language
         */
        ITALIAN: {
          code: "it",
          flag: "name:it",
          name: "Italian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Japanese language
         */
        JAPANESE: {
          code: "ja",
          flag: "name:ja",
          name: "Japanese",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Japanese language in Hiragana form
         */
        JAPANESE_HIRAGANA: {
          code: "ja-Hira",
          flag: "name:ja-Hira",
          name: "Japanese Hiragana form",
          latin: false,
          isMode: false,
          geocoding: false
        },
        /**
         * Japanese language (latin script)
         */
        JAPANESE_2018: {
          code: "ja-Latn",
          flag: "name:ja-Latn",
          name: "Japanese (Latin 2018)",
          latin: true,
          isMode: false,
          geocoding: false
        },
        /**
         * Japanese language in Kana form (non-latin script)
         */
        JAPANESE_KANA: {
          code: "ja_kana",
          flag: "name:ja_kana",
          name: "Japanese (Kana)",
          latin: false,
          isMode: false,
          geocoding: false
        },
        /**
         * Japanse language, romanized (latin script)
         */
        JAPANESE_LATIN: {
          code: "ja_rm",
          flag: "name:ja_rm",
          name: "Japanese (Latin script)",
          latin: true,
          isMode: false,
          geocoding: false
        },
        /**
         * Kannada language
         */
        KANNADA: {
          code: "kn",
          flag: "name:kn",
          name: "Kannada",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Kazakh language
         */
        KAZAKH: {
          code: "kk",
          flag: "name:kk",
          name: "Kazakh",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Korean language
         */
        KOREAN: {
          code: "ko",
          flag: "name:ko",
          name: "Korean",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Korean language (latin script)
         */
        KOREAN_LATIN: {
          code: "ko-Latn",
          flag: "name:ko-Latn",
          name: "Korean (Latin script)",
          latin: true,
          isMode: false,
          geocoding: false
        },
        /**
         * Kurdish language
         */
        KURDISH: {
          code: "ku",
          flag: "name:ku",
          name: "Kurdish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Classical Latin language
         */
        CLASSICAL_LATIN: {
          code: "la",
          flag: "name:la",
          name: "Latin",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Latvian language
         */
        LATVIAN: {
          code: "lv",
          flag: "name:lv",
          name: "Latvian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Lithuanian language
         */
        LITHUANIAN: {
          code: "lt",
          flag: "name:lt",
          name: "Lithuanian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Luxembourgish language
         */
        LUXEMBOURGISH: {
          code: "lb",
          flag: "name:lb",
          name: "Luxembourgish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Macedonian language
         */
        MACEDONIAN: {
          code: "mk",
          flag: "name:mk",
          name: "Macedonian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Malayalm language
         */
        MALAYALAM: {
          code: "ml",
          flag: "name:ml",
          name: "Malayalam",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Maltese language
         */
        MALTESE: {
          code: "mt",
          flag: "name:mt",
          name: "Maltese",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Norwegian language
         */
        NORWEGIAN: {
          code: "no",
          flag: "name:no",
          name: "Norwegian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Occitan language
         */
        OCCITAN: {
          code: "oc",
          flag: "name:oc",
          name: "Occitan",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Persian language
         */
        PERSIAN: {
          code: "fa",
          flag: "name:fa",
          name: "Persian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Polish language
         */
        POLISH: {
          code: "pl",
          flag: "name:pl",
          name: "Polish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Portuguese language
         */
        PORTUGUESE: {
          code: "pt",
          flag: "name:pt",
          name: "Portuguese",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Punjabi language
         */
        PUNJABI: {
          code: "pa",
          flag: "name:pa",
          name: "Punjabi",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Western Punjabi language
         */
        WESTERN_PUNJABI: {
          code: "pnb",
          flag: "name:pnb",
          name: "Western Punjabi",
          latin: false,
          isMode: false,
          geocoding: false
        },
        /**
         * Romanian language
         */
        ROMANIAN: {
          code: "ro",
          flag: "name:ro",
          name: "Romanian",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Romansh language
         */
        ROMANSH: {
          code: "rm",
          flag: "name:rm",
          name: "Romansh",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Russian language
         */
        RUSSIAN: {
          code: "ru",
          flag: "name:ru",
          name: "Russian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Serbian language (cyrillic script)
         */
        SERBIAN_CYRILLIC: {
          code: "sr",
          flag: "name:sr",
          name: "Serbian (Cyrillic script)",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Serbian language (latin script)
         */
        SERBIAN_LATIN: {
          code: "sr-Latn",
          flag: "name:sr-Latn",
          name: "Serbian (Latin script)",
          latin: true,
          isMode: false,
          geocoding: false
        },
        /**
         * Scottish Gaelic language
         */
        SCOTTISH_GAELIC: {
          code: "gd",
          flag: "name:gd",
          name: "Scottish Gaelic",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Slovak language
         */
        SLOVAK: {
          code: "sk",
          flag: "name:sk",
          name: "Slovak",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Slovene language
         */
        SLOVENE: {
          code: "sl",
          flag: "name:sl",
          name: "Slovene",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Spanish language
         */
        SPANISH: {
          code: "es",
          flag: "name:es",
          name: "Spanish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Swedish language
         */
        SWEDISH: {
          code: "sv",
          flag: "name:sv",
          name: "Swedish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Tamil language
         */
        TAMIL: {
          code: "ta",
          flag: "name:ta",
          name: "Tamil",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Telugu language
         */
        TELUGU: {
          code: "te",
          flag: "name:te",
          name: "Telugu",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Thai language
         */
        THAI: {
          code: "th",
          flag: "name:th",
          name: "Thai",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Turkish language
         */
        TURKISH: {
          code: "tr",
          flag: "name:tr",
          name: "Turkish",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Ukrainian language
         */
        UKRAINIAN: {
          code: "uk",
          flag: "name:uk",
          name: "Ukrainian",
          latin: false,
          isMode: false,
          geocoding: true
        },
        /**
         * Vietnamese language (latin script)
         */
        VIETNAMESE: {
          code: "vi",
          flag: "name:vi",
          name: "Vietnamese (Latin script)",
          latin: true,
          isMode: false,
          geocoding: true
        },
        /**
         * Welsh language
         */
        WELSH: {
          code: "cy",
          flag: "name:cy",
          name: "Welsh",
          latin: true,
          isMode: false,
          geocoding: true
        }
      };
      Language = {
        ...NonISOLanguage,
        ...ISOLanguage
      };
      defaults2 = {
        maptilerApiURL: "https://api.maptiler.com/",
        mapStyle: "streets-v2"
      };
      Object.freeze(defaults2);
      ServiceError = class extends Error {
        constructor(res, customMessage = "") {
          super(
            `Call to enpoint ${res.url} failed with the status code ${res.status}. ${customMessage}`
          );
          this.res = res;
        }
      };
      customMessages$3 = {
        403: "Key is missing, invalid or restricted"
      };
      geolocation = {
        info
      };
      MapStyleVariant = class {
        constructor(name, variantType, id, referenceStyle, description, imageURL, deprecated = false) {
          this.name = name;
          this.variantType = variantType;
          this.id = id;
          this.referenceStyle = referenceStyle;
          this.description = description;
          this.imageURL = imageURL;
          this.deprecated = deprecated;
        }
        /**
         * Get the human-friendly name
         * @returns
         */
        getName() {
          return this.name;
        }
        getFullName() {
          return `${this.referenceStyle.getName()} ${this.name}`;
        }
        /**
         * Get the variant type (eg. "DEFAULT", "DARK", "PASTEL", etc.)
         * @returns
         */
        getType() {
          return this.variantType;
        }
        /**
         * Get the MapTiler Cloud id
         * @returns
         */
        getId() {
          return this.id;
        }
        /**
         * Get the human-friendly description
         */
        getDescription() {
          return this.description;
        }
        /**
         * Get the reference style this variant belongs to
         * @returns
         */
        getReferenceStyle() {
          return this.referenceStyle;
        }
        /**
         * Check if a variant of a given type exists for _this_ variants
         * (eg. if this is a "DARK", then we can check if there is a "LIGHT" variant of it)
         * @param variantType
         * @returns
         */
        hasVariant(variantType) {
          return this.referenceStyle.hasVariant(variantType);
        }
        /**
         * Retrieve the variant of a given type. If not found, will return the "DEFAULT" variant.
         * (eg. _this_ "DARK" variant does not have any "PASTEL" variant, then the "DEFAULT" is returned)
         * @param variantType
         * @returns
         */
        getVariant(variantType) {
          const variant = this.referenceStyle.getVariant(variantType);
          this.warnIfDeprecated(variant);
          return variant;
        }
        /**
         * Get all the variants for _this_ variants, except _this_ current one
         * @returns
         */
        getVariants() {
          return this.referenceStyle.getVariants().filter((v) => v !== this).map((v) => {
            this.warnIfDeprecated(v);
            return v;
          });
        }
        /**
         * Get the image URL that represent _this_ variant
         * @returns
         */
        getImageURL() {
          return this.imageURL;
        }
        /**
         * Get the style as usable by MapLibre, a string (URL) or a plain style description (StyleSpecification)
         * @returns
         */
        getExpandedStyleURL() {
          return expandMapStyle(this.getId());
        }
        warnIfDeprecated(variant = this) {
          if (!variant.deprecated)
            return variant;
          const name = variant.getFullName();
          console.warn(
            `Style "${name}" is deprecated and will be removed in a future version.`
          );
          return variant;
        }
      };
      ReferenceMapStyle = class {
        constructor(name, id) {
          this.name = name;
          this.id = id;
          this.variants = {};
          this.orderedVariants = [];
        }
        /**
         * Get the human-friendly name of this reference style
         * @returns
         */
        getName() {
          return this.name;
        }
        /**
         * Get the id of _this_ reference style
         * @returns
         */
        getId() {
          return this.id;
        }
        /**
         * Add a variant to _this_ reference style
         * @param v
         */
        addVariant(v) {
          this.variants[v.getType()] = v;
          this.orderedVariants.push(v);
        }
        /**
         * Check if a given variant type exists for this reference style
         * @param variantType
         * @returns
         */
        hasVariant(variantType) {
          return variantType in this.variants;
        }
        /**
         * Get a given variant. If the given type of variant does not exist for this reference style,
         * then the most relevant default variant is returned instead
         * @param variantType
         * @returns
         */
        getVariant(variantType) {
          return variantType in this.variants ? this.variants[variantType] : this.orderedVariants[0];
        }
        /**
         * Get the list of variants for this reference style
         * @returns
         */
        getVariants() {
          return Object.values(this.variants);
        }
        /**
         * Get the defualt variant for this reference style
         * @returns
         */
        getDefaultVariant() {
          return this.orderedVariants[0].warnIfDeprecated();
        }
      };
      mapStylePresetList = [
        {
          referenceStyleID: "STREETS",
          name: "Streets",
          description: "",
          variants: [
            {
              id: "streets-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "streets-v2-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "streets-v2-light",
              name: "Light",
              variantType: "LIGHT",
              description: "",
              imageURL: ""
            },
            {
              id: "streets-v2-night",
              name: "Night",
              variantType: "NIGHT",
              description: "",
              imageURL: ""
            },
            {
              id: "streets-v2-pastel",
              name: "Pastel",
              variantType: "PASTEL",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "OUTDOOR",
          name: "Outdoor",
          description: "",
          variants: [
            {
              id: "outdoor-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "outdoor-v2-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "WINTER",
          name: "Winter",
          description: "",
          variants: [
            {
              id: "winter-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "winter-v2-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "SATELLITE",
          name: "Satellite",
          description: "",
          variants: [
            {
              id: "satellite",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "HYBRID",
          name: "Hybrid",
          description: "",
          variants: [
            {
              id: "hybrid",
              deprecated: true,
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "BASIC",
          name: "Basic",
          description: "",
          variants: [
            {
              id: "basic-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "basic-v2-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "basic-v2-light",
              name: "Light",
              variantType: "LIGHT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "BRIGHT",
          name: "Bright",
          description: "",
          variants: [
            {
              id: "bright-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "bright-v2-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "bright-v2-light",
              name: "Light",
              variantType: "LIGHT",
              description: "",
              imageURL: ""
            },
            {
              id: "bright-v2-pastel",
              name: "Pastel",
              variantType: "PASTEL",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "OPENSTREETMAP",
          name: "OpenStreetMap",
          description: "",
          variants: [
            {
              id: "openstreetmap",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "TOPO",
          name: "Topo",
          description: "",
          variants: [
            {
              id: "topo-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "topo-v2-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "topo-v2-shiny",
              name: "Shiny",
              deprecated: true,
              variantType: "SHINY",
              description: "",
              imageURL: ""
            },
            {
              id: "topo-v2-pastel",
              name: "Pastel",
              variantType: "PASTEL",
              description: "",
              imageURL: ""
            },
            {
              id: "topo-v2-topographique",
              name: "Topographique",
              variantType: "TOPOGRAPHIQUE",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "VOYAGER",
          name: "Voyager",
          description: "",
          variants: [
            {
              id: "voyager-v2",
              name: "Default",
              deprecated: true,
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "voyager-v2-darkmatter",
              name: "Darkmatter",
              deprecated: true,
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "voyager-v2-positron",
              name: "Positron",
              deprecated: true,
              variantType: "LIGHT",
              description: "",
              imageURL: ""
            },
            {
              id: "voyager-v2-vintage",
              name: "Vintage",
              deprecated: true,
              variantType: "VINTAGE",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "TONER",
          name: "Toner",
          description: "",
          variants: [
            {
              id: "toner-v2",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "toner-v2-background",
              name: "Background",
              variantType: "BACKGROUND",
              deprecated: true,
              description: "",
              imageURL: ""
            },
            {
              id: "toner-v2-lite",
              name: "Lite",
              variantType: "LITE",
              description: "",
              imageURL: ""
            },
            {
              id: "toner-v2-lines",
              name: "Lines",
              variantType: "LINES",
              deprecated: true,
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "DATAVIZ",
          name: "Dataviz",
          description: "",
          variants: [
            {
              id: "dataviz",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "dataviz-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "dataviz-light",
              name: "Light",
              variantType: "LIGHT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "BACKDROP",
          name: "Backdrop",
          description: "",
          variants: [
            {
              id: "backdrop",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "backdrop-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "backdrop-light",
              name: "Light",
              variantType: "LIGHT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "OCEAN",
          name: "Ocean",
          description: "",
          variants: [
            {
              id: "ocean",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "AQUARELLE",
          name: "Aquarelle",
          description: "Watercolor map for creative use",
          variants: [
            {
              id: "aquarelle",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "aquarelle-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "aquarelle-vivid",
              name: "Vivid",
              variantType: "VIVID",
              description: "",
              imageURL: ""
            }
          ]
        },
        {
          referenceStyleID: "LANDSCAPE",
          name: "Landscape",
          description: "Terrain map for data overlays and visualisations",
          variants: [
            {
              id: "landscape",
              name: "Default",
              variantType: "DEFAULT",
              description: "",
              imageURL: ""
            },
            {
              id: "landscape-dark",
              name: "Dark",
              variantType: "DARK",
              description: "",
              imageURL: ""
            },
            {
              id: "landscape-vivid",
              name: "Vivid",
              variantType: "VIVID",
              description: "",
              imageURL: ""
            }
          ]
        }
      ];
      MapStyle = buildMapStyles();
      EARTH_RADIUS = 63710088e-1;
      EARTH_CIRCUMFERENCE = 2 * Math.PI * EARTH_RADIUS;
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er2;
          if (args.length > 0)
            er2 = args[0];
          if (er2 instanceof Error) {
            throw er2;
          }
          var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
          err.context = er2;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/stringify.js
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  var byteToHex;
  var init_stringify = __esm({
    "node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/stringify.js"() {
      byteToHex = [];
      for (let i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).slice(1));
      }
    }
  });

  // node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      if (typeof crypto === "undefined" || !crypto.getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
      getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/native.js
  var randomUUID, native_default;
  var init_native = __esm({
    "node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/native.js"() {
      randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
      native_default = { randomUUID };
    }
  });

  // node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/v4.js"() {
      init_native();
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/index.js
  var init_esm_browser = __esm({
    "node_modules/@maptiler/sdk/node_modules/uuid/dist/esm-browser/index.js"() {
      init_v4();
    }
  });

  // node_modules/js-base64/base64.mjs
  var version, VERSION3, _hasBuffer, _TD, _TE, b64ch, b64chs, b64tab, b64re, _fromCC, _U8Afrom, _mkUriSafe, _tidyB64, btoaPolyfill, _btoa, _fromUint8Array, fromUint8Array, cb_utob, re_utob, utob, _encode, encode3, encodeURI, re_btou, cb_btou, btou, atobPolyfill, _atob, _toUint8Array, toUint8Array, _decode, _unURI, decode, isValid, _noEnum, extendString, extendUint8Array, extendBuiltins, gBase64;
  var init_base64 = __esm({
    "node_modules/js-base64/base64.mjs"() {
      version = "3.7.7";
      VERSION3 = version;
      _hasBuffer = typeof Buffer === "function";
      _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      b64chs = Array.prototype.slice.call(b64ch);
      b64tab = ((a) => {
        let tab = {};
        a.forEach((c, i) => tab[c] = i);
        return tab;
      })(b64chs);
      b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      _fromCC = String.fromCharCode.bind(String);
      _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it2) => new Uint8Array(Array.prototype.slice.call(it2, 0));
      _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
      _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
      btoaPolyfill = (bin) => {
        let u32, c0, c1, c2, asc = "";
        const pad = bin.length % 3;
        for (let i = 0; i < bin.length; ) {
          if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
      _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
        const maxargs = 4096;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      cb_utob = (c) => {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      utob = (u) => u.replace(re_utob, cb_utob);
      _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
      encode3 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      encodeURI = (src) => encode3(src, true);
      re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      cb_btou = (cccc) => {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      btou = (b) => b.replace(re_btou, cb_btou);
      atobPolyfill = (asc) => {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        let u24, bin = "", r1, r2;
        for (let i = 0; i < asc.length; ) {
          u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
      };
      _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
      _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
      toUint8Array = (a) => _toUint8Array(_unURI(a));
      _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
      _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
      decode = (src) => _decode(_unURI(src));
      isValid = (src) => {
        if (typeof src !== "string")
          return false;
        const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      _noEnum = (v) => {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      extendString = function() {
        const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode3(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode3(this, true);
        });
        _add("toBase64URL", function() {
          return encode3(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      extendUint8Array = function() {
        const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      extendBuiltins = () => {
        extendString();
        extendUint8Array();
      };
      gBase64 = {
        version,
        VERSION: VERSION3,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode3,
        encode: encode3,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
    }
  });

  // node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs
  function Dr() {
    if (typeof navigator > "u") {
      const e = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0], t = getLanguageInfoFromCode(e);
      return t || M.ENGLISH;
    }
    return Array.from(new Set(navigator.languages.map((e) => e.split("-")[0]))).map((e) => getLanguageInfoFromCode(e)).filter((e) => e)[0] ?? M.LOCAL;
  }
  function Ga(r, e) {
    if (Zt && O.caching && O.session && r.host === V.maptilerApiHost) {
      if (e === "Source" && r.href.includes("tiles.json"))
        return r.href.replace("https://", `${Kt}://`);
      if (e === "Tile" || e === "Glyphs")
        return r.href.replace("https://", `${Wt}://`);
    }
    return r.href;
  }
  async function xn() {
    return Nt || (Nt = await caches.open(Ba)), Nt;
  }
  async function Ha() {
    const r = await xn(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Ua, 0));
    for (const n of t)
      r.delete(n);
  }
  function Ka() {
    qr(
      Kt,
      async (r, e) => {
        if (!r.url) throw new Error("");
        r.url = r.url.replace(`${Kt}://`, "https://");
        const t = r;
        t.signal = e.signal;
        const n = await fetch(r.url, t), a = await n.json();
        return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get("Last-Modified")}`), {
          data: a,
          cacheControl: n.headers.get("Cache-Control"),
          expires: n.headers.get("Expires")
        };
      }
    ), qr(Wt, async (r, e) => {
      if (!r.url) throw new Error("");
      r.url = r.url.replace(`${Wt}://`, "https://");
      const t = new URL(r.url), n = new URL(t);
      n.searchParams.delete("mtsid"), n.searchParams.delete("key");
      const a = n.toString(), o = new URL(t);
      o.searchParams.delete("last-modified");
      const i = o.toString(), s = async (y) => ({
        data: await y.arrayBuffer(),
        cacheControl: y.headers.get("Cache-Control"),
        expires: y.headers.get("Expires")
      }), l = await xn(), u = await l.match(a);
      if (u)
        return s(u);
      const c = r;
      c.signal = e.signal;
      const p = await fetch(i, c);
      return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {
      }), ++Br > Va && (Ha(), Br = 0)), s(p);
    });
  }
  function Wa() {
    if (typeof window > "u") return;
    const r = import_maplibre_gl.default.getRTLTextPluginStatus();
    if (r === "unavailable" || r === "requested")
      try {
        import_maplibre_gl.default.setRTLTextPlugin(V.rtlPluginURL, true);
      } catch {
      }
  }
  function Za(r, e) {
    for (const t of r)
      typeof e[t] == "function" && (e[t] = e[t].bind(e));
  }
  function Ur(r, e) {
    let t = null;
    try {
      t = new URL(r);
    } catch {
      return {
        url: r
      };
    }
    return t.host === V.maptilerApiHost && (t.searchParams.has("key") || t.searchParams.append("key", O.apiKey), O.session && t.searchParams.append("mtsid", ur)), {
      url: Ga(t, e)
    };
  }
  function Vr(r) {
    return (e, t) => {
      if (r != null) {
        const n = r(e, t), a = Ur((n == null ? void 0 : n.url) ?? "", t);
        return {
          ...n,
          ...a
        };
      }
      return Ur(e, t);
    };
  }
  function Ya() {
    return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
  }
  function Xa(r) {
    const e = Ya();
    if (!e) return;
    let t = null;
    if (typeof r == "string" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t)
      throw new Error("The Map container must be provided.");
    const n = document.createElement("div");
    throw n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n), new Error(e);
  }
  function Gr(r, e) {
    return !(!Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" || e && !r[1].startsWith("name:") || !e && r[1] !== "name");
  }
  function Qa(r, e, t) {
    const n = structuredClone(r), a = (o) => {
      if (typeof o != "string")
        for (let i = 0; i < o.length; i += 1)
          Gr(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);
    };
    return Gr(n, t) ? e : (a(n), n);
  }
  function eo(r, e) {
    const t = e ? /\{name:\S+\}/ : /\{name\}/;
    return {
      contains: t.test(r),
      exactMatch: new RegExp(`^${t.source}$`).test(r)
    };
  }
  function to(r, e, t) {
    const n = t ? /\{name:\S+\}/ : /\{name\}/, a = r.split(n);
    return ["concat", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];
  }
  function ro(r) {
    var n;
    const e = /\{name(?::(?<language>\S+))?\}/g, t = [];
    for (; ; ) {
      const a = e.exec(r);
      if (!a) break;
      const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;
      t.push(o);
    }
    return t;
  }
  function no(r) {
    return !Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" ? null : r[1].trim() === "name" ? {
      isLanguage: true,
      localization: null
    } : r[1].trim().startsWith("name:") ? {
      isLanguage: true,
      localization: r[1].trim().split(":").pop()
    } : null;
  }
  function ao(r) {
    const e = [], t = structuredClone(r), n = (a) => {
      if (typeof a != "string")
        for (let o = 0; o < a.length; o += 1) {
          const i = no(a[o]);
          i ? e.push(i.localization) : n(a[o]);
        }
    };
    return n([t]), e;
  }
  function oo(r, e) {
    const t = [];
    for (const o of r) {
      if (o.type !== "symbol")
        continue;
      const i = o, { id: s, layout: l } = i;
      if (!l || !("text-field" in l))
        continue;
      const u = e.getLayoutProperty(s, "text-field");
      if (u)
        if (typeof u == "string") {
          const c = ro(u);
          t.push(c);
        } else {
          const c = ao(u);
          t.push(c);
        }
    }
    const n = t.flat(), a = {
      unlocalized: 0,
      localized: {}
    };
    for (const o of n)
      o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);
    return a;
  }
  function ct(r, ...e) {
    for (const t of e)
      for (const n in t)
        r[n] = t[n];
    return r;
  }
  function W(r, e) {
    return {
      kind: "array",
      itemType: r,
      N: e
    };
  }
  function N(r) {
    if (r.kind === "array") {
      const e = N(r.itemType);
      return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
    } else
      return r.kind;
  }
  function Ve(r, e) {
    if (e.kind === "error")
      return null;
    if (r.kind === "array") {
      if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Ve(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N))
        return null;
    } else {
      if (r.kind === e.kind)
        return null;
      if (r.kind === "value") {
        for (const t of ei)
          if (!Ve(t, e))
            return null;
      }
    }
    return `Expected ${N(r)} but found ${N(e)} instead.`;
  }
  function pr(r, e) {
    return e.some((t) => t.kind === r.kind);
  }
  function Ce(r, e) {
    return e.some((t) => t === "null" ? r === null : t === "array" ? Array.isArray(r) : t === "object" ? r && !Array.isArray(r) && typeof r == "object" : t === typeof r);
  }
  function _e(r, e) {
    return r.kind === "array" && e.kind === "array" ? r.itemType.kind === e.itemType.kind && typeof r.N == "number" : r.kind === e.kind;
  }
  function En(r) {
    return r = r % 360, r < 0 && (r += 360), r;
  }
  function Mn([r, e, t, n]) {
    r = Ot(r), e = Ot(e), t = Ot(t);
    let a, o;
    const i = Ft((0.2225045 * r + 0.7168786 * e + 0.0606169 * t) / Cn);
    r === e && e === t ? a = o = i : (a = Ft((0.4360747 * r + 0.3850649 * e + 0.1430804 * t) / Ln), o = Ft((0.0139322 * r + 0.0971045 * e + 0.7141733 * t) / An));
    const s = 116 * i - 16;
    return [s < 0 ? 0 : s, 500 * (a - i), 200 * (i - o), n];
  }
  function Ot(r) {
    return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
  }
  function Ft(r) {
    return r > ti ? Math.pow(r, 1 / 3) : r / In + Tn;
  }
  function _n([r, e, t, n]) {
    let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;
    return a = Cn * qt(a), o = Ln * qt(o), i = An * qt(i), [
      Dt(3.1338561 * o - 1.6168667 * a - 0.4906146 * i),
      // D50 -> sRGB
      Dt(-0.9787684 * o + 1.9161415 * a + 0.033454 * i),
      Dt(0.0719453 * o - 0.2289914 * a + 1.4052427 * i),
      n
    ];
  }
  function Dt(r) {
    return r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055, r < 0 ? 0 : r > 1 ? 1 : r;
  }
  function qt(r) {
    return r > $e ? r * r * r : In * (r - Tn);
  }
  function ai(r) {
    const [e, t, n, a] = Mn(r), o = Math.sqrt(t * t + n * n);
    return [Math.round(o * 1e4) ? En(Math.atan2(n, t) * ni) : NaN, o, e, a];
  }
  function oi([r, e, t, n]) {
    return r = isNaN(r) ? 0 : r * ri, _n([t, Math.cos(r) * e, Math.sin(r) * e, n]);
  }
  function ii([r, e, t, n]) {
    r = En(r), e /= 100, t /= 100;
    function a(o) {
      const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);
      return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));
    }
    return [a(0), a(8), a(4), n];
  }
  function si(r) {
    if (r = r.toLowerCase().trim(), r === "transparent")
      return [0, 0, 0, 0];
    const e = li[r];
    if (e) {
      const [a, o, i] = e;
      return [a / 255, o / 255, i / 255, 1];
    }
    if (r.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {
      const o = r.length < 6 ? 1 : 2;
      let i = 1;
      return [
        at(r.slice(i, i += o)),
        at(r.slice(i, i += o)),
        at(r.slice(i, i += o)),
        at(r.slice(i, i + o) || "ff")
      ];
    }
    if (r.startsWith("rgb")) {
      const a = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o = r.match(a);
      if (o) {
        const [
          i,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          s,
          // <numeric>
          l,
          // %         (optional)
          u,
          // ,         (optional)
          c,
          // <numeric>
          p,
          // %         (optional)
          y,
          // ,         (optional)
          f,
          // <numeric>
          d,
          // %         (optional)
          m,
          // ,|/       (optional)
          v,
          // <numeric> (optional)
          w
          // %         (optional)
        ] = o, b = [u || " ", y || " ", m].join("");
        if (b === "  " || b === "  /" || b === ",," || b === ",,,") {
          const T = [l, p, d].join(""), j = T === "%%%" ? 100 : T === "" ? 255 : 0;
          if (j) {
            const R = [
              ze(+s / j, 0, 1),
              ze(+c / j, 0, 1),
              ze(+f / j, 0, 1),
              v ? Kr(+v, w) : 1
            ];
            if (Wr(R))
              return R;
          }
        }
        return;
      }
    }
    const t = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, n = r.match(t);
    if (n) {
      const [
        a,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        o,
        // <numeric>
        i,
        // ,         (optional)
        s,
        // <numeric>
        l,
        // ,         (optional)
        u,
        // <numeric>
        c,
        // ,|/       (optional)
        p,
        // <numeric> (optional)
        y
        // %         (optional)
      ] = n, f = [i || " ", l || " ", c].join("");
      if (f === "  " || f === "  /" || f === ",," || f === ",,,") {
        const d = [
          +o,
          ze(+s, 0, 100),
          ze(+u, 0, 100),
          p ? Kr(+p, y) : 1
        ];
        if (Wr(d))
          return ii(d);
      }
    }
  }
  function at(r) {
    return parseInt(r.padEnd(2, r), 16) / 255;
  }
  function Kr(r, e) {
    return ze(e ? r / 100 : r, 0, 1);
  }
  function ze(r, e, t) {
    return Math.min(Math.max(e, r), t);
  }
  function Wr(r) {
    return !r.some(Number.isNaN);
  }
  function ve(r, e, t) {
    return r + t * (e - r);
  }
  function Ge(r, e, t) {
    return r.map((n, a) => ve(n, e[a], t));
  }
  function zn(r, e, t, n) {
    return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[r, e, t, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [r, e, t, n] : [r, e, t]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
  }
  function He(r) {
    if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof ee || r instanceof $ || r instanceof fr || r instanceof pe || r instanceof J || r instanceof ne || r instanceof we)
      return true;
    if (Array.isArray(r)) {
      for (const e of r)
        if (!He(e))
          return false;
      return true;
    } else if (typeof r == "object") {
      for (const e in r)
        if (!He(r[e]))
          return false;
      return true;
    } else
      return false;
  }
  function q(r) {
    if (r === null)
      return bt;
    if (typeof r == "string")
      return I;
    if (typeof r == "boolean")
      return C;
    if (typeof r == "number")
      return g;
    if (r instanceof $)
      return ie;
    if (r instanceof ee)
      return wt;
    if (r instanceof fr)
      return St;
    if (r instanceof pe)
      return xt;
    if (r instanceof J)
      return kt;
    if (r instanceof ne)
      return Lt;
    if (r instanceof we)
      return Xe;
    if (Array.isArray(r)) {
      const e = r.length;
      let t;
      for (const n of r) {
        const a = q(n);
        if (!t)
          t = a;
        else {
          if (t === a)
            continue;
          t = A;
          break;
        }
      }
      return W(t || A, e);
    } else
      return Re;
  }
  function Be(r) {
    const e = typeof r;
    return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof $ || r instanceof ee || r instanceof pe || r instanceof J || r instanceof ne || r instanceof we ? r.toString() : JSON.stringify(r);
  }
  function Rn(r, e) {
    const t = r.length - 1;
    let n = 0, a = t, o = 0, i, s;
    for (; n <= a; )
      if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {
        if (o === t || e < s)
          return o;
        n = o + 1;
      } else if (i > e)
        a = o - 1;
      else
        throw new D("Input is not a number.");
    return 0;
  }
  function fi(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
  }
  function di() {
    if (Jr) return Bt;
    Jr = 1, Bt = r;
    function r(e, t, n, a) {
      this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;
    }
    return r.prototype = {
      sampleCurveX: function(e) {
        return ((this.ax * e + this.bx) * e + this.cx) * e;
      },
      sampleCurveY: function(e) {
        return ((this.ay * e + this.by) * e + this.cy) * e;
      },
      sampleCurveDerivativeX: function(e) {
        return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
      },
      solveCurveX: function(e, t) {
        if (t === void 0 && (t = 1e-6), e < 0) return 0;
        if (e > 1) return 1;
        for (var n = e, a = 0; a < 8; a++) {
          var o = this.sampleCurveX(n) - e;
          if (Math.abs(o) < t) return n;
          var i = this.sampleCurveDerivativeX(n);
          if (Math.abs(i) < 1e-6) break;
          n = n - o / i;
        }
        var s = 0, l = 1;
        for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++)
          e > o ? s = n : l = n, n = (l - s) * 0.5 + s;
        return n;
      },
      solve: function(e, t) {
        return this.sampleCurveY(this.solveCurveX(e, t));
      }
    }, Bt;
  }
  function Ut(r, e, t, n) {
    const a = n - t, o = r - t;
    return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);
  }
  function Yr(r, e) {
    return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
  }
  function hi(r, e, t) {
    return e === t;
  }
  function gi(r, e, t) {
    return e !== t;
  }
  function vi(r, e, t) {
    return e < t;
  }
  function bi(r, e, t) {
    return e > t;
  }
  function wi(r, e, t) {
    return e <= t;
  }
  function Si(r, e, t) {
    return e >= t;
  }
  function $n(r, e, t, n) {
    return n.compare(e, t) === 0;
  }
  function xi(r, e, t, n) {
    return !$n(r, e, t, n);
  }
  function ki(r, e, t, n) {
    return n.compare(e, t) < 0;
  }
  function Li(r, e, t, n) {
    return n.compare(e, t) > 0;
  }
  function Ci(r, e, t, n) {
    return n.compare(e, t) <= 0;
  }
  function Ai(r, e, t, n) {
    return n.compare(e, t) >= 0;
  }
  function Oe(r, e, t) {
    const n = r !== "==" && r !== "!=";
    return class jn {
      constructor(o, i, s) {
        this.type = C, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === "value" || i.type.kind === "value";
      }
      static parse(o, i) {
        if (o.length !== 3 && o.length !== 4)
          return i.error("Expected two or three arguments.");
        const s = o[0];
        let l = i.parse(o[1], 1, A);
        if (!l)
          return null;
        if (!Yr(s, l.type))
          return i.concat(1).error(`"${s}" comparisons are not supported for type '${N(l.type)}'.`);
        let u = i.parse(o[2], 2, A);
        if (!u)
          return null;
        if (!Yr(s, u.type))
          return i.concat(2).error(`"${s}" comparisons are not supported for type '${N(u.type)}'.`);
        if (l.type.kind !== u.type.kind && l.type.kind !== "value" && u.type.kind !== "value")
          return i.error(`Cannot compare types '${N(l.type)}' and '${N(u.type)}'.`);
        n && (l.type.kind === "value" && u.type.kind !== "value" ? l = new te(u.type, [l]) : l.type.kind !== "value" && u.type.kind === "value" && (u = new te(l.type, [u])));
        let c = null;
        if (o.length === 4) {
          if (l.type.kind !== "string" && u.type.kind !== "string" && l.type.kind !== "value" && u.type.kind !== "value")
            return i.error("Cannot use collator to compare non-string types.");
          if (c = i.parse(o[3], 3, St), !c)
            return null;
        }
        return new jn(l, u, c);
      }
      evaluate(o) {
        const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);
        if (n && this.hasUntypedArgument) {
          const l = q(i), u = q(s);
          if (l.kind !== u.kind || !(l.kind === "string" || l.kind === "number"))
            throw new D(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);
        }
        if (this.collator && !n && this.hasUntypedArgument) {
          const l = q(i), u = q(s);
          if (l.kind !== "string" || u.kind !== "string")
            return e(o, i, s);
        }
        return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);
      }
      eachChild(o) {
        o(this.lhs), o(this.rhs), this.collator && o(this.collator);
      }
      outputDefined() {
        return true;
      }
    };
  }
  function Pi(r, e) {
    const t = Ri(r[0]), n = ji(r[1]), a = Math.pow(2, e.z);
    return [Math.round(t * a * le), Math.round(n * a * le)];
  }
  function Sr(r, e) {
    const t = Math.pow(2, e.z), n = (r[0] / le + e.x) / t, a = (r[1] / le + e.y) / t;
    return [$i(n), Ni(a)];
  }
  function Ri(r) {
    return (180 + r) / 360;
  }
  function $i(r) {
    return r * 360 - 180;
  }
  function ji(r) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
  }
  function Ni(r) {
    return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;
  }
  function Qe(r, e) {
    r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
  }
  function We(r, e) {
    return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
  }
  function Oi(r, e, t) {
    return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];
  }
  function Fi(r, e, t) {
    const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];
    return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;
  }
  function Mt(r, e, t, n) {
    const a = [e[0] - r[0], e[1] - r[1]], o = [n[0] - t[0], n[1] - t[1]];
    return Ui(o, a) === 0 ? false : !!(Xr(r, e, t, n) && Xr(t, n, r, e));
  }
  function Di(r, e, t) {
    for (const n of t)
      for (let a = 0; a < n.length - 1; ++a)
        if (Mt(r, e, n[a], n[a + 1]))
          return true;
    return false;
  }
  function Fe(r, e, t = false) {
    let n = false;
    for (const a of e)
      for (let o = 0; o < a.length - 1; o++) {
        if (Fi(r, a[o], a[o + 1]))
          return t;
        Oi(r, a[o], a[o + 1]) && (n = !n);
      }
    return n;
  }
  function qi(r, e) {
    for (const t of e)
      if (Fe(r, t))
        return true;
    return false;
  }
  function Nn(r, e) {
    for (const t of r)
      if (!Fe(t, e))
        return false;
    for (let t = 0; t < r.length - 1; ++t)
      if (Di(r[t], r[t + 1], e))
        return false;
    return true;
  }
  function Bi(r, e) {
    for (const t of e)
      if (Nn(r, t))
        return true;
    return false;
  }
  function Ui(r, e) {
    return r[0] * e[1] - r[1] * e[0];
  }
  function Xr(r, e, t, n) {
    const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;
    return c > 0 && p < 0 || c < 0 && p > 0;
  }
  function xr(r, e, t) {
    const n = [];
    for (let a = 0; a < r.length; a++) {
      const o = [];
      for (let i = 0; i < r[a].length; i++) {
        const s = Pi(r[a][i], t);
        Qe(e, s), o.push(s);
      }
      n.push(o);
    }
    return n;
  }
  function On(r, e, t) {
    const n = [];
    for (let a = 0; a < r.length; a++) {
      const o = xr(r[a], e, t);
      n.push(o);
    }
    return n;
  }
  function Fn(r, e, t, n) {
    if (r[0] < t[0] || r[0] > t[2]) {
      const a = n * 0.5;
      let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;
      o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;
    }
    Qe(e, r);
  }
  function Vi(r) {
    r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;
  }
  function Qr(r, e, t, n) {
    const a = Math.pow(2, n.z) * le, o = [n.x * le, n.y * le], i = [];
    for (const s of r)
      for (const l of s) {
        const u = [l.x + o[0], l.y + o[1]];
        Fn(u, e, t, a), i.push(u);
      }
    return i;
  }
  function en(r, e, t, n) {
    const a = Math.pow(2, n.z) * le, o = [n.x * le, n.y * le], i = [];
    for (const s of r) {
      const l = [];
      for (const u of s) {
        const c = [u.x + o[0], u.y + o[1]];
        Qe(e, c), l.push(c);
      }
      i.push(l);
    }
    if (e[2] - e[0] <= a / 2) {
      Vi(e);
      for (const s of i)
        for (const l of s)
          Fn(l, e, t, a);
    }
    return i;
  }
  function Gi(r, e) {
    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();
    if (e.type === "Polygon") {
      const o = xr(e.coordinates, n, a), i = Qr(r.geometry(), t, n, a);
      if (!We(t, n))
        return false;
      for (const s of i)
        if (!Fe(s, o))
          return false;
    }
    if (e.type === "MultiPolygon") {
      const o = On(e.coordinates, n, a), i = Qr(r.geometry(), t, n, a);
      if (!We(t, n))
        return false;
      for (const s of i)
        if (!qi(s, o))
          return false;
    }
    return true;
  }
  function Hi(r, e) {
    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();
    if (e.type === "Polygon") {
      const o = xr(e.coordinates, n, a), i = en(r.geometry(), t, n, a);
      if (!We(t, n))
        return false;
      for (const s of i)
        if (!Nn(s, o))
          return false;
    }
    if (e.type === "MultiPolygon") {
      const o = On(e.coordinates, n, a), i = en(r.geometry(), t, n, a);
      if (!We(t, n))
        return false;
      for (const s of i)
        if (!Bi(s, o))
          return false;
    }
    return true;
  }
  function Ki(r, e) {
    if (r.length <= 1)
      return [r];
    const n = [];
    let a, o;
    for (const i of r) {
      const s = Wi(i);
      s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));
    }
    return a && n.push(a), n;
  }
  function Wi(r) {
    let e = 0;
    for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++)
      o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);
    return e;
  }
  function qn(r, e) {
    return e[0] - r[0];
  }
  function dt(r) {
    return r[1] - r[0] + 1;
  }
  function de(r, e) {
    return r[1] >= r[0] && r[1] < e;
  }
  function Qt(r, e) {
    if (r[0] > r[1])
      return [null, null];
    const t = dt(r);
    if (e) {
      if (t === 2)
        return [r, null];
      const a = Math.floor(t / 2);
      return [
        [r[0], r[0] + a],
        [r[0] + a, r[1]]
      ];
    }
    if (t === 1)
      return [r, null];
    const n = Math.floor(t / 2) - 1;
    return [
      [r[0], r[0] + n],
      [r[0] + n + 1, r[1]]
    ];
  }
  function er(r, e) {
    if (!de(e, r.length))
      return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    for (let n = e[0]; n <= e[1]; ++n)
      Qe(t, r[n]);
    return t;
  }
  function tr(r) {
    const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
    for (const t of r)
      for (const n of t)
        Qe(e, n);
    return e;
  }
  function an(r) {
    return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;
  }
  function Lr(r, e, t) {
    if (!an(r) || !an(e))
      return NaN;
    let n = 0, a = 0;
    return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);
  }
  function Le(r, e, t) {
    const n = t.pointOnLine(e, r);
    return t.distance(r, n.point);
  }
  function Cr(r, e, t, n, a) {
    const o = Math.min(Le(r, [t, n], a), Le(e, [t, n], a)), i = Math.min(Le(t, [r, e], a), Le(n, [r, e], a));
    return Math.min(o, i);
  }
  function Ji(r, e, t, n, a) {
    if (!(de(e, r.length) && de(n, t.length)))
      return 1 / 0;
    let i = 1 / 0;
    for (let s = e[0]; s < e[1]; ++s) {
      const l = r[s], u = r[s + 1];
      for (let c = n[0]; c < n[1]; ++c) {
        const p = t[c], y = t[c + 1];
        if (Mt(l, u, p, y))
          return 0;
        i = Math.min(i, Cr(l, u, p, y, a));
      }
    }
    return i;
  }
  function Yi(r, e, t, n, a) {
    if (!(de(e, r.length) && de(n, t.length)))
      return NaN;
    let i = 1 / 0;
    for (let s = e[0]; s <= e[1]; ++s)
      for (let l = n[0]; l <= n[1]; ++l)
        if (i = Math.min(i, a.distance(r[s], t[l])), i === 0)
          return i;
    return i;
  }
  function Xi(r, e, t) {
    if (Fe(r, e, true))
      return 0;
    let n = 1 / 0;
    for (const a of e) {
      const o = a[0], i = a[a.length - 1];
      if (o !== i && (n = Math.min(n, Le(r, [i, o], t)), n === 0))
        return n;
      const s = t.pointOnLine(a, r);
      if (n = Math.min(n, t.distance(r, s.point)), n === 0)
        return n;
    }
    return n;
  }
  function Qi(r, e, t, n) {
    if (!de(e, r.length))
      return NaN;
    for (let o = e[0]; o <= e[1]; ++o)
      if (Fe(r[o], t, true))
        return 0;
    let a = 1 / 0;
    for (let o = e[0]; o < e[1]; ++o) {
      const i = r[o], s = r[o + 1];
      for (const l of t)
        for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {
          const y = l[p], f = l[u];
          if (Mt(i, s, y, f))
            return 0;
          a = Math.min(a, Cr(i, s, y, f, n));
        }
    }
    return a;
  }
  function on(r, e) {
    for (const t of r)
      for (const n of t)
        if (Fe(n, e, true))
          return true;
    return false;
  }
  function es(r, e, t, n = 1 / 0) {
    const a = tr(r), o = tr(e);
    if (n !== 1 / 0 && Lr(a, o, t) >= n)
      return n;
    if (We(a, o)) {
      if (on(r, e))
        return 0;
    } else if (on(e, r))
      return 0;
    let i = 1 / 0;
    for (const s of r)
      for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {
        const p = s[c], y = s[l];
        for (const f of e)
          for (let d = 0, m = f.length, v = m - 1; d < m; v = d++) {
            const w = f[v], b = f[d];
            if (Mt(p, y, w, b))
              return 0;
            i = Math.min(i, Cr(p, y, w, b, t));
          }
      }
    return i;
  }
  function sn(r, e, t, n, a, o) {
    if (!o)
      return;
    const i = Lr(er(n, o), a, t);
    i < e && r.push([i, o, [0, 0]]);
  }
  function it(r, e, t, n, a, o, i) {
    if (!o || !i)
      return;
    const s = Lr(er(n, o), er(a, i), t);
    s < e && r.push([s, o, i]);
  }
  function yt(r, e, t, n, a = 1 / 0) {
    let o = Math.min(n.distance(r[0], t[0][0]), a);
    if (o === 0)
      return o;
    const i = new Dn([[0, [0, r.length - 1], [0, 0]]], qn), s = tr(t);
    for (; i.length > 0; ) {
      const l = i.pop();
      if (l[0] >= o)
        continue;
      const u = l[1], c = e ? Xt : Yt;
      if (dt(u) <= c) {
        if (!de(u, r.length))
          return NaN;
        if (e) {
          const p = Qi(r, u, t, n);
          if (isNaN(p) || p === 0)
            return p;
          o = Math.min(o, p);
        } else
          for (let p = u[0]; p <= u[1]; ++p) {
            const y = Xi(r[p], t, n);
            if (o = Math.min(o, y), o === 0)
              return 0;
          }
      } else {
        const p = Qt(u, e);
        sn(i, o, n, r, s, p[0]), sn(i, o, n, r, s, p[1]);
      }
    }
    return o;
  }
  function mt(r, e, t, n, a, o = 1 / 0) {
    let i = Math.min(o, a.distance(r[0], t[0]));
    if (i === 0)
      return i;
    const s = new Dn([[0, [0, r.length - 1], [0, t.length - 1]]], qn);
    for (; s.length > 0; ) {
      const l = s.pop();
      if (l[0] >= i)
        continue;
      const u = l[1], c = l[2], p = e ? Xt : Yt, y = n ? Xt : Yt;
      if (dt(u) <= p && dt(c) <= y) {
        if (!de(u, r.length) && de(c, t.length))
          return NaN;
        let f;
        if (e && n)
          f = Ji(r, u, t, c, a), i = Math.min(i, f);
        else if (e && !n) {
          const d = r.slice(u[0], u[1] + 1);
          for (let m = c[0]; m <= c[1]; ++m)
            if (f = Le(t[m], d, a), i = Math.min(i, f), i === 0)
              return i;
        } else if (!e && n) {
          const d = t.slice(c[0], c[1] + 1);
          for (let m = u[0]; m <= u[1]; ++m)
            if (f = Le(r[m], d, a), i = Math.min(i, f), i === 0)
              return i;
        } else
          f = Yi(r, u, t, c, a), i = Math.min(i, f);
      } else {
        const f = Qt(u, e), d = Qt(c, n);
        it(s, i, a, r, t, f[0], d[0]), it(s, i, a, r, t, f[0], d[1]), it(s, i, a, r, t, f[1], d[0]), it(s, i, a, r, t, f[1], d[1]);
      }
    }
    return i;
  }
  function ts(r, e) {
    const t = r.geometry(), n = t.flat().map((i) => Sr([i.x, i.y], r.canonical));
    if (t.length === 0)
      return NaN;
    const a = new kr(n[0][1]);
    let o = 1 / 0;
    for (const i of e) {
      switch (i.type) {
        case "Point":
          o = Math.min(o, mt(n, false, [i.coordinates], false, a, o));
          break;
        case "LineString":
          o = Math.min(o, mt(n, false, i.coordinates, true, a, o));
          break;
        case "Polygon":
          o = Math.min(o, yt(n, false, i.coordinates, a, o));
          break;
      }
      if (o === 0)
        return o;
    }
    return o;
  }
  function rs(r, e) {
    const t = r.geometry(), n = t.flat().map((i) => Sr([i.x, i.y], r.canonical));
    if (t.length === 0)
      return NaN;
    const a = new kr(n[0][1]);
    let o = 1 / 0;
    for (const i of e) {
      switch (i.type) {
        case "Point":
          o = Math.min(o, mt(n, true, [i.coordinates], false, a, o));
          break;
        case "LineString":
          o = Math.min(o, mt(n, true, i.coordinates, true, a, o));
          break;
        case "Polygon":
          o = Math.min(o, yt(n, true, i.coordinates, a, o));
          break;
      }
      if (o === 0)
        return o;
    }
    return o;
  }
  function ns(r, e) {
    const t = r.geometry();
    if (t.length === 0 || t[0].length === 0)
      return NaN;
    const n = Ki(t).map((i) => i.map((s) => s.map((l) => Sr([l.x, l.y], r.canonical)))), a = new kr(n[0][0][0][1]);
    let o = 1 / 0;
    for (const i of e)
      for (const s of n) {
        switch (i.type) {
          case "Point":
            o = Math.min(o, yt([i.coordinates], false, s, a, o));
            break;
          case "LineString":
            o = Math.min(o, yt(i.coordinates, true, s, a, o));
            break;
          case "Polygon":
            o = Math.min(o, es(s, i.coordinates, a, o));
            break;
        }
        if (o === 0)
          return o;
      }
    return o;
  }
  function Vt(r) {
    return r.type === "MultiPolygon" ? r.coordinates.map((e) => ({
      type: "Polygon",
      coordinates: e
    })) : r.type === "MultiLineString" ? r.coordinates.map((e) => ({
      type: "LineString",
      coordinates: e
    })) : r.type === "MultiPoint" ? r.coordinates.map((e) => ({
      type: "Point",
      coordinates: e
    })) : [r];
  }
  function ln(r, [e, t, n, a]) {
    e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);
    const o = a ? a.evaluate(r) : 1, i = zn(e, t, n, o);
    if (i)
      throw new D(i);
    return new $(e / 255, t / 255, n / 255, o, false);
  }
  function un(r, e) {
    return r in e;
  }
  function Gt(r, e) {
    const t = e[r];
    return typeof t > "u" ? null : t;
  }
  function as(r, e, t, n) {
    for (; t <= n; ) {
      const a = t + n >> 1;
      if (e[a] === r)
        return true;
      e[a] > r ? n = a - 1 : t = a + 1;
    }
    return false;
  }
  function ke(r) {
    return { type: r };
  }
  function os(r) {
    return Array.isArray(r) ? `(${r.map(N).join(", ")})` : `(${N(r.type)}...)`;
  }
  function ht(r) {
    if (r instanceof Tt)
      return ht(r.boundExpression);
    if (r instanceof re && r.name === "error")
      return false;
    if (r instanceof Et)
      return false;
    if (r instanceof Ae)
      return false;
    if (r instanceof Te)
      return false;
    const e = r instanceof ge || r instanceof te;
    let t = true;
    return r.eachChild((n) => {
      e ? t = t && ht(n) : t = t && n instanceof je;
    }), t ? _t(r) && zt(r, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) : false;
  }
  function _t(r) {
    if (r instanceof re) {
      if (r.name === "get" && r.args.length === 1)
        return false;
      if (r.name === "feature-state")
        return false;
      if (r.name === "has" && r.args.length === 1)
        return false;
      if (r.name === "properties" || r.name === "geometry-type" || r.name === "id")
        return false;
      if (/^filter-/.test(r.name))
        return false;
    }
    if (r instanceof Ae || r instanceof Te)
      return false;
    let e = true;
    return r.eachChild((t) => {
      e && !_t(t) && (e = false);
    }), e;
  }
  function Ze(r) {
    if (r instanceof re && r.name === "feature-state")
      return false;
    let e = true;
    return r.eachChild((t) => {
      e && !Ze(t) && (e = false);
    }), e;
  }
  function zt(r, e) {
    if (r instanceof re && e.indexOf(r.name) >= 0)
      return false;
    let t = true;
    return r.eachChild((n) => {
      t && !zt(n, e) && (t = false);
    }), t;
  }
  function rr(r) {
    return { result: "success", value: r };
  }
  function Pe(r) {
    return { result: "error", value: r };
  }
  function gt(r) {
    return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
  }
  function Bn(r) {
    return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
  }
  function Un(r) {
    return !!r.expression && r.expression.interpolated;
  }
  function _(r) {
    return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
  }
  function Tr(r) {
    return typeof r == "object" && r !== null && !Array.isArray(r);
  }
  function Vn(r) {
    return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in Ar;
  }
  function Gn(r, e) {
    const t = new Ct(Ar, ht, [], e ? ls(e) : void 0), n = t.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
    return n ? rr(new is(n, e)) : Pe(t.errors);
  }
  function ss(r, e) {
    const t = Gn(r, e);
    if (t.result === "error")
      return t;
    const n = t.value.expression, a = _t(n);
    if (!a && !gt(e))
      return Pe([new oe("", "data expressions not supported")]);
    const o = zt(n, ["zoom"]);
    if (!o && !Bn(e))
      return Pe([new oe("", "zoom expressions not supported")]);
    const i = lt(n);
    if (!i && !o)
      return Pe([new oe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    if (i instanceof oe)
      return Pe([i]);
    if (i instanceof se && !Un(e))
      return Pe([new oe("", '"interpolate" expressions cannot be used with this property')]);
    if (!i)
      return rr(a ? new cn("constant", t.value) : new cn("source", t.value));
    const s = i instanceof se ? i.interpolation : void 0;
    return rr(a ? new pn("camera", t.value, i.labels, s) : new pn("composite", t.value, i.labels, s));
  }
  function lt(r) {
    let e = null;
    if (r instanceof At)
      e = lt(r.result);
    else if (r instanceof Ke) {
      for (const t of r.args)
        if (e = lt(t), e)
          break;
    } else (r instanceof It || r instanceof se) && r.input instanceof re && r.input.name === "zoom" && (e = r);
    return e instanceof oe || r.eachChild((t) => {
      const n = lt(t);
      n instanceof oe ? e = n : !e && n ? e = new oe("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new oe("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
    }), e;
  }
  function ls(r) {
    const e = {
      color: ie,
      string: I,
      number: g,
      enum: I,
      boolean: C,
      formatted: xt,
      padding: kt,
      projectionDefinition: wt,
      resolvedImage: Xe,
      variableAnchorOffsetCollection: Lt
    };
    return r.type === "array" ? W(e[r.value] || A, r.length) : e[r.type];
  }
  function us(r) {
    return r.type === "color" && Tr(r.default) ? new $(0, 0, 0, 0) : r.type === "color" ? $.parse(r.default) || null : r.type === "padding" ? J.parse(r.default) || null : r.type === "variableAnchorOffsetCollection" ? ne.parse(r.default) || null : r.type === "projectionDefinition" ? ee.parse(r.default) || null : r.default === void 0 ? null : r.default;
  }
  function Hn(r) {
    if (r === true || r === false)
      return true;
    if (!Array.isArray(r) || r.length === 0)
      return false;
    switch (r[0]) {
      case "has":
        return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
      case "in":
        return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
      case "!in":
      case "!has":
      case "none":
        return false;
      case "==":
      case "!=":
      case ">":
      case ">=":
      case "<":
      case "<=":
        return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
      case "any":
      case "all":
        for (const e of r.slice(1))
          if (!Hn(e) && typeof e != "boolean")
            return false;
        return true;
      default:
        return true;
    }
  }
  function Kn(r) {
    const e = r.key, t = r.value;
    return t ? [new h(e, t, "constants have been deprecated as of v8")] : [];
  }
  function F(r) {
    return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
  }
  function Ee(r) {
    if (Array.isArray(r))
      return r.map(Ee);
    if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
      const e = {};
      for (const t in r)
        e[t] = Ee(r[t]);
      return e;
    }
    return F(r);
  }
  function Y(r) {
    const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;
    let l = [];
    const u = _(t);
    if (u !== "object")
      return [new h(e, t, `object expected, ${u} found`)];
    for (const c in t) {
      const p = c.split(".")[0], y = n[p] || n["*"];
      let f;
      if (a[p])
        f = a[p];
      else if (n[p])
        f = s;
      else if (a["*"])
        f = a["*"];
      else if (n["*"])
        f = s;
      else {
        l.push(new h(e, t[c], `unknown property "${c}"`));
        continue;
      }
      l = l.concat(f({
        key: (e && `${e}.`) + c,
        value: t[c],
        valueSpec: y,
        style: o,
        styleSpec: i,
        object: t,
        objectKey: c,
        validateSpec: s
      }, t));
    }
    for (const c in n)
      a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new h(e, t, `missing required property "${c}"`));
    return l;
  }
  function Ir(r) {
    const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;
    if (_(e) !== "array")
      return [new h(i, e, `array expected, ${_(e)} found`)];
    if (t.length && e.length !== t.length)
      return [new h(i, e, `array length ${t.length} expected, length ${e.length} found`)];
    if (t["min-length"] && e.length < t["min-length"])
      return [new h(i, e, `array length at least ${t["min-length"]} expected, length ${e.length} found`)];
    let l = {
      type: t.value,
      values: t.values
    };
    o.$version < 7 && (l.function = t.function), _(t.value) === "object" && (l = t.value);
    let u = [];
    for (let c = 0; c < e.length; c++)
      u = u.concat(s({
        array: e,
        arrayIndex: c,
        value: e[c],
        valueSpec: l,
        validateSpec: r.validateSpec,
        style: a,
        styleSpec: o,
        key: `${i}[${c}]`
      }));
    return u;
  }
  function Er(r) {
    const e = r.key, t = r.value, n = r.valueSpec;
    let a = _(t);
    return a === "number" && t !== t && (a = "NaN"), a !== "number" ? [new h(e, t, `number expected, ${a} found`)] : "minimum" in n && t < n.minimum ? [new h(e, t, `${t} is less than the minimum value ${n.minimum}`)] : "maximum" in n && t > n.maximum ? [new h(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];
  }
  function Wn(r) {
    const e = r.valueSpec, t = F(r.value.type);
    let n, a = {}, o, i;
    const s = t !== "categorical" && r.value.property === void 0, l = !s, u = _(r.value.stops) === "array" && _(r.value.stops[0]) === "array" && _(r.value.stops[0][0]) === "object", c = Y({
      key: r.key,
      value: r.value,
      valueSpec: r.styleSpec.function,
      validateSpec: r.validateSpec,
      style: r.style,
      styleSpec: r.styleSpec,
      objectElementValidators: {
        stops: p,
        default: d
      }
    });
    return t === "identity" && s && c.push(new h(r.key, r.value, 'missing required property "property"')), t !== "identity" && !r.value.stops && c.push(new h(r.key, r.value, 'missing required property "stops"')), t === "exponential" && r.valueSpec.expression && !Un(r.valueSpec) && c.push(new h(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (l && !gt(r.valueSpec) ? c.push(new h(r.key, r.value, "property functions not supported")) : s && !Bn(r.valueSpec) && c.push(new h(r.key, r.value, "zoom functions not supported"))), (t === "categorical" || u) && r.value.property === void 0 && c.push(new h(r.key, r.value, '"property" property is required')), c;
    function p(m) {
      if (t === "identity")
        return [new h(m.key, m.value, 'identity function may not have a "stops" property')];
      let v = [];
      const w = m.value;
      return v = v.concat(Ir({
        key: m.key,
        value: w,
        valueSpec: m.valueSpec,
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec,
        arrayElementValidator: y
      })), _(w) === "array" && w.length === 0 && v.push(new h(m.key, w, "array must have at least one stop")), v;
    }
    function y(m) {
      let v = [];
      const w = m.value, b = m.key;
      if (_(w) !== "array")
        return [new h(b, w, `array expected, ${_(w)} found`)];
      if (w.length !== 2)
        return [new h(b, w, `array length 2 expected, length ${w.length} found`)];
      if (u) {
        if (_(w[0]) !== "object")
          return [new h(b, w, `object expected, ${_(w[0])} found`)];
        if (w[0].zoom === void 0)
          return [new h(b, w, "object stop key must have zoom")];
        if (w[0].value === void 0)
          return [new h(b, w, "object stop key must have value")];
        if (i && i > F(w[0].zoom))
          return [new h(b, w[0].zoom, "stop zoom values must appear in ascending order")];
        F(w[0].zoom) !== i && (i = F(w[0].zoom), o = void 0, a = {}), v = v.concat(Y({
          key: `${b}[0]`,
          value: w[0],
          valueSpec: { zoom: {} },
          validateSpec: m.validateSpec,
          style: m.style,
          styleSpec: m.styleSpec,
          objectElementValidators: { zoom: Er, value: f }
        }));
      } else
        v = v.concat(f({
          key: `${b}[0]`,
          value: w[0],
          valueSpec: {},
          validateSpec: m.validateSpec,
          style: m.style,
          styleSpec: m.styleSpec
        }, w));
      return Vn(Ee(w[1])) ? v.concat([new h(`${b}[1]`, w[1], "expressions are not allowed in function stops.")]) : v.concat(m.validateSpec({
        key: `${b}[1]`,
        value: w[1],
        valueSpec: e,
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec
      }));
    }
    function f(m, v) {
      const w = _(m.value), b = F(m.value), T = m.value !== null ? m.value : v;
      if (!n)
        n = w;
      else if (w !== n)
        return [new h(m.key, T, `${w} stop domain type must match previous stop domain type ${n}`)];
      if (w !== "number" && w !== "string" && w !== "boolean")
        return [new h(m.key, T, "stop domain value must be a number, string, or boolean")];
      if (w !== "number" && t !== "categorical") {
        let j = `number expected, ${w} found`;
        return gt(e) && t === void 0 && (j += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new h(m.key, T, j)];
      }
      return t === "categorical" && w === "number" && (!isFinite(b) || Math.floor(b) !== b) ? [new h(m.key, T, `integer expected, found ${b}`)] : t !== "categorical" && w === "number" && o !== void 0 && b < o ? [new h(m.key, T, "stop domain values must appear in ascending order")] : (o = b, t === "categorical" && b in a ? [new h(m.key, T, "stop domain values must be unique")] : (a[b] = true, []));
    }
    function d(m) {
      return m.validateSpec({
        key: m.key,
        value: m.value,
        valueSpec: e,
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec
      });
    }
  }
  function Ne(r) {
    const e = (r.expressionContext === "property" ? ss : Gn)(Ee(r.value), r.valueSpec);
    if (e.result === "error")
      return e.value.map((n) => new h(`${r.key}${n.key}`, r.value, n.message));
    const t = e.value.expression || e.value._styleExpression.expression;
    if (r.expressionContext === "property" && r.propertyKey === "text-font" && !t.outputDefined())
      return [new h(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
    if (r.expressionContext === "property" && r.propertyType === "layout" && !Ze(t))
      return [new h(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
    if (r.expressionContext === "filter" && !Ze(t))
      return [new h(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
    if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
      if (!zt(t, ["zoom", "feature-state"]))
        return [new h(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
      if (r.expressionContext === "cluster-initial" && !_t(t))
        return [new h(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
    }
    return [];
  }
  function cs(r) {
    const e = r.value, t = r.key, n = _(e);
    return n !== "boolean" ? [new h(t, e, `boolean expected, ${n} found`)] : [];
  }
  function ps(r) {
    const e = r.key, t = r.value, n = _(t);
    return n !== "string" ? [new h(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new h(e, t, `color expected, "${t}" found`)];
  }
  function Je(r) {
    const e = r.key, t = r.value, n = r.valueSpec, a = [];
    return Array.isArray(n.values) ? n.values.indexOf(F(t)) === -1 && a.push(new h(e, t, `expected one of [${n.values.join(", ")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(F(t)) === -1 && a.push(new h(e, t, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(t)} found`)), a;
  }
  function Mr(r) {
    return Hn(Ee(r.value)) ? Ne(ct({}, r, {
      expressionContext: "filter",
      valueSpec: { value: "boolean" }
    })) : Zn(r);
  }
  function Zn(r) {
    const e = r.value, t = r.key;
    if (_(e) !== "array")
      return [new h(t, e, `array expected, ${_(e)} found`)];
    const n = r.styleSpec;
    let a, o = [];
    if (e.length < 1)
      return [new h(t, e, "filter array must have at least 1 element")];
    switch (o = o.concat(Je({
      key: `${t}[0]`,
      value: e[0],
      valueSpec: n.filter_operator,
      style: r.style,
      styleSpec: r.styleSpec
    })), F(e[0])) {
      case "<":
      case "<=":
      case ">":
      case ">=":
        e.length >= 2 && F(e[1]) === "$type" && o.push(new h(t, e, `"$type" cannot be use with operator "${e[0]}"`));
      /* falls through */
      case "==":
      case "!=":
        e.length !== 3 && o.push(new h(t, e, `filter array for operator "${e[0]}" must have 3 elements`));
      /* falls through */
      case "in":
      case "!in":
        e.length >= 2 && (a = _(e[1]), a !== "string" && o.push(new h(`${t}[1]`, e[1], `string expected, ${a} found`)));
        for (let i = 2; i < e.length; i++)
          a = _(e[i]), F(e[1]) === "$type" ? o = o.concat(Je({
            key: `${t}[${i}]`,
            value: e[i],
            valueSpec: n.geometry_type,
            style: r.style,
            styleSpec: r.styleSpec
          })) : a !== "string" && a !== "number" && a !== "boolean" && o.push(new h(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));
        break;
      case "any":
      case "all":
      case "none":
        for (let i = 1; i < e.length; i++)
          o = o.concat(Zn({
            key: `${t}[${i}]`,
            value: e[i],
            style: r.style,
            styleSpec: r.styleSpec
          }));
        break;
      case "has":
      case "!has":
        a = _(e[1]), e.length !== 2 ? o.push(new h(t, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "string" && o.push(new h(`${t}[1]`, e[1], `string expected, ${a} found`));
        break;
    }
    return o;
  }
  function Jn(r, e) {
    const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];
    if (!l)
      return [];
    const u = s.match(/^(.*)-transition$/);
    if (e === "paint" && u && l[u[1]] && l[u[1]].transition)
      return n({
        key: t,
        value: i,
        valueSpec: o.transition,
        style: a,
        styleSpec: o
      });
    const c = r.valueSpec || l[s];
    if (!c)
      return [new h(t, i, `unknown property "${s}"`)];
    let p;
    if (_(i) === "string" && gt(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i)))
      return [new h(t, i, `"${s}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\`.`)];
    const y = [];
    return r.layerType === "symbol" && (s === "text-field" && a && !a.glyphs && y.push(new h(t, i, 'use of "text-field" requires a style "glyphs" property')), s === "text-font" && Tr(Ee(i)) && F(i.type) === "identity" && y.push(new h(t, i, '"text-font" does not support identity functions'))), y.concat(n({
      key: r.key,
      value: i,
      valueSpec: c,
      style: a,
      styleSpec: o,
      expressionContext: "property",
      propertyType: e,
      propertyKey: s
    }));
  }
  function Yn(r) {
    return Jn(r, "paint");
  }
  function Xn(r) {
    return Jn(r, "layout");
  }
  function Qn(r) {
    let e = [];
    const t = r.value, n = r.key, a = r.style, o = r.styleSpec;
    !t.type && !t.ref && e.push(new h(n, t, 'either "type" or "ref" is required'));
    let i = F(t.type);
    const s = F(t.ref);
    if (t.id) {
      const l = F(t.id);
      for (let u = 0; u < r.arrayIndex; u++) {
        const c = a.layers[u];
        F(c.id) === l && e.push(new h(n, t.id, `duplicate layer id "${t.id}", previously used at line ${c.id.__line__}`));
      }
    }
    if ("ref" in t) {
      ["type", "source", "source-layer", "filter", "layout"].forEach((u) => {
        u in t && e.push(new h(n, t[u], `"${u}" is prohibited for ref layers`));
      });
      let l;
      a.layers.forEach((u) => {
        F(u.id) === s && (l = u);
      }), l ? l.ref ? e.push(new h(n, t.ref, "ref cannot reference another ref layer")) : i = F(l.type) : e.push(new h(n, t.ref, `ref layer "${s}" not found`));
    } else if (i !== "background")
      if (!t.source)
        e.push(new h(n, t, 'missing required property "source"'));
      else {
        const l = a.sources && a.sources[t.source], u = l && F(l.type);
        l ? u === "vector" && i === "raster" ? e.push(new h(n, t.source, `layer "${t.id}" requires a raster source`)) : u !== "raster-dem" && i === "hillshade" ? e.push(new h(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u === "raster" && i !== "raster" ? e.push(new h(n, t.source, `layer "${t.id}" requires a vector source`)) : u === "vector" && !t["source-layer"] ? e.push(new h(n, t, `layer "${t.id}" must specify a "source-layer"`)) : u === "raster-dem" && i !== "hillshade" ? e.push(new h(n, t.source, "raster-dem source can only be used with layer type 'hillshade'.")) : i === "line" && t.paint && t.paint["line-gradient"] && (u !== "geojson" || !l.lineMetrics) && e.push(new h(n, t, `layer "${t.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new h(n, t.source, `source "${t.source}" not found`));
      }
    return e = e.concat(Y({
      key: n,
      value: t,
      valueSpec: o.layer,
      style: r.style,
      styleSpec: r.styleSpec,
      validateSpec: r.validateSpec,
      objectElementValidators: {
        "*"() {
          return [];
        },
        // We don't want to enforce the spec's `"requires": true` for backward compatibility with refs;
        // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.
        type() {
          return r.validateSpec({
            key: `${n}.type`,
            value: t.type,
            valueSpec: o.layer.type,
            style: r.style,
            styleSpec: r.styleSpec,
            validateSpec: r.validateSpec,
            object: t,
            objectKey: "type"
          });
        },
        filter: Mr,
        layout(l) {
          return Y({
            layer: t,
            key: l.key,
            value: l.value,
            style: l.style,
            styleSpec: l.styleSpec,
            validateSpec: l.validateSpec,
            objectElementValidators: {
              "*"(u) {
                return Xn(ct({ layerType: i }, u));
              }
            }
          });
        },
        paint(l) {
          return Y({
            layer: t,
            key: l.key,
            value: l.value,
            style: l.style,
            styleSpec: l.styleSpec,
            validateSpec: l.validateSpec,
            objectElementValidators: {
              "*"(u) {
                return Yn(ct({ layerType: i }, u));
              }
            }
          });
        }
      }
    })), e;
  }
  function Me(r) {
    const e = r.value, t = r.key, n = _(e);
    return n !== "string" ? [new h(t, e, `string expected, ${n} found`)] : [];
  }
  function fs(r) {
    var e;
    const t = (e = r.sourceName) !== null && e !== void 0 ? e : "", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;
    let s = [];
    const l = _(n);
    if (n === void 0)
      return s;
    if (l !== "object")
      return s.push(new h("source_raster_dem", n, `object expected, ${l} found`)), s;
    const c = F(n.encoding) === "custom", p = ["redFactor", "greenFactor", "blueFactor", "baseShift"], y = r.value.encoding ? `"${r.value.encoding}"` : "Default";
    for (const f in n)
      !c && p.includes(f) ? s.push(new h(f, n[f], `In "${t}": "${f}" is only valid when "encoding" is set to "custom". ${y} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({
        key: f,
        value: n[f],
        valueSpec: o[f],
        validateSpec: r.validateSpec,
        style: i,
        styleSpec: a
      })) : s.push(new h(f, n[f], `unknown property "${f}"`));
    return s;
  }
  function ea(r) {
    const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;
    if (!e.type)
      return [new h(t, e, '"type" is required')];
    const i = F(e.type);
    let s;
    switch (i) {
      case "vector":
      case "raster":
        return s = Y({
          key: t,
          value: e,
          valueSpec: n[`source_${i.replace("-", "_")}`],
          style: r.style,
          styleSpec: n,
          objectElementValidators: fn,
          validateSpec: o
        }), s;
      case "raster-dem":
        return s = fs({
          sourceName: t,
          value: e,
          style: r.style,
          styleSpec: n,
          validateSpec: o
        }), s;
      case "geojson":
        if (s = Y({
          key: t,
          value: e,
          valueSpec: n.source_geojson,
          style: a,
          styleSpec: n,
          validateSpec: o,
          objectElementValidators: fn
        }), e.cluster)
          for (const l in e.clusterProperties) {
            const [u, c] = e.clusterProperties[l], p = typeof u == "string" ? [u, ["accumulated"], ["get", l]] : u;
            s.push(...Ne({
              key: `${t}.${l}.map`,
              value: c,
              validateSpec: o,
              expressionContext: "cluster-map"
            })), s.push(...Ne({
              key: `${t}.${l}.reduce`,
              value: p,
              validateSpec: o,
              expressionContext: "cluster-reduce"
            }));
          }
        return s;
      case "video":
        return Y({
          key: t,
          value: e,
          valueSpec: n.source_video,
          style: a,
          validateSpec: o,
          styleSpec: n
        });
      case "image":
        return Y({
          key: t,
          value: e,
          valueSpec: n.source_image,
          style: a,
          validateSpec: o,
          styleSpec: n
        });
      case "canvas":
        return [new h(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
      default:
        return Je({
          key: `${t}.type`,
          value: e.type,
          valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] },
          style: a,
          validateSpec: o,
          styleSpec: n
        });
    }
  }
  function ds({ key: r, value: e }) {
    if (_(e) === "string")
      return Me({ key: r, value: e });
    {
      const t = [];
      for (const n in e)
        t.push(...Me({ key: `${r}.${n}`, value: e[n] }));
      return t;
    }
  }
  function ta(r) {
    const e = r.value, t = r.styleSpec, n = t.light, a = r.style;
    let o = [];
    const i = _(e);
    if (e === void 0)
      return o;
    if (i !== "object")
      return o = o.concat([new h("light", e, `object expected, ${i} found`)]), o;
    for (const s in e) {
      const l = s.match(/^(.*)-transition$/);
      l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({
        key: s,
        value: e[s],
        valueSpec: t.transition,
        validateSpec: r.validateSpec,
        style: a,
        styleSpec: t
      })) : n[s] ? o = o.concat(r.validateSpec({
        key: s,
        value: e[s],
        valueSpec: n[s],
        validateSpec: r.validateSpec,
        style: a,
        styleSpec: t
      })) : o = o.concat([new h(s, e[s], `unknown property "${s}"`)]);
    }
    return o;
  }
  function ra(r) {
    const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = _(e);
    if (e === void 0)
      return [];
    if (o !== "object")
      return [new h("sky", e, `object expected, ${o} found`)];
    let i = [];
    for (const s in e)
      n[s] ? i = i.concat(r.validateSpec({
        key: s,
        value: e[s],
        valueSpec: n[s],
        style: a,
        styleSpec: t
      })) : i = i.concat([new h(s, e[s], `unknown property "${s}"`)]);
    return i;
  }
  function na(r) {
    const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;
    let o = [];
    const i = _(e);
    if (e === void 0)
      return o;
    if (i !== "object")
      return o = o.concat([new h("terrain", e, `object expected, ${i} found`)]), o;
    for (const s in e)
      n[s] ? o = o.concat(r.validateSpec({
        key: s,
        value: e[s],
        valueSpec: n[s],
        validateSpec: r.validateSpec,
        style: a,
        styleSpec: t
      })) : o = o.concat([new h(s, e[s], `unknown property "${s}"`)]);
    return o;
  }
  function ys(r) {
    return Me(r).length === 0 ? [] : Ne(r);
  }
  function ms(r) {
    return Me(r).length === 0 ? [] : Ne(r);
  }
  function hs(r) {
    const e = r.key, t = r.value;
    if (_(t) === "array") {
      if (t.length < 1 || t.length > 4)
        return [new h(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];
      const a = {
        type: "number"
      };
      let o = [];
      for (let i = 0; i < t.length; i++)
        o = o.concat(r.validateSpec({
          key: `${e}[${i}]`,
          value: t[i],
          validateSpec: r.validateSpec,
          valueSpec: a
        }));
      return o;
    } else
      return Er({
        key: e,
        value: t,
        valueSpec: {}
      });
  }
  function gs(r) {
    const e = r.key, t = r.value, n = _(t), a = r.styleSpec;
    if (n !== "array" || t.length < 1 || t.length % 2 !== 0)
      return [new h(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")];
    let o = [];
    for (let i = 0; i < t.length; i += 2)
      o = o.concat(Je({
        key: `${e}[${i}]`,
        value: t[i],
        valueSpec: a.layout_symbol["text-anchor"]
      })), o = o.concat(Ir({
        key: `${e}[${i + 1}]`,
        value: t[i + 1],
        valueSpec: {
          length: 2,
          value: "number"
        },
        validateSpec: r.validateSpec,
        style: r.style,
        styleSpec: a
      }));
    return o;
  }
  function aa(r) {
    let e = [];
    const t = r.value, n = r.key;
    if (Array.isArray(t)) {
      const a = [], o = [];
      for (const i in t) {
        t[i].id && a.includes(t[i].id) && e.push(new h(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new h(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);
        const s = {
          id: {
            type: "string",
            required: true
          },
          url: {
            type: "string",
            required: true
          }
        };
        e = e.concat(Y({
          key: `${n}[${i}]`,
          value: t[i],
          valueSpec: s,
          validateSpec: r.validateSpec
        }));
      }
      return e;
    } else
      return Me({
        key: n,
        value: t
      });
  }
  function vs(r) {
    const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = _(e);
    if (e === void 0)
      return [];
    if (o !== "object")
      return [new h("projection", e, `object expected, ${o} found`)];
    let i = [];
    for (const s in e)
      n[s] ? i = i.concat(r.validateSpec({
        key: s,
        value: e[s],
        valueSpec: n[s],
        style: a,
        styleSpec: t
      })) : i = i.concat([new h(s, e[s], `unknown property "${s}"`)]);
    return i;
  }
  function bs(r) {
    const e = r.key;
    let t = r.value;
    t = t instanceof String ? t.valueOf() : t;
    const n = _(t);
    return n === "array" && !Ss(t) && !ws(t) ? [new h(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : ["array", "string"].includes(n) ? [] : [new h(e, t, `projection expected, invalid type "${n}" found`)];
  }
  function ws(r) {
    return !!["interpolate", "step", "literal"].includes(r[0]);
  }
  function Ss(r) {
    return Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && typeof r[1] == "string" && typeof r[2] == "number";
  }
  function Ue(r) {
    const e = r.value, t = r.valueSpec, n = r.styleSpec;
    return r.validateSpec = Ue, t.expression && Tr(F(e)) ? Wn(r) : t.expression && Vn(Ee(e)) ? Ne(r) : t.type && dn[t.type] ? dn[t.type](r) : Y(ct({}, r, {
      valueSpec: t.type ? n[t.type] : t
    }));
  }
  function oa(r) {
    const e = r.value, t = r.key, n = Me(r);
    return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new h(t, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && n.push(new h(t, e, '"glyphs" url must include a "{range}" token'))), n;
  }
  function X(r, e = Xo) {
    let t = [];
    return t = t.concat(Ue({
      key: "",
      value: r,
      valueSpec: e.$root,
      styleSpec: e,
      style: r,
      validateSpec: Ue,
      objectElementValidators: {
        glyphs: oa,
        "*"() {
          return [];
        }
      }
    })), r.constants && (t = t.concat(Kn({
      key: "constants",
      value: r.constants,
      style: r,
      styleSpec: e,
      validateSpec: Ue
    }))), ia(t);
  }
  function ue(r) {
    return function(e) {
      return r({
        ...e,
        validateSpec: Ue
      });
    };
  }
  function ia(r) {
    return [].concat(r).sort((e, t) => e.line - t.line);
  }
  function ce(r) {
    return function(...e) {
      return ia(r.apply(this, e));
    };
  }
  function yn(r) {
    if (!r)
      return {
        style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
        requiresUrlMonitoring: false,
        // default styles don't require URL monitoring
        isFallback: true
      };
    if (typeof r == "string") {
      const t = ks(r);
      return t.isValidStyle ? {
        style: t.styleObject,
        requiresUrlMonitoring: false,
        isFallback: false
      } : t.isValidJSON ? {
        style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
        requiresUrlMonitoring: false,
        // default styles don't require URL monitoring
        isFallback: true
      } : r.startsWith("http") ? { style: r, requiresUrlMonitoring: true, isFallback: false } : r.toLowerCase().includes(".json") ? {
        style: xs(r),
        requiresUrlMonitoring: true,
        isFallback: false
      } : {
        style: expandMapStyle(r),
        requiresUrlMonitoring: true,
        isFallback: false
      };
    }
    return r instanceof MapStyleVariant ? {
      style: r.getExpandedStyleURL(),
      requiresUrlMonitoring: false,
      isFallback: false
    } : r instanceof ReferenceMapStyle ? {
      style: r.getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: false,
      isFallback: false
    } : X(r).length === 0 ? {
      style: r,
      requiresUrlMonitoring: false,
      isFallback: false
    } : {
      style: MapStyle[mapStylePresetList[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: false,
      // default styles don't require URL monitoring
      isFallback: true
    };
  }
  function xs(r) {
    try {
      return new URL(r).href;
    } catch {
    }
    return new URL(r, location.origin).href;
  }
  function ks(r) {
    try {
      const e = JSON.parse(r), t = X(e);
      return {
        isValidJSON: true,
        isValidStyle: t.length === 0,
        styleObject: t.length === 0 ? e : null
      };
    } catch {
      return {
        isValidJSON: false,
        isValidStyle: false,
        styleObject: null
      };
    }
  }
  function fe(r, e, t) {
    const n = window.document.createElement(r);
    return e !== void 0 && (n.className = e), t && t.appendChild(n), n;
  }
  function _r(r) {
    r.parentNode && r.parentNode.removeChild(r);
  }
  function st(r) {
    const e = r.toString(16);
    return e.length === 1 ? `0${e}` : e;
  }
  function al(r) {
    return `#${st(r[0])}${st(r[1])}${st(r[2])}${r.length === 4 ? st(r[3]) : ""}`;
  }
  var import_maplibre_gl, import_events, _a, jr, za, L, Rt, E, ye, xe, G, M, V, ur, qa, O, Kt, Wt, Ba, Ua, Va, Zt, qr, Nt, Br, gl, bl, wl, Sl, xl, kl, Ll, Cl, Al, Tl, io, so, Il, lo, uo, co, El, Ml, _l, zl, Pl, Rl, $l, jl, Nl, Hr, po, fo, yo, mo, ho, go, vo, bo, wo, So, xo, ko, Lo, Co, Ao, To, Io, Eo, Mo, _o, zo, Po, Ro, $o, jo, No, Oo, Fo, Do, qo, Bo, Uo, Vo, Go, Ho, Ko, Wo, Zo, Jo, Yo, Xo, h, oe, cr, bt, g, I, C, ie, wt, Re, A, Qo, St, xt, kt, Xe, Lt, ei, Ln, Cn, An, Tn, $e, In, ti, ri, ni, li, $, fr, ui, Jt, pe, J, D, ci, ne, we, ee, je, ot, te, Zr, ge, pi, Pn, Ct, At, Tt, dr, yr, pt, mr, hr, ft, It, Bt, Jr, yi, mi, se, Ke, Ti, Ii, Ei, Mi, _i, zi, Et, gr, vr, br, wr, le, Ae, Dn, Zi, tn, rn, nn, kr, Yt, Xt, Te, Ar, re, is, cn, pn, fn, dn, Ls, Cs, mn, hn, As, Ts, H, Q, me, he, K, Ye, B, sa, Z, la, Ht, Is, Es, Ms, _s, zs, Ps, Rs, $s, js, Ns, Os, Fs, Ds, qs, Bs, Us, Vs, Gs, Hs, Ks, zr, x, Sa, Dl, ql, Bl, Ul, Vl, Gl, Hl, Kl, Wl, Zl, Jl, Yl, Xl, Ql, eu, tu, ru, nu, au, ou, iu, su, lu, uu, cu, pu, fu, du, yu, mu, hu, gu, vu, bu, wu, Su, xu, ku, Lu, Cu, Au, Tu, Iu, Eu, Mu, _u, zu, Pu, Ru, $u, ju, Nu, Ou, Fu, Du, qu;
  var init_maptiler_sdk2 = __esm({
    "node_modules/@maptiler/sdk/dist/maptiler-sdk.mjs"() {
      import_maplibre_gl = __toESM(require_maplibre_gl(), 1);
      init_maptiler_client();
      init_maptiler_client();
      import_events = __toESM(require_events(), 1);
      init_esm_browser();
      init_base64();
      _a = Object.defineProperty;
      jr = (r) => {
        throw TypeError(r);
      };
      za = (r, e, t) => e in r ? _a(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
      L = (r, e, t) => za(r, typeof e != "symbol" ? e + "" : e, t);
      Rt = (r, e, t) => e.has(r) || jr("Cannot " + t);
      E = (r, e, t) => (Rt(r, e, "read from private field"), t ? t.call(r) : e.get(r));
      ye = (r, e, t) => e.has(r) ? jr("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t);
      xe = (r, e, t, n) => (Rt(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t);
      G = (r, e, t) => (Rt(r, e, "access private method"), t);
      M = {
        /**
         * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.
         * Note that if those two languages are the same, labels won't be duplicated.
         */
        VISITOR: {
          code: null,
          flag: "visitor",
          name: "Visitor",
          latin: true,
          isMode: true,
          geocoding: false
        },
        /**
         * Language mode to display labels in both the local language and English, concatenated.
         * Note that if those two languages are the same, labels won't be duplicated.
         */
        VISITOR_ENGLISH: {
          code: null,
          flag: "visitor_en",
          name: "Visitor English",
          latin: true,
          isMode: true,
          geocoding: false
        },
        /**
         * Language mode to display labels in a language enforced in the style.
         */
        STYLE: {
          code: null,
          flag: "style",
          name: "Style",
          latin: false,
          isMode: true,
          geocoding: false
        },
        /**
         * Language mode to display labels in a language enforced in the style. The language cannot be further modified.
         */
        STYLE_LOCK: {
          code: null,
          flag: "style_lock",
          name: "Style Lock",
          latin: false,
          isMode: true,
          geocoding: false
        },
        ...Language
      };
      V = {
        maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
        maptilerURL: "https://www.maptiler.com/",
        maptilerApiHost: "api.maptiler.com",
        telemetryURL: "https://api.maptiler.com/metrics",
        rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
        primaryLanguage: M.STYLE,
        secondaryLanguage: M.LOCAL,
        terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
        terrainSourceId: "maptiler-terrain"
      };
      Object.freeze(V);
      ur = v4_default();
      qa = class extends import_events.default {
        constructor() {
          super(...arguments);
          L(this, "primaryLanguage", V.primaryLanguage);
          L(this, "secondaryLanguage");
          L(this, "session", true);
          L(this, "caching", true);
          L(this, "telemetry", true);
          L(this, "_unit", "metric");
          L(this, "_apiKey", "");
        }
        /**
         * Set the unit system
         */
        set unit(t) {
          this._unit = t, this.emit("unit", t);
        }
        /**
         * Get the unit system
         */
        get unit() {
          return this._unit;
        }
        /**
         * Set the MapTiler Cloud API key
         */
        set apiKey(t) {
          this._apiKey = t, config.apiKey = t, this.emit("apiKey", t);
        }
        /**
         * Get the MapTiler Cloud API key
         */
        get apiKey() {
          return this._apiKey;
        }
        /**
         * Set a the custom fetch function to replace the default one
         */
        set fetch(t) {
          config.fetch = t;
        }
        /**
         * Get the fetch fucntion
         */
        get fetch() {
          return config.fetch;
        }
      };
      O = new qa();
      Kt = "localcache_source";
      Wt = "localcache";
      Ba = "maptiler_sdk";
      Ua = 1e3;
      Va = 100;
      Zt = typeof caches < "u";
      ({ addProtocol: qr } = import_maplibre_gl.default);
      Br = 0;
      gl = class extends import_maplibre_gl.default.Marker {
        addTo(e) {
          return super.addTo(e);
        }
      };
      bl = class extends import_maplibre_gl.default.Popup {
        addTo(e) {
          return super.addTo(e);
        }
      };
      wl = class extends import_maplibre_gl.default.Style {
        constructor(e, t = {}) {
          super(e, t);
        }
      };
      Sl = class extends import_maplibre_gl.default.CanvasSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      xl = class extends import_maplibre_gl.default.GeoJSONSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      kl = class extends import_maplibre_gl.default.ImageSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      Ll = class extends import_maplibre_gl.default.RasterTileSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      Cl = class extends import_maplibre_gl.default.RasterDEMTileSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      Al = class extends import_maplibre_gl.default.VectorTileSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      Tl = class extends import_maplibre_gl.default.VideoSource {
        onAdd(e) {
          super.onAdd(e);
        }
      };
      io = class extends import_maplibre_gl.default.NavigationControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      so = class extends import_maplibre_gl.default.GeolocateControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      Il = class extends import_maplibre_gl.default.AttributionControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      lo = class extends import_maplibre_gl.default.LogoControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      uo = class extends import_maplibre_gl.default.ScaleControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      co = class extends import_maplibre_gl.default.FullscreenControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      El = class extends import_maplibre_gl.default.TerrainControl {
        onAdd(e) {
          return super.onAdd(e);
        }
      };
      Ml = class extends import_maplibre_gl.default.BoxZoomHandler {
        constructor(e, t) {
          super(e, t);
        }
      };
      _l = class extends import_maplibre_gl.default.ScrollZoomHandler {
        constructor(e, t) {
          super(e, t);
        }
      };
      zl = class extends import_maplibre_gl.default.CooperativeGesturesHandler {
        constructor(e, t) {
          super(e, t);
        }
      };
      Pl = class extends import_maplibre_gl.default.KeyboardHandler {
        constructor(e) {
          super(e);
        }
      };
      Rl = class extends import_maplibre_gl.default.TwoFingersTouchPitchHandler {
        constructor(e) {
          super(e);
        }
      };
      $l = class extends import_maplibre_gl.default.MapWheelEvent {
        constructor(e, t, n) {
          super(e, t, n);
        }
      };
      jl = class extends import_maplibre_gl.default.MapTouchEvent {
        constructor(e, t, n) {
          super(e, t, n);
        }
      };
      Nl = class extends import_maplibre_gl.default.MapMouseEvent {
        constructor(e, t, n, a = {}) {
          super(e, t, n, a);
        }
      };
      Hr = class extends lo {
        constructor(t = {}) {
          super(t);
          L(this, "logoURL", "");
          L(this, "linkURL", "");
          this.logoURL = t.logoURL ?? V.maptilerLogoURL, this.linkURL = t.linkURL ?? V.maptilerURL;
        }
        onAdd(t) {
          this._map = t, this._compact = this.options.compact ?? false, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
          const n = window.document.createElement("a");
          return n.style.backgroundRepeat = "no-repeat", n.style.cursor = "pointer", n.style.display = "block", n.style.height = "23px", n.style.margin = "0 0 -4px -4px", n.style.overflow = "hidden", n.style.width = "88px", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = "100px 30px", n.style.width = "100px", n.style.height = "30px", n.target = "_blank", n.rel = "noopener", n.href = this.linkURL, n.setAttribute("aria-label", "MapTiler logo"), n.setAttribute("rel", "noopener"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
      };
      po = 8;
      fo = {
        version: {
          required: true,
          type: "enum",
          values: [
            8
          ]
        },
        name: {
          type: "string"
        },
        metadata: {
          type: "*"
        },
        center: {
          type: "array",
          value: "number"
        },
        centerAltitude: {
          type: "number"
        },
        zoom: {
          type: "number"
        },
        bearing: {
          type: "number",
          default: 0,
          period: 360,
          units: "degrees"
        },
        pitch: {
          type: "number",
          default: 0,
          units: "degrees"
        },
        roll: {
          type: "number",
          default: 0,
          units: "degrees"
        },
        light: {
          type: "light"
        },
        sky: {
          type: "sky"
        },
        projection: {
          type: "projection"
        },
        terrain: {
          type: "terrain"
        },
        sources: {
          required: true,
          type: "sources"
        },
        sprite: {
          type: "sprite"
        },
        glyphs: {
          type: "string"
        },
        transition: {
          type: "transition"
        },
        layers: {
          required: true,
          type: "array",
          value: "layer"
        }
      };
      yo = {
        "*": {
          type: "source"
        }
      };
      mo = [
        "source_vector",
        "source_raster",
        "source_raster_dem",
        "source_geojson",
        "source_video",
        "source_image"
      ];
      ho = {
        type: {
          required: true,
          type: "enum",
          values: {
            vector: {}
          }
        },
        url: {
          type: "string"
        },
        tiles: {
          type: "array",
          value: "string"
        },
        bounds: {
          type: "array",
          value: "number",
          length: 4,
          default: [
            -180,
            -85.051129,
            180,
            85.051129
          ]
        },
        scheme: {
          type: "enum",
          values: {
            xyz: {},
            tms: {}
          },
          default: "xyz"
        },
        minzoom: {
          type: "number",
          default: 0
        },
        maxzoom: {
          type: "number",
          default: 22
        },
        attribution: {
          type: "string"
        },
        promoteId: {
          type: "promoteId"
        },
        volatile: {
          type: "boolean",
          default: false
        },
        "*": {
          type: "*"
        }
      };
      go = {
        type: {
          required: true,
          type: "enum",
          values: {
            raster: {}
          }
        },
        url: {
          type: "string"
        },
        tiles: {
          type: "array",
          value: "string"
        },
        bounds: {
          type: "array",
          value: "number",
          length: 4,
          default: [
            -180,
            -85.051129,
            180,
            85.051129
          ]
        },
        minzoom: {
          type: "number",
          default: 0
        },
        maxzoom: {
          type: "number",
          default: 22
        },
        tileSize: {
          type: "number",
          default: 512,
          units: "pixels"
        },
        scheme: {
          type: "enum",
          values: {
            xyz: {},
            tms: {}
          },
          default: "xyz"
        },
        attribution: {
          type: "string"
        },
        volatile: {
          type: "boolean",
          default: false
        },
        "*": {
          type: "*"
        }
      };
      vo = {
        type: {
          required: true,
          type: "enum",
          values: {
            "raster-dem": {}
          }
        },
        url: {
          type: "string"
        },
        tiles: {
          type: "array",
          value: "string"
        },
        bounds: {
          type: "array",
          value: "number",
          length: 4,
          default: [
            -180,
            -85.051129,
            180,
            85.051129
          ]
        },
        minzoom: {
          type: "number",
          default: 0
        },
        maxzoom: {
          type: "number",
          default: 22
        },
        tileSize: {
          type: "number",
          default: 512,
          units: "pixels"
        },
        attribution: {
          type: "string"
        },
        encoding: {
          type: "enum",
          values: {
            terrarium: {},
            mapbox: {},
            custom: {}
          },
          default: "mapbox"
        },
        redFactor: {
          type: "number",
          default: 1
        },
        blueFactor: {
          type: "number",
          default: 1
        },
        greenFactor: {
          type: "number",
          default: 1
        },
        baseShift: {
          type: "number",
          default: 0
        },
        volatile: {
          type: "boolean",
          default: false
        },
        "*": {
          type: "*"
        }
      };
      bo = {
        type: {
          required: true,
          type: "enum",
          values: {
            geojson: {}
          }
        },
        data: {
          required: true,
          type: "*"
        },
        maxzoom: {
          type: "number",
          default: 18
        },
        attribution: {
          type: "string"
        },
        buffer: {
          type: "number",
          default: 128,
          maximum: 512,
          minimum: 0
        },
        filter: {
          type: "*"
        },
        tolerance: {
          type: "number",
          default: 0.375
        },
        cluster: {
          type: "boolean",
          default: false
        },
        clusterRadius: {
          type: "number",
          default: 50,
          minimum: 0
        },
        clusterMaxZoom: {
          type: "number"
        },
        clusterMinPoints: {
          type: "number"
        },
        clusterProperties: {
          type: "*"
        },
        lineMetrics: {
          type: "boolean",
          default: false
        },
        generateId: {
          type: "boolean",
          default: false
        },
        promoteId: {
          type: "promoteId"
        }
      };
      wo = {
        type: {
          required: true,
          type: "enum",
          values: {
            video: {}
          }
        },
        urls: {
          required: true,
          type: "array",
          value: "string"
        },
        coordinates: {
          required: true,
          type: "array",
          length: 4,
          value: {
            type: "array",
            length: 2,
            value: "number"
          }
        }
      };
      So = {
        type: {
          required: true,
          type: "enum",
          values: {
            image: {}
          }
        },
        url: {
          required: true,
          type: "string"
        },
        coordinates: {
          required: true,
          type: "array",
          length: 4,
          value: {
            type: "array",
            length: 2,
            value: "number"
          }
        }
      };
      xo = {
        id: {
          type: "string",
          required: true
        },
        type: {
          type: "enum",
          values: {
            fill: {},
            line: {},
            symbol: {},
            circle: {},
            heatmap: {},
            "fill-extrusion": {},
            raster: {},
            hillshade: {},
            background: {}
          },
          required: true
        },
        metadata: {
          type: "*"
        },
        source: {
          type: "string"
        },
        "source-layer": {
          type: "string"
        },
        minzoom: {
          type: "number",
          minimum: 0,
          maximum: 24
        },
        maxzoom: {
          type: "number",
          minimum: 0,
          maximum: 24
        },
        filter: {
          type: "filter"
        },
        layout: {
          type: "layout"
        },
        paint: {
          type: "paint"
        }
      };
      ko = [
        "layout_fill",
        "layout_line",
        "layout_circle",
        "layout_heatmap",
        "layout_fill-extrusion",
        "layout_symbol",
        "layout_raster",
        "layout_hillshade",
        "layout_background"
      ];
      Lo = {
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      Co = {
        "fill-sort-key": {
          type: "number",
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      Ao = {
        "circle-sort-key": {
          type: "number",
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      To = {
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      Io = {
        "line-cap": {
          type: "enum",
          values: {
            butt: {},
            round: {},
            square: {}
          },
          default: "butt",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "line-join": {
          type: "enum",
          values: {
            bevel: {},
            round: {},
            miter: {}
          },
          default: "miter",
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "line-miter-limit": {
          type: "number",
          default: 2,
          requires: [
            {
              "line-join": "miter"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "line-round-limit": {
          type: "number",
          default: 1.05,
          requires: [
            {
              "line-join": "round"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "line-sort-key": {
          type: "number",
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      Eo = {
        "symbol-placement": {
          type: "enum",
          values: {
            point: {},
            line: {},
            "line-center": {}
          },
          default: "point",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "symbol-spacing": {
          type: "number",
          default: 250,
          minimum: 1,
          units: "pixels",
          requires: [
            {
              "symbol-placement": "line"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "symbol-avoid-edges": {
          type: "boolean",
          default: false,
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "symbol-sort-key": {
          type: "number",
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "symbol-z-order": {
          type: "enum",
          values: {
            auto: {},
            "viewport-y": {},
            source: {}
          },
          default: "auto",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-allow-overlap": {
          type: "boolean",
          default: false,
          requires: [
            "icon-image",
            {
              "!": "icon-overlap"
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-overlap": {
          type: "enum",
          values: {
            never: {},
            always: {},
            cooperative: {}
          },
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-ignore-placement": {
          type: "boolean",
          default: false,
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-optional": {
          type: "boolean",
          default: false,
          requires: [
            "icon-image",
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-rotation-alignment": {
          type: "enum",
          values: {
            map: {},
            viewport: {},
            auto: {}
          },
          default: "auto",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-size": {
          type: "number",
          default: 1,
          minimum: 0,
          units: "factor of the original icon size",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-text-fit": {
          type: "enum",
          values: {
            none: {},
            width: {},
            height: {},
            both: {}
          },
          default: "none",
          requires: [
            "icon-image",
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-text-fit-padding": {
          type: "array",
          value: "number",
          length: 4,
          default: [
            0,
            0,
            0,
            0
          ],
          units: "pixels",
          requires: [
            "icon-image",
            "text-field",
            {
              "icon-text-fit": [
                "both",
                "width",
                "height"
              ]
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-image": {
          type: "resolvedImage",
          tokens: true,
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-rotate": {
          type: "number",
          default: 0,
          period: 360,
          units: "degrees",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-padding": {
          type: "padding",
          default: [
            2
          ],
          units: "pixels",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-keep-upright": {
          type: "boolean",
          default: false,
          requires: [
            "icon-image",
            {
              "icon-rotation-alignment": "map"
            },
            {
              "symbol-placement": [
                "line",
                "line-center"
              ]
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-offset": {
          type: "array",
          value: "number",
          length: 2,
          default: [
            0,
            0
          ],
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-anchor": {
          type: "enum",
          values: {
            center: {},
            left: {},
            right: {},
            top: {},
            bottom: {},
            "top-left": {},
            "top-right": {},
            "bottom-left": {},
            "bottom-right": {}
          },
          default: "center",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-pitch-alignment": {
          type: "enum",
          values: {
            map: {},
            viewport: {},
            auto: {}
          },
          default: "auto",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-pitch-alignment": {
          type: "enum",
          values: {
            map: {},
            viewport: {},
            auto: {}
          },
          default: "auto",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-rotation-alignment": {
          type: "enum",
          values: {
            map: {},
            viewport: {},
            "viewport-glyph": {},
            auto: {}
          },
          default: "auto",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-field": {
          type: "formatted",
          default: "",
          tokens: true,
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-font": {
          type: "array",
          value: "string",
          default: [
            "Open Sans Regular",
            "Arial Unicode MS Regular"
          ],
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-size": {
          type: "number",
          default: 16,
          minimum: 0,
          units: "pixels",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-max-width": {
          type: "number",
          default: 10,
          minimum: 0,
          units: "ems",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-line-height": {
          type: "number",
          default: 1.2,
          units: "ems",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-letter-spacing": {
          type: "number",
          default: 0,
          units: "ems",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-justify": {
          type: "enum",
          values: {
            auto: {},
            left: {},
            center: {},
            right: {}
          },
          default: "center",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-radial-offset": {
          type: "number",
          units: "ems",
          default: 0,
          requires: [
            "text-field"
          ],
          "property-type": "data-driven",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          }
        },
        "text-variable-anchor": {
          type: "array",
          value: "enum",
          values: {
            center: {},
            left: {},
            right: {},
            top: {},
            bottom: {},
            "top-left": {},
            "top-right": {},
            "bottom-left": {},
            "bottom-right": {}
          },
          requires: [
            "text-field",
            {
              "symbol-placement": [
                "point"
              ]
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-variable-anchor-offset": {
          type: "variableAnchorOffsetCollection",
          requires: [
            "text-field",
            {
              "symbol-placement": [
                "point"
              ]
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-anchor": {
          type: "enum",
          values: {
            center: {},
            left: {},
            right: {},
            top: {},
            bottom: {},
            "top-left": {},
            "top-right": {},
            "bottom-left": {},
            "bottom-right": {}
          },
          default: "center",
          requires: [
            "text-field",
            {
              "!": "text-variable-anchor"
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-max-angle": {
          type: "number",
          default: 45,
          units: "degrees",
          requires: [
            "text-field",
            {
              "symbol-placement": [
                "line",
                "line-center"
              ]
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-writing-mode": {
          type: "array",
          value: "enum",
          values: {
            horizontal: {},
            vertical: {}
          },
          requires: [
            "text-field",
            {
              "symbol-placement": [
                "point"
              ]
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-rotate": {
          type: "number",
          default: 0,
          period: 360,
          units: "degrees",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-padding": {
          type: "number",
          default: 2,
          minimum: 0,
          units: "pixels",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-keep-upright": {
          type: "boolean",
          default: true,
          requires: [
            "text-field",
            {
              "text-rotation-alignment": "map"
            },
            {
              "symbol-placement": [
                "line",
                "line-center"
              ]
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-transform": {
          type: "enum",
          values: {
            none: {},
            uppercase: {},
            lowercase: {}
          },
          default: "none",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-offset": {
          type: "array",
          value: "number",
          units: "ems",
          length: 2,
          default: [
            0,
            0
          ],
          requires: [
            "text-field",
            {
              "!": "text-radial-offset"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "data-driven"
        },
        "text-allow-overlap": {
          type: "boolean",
          default: false,
          requires: [
            "text-field",
            {
              "!": "text-overlap"
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-overlap": {
          type: "enum",
          values: {
            never: {},
            always: {},
            cooperative: {}
          },
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-ignore-placement": {
          type: "boolean",
          default: false,
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-optional": {
          type: "boolean",
          default: false,
          requires: [
            "text-field",
            "icon-image"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      Mo = {
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      _o = {
        visibility: {
          type: "enum",
          values: {
            visible: {},
            none: {}
          },
          default: "visible",
          "property-type": "constant"
        }
      };
      zo = {
        type: "array",
        value: "*"
      };
      Po = {
        type: "enum",
        values: {
          "==": {},
          "!=": {},
          ">": {},
          ">=": {},
          "<": {},
          "<=": {},
          in: {},
          "!in": {},
          all: {},
          any: {},
          none: {},
          has: {},
          "!has": {}
        }
      };
      Ro = {
        type: "enum",
        values: {
          Point: {},
          LineString: {},
          Polygon: {}
        }
      };
      $o = {
        type: "array",
        minimum: 0,
        maximum: 24,
        value: [
          "number",
          "color"
        ],
        length: 2
      };
      jo = {
        type: "array",
        value: "*",
        minimum: 1
      };
      No = {
        anchor: {
          type: "enum",
          default: "viewport",
          values: {
            map: {},
            viewport: {}
          },
          "property-type": "data-constant",
          transition: false,
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          }
        },
        position: {
          type: "array",
          default: [
            1.15,
            210,
            30
          ],
          length: 3,
          value: "number",
          "property-type": "data-constant",
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          }
        },
        color: {
          type: "color",
          "property-type": "data-constant",
          default: "#ffffff",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        intensity: {
          type: "number",
          "property-type": "data-constant",
          default: 0.5,
          minimum: 0,
          maximum: 1,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        }
      };
      Oo = {
        "sky-color": {
          type: "color",
          "property-type": "data-constant",
          default: "#88C6FC",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        "horizon-color": {
          type: "color",
          "property-type": "data-constant",
          default: "#ffffff",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        "fog-color": {
          type: "color",
          "property-type": "data-constant",
          default: "#ffffff",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        "fog-ground-blend": {
          type: "number",
          "property-type": "data-constant",
          default: 0.5,
          minimum: 0,
          maximum: 1,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        "horizon-fog-blend": {
          type: "number",
          "property-type": "data-constant",
          default: 0.8,
          minimum: 0,
          maximum: 1,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        "sky-horizon-blend": {
          type: "number",
          "property-type": "data-constant",
          default: 0.8,
          minimum: 0,
          maximum: 1,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        },
        "atmosphere-blend": {
          type: "number",
          "property-type": "data-constant",
          default: 0.8,
          minimum: 0,
          maximum: 1,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          transition: true
        }
      };
      Fo = {
        source: {
          type: "string",
          required: true
        },
        exaggeration: {
          type: "number",
          minimum: 0,
          default: 1
        }
      };
      Do = {
        type: {
          type: "projectionDefinition",
          default: "mercator",
          "property-type": "data-constant",
          transition: false,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          }
        }
      };
      qo = [
        "paint_fill",
        "paint_line",
        "paint_circle",
        "paint_heatmap",
        "paint_fill-extrusion",
        "paint_symbol",
        "paint_raster",
        "paint_hillshade",
        "paint_background"
      ];
      Bo = {
        "fill-antialias": {
          type: "boolean",
          default: true,
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "fill-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "fill-color": {
          type: "color",
          default: "#000000",
          transition: true,
          requires: [
            {
              "!": "fill-pattern"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "fill-outline-color": {
          type: "color",
          transition: true,
          requires: [
            {
              "!": "fill-pattern"
            },
            {
              "fill-antialias": true
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "fill-translate": {
          type: "array",
          value: "number",
          length: 2,
          default: [
            0,
            0
          ],
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "fill-translate-anchor": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "map",
          requires: [
            "fill-translate"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "fill-pattern": {
          type: "resolvedImage",
          transition: true,
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "cross-faded-data-driven"
        }
      };
      Uo = {
        "line-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "line-color": {
          type: "color",
          default: "#000000",
          transition: true,
          requires: [
            {
              "!": "line-pattern"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "line-translate": {
          type: "array",
          value: "number",
          length: 2,
          default: [
            0,
            0
          ],
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "line-translate-anchor": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "map",
          requires: [
            "line-translate"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "line-width": {
          type: "number",
          default: 1,
          minimum: 0,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "line-gap-width": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "line-offset": {
          type: "number",
          default: 0,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "line-blur": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "line-dasharray": {
          type: "array",
          value: "number",
          minimum: 0,
          transition: true,
          units: "line widths",
          requires: [
            {
              "!": "line-pattern"
            }
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "cross-faded"
        },
        "line-pattern": {
          type: "resolvedImage",
          transition: true,
          expression: {
            interpolated: false,
            parameters: [
              "zoom",
              "feature"
            ]
          },
          "property-type": "cross-faded-data-driven"
        },
        "line-gradient": {
          type: "color",
          transition: false,
          requires: [
            {
              "!": "line-dasharray"
            },
            {
              "!": "line-pattern"
            },
            {
              source: "geojson",
              has: {
                lineMetrics: true
              }
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "line-progress"
            ]
          },
          "property-type": "color-ramp"
        }
      };
      Vo = {
        "circle-radius": {
          type: "number",
          default: 5,
          minimum: 0,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "circle-color": {
          type: "color",
          default: "#000000",
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "circle-blur": {
          type: "number",
          default: 0,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "circle-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "circle-translate": {
          type: "array",
          value: "number",
          length: 2,
          default: [
            0,
            0
          ],
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "circle-translate-anchor": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "map",
          requires: [
            "circle-translate"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "circle-pitch-scale": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "map",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "circle-pitch-alignment": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "viewport",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "circle-stroke-width": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "circle-stroke-color": {
          type: "color",
          default: "#000000",
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "circle-stroke-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        }
      };
      Go = {
        "heatmap-radius": {
          type: "number",
          default: 30,
          minimum: 1,
          transition: true,
          units: "pixels",
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "heatmap-weight": {
          type: "number",
          default: 1,
          minimum: 0,
          transition: false,
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "heatmap-intensity": {
          type: "number",
          default: 1,
          minimum: 0,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "heatmap-color": {
          type: "color",
          default: [
            "interpolate",
            [
              "linear"
            ],
            [
              "heatmap-density"
            ],
            0,
            "rgba(0, 0, 255, 0)",
            0.1,
            "royalblue",
            0.3,
            "cyan",
            0.5,
            "lime",
            0.7,
            "yellow",
            1,
            "red"
          ],
          transition: false,
          expression: {
            interpolated: true,
            parameters: [
              "heatmap-density"
            ]
          },
          "property-type": "color-ramp"
        },
        "heatmap-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        }
      };
      Ho = {
        "icon-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-color": {
          type: "color",
          default: "#000000",
          transition: true,
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-halo-color": {
          type: "color",
          default: "rgba(0, 0, 0, 0)",
          transition: true,
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-halo-width": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-halo-blur": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "icon-translate": {
          type: "array",
          value: "number",
          length: 2,
          default: [
            0,
            0
          ],
          transition: true,
          units: "pixels",
          requires: [
            "icon-image"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "icon-translate-anchor": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "map",
          requires: [
            "icon-image",
            "icon-translate"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "text-color": {
          type: "color",
          default: "#000000",
          transition: true,
          overridable: true,
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "text-halo-color": {
          type: "color",
          default: "rgba(0, 0, 0, 0)",
          transition: true,
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "text-halo-width": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "text-halo-blur": {
          type: "number",
          default: 0,
          minimum: 0,
          transition: true,
          units: "pixels",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom",
              "feature",
              "feature-state"
            ]
          },
          "property-type": "data-driven"
        },
        "text-translate": {
          type: "array",
          value: "number",
          length: 2,
          default: [
            0,
            0
          ],
          transition: true,
          units: "pixels",
          requires: [
            "text-field"
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "text-translate-anchor": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "map",
          requires: [
            "text-field",
            "text-translate"
          ],
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        }
      };
      Ko = {
        "raster-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-hue-rotate": {
          type: "number",
          default: 0,
          period: 360,
          transition: true,
          units: "degrees",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-brightness-min": {
          type: "number",
          default: 0,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-brightness-max": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-saturation": {
          type: "number",
          default: 0,
          minimum: -1,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-contrast": {
          type: "number",
          default: 0,
          minimum: -1,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-resampling": {
          type: "enum",
          values: {
            linear: {},
            nearest: {}
          },
          default: "linear",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "raster-fade-duration": {
          type: "number",
          default: 300,
          minimum: 0,
          transition: false,
          units: "milliseconds",
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        }
      };
      Wo = {
        "hillshade-illumination-direction": {
          type: "number",
          default: 335,
          minimum: 0,
          maximum: 359,
          transition: false,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "hillshade-illumination-anchor": {
          type: "enum",
          values: {
            map: {},
            viewport: {}
          },
          default: "viewport",
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "hillshade-exaggeration": {
          type: "number",
          default: 0.5,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "hillshade-shadow-color": {
          type: "color",
          default: "#000000",
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "hillshade-highlight-color": {
          type: "color",
          default: "#FFFFFF",
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "hillshade-accent-color": {
          type: "color",
          default: "#000000",
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        }
      };
      Zo = {
        "background-color": {
          type: "color",
          default: "#000000",
          transition: true,
          requires: [
            {
              "!": "background-pattern"
            }
          ],
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        },
        "background-pattern": {
          type: "resolvedImage",
          transition: true,
          expression: {
            interpolated: false,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "cross-faded"
        },
        "background-opacity": {
          type: "number",
          default: 1,
          minimum: 0,
          maximum: 1,
          transition: true,
          expression: {
            interpolated: true,
            parameters: [
              "zoom"
            ]
          },
          "property-type": "data-constant"
        }
      };
      Jo = {
        duration: {
          type: "number",
          default: 300,
          minimum: 0,
          units: "milliseconds"
        },
        delay: {
          type: "number",
          default: 0,
          minimum: 0,
          units: "milliseconds"
        }
      };
      Yo = {
        "*": {
          type: "string"
        }
      };
      Xo = {
        $version: po,
        $root: fo,
        sources: yo,
        source: mo,
        source_vector: ho,
        source_raster: go,
        source_raster_dem: vo,
        source_geojson: bo,
        source_video: wo,
        source_image: So,
        layer: xo,
        layout: ko,
        layout_background: Lo,
        layout_fill: Co,
        layout_circle: Ao,
        layout_heatmap: To,
        "layout_fill-extrusion": {
          visibility: {
            type: "enum",
            values: {
              visible: {},
              none: {}
            },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_line: Io,
        layout_symbol: Eo,
        layout_raster: Mo,
        layout_hillshade: _o,
        filter: zo,
        filter_operator: Po,
        geometry_type: Ro,
        function: {
          expression: {
            type: "expression"
          },
          stops: {
            type: "array",
            value: "function_stop"
          },
          base: {
            type: "number",
            default: 1,
            minimum: 0
          },
          property: {
            type: "string",
            default: "$zoom"
          },
          type: {
            type: "enum",
            values: {
              identity: {},
              exponential: {},
              interval: {},
              categorical: {}
            },
            default: "exponential"
          },
          colorSpace: {
            type: "enum",
            values: {
              rgb: {},
              lab: {},
              hcl: {}
            },
            default: "rgb"
          },
          default: {
            type: "*",
            required: false
          }
        },
        function_stop: $o,
        expression: jo,
        light: No,
        sky: Oo,
        terrain: Fo,
        projection: Do,
        paint: qo,
        paint_fill: Bo,
        "paint_fill-extrusion": {
          "fill-extrusion-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: {
              interpolated: true,
              parameters: [
                "zoom"
              ]
            },
            "property-type": "data-constant"
          },
          "fill-extrusion-color": {
            type: "color",
            default: "#000000",
            transition: true,
            requires: [
              {
                "!": "fill-extrusion-pattern"
              }
            ],
            expression: {
              interpolated: true,
              parameters: [
                "zoom",
                "feature",
                "feature-state"
              ]
            },
            "property-type": "data-driven"
          },
          "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [
              0,
              0
            ],
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: [
                "zoom"
              ]
            },
            "property-type": "data-constant"
          },
          "fill-extrusion-translate-anchor": {
            type: "enum",
            values: {
              map: {},
              viewport: {}
            },
            default: "map",
            requires: [
              "fill-extrusion-translate"
            ],
            expression: {
              interpolated: false,
              parameters: [
                "zoom"
              ]
            },
            "property-type": "data-constant"
          },
          "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: true,
            expression: {
              interpolated: false,
              parameters: [
                "zoom",
                "feature"
              ]
            },
            "property-type": "cross-faded-data-driven"
          },
          "fill-extrusion-height": {
            type: "number",
            default: 0,
            minimum: 0,
            units: "meters",
            transition: true,
            expression: {
              interpolated: true,
              parameters: [
                "zoom",
                "feature",
                "feature-state"
              ]
            },
            "property-type": "data-driven"
          },
          "fill-extrusion-base": {
            type: "number",
            default: 0,
            minimum: 0,
            units: "meters",
            transition: true,
            requires: [
              "fill-extrusion-height"
            ],
            expression: {
              interpolated: true,
              parameters: [
                "zoom",
                "feature",
                "feature-state"
              ]
            },
            "property-type": "data-driven"
          },
          "fill-extrusion-vertical-gradient": {
            type: "boolean",
            default: true,
            transition: false,
            expression: {
              interpolated: false,
              parameters: [
                "zoom"
              ]
            },
            "property-type": "data-constant"
          }
        },
        paint_line: Uo,
        paint_circle: Vo,
        paint_heatmap: Go,
        paint_symbol: Ho,
        paint_raster: Ko,
        paint_hillshade: Wo,
        paint_background: Zo,
        transition: Jo,
        "property-type": {
          "data-driven": {
            type: "property-type"
          },
          "cross-faded": {
            type: "property-type"
          },
          "cross-faded-data-driven": {
            type: "property-type"
          },
          "color-ramp": {
            type: "property-type"
          },
          "data-constant": {
            type: "property-type"
          },
          constant: {
            type: "property-type"
          }
        },
        promoteId: Yo
      };
      h = class {
        constructor(e, t, n, a) {
          this.message = (e ? `${e}: ` : "") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);
        }
      };
      oe = class extends Error {
        constructor(e, t) {
          super(t), this.message = t, this.key = e;
        }
      };
      cr = class _cr {
        constructor(e, t = []) {
          this.parent = e, this.bindings = {};
          for (const [n, a] of t)
            this.bindings[n] = a;
        }
        concat(e) {
          return new _cr(this, e);
        }
        get(e) {
          if (this.bindings[e])
            return this.bindings[e];
          if (this.parent)
            return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return this.bindings[e] ? true : this.parent ? this.parent.has(e) : false;
        }
      };
      bt = { kind: "null" };
      g = { kind: "number" };
      I = { kind: "string" };
      C = { kind: "boolean" };
      ie = { kind: "color" };
      wt = { kind: "projectionDefinition" };
      Re = { kind: "object" };
      A = { kind: "value" };
      Qo = { kind: "error" };
      St = { kind: "collator" };
      xt = { kind: "formatted" };
      kt = { kind: "padding" };
      Xe = { kind: "resolvedImage" };
      Lt = { kind: "variableAnchorOffsetCollection" };
      ei = [
        bt,
        g,
        I,
        C,
        ie,
        wt,
        xt,
        Re,
        W(A),
        kt,
        Xe,
        Lt
      ];
      Ln = 0.96422;
      Cn = 1;
      An = 0.82521;
      Tn = 4 / 29;
      $e = 6 / 29;
      In = 3 * $e * $e;
      ti = $e * $e * $e;
      ri = Math.PI / 180;
      ni = 180 / Math.PI;
      li = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
      $ = class _$ {
        /**
         * @param r Red component premultiplied by `alpha` 0..1
         * @param g Green component premultiplied by `alpha` 0..1
         * @param b Blue component premultiplied by `alpha` 0..1
         * @param [alpha=1] Alpha component 0..1
         * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
         * been multiplied by alpha. If `true` nothing happens if `false` then they will
         * be multiplied automatically.
         */
        constructor(e, t, n, a = 1, o = true) {
          this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter("rgb", [e, t, n, a]));
        }
        /**
         * Parses CSS color strings and converts colors to sRGB color space if needed.
         * Officially supported color formats:
         * - keyword, e.g. 'aquamarine' or 'steelblue'
         * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
         * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
         * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
         *
         * @param input CSS color string to parse.
         * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
         */
        static parse(e) {
          if (e instanceof _$)
            return e;
          if (typeof e != "string")
            return;
          const t = si(e);
          if (t)
            return new _$(...t, false);
        }
        /**
         * Used in color interpolation and by 'to-rgba' expression.
         *
         * @returns Gien color, with reversed alpha blending, in sRGB color space.
         */
        get rgb() {
          const { r: e, g: t, b: n, a } = this, o = a || 1 / 0;
          return this.overwriteGetter("rgb", [e / o, t / o, n / o, a]);
        }
        /**
         * Used in color interpolation.
         *
         * @returns Gien color, with reversed alpha blending, in HCL color space.
         */
        get hcl() {
          return this.overwriteGetter("hcl", ai(this.rgb));
        }
        /**
         * Used in color interpolation.
         *
         * @returns Gien color, with reversed alpha blending, in LAB color space.
         */
        get lab() {
          return this.overwriteGetter("lab", Mn(this.rgb));
        }
        /**
         * Lazy getter pattern. When getter is called for the first time lazy value
         * is calculated and then overwrites getter function in given object instance.
         *
         * @example:
         * const redColor = Color.parse('red');
         * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
         * // the value of red in HCL space and invoke this `overwriteGetter` function
         * // which in turn will set a field with a key 'hcl' in the `redColor` object.
         * // In other words it will override `get hcl()` from its `Color` prototype
         * // with its own property: hcl = [calculated red value in hcl].
         * let y = redColor.hcl; // next call will no longer invoke getter but simply
         * // return the previously calculated value
         * x === y; // true - `x` is exactly the same object as `y`
         *
         * @param getterKey Getter key
         * @param lazyValue Lazily calculated value to be memoized by current instance
         * @private
         */
        overwriteGetter(e, t) {
          return Object.defineProperty(this, e, { value: t }), t;
        }
        /**
         * Used by 'to-string' expression.
         *
         * @returns Serialized color in format `rgba(r,g,b,a)`
         * where r,g,b are numbers within 0..255 and alpha is number within 1..0
         *
         * @example
         * var purple = new Color.parse('purple');
         * purple.toString; // = "rgba(128,0,128,1)"
         * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
         * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
         */
        toString() {
          const [e, t, n, a] = this.rgb;
          return `rgba(${[e, t, n].map((o) => Math.round(o * 255)).join(",")},${a})`;
        }
        static interpolate(e, t, n, a = "rgb") {
          switch (a) {
            case "rgb": {
              const [o, i, s, l] = Ge(e.rgb, t.rgb, n);
              return new _$(o, i, s, l, false);
            }
            case "hcl": {
              const [o, i, s, l] = e.hcl, [u, c, p, y] = t.hcl;
              let f, d;
              if (!isNaN(o) && !isNaN(u)) {
                let T = u - o;
                u > o && T > 180 ? T -= 360 : u < o && o - u > 180 && (T += 360), f = o + n * T;
              } else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (d = c)) : (f = o, (p === 1 || p === 0) && (d = i));
              const [m, v, w, b] = oi([
                f,
                d ?? ve(i, c, n),
                ve(s, p, n),
                ve(l, y, n)
              ]);
              return new _$(m, v, w, b, false);
            }
            case "lab": {
              const [o, i, s, l] = _n(Ge(e.lab, t.lab, n));
              return new _$(o, i, s, l, false);
            }
          }
        }
      };
      $.black = new $(0, 0, 0, 1);
      $.white = new $(1, 1, 1, 1);
      $.transparent = new $(0, 0, 0, 0);
      $.red = new $(1, 0, 0, 1);
      fr = class {
        constructor(e, t, n) {
          e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, t) {
          return this.collator.compare(e, t);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      };
      ui = ["bottom", "center", "top"];
      Jt = class {
        constructor(e, t, n, a, o, i) {
          this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;
        }
      };
      pe = class _pe {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new _pe([new Jt(e, null, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 ? true : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
        }
        static factory(e) {
          return e instanceof _pe ? e : _pe.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
      };
      J = class _J {
        constructor(e) {
          this.values = e.slice();
        }
        /**
         * Numeric padding values
         * @param input A padding value
         * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
         */
        static parse(e) {
          if (e instanceof _J)
            return e;
          if (typeof e == "number")
            return new _J([e, e, e, e]);
          if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
            for (const t of e)
              if (typeof t != "number")
                return;
            switch (e.length) {
              case 1:
                e = [e[0], e[0], e[0], e[0]];
                break;
              case 2:
                e = [e[0], e[1], e[0], e[1]];
                break;
              case 3:
                e = [e[0], e[1], e[2], e[1]];
                break;
            }
            return new _J(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(e, t, n) {
          return new _J(Ge(e.values, t.values, n));
        }
      };
      D = class {
        constructor(e) {
          this.name = "ExpressionEvaluationError", this.message = e;
        }
        toJSON() {
          return this.message;
        }
      };
      ci = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      ne = class _ne {
        constructor(e) {
          this.values = e.slice();
        }
        static parse(e) {
          if (e instanceof _ne)
            return e;
          if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
            for (let t = 0; t < e.length; t += 2) {
              const n = e[t], a = e[t + 1];
              if (typeof n != "string" || !ci.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != "number" || typeof a[1] != "number")
                return;
            }
            return new _ne(e);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(e, t, n) {
          const a = e.values, o = t.values;
          if (a.length !== o.length)
            throw new D(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
          const i = [];
          for (let s = 0; s < a.length; s += 2) {
            if (a[s] !== o[s])
              throw new D(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);
            i.push(a[s]);
            const [l, u] = a[s + 1], [c, p] = o[s + 1];
            i.push([ve(l, c, n), ve(u, p, n)]);
          }
          return new _ne(i);
        }
      };
      we = class _we {
        constructor(e) {
          this.name = e.name, this.available = e.available;
        }
        toString() {
          return this.name;
        }
        static fromString(e) {
          return e ? new _we({ name: e, available: false }) : null;
        }
      };
      ee = class _ee {
        constructor(e, t, n) {
          this.from = e, this.to = t, this.transition = n;
        }
        static interpolate(e, t, n) {
          return new _ee(e, t, n);
        }
        static parse(e) {
          if (e instanceof _ee)
            return e;
          if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number")
            return new _ee(e[0], e[1], e[2]);
          if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number")
            return new _ee(e.from, e.to, e.transition);
          if (typeof e == "string")
            return new _ee(e, e, 1);
        }
      };
      je = class _je {
        constructor(e, t) {
          this.type = e, this.value = t;
        }
        static parse(e, t) {
          if (e.length !== 2)
            return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!He(e[1]))
            return t.error("invalid value");
          const n = e[1];
          let a = q(n);
          const o = t.expectedType;
          return a.kind === "array" && a.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (a = o), new _je(a, n);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      };
      ot = {
        string: I,
        number: g,
        boolean: C,
        object: Re
      };
      te = class _te {
        constructor(e, t) {
          this.type = e, this.args = t;
        }
        static parse(e, t) {
          if (e.length < 2)
            return t.error("Expected at least one argument.");
          let n = 1, a;
          const o = e[0];
          if (o === "array") {
            let s;
            if (e.length > 2) {
              const u = e[1];
              if (typeof u != "string" || !(u in ot) || u === "object")
                return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
              s = ot[u], n++;
            } else
              s = A;
            let l;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
                return t.error('The length argument to "array" must be a positive integer literal', 2);
              l = e[2], n++;
            }
            a = W(s, l);
          } else {
            if (!ot[o])
              throw new Error(`Types doesn't contain name = ${o}`);
            a = ot[o];
          }
          const i = [];
          for (; n < e.length; n++) {
            const s = t.parse(e[n], n, A);
            if (!s)
              return null;
            i.push(s);
          }
          return new _te(a, i);
        }
        evaluate(e) {
          for (let t = 0; t < this.args.length; t++) {
            const n = this.args[t].evaluate(e);
            if (Ve(this.type, q(n))) {
              if (t === this.args.length - 1)
                throw new D(`Expected value to be of type ${N(this.type)}, but found ${N(q(n))} instead.`);
            } else return n;
          }
          throw new Error();
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      };
      Zr = {
        "to-boolean": C,
        "to-color": ie,
        "to-number": g,
        "to-string": I
      };
      ge = class _ge {
        constructor(e, t) {
          this.type = e, this.args = t;
        }
        static parse(e, t) {
          if (e.length < 2)
            return t.error("Expected at least one argument.");
          const n = e[0];
          if (!Zr[n])
            throw new Error(`Can't parse ${n} as it is not part of the known types`);
          if ((n === "to-boolean" || n === "to-string") && e.length !== 2)
            return t.error("Expected one argument.");
          const a = Zr[n], o = [];
          for (let i = 1; i < e.length; i++) {
            const s = t.parse(e[i], i, A);
            if (!s)
              return null;
            o.push(s);
          }
          return new _ge(a, o);
        }
        evaluate(e) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(e);
            case "color": {
              let t, n;
              for (const a of this.args) {
                if (t = a.evaluate(e), n = null, t instanceof $)
                  return t;
                if (typeof t == "string") {
                  const o = e.parseColor(t);
                  if (o)
                    return o;
                } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = zn(t[0], t[1], t[2], t[3]), !n))
                  return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
              }
              throw new D(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
            }
            case "padding": {
              let t;
              for (const n of this.args) {
                t = n.evaluate(e);
                const a = J.parse(t);
                if (a)
                  return a;
              }
              throw new D(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let t;
              for (const n of this.args) {
                t = n.evaluate(e);
                const a = ne.parse(t);
                if (a)
                  return a;
              }
              throw new D(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
            }
            case "number": {
              let t = null;
              for (const n of this.args) {
                if (t = n.evaluate(e), t === null)
                  return 0;
                const a = Number(t);
                if (!isNaN(a))
                  return a;
              }
              throw new D(`Could not convert ${JSON.stringify(t)} to number.`);
            }
            case "formatted":
              return pe.fromString(Be(this.args[0].evaluate(e)));
            case "resolvedImage":
              return we.fromString(Be(this.args[0].evaluate(e)));
            case "projectionDefinition":
              return this.args[0].evaluate(e);
            default:
              return Be(this.args[0].evaluate(e));
          }
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      };
      pi = ["Unknown", "Point", "LineString", "Polygon"];
      Pn = class {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? pi[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(e) {
          let t = this._parseColorCache[e];
          return t || (t = this._parseColorCache[e] = $.parse(e)), t;
        }
      };
      Ct = class _Ct {
        constructor(e, t, n = [], a, o = new cr(), i = []) {
          this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(""), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;
        }
        /**
         * @param expr the JSON expression to parse
         * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
         * @param options
         * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
         * @private
         */
        parse(e, t, n, a, o = {}) {
          return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);
        }
        _parse(e, t) {
          (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
          function n(a, o, i) {
            return i === "assert" ? new te(o, [a]) : i === "coerce" ? new ge(o, [a]) : a;
          }
          if (Array.isArray(e)) {
            if (e.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const a = e[0];
            if (typeof a != "string")
              return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const o = this.registry[a];
            if (o) {
              let i = o.parse(e, this);
              if (!i)
                return null;
              if (this.expectedType) {
                const s = this.expectedType, l = i.type;
                if ((s.kind === "string" || s.kind === "number" || s.kind === "boolean" || s.kind === "object" || s.kind === "array") && l.kind === "value")
                  i = n(i, s, t.typeAnnotation || "assert");
                else if (s.kind === "projectionDefinition" && (l.kind === "string" || l.kind === "array"))
                  i = n(i, s, t.typeAnnotation || "coerce");
                else if ((s.kind === "color" || s.kind === "formatted" || s.kind === "resolvedImage") && (l.kind === "value" || l.kind === "string"))
                  i = n(i, s, t.typeAnnotation || "coerce");
                else if (s.kind === "padding" && (l.kind === "value" || l.kind === "number" || l.kind === "array"))
                  i = n(i, s, t.typeAnnotation || "coerce");
                else if (s.kind === "variableAnchorOffsetCollection" && (l.kind === "value" || l.kind === "array"))
                  i = n(i, s, t.typeAnnotation || "coerce");
                else if (this.checkSubtype(s, l))
                  return null;
              }
              if (!(i instanceof je) && i.type.kind !== "resolvedImage" && this._isConstant(i)) {
                const s = new Pn();
                try {
                  i = new je(i.type, i.evaluate(s));
                } catch (l) {
                  return this.error(l.message), null;
                }
              }
              return i;
            }
            return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
          } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
        }
        /**
         * Returns a copy of this context suitable for parsing the subexpression at
         * index `index`, optionally appending to 'let' binding map.
         *
         * Note that `errors` property, intended for collecting errors while
         * parsing, is copied by reference rather than cloned.
         * @private
         */
        concat(e, t, n) {
          const a = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
          return new _Ct(this.registry, this._isConstant, a, t || null, o, this.errors);
        }
        /**
         * Push a parsing (or type checking) error into the `this.errors`
         * @param error The message
         * @param keys Optionally specify the source of the error at a child
         * of the current expression at `this.key`.
         * @private
         */
        error(e, ...t) {
          const n = `${this.key}${t.map((a) => `[${a}]`).join("")}`;
          this.errors.push(new oe(n, e));
        }
        /**
         * Returns null if `t` is a subtype of `expected`; otherwise returns an
         * error message and also pushes it to `this.errors`.
         * @param expected The expected type
         * @param t The actual type
         * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
         */
        checkSubtype(e, t) {
          const n = Ve(e, t);
          return n && this.error(n), n;
        }
      };
      At = class _At {
        constructor(e, t) {
          this.type = t.type, this.bindings = [].concat(e), this.result = t;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const t of this.bindings)
            e(t[1]);
          e(this.result);
        }
        static parse(e, t) {
          if (e.length < 4)
            return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const n = [];
          for (let o = 1; o < e.length - 1; o += 2) {
            const i = e[o];
            if (typeof i != "string")
              return t.error(`Expected string, but found ${typeof i} instead.`, o);
            if (/[^a-zA-Z0-9_]/.test(i))
              return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
            const s = t.parse(e[o + 1], o + 1);
            if (!s)
              return null;
            n.push([i, s]);
          }
          const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
          return a ? new _At(n, a) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      };
      Tt = class _Tt {
        constructor(e, t) {
          this.type = t.type, this.name = e, this.boundExpression = t;
        }
        static parse(e, t) {
          if (e.length !== 2 || typeof e[1] != "string")
            return t.error("'var' expression requires exactly one string literal argument.");
          const n = e[1];
          return t.scope.has(n) ? new _Tt(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      };
      dr = class _dr {
        constructor(e, t, n) {
          this.type = e, this.index = t, this.input = n;
        }
        static parse(e, t) {
          if (e.length !== 3)
            return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const n = t.parse(e[1], 1, g), a = t.parse(e[2], 2, W(t.expectedType || A));
          if (!n || !a)
            return null;
          const o = a.type;
          return new _dr(o.itemType, n, a);
        }
        evaluate(e) {
          const t = this.index.evaluate(e), n = this.input.evaluate(e);
          if (t < 0)
            throw new D(`Array index out of bounds: ${t} < 0.`);
          if (t >= n.length)
            throw new D(`Array index out of bounds: ${t} > ${n.length - 1}.`);
          if (t !== Math.floor(t))
            throw new D(`Array index must be an integer, but found ${t} instead.`);
          return n[t];
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return false;
        }
      };
      yr = class _yr {
        constructor(e, t) {
          this.type = C, this.needle = e, this.haystack = t;
        }
        static parse(e, t) {
          if (e.length !== 3)
            return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const n = t.parse(e[1], 1, A), a = t.parse(e[2], 2, A);
          return !n || !a ? null : pr(n.type, [C, I, g, bt, A]) ? new _yr(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${N(n.type)} instead`);
        }
        evaluate(e) {
          const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
          if (!n)
            return false;
          if (!Ce(t, ["boolean", "string", "number", "null"]))
            throw new D(`Expected first argument to be of type boolean, string, number or null, but found ${N(q(t))} instead.`);
          if (!Ce(n, ["string", "array"]))
            throw new D(`Expected second argument to be of type array or string, but found ${N(q(n))} instead.`);
          return n.indexOf(t) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return true;
        }
      };
      pt = class _pt {
        constructor(e, t, n) {
          this.type = g, this.needle = e, this.haystack = t, this.fromIndex = n;
        }
        static parse(e, t) {
          if (e.length <= 2 || e.length >= 5)
            return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const n = t.parse(e[1], 1, A), a = t.parse(e[2], 2, A);
          if (!n || !a)
            return null;
          if (!pr(n.type, [C, I, g, bt, A]))
            return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${N(n.type)} instead`);
          if (e.length === 4) {
            const o = t.parse(e[3], 3, g);
            return o ? new _pt(n, a, o) : null;
          } else
            return new _pt(n, a);
        }
        evaluate(e) {
          const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
          if (!Ce(t, ["boolean", "string", "number", "null"]))
            throw new D(`Expected first argument to be of type boolean, string, number or null, but found ${N(q(t))} instead.`);
          let a;
          if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ce(n, ["string"])) {
            const o = n.indexOf(t, a);
            return o === -1 ? -1 : [...n.slice(0, o)].length;
          } else {
            if (Ce(n, ["array"]))
              return n.indexOf(t, a);
            throw new D(`Expected second argument to be of type array or string, but found ${N(q(n))} instead.`);
          }
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
      };
      mr = class _mr {
        constructor(e, t, n, a, o, i) {
          this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;
        }
        static parse(e, t) {
          if (e.length < 5)
            return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 !== 1)
            return t.error("Expected an even number of arguments.");
          let n, a;
          t.expectedType && t.expectedType.kind !== "value" && (a = t.expectedType);
          const o = {}, i = [];
          for (let u = 2; u < e.length - 1; u += 2) {
            let c = e[u];
            const p = e[u + 1];
            Array.isArray(c) || (c = [c]);
            const y = t.concat(u);
            if (c.length === 0)
              return y.error("Expected at least one branch label.");
            for (const d of c) {
              if (typeof d != "number" && typeof d != "string")
                return y.error("Branch labels must be numbers or strings.");
              if (typeof d == "number" && Math.abs(d) > Number.MAX_SAFE_INTEGER)
                return y.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof d == "number" && Math.floor(d) !== d)
                return y.error("Numeric branch labels must be integer values.");
              if (!n)
                n = q(d);
              else if (y.checkSubtype(n, q(d)))
                return null;
              if (typeof o[String(d)] < "u")
                return y.error("Branch labels must be unique.");
              o[String(d)] = i.length;
            }
            const f = t.parse(p, u, a);
            if (!f)
              return null;
            a = a || f.type, i.push(f);
          }
          const s = t.parse(e[1], 1, A);
          if (!s)
            return null;
          const l = t.parse(e[e.length - 1], e.length - 1, a);
          return !l || s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new _mr(n, a, s, o, i, l);
        }
        evaluate(e) {
          const t = this.input.evaluate(e);
          return (q(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
      };
      hr = class _hr {
        constructor(e, t, n) {
          this.type = e, this.branches = t, this.otherwise = n;
        }
        static parse(e, t) {
          if (e.length < 4)
            return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 !== 0)
            return t.error("Expected an odd number of arguments.");
          let n;
          t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
          const a = [];
          for (let i = 1; i < e.length - 1; i += 2) {
            const s = t.parse(e[i], i, C);
            if (!s)
              return null;
            const l = t.parse(e[i + 1], i + 1, n);
            if (!l)
              return null;
            a.push([s, l]), n = n || l.type;
          }
          const o = t.parse(e[e.length - 1], e.length - 1, n);
          if (!o)
            return null;
          if (!n)
            throw new Error("Can't infer output type");
          return new _hr(n, a, o);
        }
        evaluate(e) {
          for (const [t, n] of this.branches)
            if (t.evaluate(e))
              return n.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [t, n] of this.branches)
            e(t), e(n);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
        }
      };
      ft = class _ft {
        constructor(e, t, n, a) {
          this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;
        }
        static parse(e, t) {
          if (e.length <= 2 || e.length >= 5)
            return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const n = t.parse(e[1], 1, A), a = t.parse(e[2], 2, g);
          if (!n || !a)
            return null;
          if (!pr(n.type, [W(A), I, A]))
            return t.error(`Expected first argument to be of type array or string, but found ${N(n.type)} instead`);
          if (e.length === 4) {
            const o = t.parse(e[3], 3, g);
            return o ? new _ft(n.type, n, a, o) : null;
          } else
            return new _ft(n.type, n, a);
        }
        evaluate(e) {
          const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
          let a;
          if (this.endIndex && (a = this.endIndex.evaluate(e)), Ce(t, ["string"]))
            return [...t].slice(n, a).join("");
          if (Ce(t, ["array"]))
            return t.slice(n, a);
          throw new D(`Expected first argument to be of type array or string, but found ${N(q(t))} instead.`);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return false;
        }
      };
      It = class _It {
        constructor(e, t, n) {
          this.type = e, this.input = t, this.labels = [], this.outputs = [];
          for (const [a, o] of n)
            this.labels.push(a), this.outputs.push(o);
        }
        static parse(e, t) {
          if (e.length - 1 < 4)
            return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 !== 0)
            return t.error("Expected an even number of arguments.");
          const n = t.parse(e[1], 1, g);
          if (!n)
            return null;
          const a = [];
          let o = null;
          t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
          for (let i = 1; i < e.length; i += 2) {
            const s = i === 1 ? -1 / 0 : e[i], l = e[i + 1], u = i, c = i + 1;
            if (typeof s != "number")
              return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);
            if (a.length && a[a.length - 1][0] >= s)
              return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u);
            const p = t.parse(l, c, o);
            if (!p)
              return null;
            o = o || p.type, a.push([s, p]);
          }
          return new _It(o, n, a);
        }
        evaluate(e) {
          const t = this.labels, n = this.outputs;
          if (t.length === 1)
            return n[0].evaluate(e);
          const a = this.input.evaluate(e);
          if (a <= t[0])
            return n[0].evaluate(e);
          const o = t.length;
          if (a >= t[o - 1])
            return n[o - 1].evaluate(e);
          const i = Rn(t, a);
          return n[i].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const t of this.outputs)
            e(t);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      };
      yi = di();
      mi = /* @__PURE__ */ fi(yi);
      se = class _se {
        constructor(e, t, n, a, o) {
          this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
          for (const [i, s] of o)
            this.labels.push(i), this.outputs.push(s);
        }
        static interpolationFactor(e, t, n, a) {
          let o = 0;
          if (e.name === "exponential")
            o = Ut(t, e.base, n, a);
          else if (e.name === "linear")
            o = Ut(t, 1, n, a);
          else if (e.name === "cubic-bezier") {
            const i = e.controlPoints;
            o = new mi(i[0], i[1], i[2], i[3]).solve(Ut(t, 1, n, a));
          }
          return o;
        }
        static parse(e, t) {
          let [n, a, o, ...i] = e;
          if (!Array.isArray(a) || a.length === 0)
            return t.error("Expected an interpolation type expression.", 1);
          if (a[0] === "linear")
            a = { name: "linear" };
          else if (a[0] === "exponential") {
            const u = a[1];
            if (typeof u != "number")
              return t.error("Exponential interpolation requires a numeric base.", 1, 1);
            a = {
              name: "exponential",
              base: u
            };
          } else if (a[0] === "cubic-bezier") {
            const u = a.slice(1);
            if (u.length !== 4 || u.some((c) => typeof c != "number" || c < 0 || c > 1))
              return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
            a = {
              name: "cubic-bezier",
              controlPoints: u
            };
          } else
            return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
          if (e.length - 1 < 4)
            return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 !== 0)
            return t.error("Expected an even number of arguments.");
          if (o = t.parse(o, 2, g), !o)
            return null;
          const s = [];
          let l = null;
          n === "interpolate-hcl" || n === "interpolate-lab" ? l = ie : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
          for (let u = 0; u < i.length; u += 2) {
            const c = i[u], p = i[u + 1], y = u + 3, f = u + 4;
            if (typeof c != "number")
              return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', y);
            if (s.length && s[s.length - 1][0] >= c)
              return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', y);
            const d = t.parse(p, f, l);
            if (!d)
              return null;
            l = l || d.type, s.push([c, d]);
          }
          return !_e(l, g) && !_e(l, wt) && !_e(l, ie) && !_e(l, kt) && !_e(l, Lt) && !_e(l, W(g)) ? t.error(`Type ${N(l)} is not interpolatable.`) : new _se(l, n, a, o, s);
        }
        evaluate(e) {
          const t = this.labels, n = this.outputs;
          if (t.length === 1)
            return n[0].evaluate(e);
          const a = this.input.evaluate(e);
          if (a <= t[0])
            return n[0].evaluate(e);
          const o = t.length;
          if (a >= t[o - 1])
            return n[o - 1].evaluate(e);
          const i = Rn(t, a), s = t[i], l = t[i + 1], u = _se.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);
          switch (this.operator) {
            case "interpolate":
              switch (this.type.kind) {
                case "number":
                  return ve(c, p, u);
                case "color":
                  return $.interpolate(c, p, u);
                case "padding":
                  return J.interpolate(c, p, u);
                case "variableAnchorOffsetCollection":
                  return ne.interpolate(c, p, u);
                case "array":
                  return Ge(c, p, u);
                case "projectionDefinition":
                  return ee.interpolate(c, p, u);
              }
            case "interpolate-hcl":
              return $.interpolate(c, p, u, "hcl");
            case "interpolate-lab":
              return $.interpolate(c, p, u, "lab");
          }
        }
        eachChild(e) {
          e(this.input);
          for (const t of this.outputs)
            e(t);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
      };
      $.interpolate, J.interpolate, ne.interpolate;
      Ke = class _Ke {
        constructor(e, t) {
          this.type = e, this.args = t;
        }
        static parse(e, t) {
          if (e.length < 2)
            return t.error("Expected at least one argument.");
          let n = null;
          const a = t.expectedType;
          a && a.kind !== "value" && (n = a);
          const o = [];
          for (const s of e.slice(1)) {
            const l = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: "omit" });
            if (!l)
              return null;
            n = n || l.type, o.push(l);
          }
          if (!n)
            throw new Error("No output type");
          return a && o.some((s) => Ve(a, s.type)) ? new _Ke(A, o) : new _Ke(n, o);
        }
        evaluate(e) {
          let t = null, n = 0, a;
          for (const o of this.args)
            if (n++, t = o.evaluate(e), t && t instanceof we && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null)
              break;
          return t;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
      };
      Ti = Oe("==", hi, $n);
      Ii = Oe("!=", gi, xi);
      Ei = Oe("<", vi, ki);
      Mi = Oe(">", bi, Li);
      _i = Oe("<=", wi, Ci);
      zi = Oe(">=", Si, Ai);
      Et = class _Et {
        constructor(e, t, n) {
          this.type = St, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
        }
        static parse(e, t) {
          if (e.length !== 2)
            return t.error("Expected one argument.");
          const n = e[1];
          if (typeof n != "object" || Array.isArray(n))
            return t.error("Collator options argument must be an object.");
          const a = t.parse(n["case-sensitive"] === void 0 ? false : n["case-sensitive"], 1, C);
          if (!a)
            return null;
          const o = t.parse(n["diacritic-sensitive"] === void 0 ? false : n["diacritic-sensitive"], 1, C);
          if (!o)
            return null;
          let i = null;
          return n.locale && (i = t.parse(n.locale, 1, I), !i) ? null : new _Et(a, o, i);
        }
        evaluate(e) {
          return new fr(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return false;
        }
      };
      gr = class _gr {
        constructor(e, t, n, a, o) {
          this.type = I, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;
        }
        static parse(e, t) {
          if (e.length !== 3)
            return t.error("Expected two arguments.");
          const n = t.parse(e[1], 1, g);
          if (!n)
            return null;
          const a = e[2];
          if (typeof a != "object" || Array.isArray(a))
            return t.error("NumberFormat options argument must be an object.");
          let o = null;
          if (a.locale && (o = t.parse(a.locale, 1, I), !o))
            return null;
          let i = null;
          if (a.currency && (i = t.parse(a.currency, 1, I), !i))
            return null;
          let s = null;
          if (a["min-fraction-digits"] && (s = t.parse(a["min-fraction-digits"], 1, g), !s))
            return null;
          let l = null;
          return a["max-fraction-digits"] && (l = t.parse(a["max-fraction-digits"], 1, g), !l) ? null : new _gr(n, o, i, s, l);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
            style: this.currency ? "currency" : "decimal",
            currency: this.currency ? this.currency.evaluate(e) : void 0,
            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
          }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
      };
      vr = class _vr {
        constructor(e) {
          this.type = xt, this.sections = e;
        }
        static parse(e, t) {
          if (e.length < 2)
            return t.error("Expected at least one argument.");
          const n = e[1];
          if (!Array.isArray(n) && typeof n == "object")
            return t.error("First argument must be an image or text section.");
          const a = [];
          let o = false;
          for (let i = 1; i <= e.length - 1; ++i) {
            const s = e[i];
            if (o && typeof s == "object" && !Array.isArray(s)) {
              o = false;
              let l = null;
              if (s["font-scale"] && (l = t.parse(s["font-scale"], 1, g), !l))
                return null;
              let u = null;
              if (s["text-font"] && (u = t.parse(s["text-font"], 1, W(I)), !u))
                return null;
              let c = null;
              if (s["text-color"] && (c = t.parse(s["text-color"], 1, ie), !c))
                return null;
              let p = null;
              if (s["vertical-align"]) {
                if (typeof s["vertical-align"] == "string" && !ui.includes(s["vertical-align"]))
                  return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s["vertical-align"]}' instead.`);
                if (p = t.parse(s["vertical-align"], 1, I), !p)
                  return null;
              }
              const y = a[a.length - 1];
              y.scale = l, y.font = u, y.textColor = c, y.verticalAlign = p;
            } else {
              const l = t.parse(e[i], 1, A);
              if (!l)
                return null;
              const u = l.type.kind;
              if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage")
                return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              o = true, a.push({ content: l, scale: null, font: null, textColor: null, verticalAlign: null });
            }
          }
          return new _vr(a);
        }
        evaluate(e) {
          const t = (n) => {
            const a = n.content.evaluate(e);
            return q(a) === Xe ? new Jt("", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new Jt(Be(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
          };
          return new pe(this.sections.map(t));
        }
        eachChild(e) {
          for (const t of this.sections)
            e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
        }
        outputDefined() {
          return false;
        }
      };
      br = class _br {
        constructor(e) {
          this.type = Xe, this.input = e;
        }
        static parse(e, t) {
          if (e.length !== 2)
            return t.error("Expected two arguments.");
          const n = t.parse(e[1], 1, I);
          return n ? new _br(n) : t.error("No image name provided.");
        }
        evaluate(e) {
          const t = this.input.evaluate(e), n = we.fromString(t);
          return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return false;
        }
      };
      wr = class _wr {
        constructor(e) {
          this.type = g, this.input = e;
        }
        static parse(e, t) {
          if (e.length !== 2)
            return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const n = t.parse(e[1], 1);
          return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${N(n.type)} instead.`) : new _wr(n) : null;
        }
        evaluate(e) {
          const t = this.input.evaluate(e);
          if (typeof t == "string")
            return [...t].length;
          if (Array.isArray(t))
            return t.length;
          throw new D(`Expected value to be of type string or array, but found ${N(q(t))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return false;
        }
      };
      le = 8192;
      Ae = class _Ae {
        constructor(e, t) {
          this.type = C, this.geojson = e, this.geometries = t;
        }
        static parse(e, t) {
          if (e.length !== 2)
            return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (He(e[1])) {
            const n = e[1];
            if (n.type === "FeatureCollection") {
              const a = [];
              for (const o of n.features) {
                const { type: i, coordinates: s } = o.geometry;
                i === "Polygon" && a.push(s), i === "MultiPolygon" && a.push(...s);
              }
              if (a.length) {
                const o = {
                  type: "MultiPolygon",
                  coordinates: a
                };
                return new _Ae(n, o);
              }
            } else if (n.type === "Feature") {
              const a = n.geometry.type;
              if (a === "Polygon" || a === "MultiPolygon")
                return new _Ae(n, n.geometry);
            } else if (n.type === "Polygon" || n.type === "MultiPolygon")
              return new _Ae(n, n);
          }
          return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point")
              return Gi(e, this.geometries);
            if (e.geometryType() === "LineString")
              return Hi(e, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      };
      Dn = class {
        constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
          if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)
            for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        }
        push(e) {
          this.data.push(e), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const e = this.data[0], t = this.data.pop();
          return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: t, compare: n } = this, a = t[e];
          for (; e > 0; ) {
            const o = e - 1 >> 1, i = t[o];
            if (n(a, i) >= 0) break;
            t[e] = i, e = o;
          }
          t[e] = a;
        }
        _down(e) {
          const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];
          for (; e < a; ) {
            let i = (e << 1) + 1;
            const s = i + 1;
            if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;
            t[e] = t[i], e = i;
          }
          t[e] = o;
        }
      };
      Zi = 6378.137;
      tn = 1 / 298.257223563;
      rn = tn * (2 - tn);
      nn = Math.PI / 180;
      kr = class {
        constructor(e) {
          const t = nn * Zi * 1e3, n = Math.cos(e * nn), a = 1 / (1 - rn * (1 - n * n)), o = Math.sqrt(a);
          this.kx = t * o * n, this.ky = t * o * a * (1 - rn);
        }
        /**
         * Given two points of the form [longitude, latitude], returns the distance.
         *
         * @param a - point [longitude, latitude]
         * @param b - point [longitude, latitude]
         * @returns distance
         * @example
         * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
         * //=distance
         */
        distance(e, t) {
          const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;
          return Math.sqrt(n * n + a * a);
        }
        /**
         * Returns an object of the form {point, index, t}, where point is closest point on the line
         * from the given point, index is the start index of the segment with the closest point,
         * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
         *
         * @param line - an array of points that form the line
         * @param p - point [longitude, latitude]
         * @returns the nearest point, its index in the array and the proportion along the line
         * @example
         * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
         * //=point
         */
        pointOnLine(e, t) {
          let n = 1 / 0, a, o, i, s;
          for (let l = 0; l < e.length - 1; l++) {
            let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, y = (e[l + 1][1] - c) * this.ky, f = 0;
            (p !== 0 || y !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * y) / (p * p + y * y), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += y / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, y = (t[1] - c) * this.ky;
            const d = p * p + y * y;
            d < n && (n = d, a = u, o = c, i = l, s = f);
          }
          return {
            point: [a, o],
            index: i,
            t: Math.max(0, Math.min(1, s))
          };
        }
        wrap(e) {
          for (; e < -180; )
            e += 360;
          for (; e > 180; )
            e -= 360;
          return e;
        }
      };
      Yt = 100;
      Xt = 50;
      Te = class _Te {
        constructor(e, t) {
          this.type = g, this.geojson = e, this.geometries = t;
        }
        static parse(e, t) {
          if (e.length !== 2)
            return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (He(e[1])) {
            const n = e[1];
            if (n.type === "FeatureCollection")
              return new _Te(n, n.features.map((a) => Vt(a.geometry)).flat());
            if (n.type === "Feature")
              return new _Te(n, Vt(n.geometry));
            if ("type" in n && "coordinates" in n)
              return new _Te(n, Vt(n));
          }
          return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point")
              return ts(e, this.geometries);
            if (e.geometryType() === "LineString")
              return rs(e, this.geometries);
            if (e.geometryType() === "Polygon")
              return ns(e, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      };
      Ar = {
        // special forms
        "==": Ti,
        "!=": Ii,
        ">": Mi,
        "<": Ei,
        ">=": zi,
        "<=": _i,
        array: te,
        at: dr,
        boolean: te,
        case: hr,
        coalesce: Ke,
        collator: Et,
        format: vr,
        image: br,
        in: yr,
        "index-of": pt,
        interpolate: se,
        "interpolate-hcl": se,
        "interpolate-lab": se,
        length: wr,
        let: At,
        literal: je,
        match: mr,
        number: te,
        "number-format": gr,
        object: te,
        slice: ft,
        step: It,
        string: te,
        "to-boolean": ge,
        "to-color": ge,
        "to-number": ge,
        "to-string": ge,
        var: Tt,
        within: Ae,
        distance: Te
      };
      re = class _re {
        constructor(e, t, n, a) {
          this.name = e, this.type = t, this._evaluate = n, this.args = a;
        }
        evaluate(e) {
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return false;
        }
        static parse(e, t) {
          const n = e[0], a = _re.definitions[n];
          if (!a)
            return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(([u]) => !Array.isArray(u) || // varags
          u.length === e.length - 1);
          let l = null;
          for (const [u, c] of s) {
            l = new Ct(t.registry, ht, t.path, null, t.scope);
            const p = [];
            let y = false;
            for (let f = 1; f < e.length; f++) {
              const d = e[f], m = Array.isArray(u) ? u[f - 1] : u.type, v = l.parse(d, 1 + p.length, m);
              if (!v) {
                y = true;
                break;
              }
              p.push(v);
            }
            if (!y) {
              if (Array.isArray(u) && u.length !== p.length) {
                l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);
                continue;
              }
              for (let f = 0; f < p.length; f++) {
                const d = Array.isArray(u) ? u[f] : u.type, m = p[f];
                l.concat(f + 1).checkSubtype(d, m.type);
              }
              if (l.errors.length === 0)
                return new _re(n, o, c, p);
            }
          }
          if (s.length === 1)
            t.errors.push(...l.errors);
          else {
            const c = (s.length ? s : i).map(([y]) => os(y)).join(" | "), p = [];
            for (let y = 1; y < e.length; y++) {
              const f = t.parse(e[y], 1 + p.length);
              if (!f)
                return null;
              p.push(N(f.type));
            }
            t.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, t) {
          _re.definitions = t;
          for (const n in t)
            e[n] = _re;
        }
      };
      re.register(Ar, {
        error: [
          Qo,
          [I],
          (r, [e]) => {
            throw new D(e.evaluate(r));
          }
        ],
        typeof: [
          I,
          [A],
          (r, [e]) => N(q(e.evaluate(r)))
        ],
        "to-rgba": [
          W(g, 4),
          [ie],
          (r, [e]) => {
            const [t, n, a, o] = e.evaluate(r).rgb;
            return [t * 255, n * 255, a * 255, o];
          }
        ],
        rgb: [
          ie,
          [g, g, g],
          ln
        ],
        rgba: [
          ie,
          [g, g, g, g],
          ln
        ],
        has: {
          type: C,
          overloads: [
            [
              [I],
              (r, [e]) => un(e.evaluate(r), r.properties())
            ],
            [
              [I, Re],
              (r, [e, t]) => un(e.evaluate(r), t.evaluate(r))
            ]
          ]
        },
        get: {
          type: A,
          overloads: [
            [
              [I],
              (r, [e]) => Gt(e.evaluate(r), r.properties())
            ],
            [
              [I, Re],
              (r, [e, t]) => Gt(e.evaluate(r), t.evaluate(r))
            ]
          ]
        },
        "feature-state": [
          A,
          [I],
          (r, [e]) => Gt(e.evaluate(r), r.featureState || {})
        ],
        properties: [
          Re,
          [],
          (r) => r.properties()
        ],
        "geometry-type": [
          I,
          [],
          (r) => r.geometryType()
        ],
        id: [
          A,
          [],
          (r) => r.id()
        ],
        zoom: [
          g,
          [],
          (r) => r.globals.zoom
        ],
        "heatmap-density": [
          g,
          [],
          (r) => r.globals.heatmapDensity || 0
        ],
        "line-progress": [
          g,
          [],
          (r) => r.globals.lineProgress || 0
        ],
        accumulated: [
          A,
          [],
          (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated
        ],
        "+": [
          g,
          ke(g),
          (r, e) => {
            let t = 0;
            for (const n of e)
              t += n.evaluate(r);
            return t;
          }
        ],
        "*": [
          g,
          ke(g),
          (r, e) => {
            let t = 1;
            for (const n of e)
              t *= n.evaluate(r);
            return t;
          }
        ],
        "-": {
          type: g,
          overloads: [
            [
              [g, g],
              (r, [e, t]) => e.evaluate(r) - t.evaluate(r)
            ],
            [
              [g],
              (r, [e]) => -e.evaluate(r)
            ]
          ]
        },
        "/": [
          g,
          [g, g],
          (r, [e, t]) => e.evaluate(r) / t.evaluate(r)
        ],
        "%": [
          g,
          [g, g],
          (r, [e, t]) => e.evaluate(r) % t.evaluate(r)
        ],
        ln2: [
          g,
          [],
          () => Math.LN2
        ],
        pi: [
          g,
          [],
          () => Math.PI
        ],
        e: [
          g,
          [],
          () => Math.E
        ],
        "^": [
          g,
          [g, g],
          (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))
        ],
        sqrt: [
          g,
          [g],
          (r, [e]) => Math.sqrt(e.evaluate(r))
        ],
        log10: [
          g,
          [g],
          (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10
        ],
        ln: [
          g,
          [g],
          (r, [e]) => Math.log(e.evaluate(r))
        ],
        log2: [
          g,
          [g],
          (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2
        ],
        sin: [
          g,
          [g],
          (r, [e]) => Math.sin(e.evaluate(r))
        ],
        cos: [
          g,
          [g],
          (r, [e]) => Math.cos(e.evaluate(r))
        ],
        tan: [
          g,
          [g],
          (r, [e]) => Math.tan(e.evaluate(r))
        ],
        asin: [
          g,
          [g],
          (r, [e]) => Math.asin(e.evaluate(r))
        ],
        acos: [
          g,
          [g],
          (r, [e]) => Math.acos(e.evaluate(r))
        ],
        atan: [
          g,
          [g],
          (r, [e]) => Math.atan(e.evaluate(r))
        ],
        min: [
          g,
          ke(g),
          (r, e) => Math.min(...e.map((t) => t.evaluate(r)))
        ],
        max: [
          g,
          ke(g),
          (r, e) => Math.max(...e.map((t) => t.evaluate(r)))
        ],
        abs: [
          g,
          [g],
          (r, [e]) => Math.abs(e.evaluate(r))
        ],
        round: [
          g,
          [g],
          (r, [e]) => {
            const t = e.evaluate(r);
            return t < 0 ? -Math.round(-t) : Math.round(t);
          }
        ],
        floor: [
          g,
          [g],
          (r, [e]) => Math.floor(e.evaluate(r))
        ],
        ceil: [
          g,
          [g],
          (r, [e]) => Math.ceil(e.evaluate(r))
        ],
        "filter-==": [
          C,
          [I, A],
          (r, [e, t]) => r.properties()[e.value] === t.value
        ],
        "filter-id-==": [
          C,
          [A],
          (r, [e]) => r.id() === e.value
        ],
        "filter-type-==": [
          C,
          [I],
          (r, [e]) => r.geometryType() === e.value
        ],
        "filter-<": [
          C,
          [I, A],
          (r, [e, t]) => {
            const n = r.properties()[e.value], a = t.value;
            return typeof n == typeof a && n < a;
          }
        ],
        "filter-id-<": [
          C,
          [A],
          (r, [e]) => {
            const t = r.id(), n = e.value;
            return typeof t == typeof n && t < n;
          }
        ],
        "filter->": [
          C,
          [I, A],
          (r, [e, t]) => {
            const n = r.properties()[e.value], a = t.value;
            return typeof n == typeof a && n > a;
          }
        ],
        "filter-id->": [
          C,
          [A],
          (r, [e]) => {
            const t = r.id(), n = e.value;
            return typeof t == typeof n && t > n;
          }
        ],
        "filter-<=": [
          C,
          [I, A],
          (r, [e, t]) => {
            const n = r.properties()[e.value], a = t.value;
            return typeof n == typeof a && n <= a;
          }
        ],
        "filter-id-<=": [
          C,
          [A],
          (r, [e]) => {
            const t = r.id(), n = e.value;
            return typeof t == typeof n && t <= n;
          }
        ],
        "filter->=": [
          C,
          [I, A],
          (r, [e, t]) => {
            const n = r.properties()[e.value], a = t.value;
            return typeof n == typeof a && n >= a;
          }
        ],
        "filter-id->=": [
          C,
          [A],
          (r, [e]) => {
            const t = r.id(), n = e.value;
            return typeof t == typeof n && t >= n;
          }
        ],
        "filter-has": [
          C,
          [A],
          (r, [e]) => e.value in r.properties()
        ],
        "filter-has-id": [
          C,
          [],
          (r) => r.id() !== null && r.id() !== void 0
        ],
        "filter-type-in": [
          C,
          [W(I)],
          (r, [e]) => e.value.indexOf(r.geometryType()) >= 0
        ],
        "filter-id-in": [
          C,
          [W(A)],
          (r, [e]) => e.value.indexOf(r.id()) >= 0
        ],
        "filter-in-small": [
          C,
          [I, W(A)],
          // assumes v is an array literal
          (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0
        ],
        "filter-in-large": [
          C,
          [I, W(A)],
          // assumes v is a array literal with values sorted in ascending order and of a single type
          (r, [e, t]) => as(r.properties()[e.value], t.value, 0, t.value.length - 1)
        ],
        all: {
          type: C,
          overloads: [
            [
              [C, C],
              (r, [e, t]) => e.evaluate(r) && t.evaluate(r)
            ],
            [
              ke(C),
              (r, e) => {
                for (const t of e)
                  if (!t.evaluate(r))
                    return false;
                return true;
              }
            ]
          ]
        },
        any: {
          type: C,
          overloads: [
            [
              [C, C],
              (r, [e, t]) => e.evaluate(r) || t.evaluate(r)
            ],
            [
              ke(C),
              (r, e) => {
                for (const t of e)
                  if (t.evaluate(r))
                    return true;
                return false;
              }
            ]
          ]
        },
        "!": [
          C,
          [C],
          (r, [e]) => !e.evaluate(r)
        ],
        "is-supported-script": [
          C,
          [I],
          // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
          (r, [e]) => {
            const t = r.globals && r.globals.isSupportedScript;
            return t ? t(e.evaluate(r)) : true;
          }
        ],
        upcase: [
          I,
          [I],
          (r, [e]) => e.evaluate(r).toUpperCase()
        ],
        downcase: [
          I,
          [I],
          (r, [e]) => e.evaluate(r).toLowerCase()
        ],
        concat: [
          I,
          ke(A),
          (r, e) => e.map((t) => Be(t.evaluate(r))).join("")
        ],
        "resolved-locale": [
          I,
          [St],
          (r, [e]) => e.evaluate(r).resolvedLocale()
        ]
      });
      is = class {
        constructor(e, t) {
          this.expression = e, this._warningHistory = {}, this._evaluator = new Pn(), this._defaultValue = t ? us(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null;
        }
        evaluateWithoutErrorHandling(e, t, n, a, o, i) {
          return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, t, n, a, o, i) {
          this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;
          try {
            const s = this.expression.evaluate(this._evaluator);
            if (s == null || typeof s == "number" && s !== s)
              return this._defaultValue;
            if (this._enumValues && !(s in this._enumValues))
              throw new D(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);
            return s;
          } catch (s) {
            return this._warningHistory[s.message] || (this._warningHistory[s.message] = true, typeof console < "u" && console.warn(s.message)), this._defaultValue;
          }
        }
      };
      cn = class {
        constructor(e, t) {
          this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !Ze(t.expression);
        }
        evaluateWithoutErrorHandling(e, t, n, a, o, i) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
        }
        evaluate(e, t, n, a, o, i) {
          return this._styleExpression.evaluate(e, t, n, a, o, i);
        }
      };
      pn = class {
        constructor(e, t, n, a) {
          this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !Ze(t.expression), this.interpolationType = a;
        }
        evaluateWithoutErrorHandling(e, t, n, a, o, i) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
        }
        evaluate(e, t, n, a, o, i) {
          return this._styleExpression.evaluate(e, t, n, a, o, i);
        }
        interpolationFactor(e, t, n) {
          return this.interpolationType ? se.interpolationFactor(this.interpolationType, e, t, n) : 0;
        }
      };
      fn = {
        promoteId: ds
      };
      dn = {
        "*"() {
          return [];
        },
        array: Ir,
        boolean: cs,
        number: Er,
        color: ps,
        constants: Kn,
        enum: Je,
        filter: Mr,
        function: Wn,
        layer: Qn,
        object: Y,
        source: ea,
        light: ta,
        sky: ra,
        terrain: na,
        projection: vs,
        projectionDefinition: bs,
        string: Me,
        formatted: ys,
        resolvedImage: ms,
        padding: hs,
        variableAnchorOffsetCollection: gs,
        sprite: aa
      };
      X.source = ce(ue(ea));
      X.sprite = ce(ue(aa));
      X.glyphs = ce(ue(oa));
      X.light = ce(ue(ta));
      X.sky = ce(ue(ra));
      X.terrain = ce(ue(na));
      X.layer = ce(ue(Qn));
      X.filter = ce(ue(Mr));
      X.paintProperty = ce(ue(Yn));
      X.layoutProperty = ce(ue(Xn));
      Ls = class {
        constructor() {
          L(this, "_map");
          L(this, "_container");
          L(this, "_terrainButton");
          Za(["_toggleTerrain", "_updateTerrainIcon"], this);
        }
        onAdd(e) {
          return this._map = e, this._container = fe("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = fe("button", "maplibregl-ctrl-terrain", this._container), fe("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          _r(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
        _toggleTerrain() {
          this._map.hasTerrain() ? this._map.disableTerrain() : this._map.enableTerrain(), this._updateTerrainIcon();
        }
        _updateTerrainIcon() {
          this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
        }
      };
      Cs = class extends io {
        constructor(t = {}) {
          super({
            showCompass: t.showCompass ?? true,
            showZoom: t.showZoom ?? true,
            visualizePitch: t.visualizePitch ?? true
          });
          L(this, "_rotateCompassArrow", () => {
            const t2 = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t2}deg)` : `rotate(${-t2}deg)`;
            this._compassIcon.style.transform = a;
          });
          this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (n) => {
            this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });
          }));
        }
        /**
         * Overloading: the button now stores its click callback so that we can later on delete it and replace it
         */
        _createButton(t, n) {
          const a = super._createButton(t, n);
          return a.clickFunction = n, a;
        }
      };
      mn = import_maplibre_gl.default.Marker;
      hn = import_maplibre_gl.default.LngLat;
      As = import_maplibre_gl.default.LngLatBounds;
      Ts = class extends so {
        constructor() {
          super(...arguments);
          L(this, "lastUpdatedCenter", new hn(0, 0));
          L(this, "_updateCamera", (t) => {
            var c;
            const n = new hn(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {
              bearing: this._map.getBearing(),
              ...this.options.fitBoundsOptions,
              linear: true
            }, s = this._map.getZoom();
            s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(As.fromLngLat(n, a), i, {
              geolocateSource: true
              // tag this camera change so it won't cause the control to change to background state
            });
            let l = false;
            const u = () => {
              l = true;
            };
            this._map.once("click", u), this._map.once("dblclick", u), this._map.once("dragstart", u), this._map.once("mousedown", u), this._map.once("touchstart", u), this._map.once("wheel", u), this._map.once("moveend", () => {
              this._map.off("click", u), this._map.off("dblclick", u), this._map.off("dragstart", u), this._map.off("mousedown", u), this._map.off("touchstart", u), this._map.off("wheel", u), !l && (this.lastUpdatedCenter = this._map.getCenter());
            });
          });
          L(this, "_finishSetupUI", (t) => {
            if (this._map) {
              if (t === false) {
                const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
              } else {
                const n = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = false, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = fe("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new mn({ element: this._dotElement }), this._circleElement = fe("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new mn({
                element: this._circleElement,
                pitchAlignment: "map"
              }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("moveend", (n) => {
                const a = n.originalEvent && n.originalEvent.type === "resize", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
                !n.geolocateSource && this._watchState === "ACTIVE_LOCK" && !a && o > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
              });
            }
          });
          L(this, "_onZoom", () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          });
        }
        _updateCircleRadius() {
          if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK")
            return;
          const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);
          this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
        }
        // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the
        // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.
        // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            case "BACKGROUND_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
      };
      Ht = class {
        constructor(e, t) {
          ye(this, B);
          ye(this, H);
          L(this, "map");
          ye(this, Q);
          ye(this, me);
          ye(this, he);
          ye(this, K, false);
          ye(this, Ye);
          e.style !== void 0 && xe(this, K, true), xe(this, H, {
            // set defaults
            zoomAdjust: -4,
            position: "top-right",
            // inherit map options
            ...t,
            // override any lingering control options
            forceNoAttributionControl: true,
            attributionControl: false,
            navigationControl: false,
            geolocateControl: false,
            maptilerLogo: false,
            minimap: false,
            hash: false,
            pitchAdjust: false,
            // override map options with new user defined minimap options
            ...e,
            containerStyle: {
              border: "1px solid #000",
              width: "400px",
              height: "300px",
              ...e.containerStyle ?? {}
            }
          }), e.lockZoom !== void 0 && (E(this, H).minZoom = e.lockZoom, E(this, H).maxZoom = e.lockZoom);
        }
        setStyle(e, t) {
          E(this, K) || this.map.setStyle(e, t), G(this, B, Z).call(this);
        }
        addLayer(e, t) {
          return E(this, K) || this.map.addLayer(e, t), G(this, B, Z).call(this), this.map;
        }
        moveLayer(e, t) {
          return E(this, K) || this.map.moveLayer(e, t), G(this, B, Z).call(this), this.map;
        }
        removeLayer(e) {
          return E(this, K) || this.map.removeLayer(e), G(this, B, Z).call(this), this;
        }
        setLayerZoomRange(e, t, n) {
          return E(this, K) || this.map.setLayerZoomRange(e, t, n), G(this, B, Z).call(this), this;
        }
        setFilter(e, t, n) {
          return E(this, K) || this.map.setFilter(e, t, n), G(this, B, Z).call(this), this;
        }
        setPaintProperty(e, t, n, a) {
          return E(this, K) || this.map.setPaintProperty(e, t, n, a), G(this, B, Z).call(this), this;
        }
        setLayoutProperty(e, t, n, a) {
          return E(this, K) || this.map.setLayoutProperty(e, t, n, a), G(this, B, Z).call(this), this;
        }
        setGlyphs(e, t) {
          return E(this, K) || this.map.setGlyphs(e, t), G(this, B, Z).call(this), this;
        }
        onAdd(e) {
          xe(this, Q, e), xe(this, me, fe("div", "maplibregl-ctrl maplibregl-ctrl-group"));
          for (const [t, n] of Object.entries(E(this, H).containerStyle))
            E(this, me).style.setProperty(t, n);
          return E(this, H).container = E(this, me), E(this, H).zoom = e.getZoom() + E(this, H).zoomAdjust, this.map = new zr(E(this, H)), this.map.once("style.load", () => {
            this.map.resize();
          }), this.map.once("load", () => {
            G(this, B, sa).call(this, E(this, H).parentRect), xe(this, Ye, G(this, B, la).call(this));
          }), E(this, me);
        }
        onRemove() {
          var e;
          (e = E(this, Ye)) == null || e.call(this), _r(E(this, me));
        }
      };
      H = /* @__PURE__ */ new WeakMap(), Q = /* @__PURE__ */ new WeakMap(), me = /* @__PURE__ */ new WeakMap(), he = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), Ye = /* @__PURE__ */ new WeakMap(), B = /* @__PURE__ */ new WeakSet(), sa = function(e) {
        e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (xe(this, he, {
          type: "Feature",
          properties: {
            name: "parentRect"
          },
          geometry: {
            type: "Polygon",
            coordinates: [[[], [], [], [], []]]
          }
        }), this.map.addSource("parentRect", {
          type: "geojson",
          data: E(this, he)
        }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({
          id: "parentRectOutline",
          type: "line",
          source: "parentRect",
          layout: {
            ...e.lineLayout
          },
          paint: {
            "line-color": "#FFF",
            "line-width": 1,
            "line-opacity": 0.85,
            ...e.linePaint
          }
        }), e.fillPaint !== void 0 && this.map.addLayer({
          id: "parentRectFill",
          type: "fill",
          source: "parentRect",
          layout: {},
          paint: {
            "fill-color": "#08F",
            "fill-opacity": 0.135,
            ...e.fillPaint
          }
        }), G(this, B, Z).call(this));
      }, Z = function() {
        if (E(this, he) === void 0) return;
        const { devicePixelRatio: e } = window, t = E(this, Q).getCanvas(), n = t.width / e, a = t.height / e, o = E(this, Q).unproject.bind(E(this, Q)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);
        E(this, he).geometry.coordinates = [[l.toArray(), u.toArray(), s.toArray(), i.toArray(), l.toArray()]];
        const c = this.map.getSource("parentRect");
        c !== void 0 && c.setData(E(this, he));
      }, la = function() {
        const { pitchAdjust: e } = E(this, H), t = () => {
          i("parent");
        }, n = () => {
          i("minimap");
        }, a = () => {
          E(this, Q).on("move", t), this.map.on("move", n);
        }, o = () => {
          E(this, Q).off("move", t), this.map.off("move", n);
        }, i = (s) => {
          o();
          const l = s === "parent" ? E(this, Q) : this.map, u = s === "parent" ? this.map : E(this, Q), c = l.getCenter(), p = l.getZoom() + E(this, H).zoomAdjust * (s === "parent" ? 1 : -1), y = l.getBearing(), f = l.getPitch();
          u.jumpTo({
            center: c,
            zoom: p,
            bearing: y,
            pitch: e ? f : 0
          }), G(this, B, Z).call(this), a();
        };
        return a(), () => {
          o();
        };
      };
      Is = class {
        constructor() {
          L(this, "map");
          L(this, "container");
          L(this, "projectionButton");
        }
        onAdd(e) {
          return this.map = e, this.container = fe("div", "maplibregl-ctrl maplibregl-ctrl-group"), this.projectionButton = fe("button", "maplibregl-ctrl-projection", this.container), fe("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"), this.projectionButton.type = "button", this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)), e.on("projectiontransition", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;
        }
        onRemove() {
          _r(this.container), this.map.off("projectiontransition", this.updateProjectionIcon), this.map = void 0;
        }
        toggleProjection() {
          this.map.getProjection() === void 0 && this.map.setProjection({ type: "mercator" }), this.map.isGlobeProjection() ? this.map.enableMercatorProjection() : this.map.enableGlobeProjection(), this.updateProjectionIcon();
        }
        updateProjectionIcon() {
          this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"), this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"), this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"), this.projectionButton.title = "Enable Globe projection");
        }
      };
      Es = "@maptiler/sdk";
      Ms = "3.2.3";
      _s = "The Javascript & TypeScript map SDK tailored for MapTiler Cloud";
      zs = "MapTiler";
      Ps = "dist/maptiler-sdk.mjs";
      Rs = "dist/maptiler-sdk.d.ts";
      $s = "dist/maptiler-sdk.css";
      js = "module";
      Ns = { ".": { import: "./dist/maptiler-sdk.mjs", types: "./dist/maptiler-sdk.d.ts" }, "./dist/maptiler-sdk.css": { import: "./dist/maptiler-sdk.css" }, "./style.css": { import: "./dist/maptiler-sdk.css" } };
      Os = ["maptiler", "map", "sdk", "webmap", "cloud", "webGL", "maplibre"];
      Fs = "https://docs.maptiler.com/sdk-js/";
      Ds = "BSD-3-Clause";
      qs = { type: "git", url: "https://github.com/maptiler/maptiler-sdk-js.git" };
      Bs = { prepare: "husky", doc: "rm -rf docs/* && typedoc --out docs && cp -r images docs/", ncu: "npx npm-check-updates", lint: "tsc --noEmit && eslint src", "lint:fix": "tsc --noEmit && eslint src --fix", "test:watch": "vitest watch -c vite.config-test.ts --dom", test: "vitest run -c vite.config-test.ts --dom", "install:clean": "rm -rf build/ dist/ node_modules/ && npm ci", dev: "vite -c vite.config-dev.ts", "dev-umd": "npm run build-css && tsc && NODE_ENV=development vite build -w -c vite.config-umd.ts", "build-css": "mkdir -p dist build && node scripts/replace-path-with-content.js src/style/style_template.css dist/tmp_maptiler-sdk.css && cat node_modules/maplibre-gl/dist/maplibre-gl.css dist/tmp_maptiler-sdk.css > dist/maptiler-sdk.css && rm dist/tmp_maptiler-sdk.css && cp dist/maptiler-sdk.css build/maptiler-sdk.css", "build-umd": "tsc && NODE_ENV=production vite build -c vite.config-umd.ts", "build-es": "tsc && NODE_ENV=production vite build -c vite.config-es.ts", build: "npm run build-es; npm run build-umd; npm run build-css", make: "npm run install:clean && npm run build" };
      Us = { "@canvas/image-data": "^1.0.0", "@eslint/js": "^9.21.0", "@types/stats.js": "^0.17.4", "@types/uuid": "^10.0.0", "@types/xmldom": "^0.1.31", "@vitest/web-worker": "^3.0.9", "@xmldom/xmldom": "^0.8.10", concurrently: "^9.1.2", eslint: "^9.21.0", "eslint-config-prettier": "^10.0.2", "eslint-plugin-prettier": "^5.2.3", "happy-dom": "^17.4.4", husky: "^8.0.0", jiti: "^2.4.2", "lint-staged": "^15.4.3", prettier: "3.5.2", "stats.js": "^0.17.0", typedoc: "^0.27.6", typescript: "^5.7.3", "typescript-eslint": "^8.25.0", vite: "^6.0.7", "vite-plugin-dts": "^4.5.0", vitest: "^3.0.9" };
      Vs = { "@maplibre/maplibre-gl-style-spec": "^23.0.0", "@maptiler/client": "^2.3.2", events: "^3.3.0", "js-base64": "^3.7.7", "maplibre-gl": "^5.3.1", uuid: "^11.0.5" };
      Gs = {
        name: Es,
        version: Ms,
        description: _s,
        author: zs,
        module: Ps,
        types: Rs,
        style: $s,
        type: js,
        exports: Ns,
        keywords: Os,
        homepage: Fs,
        license: Ds,
        repository: qs,
        scripts: Bs,
        "lint-staged": { "*.ts": "npm run lint:fix" },
        devDependencies: Us,
        dependencies: Vs
      };
      Hs = class {
        /**
         *
         * @param map : a Map instance
         * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)
         */
        constructor(e, t = 2e3) {
          L(this, "map");
          L(this, "registeredModules", /* @__PURE__ */ new Set());
          this.map = e, setTimeout(
            async () => {
              if (!O.telemetry)
                return;
              const n = this.preparePayload();
              try {
                (await fetch(n, { method: "POST" })).ok || console.warn("The metrics could not be sent to MapTiler Cloud");
              } catch (a) {
                console.warn("The metrics could not be sent to MapTiler Cloud", a);
              }
            },
            Math.max(1e3, t)
          );
        }
        /**
         * Register a module to the telemetry system of the SDK.
         * The arguments `name` and `version` likely come from the package.json
         * of each module.
         */
        registerModule(e, t) {
          this.registeredModules.add(`${e}:${t}`);
        }
        preparePayload() {
          const e = new URL(V.telemetryURL);
          return e.searchParams.append("sdk", Gs.version), e.searchParams.append("key", O.apiKey), e.searchParams.append("mtsid", ur), e.searchParams.append("session", O.session ? "1" : "0"), e.searchParams.append("caching", O.caching ? "1" : "0"), e.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"), e.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"), e.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"), this.registeredModules.size > 0 && e.searchParams.append("modules", Array.from(this.registeredModules).join("|")), e.href;
        }
      };
      Ks = {
        POINT: "POINT",
        COUNTRY: "COUNTRY"
      };
      zr = class _zr extends import_maplibre_gl.default.Map {
        constructor(t) {
          Xa(t.container), t.apiKey && (O.apiKey = t.apiKey);
          const { style: n, requiresUrlMonitoring: a, isFallback: o } = yn(t.style);
          o && console.warn(
            "Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
          ), O.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
          const i = location.hash;
          let s = {
            compact: false
          };
          t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == "object" && (s = {
            ...s,
            ...t.attributionControl
          });
          const l = {
            ...t,
            style: n,
            maplibreLogo: false,
            transformRequest: Vr(t.transformRequest),
            attributionControl: t.forceNoAttributionControl === true ? false : s
          };
          delete l.style;
          super(l);
          L(this, "options");
          L(this, "telemetry");
          L(this, "isTerrainEnabled", false);
          L(this, "terrainExaggeration", 1);
          L(this, "primaryLanguage");
          L(this, "terrainGrowing", false);
          L(this, "terrainFlattening", false);
          L(this, "minimap");
          L(this, "forceLanguageUpdate");
          L(this, "languageAlwaysBeenStyle");
          L(this, "isReady", false);
          L(this, "terrainAnimationDuration", 1e3);
          L(this, "monitoredStyleUrls");
          L(this, "styleInProcess", false);
          L(this, "curentProjection");
          L(this, "originalLabelStyle", new window.Map());
          L(this, "isStyleLocalized", false);
          L(this, "languageIsUpdated", false);
          this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);
          const u = () => {
            let d = "The distant style could not be loaded.";
            this.getStyle() ? d += "Leaving the style as is." : (this.setStyle(MapStyle.STREETS), d += `Loading default MapTiler Cloud style "${MapStyle.STREETS.getDefaultVariant().getId()}" as a fallback.`), console.warn(d);
          };
          if (this.on("style.load", () => {
            this.styleInProcess = false;
          }), this.on("error", (d) => {
            if (d.error instanceof import_maplibre_gl.default.AJAXError) {
              const v = d.error.url, w = new URL(v);
              w.search = "";
              const b = w.href;
              this.monitoredStyleUrls && this.monitoredStyleUrls.has(b) && (this.monitoredStyleUrls.delete(b), u());
              return;
            }
            if (this.styleInProcess) {
              u();
              return;
            }
          }), O.caching && !Zt && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"), O.caching && Zt && Ka(), typeof t.language > "u")
            this.primaryLanguage = O.primaryLanguage;
          else {
            const d = toLanguageInfo(t.language, M);
            this.primaryLanguage = d ?? O.primaryLanguage;
          }
          this.forceLanguageUpdate = !(this.primaryLanguage === M.STYLE || this.primaryLanguage === M.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === M.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on("styledata", () => {
            this.curentProjection === "mercator" ? this.setProjection({ type: "mercator" }) : this.curentProjection === "globe" && this.setProjection({ type: "globe" });
          }), this.once("styledata", async () => {
            if (!t.geolocate || t.center || t.hash && i)
              return;
            try {
              if (t.geolocate === Ks.COUNTRY) {
                await this.fitToIpBounds();
                return;
              }
            } catch (v) {
              console.warn(v.message);
            }
            let d;
            try {
              await this.centerOnIpPoint(t.zoom), d = this.getCameraHash();
            } catch (v) {
              console.warn(v.message);
            }
            (await navigator.permissions.query({
              name: "geolocation"
            })).state === "granted" && navigator.geolocation.getCurrentPosition(
              // success callback
              (v) => {
                d === this.getCameraHash() && (this.terrain ? this.easeTo({
                  center: [v.coords.longitude, v.coords.latitude],
                  zoom: t.zoom || 12,
                  duration: 2e3
                }) : this.once("terrain", () => {
                  this.easeTo({
                    center: [v.coords.longitude, v.coords.latitude],
                    zoom: t.zoom || 12,
                    duration: 2e3
                  });
                }));
              },
              // error callback
              null,
              // options
              {
                maximumAge: 24 * 3600 * 1e3,
                // a day in millisec
                timeout: 5e3,
                // milliseconds
                enableHighAccuracy: false
              }
            );
          }), this.on("styledata", () => {
            this.setPrimaryLanguage(this.primaryLanguage);
          }), this.on("styledata", () => {
            this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
          }), this.once("load", async () => {
            let d = { logo: null };
            try {
              const m = Object.keys(this.style.sourceCaches).map((b) => this.getSource(b)).filter((b) => b && "url" in b && typeof b.url == "string" && b.url.includes("tiles.json")), v = new URL(m[0].url);
              v.searchParams.has("key") || v.searchParams.append("key", O.apiKey), d = await (await fetch(v.href)).json();
            } catch {
            }
            if (t.forceNoAttributionControl !== true)
              if ("logo" in d && d.logo) {
                const m = d.logo;
                this.addControl(new Hr({ logoURL: m }), t.logoPosition);
              } else t.maptilerLogo && this.addControl(new Hr(), t.logoPosition);
            if (t.scaleControl) {
              const m = t.scaleControl === true || t.scaleControl === void 0 ? "bottom-right" : t.scaleControl, v = new uo({ unit: O.unit });
              this.addControl(v, m), O.on("unit", (w) => {
                v.setUnit(w);
              });
            }
            if (t.navigationControl !== false) {
              const m = t.navigationControl === true || t.navigationControl === void 0 ? "top-right" : t.navigationControl;
              this.addControl(new Cs(), m);
            }
            if (t.geolocateControl !== false) {
              const m = t.geolocateControl === true || t.geolocateControl === void 0 ? "top-right" : t.geolocateControl;
              this.addControl(
                // new maplibregl.GeolocateControl({
                new Ts({
                  positionOptions: {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 6e3
                  },
                  fitBoundsOptions: {
                    maxZoom: 15
                  },
                  trackUserLocation: true,
                  showAccuracyCircle: true,
                  showUserLocation: true
                }),
                m
              );
            }
            if (t.terrainControl) {
              const m = t.terrainControl === true || t.terrainControl === void 0 ? "top-right" : t.terrainControl;
              this.addControl(new Ls(), m);
            }
            if (t.projectionControl) {
              const m = t.projectionControl === true || t.projectionControl === void 0 ? "top-right" : t.projectionControl;
              this.addControl(new Is(), m);
            }
            if (t.fullscreenControl) {
              const m = t.fullscreenControl === true || t.fullscreenControl === void 0 ? "top-right" : t.fullscreenControl;
              this.addControl(new co({}), m);
            }
            this.isReady = true, this.fire("ready", { target: this });
          });
          let c = false, p = false, y;
          this.once("ready", () => {
            c = true, p && this.fire("loadWithTerrain", y);
          }), this.once("style.load", () => {
            const { minimap: d } = t;
            if (typeof d == "object") {
              const {
                zoom: m,
                center: v,
                style: w,
                language: b,
                apiKey: T,
                maptilerLogo: j,
                canvasContextAttributes: R,
                refreshExpiredTiles: ae,
                maxBounds: Se,
                scrollZoom: De,
                minZoom: rt,
                maxZoom: nt,
                boxZoom: xa,
                locale: ka,
                fadeDuration: La,
                crossSourceCollisions: Ca,
                clickTolerance: Aa,
                bounds: Ta,
                fitBoundsOptions: Ia,
                pixelRatio: Ea,
                validateStyle: Ma
              } = t;
              this.minimap = new Ht(d, {
                zoom: m,
                center: v,
                style: w,
                language: b,
                apiKey: T,
                container: "null",
                maptilerLogo: j,
                canvasContextAttributes: R,
                refreshExpiredTiles: ae,
                maxBounds: Se,
                scrollZoom: De,
                minZoom: rt,
                maxZoom: nt,
                boxZoom: xa,
                locale: ka,
                fadeDuration: La,
                crossSourceCollisions: Ca,
                clickTolerance: Aa,
                bounds: Ta,
                fitBoundsOptions: Ia,
                pixelRatio: Ea,
                validateStyle: Ma
              }), this.addControl(this.minimap, d.position ?? "bottom-left");
            } else d === true ? (this.minimap = new Ht({}, t), this.addControl(this.minimap, "bottom-left")) : d !== void 0 && d !== false && (this.minimap = new Ht({}, t), this.addControl(this.minimap, d));
          });
          const f = (d) => {
            d.terrain && (p = true, y = {
              type: "loadWithTerrain",
              target: this,
              terrain: d.terrain
            }, this.off("terrain", f), c && this.fire("loadWithTerrain", y));
          };
          this.on("terrain", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once("load", () => {
            this.getCanvas().addEventListener("webglcontextlost", (d) => {
              if (this._removed === true) {
                console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
                return;
              }
              console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"), this.fire("webglContextLost", d);
            });
          }), this.telemetry = new Hs(this);
        }
        /**
         * Recreates the map instance with the same options.
         * Useful for WebGL context loss.
         */
        recreate() {
          const t = {
            center: this.getCenter(),
            zoom: this.getZoom(),
            bearing: this.getBearing(),
            pitch: this.getPitch()
          };
          this.remove(), Object.assign(this, new _zr({ ...this.options })), this.once("load", () => {
            this.jumpTo(t);
          });
        }
        /**
         * Set the duration (millisec) of the terrain animation for growing or flattening.
         * Must be positive. (Built-in default: `1000` milliseconds)
         */
        setTerrainAnimationDuration(t) {
          this.terrainAnimationDuration = Math.max(t, 0);
        }
        /**
         * Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
         * If _this_ Map instance is already loaded, the Promise is resolved directly,
         * otherwise, it is resolved as a result of the "load" event.
         * @returns
         */
        async onLoadAsync() {
          return new Promise((t) => {
            if (this.loaded()) {
              t(this);
              return;
            }
            this.once("load", () => {
              t(this);
            });
          });
        }
        /**
         * Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
         * If _this_ Map instance is already ready, the Promise is resolved directly,
         * otherwise, it is resolved as a result of the "ready" event.
         * A map instance is "ready" when all the controls that can be managed by the contructor are
         * dealt with. This happens after the "load" event, due to the asynchronous nature
         * of some built-in controls.
         */
        async onReadyAsync() {
          return new Promise((t) => {
            if (this.isReady) {
              t(this);
              return;
            }
            this.once("ready", () => {
              t(this);
            });
          });
        }
        /**
         * Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
         * and returns a Promise to the Map.
         * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
         * otherwise, it is resolved as a result of the "loadWithTerrain" event.
         * @returns
         */
        async onLoadWithTerrainAsync() {
          return new Promise((t) => {
            if (this.isReady && this.terrain) {
              t(this);
              return;
            }
            this.once("loadWithTerrain", () => {
              t(this);
            });
          });
        }
        monitorStyleUrl(t) {
          typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());
          const n = new URL(t);
          n.search = "", this.monitoredStyleUrls.add(n.href);
        }
        /**
         * Update the style of the map.
         * Can be:
         * - a full style URL (possibly with API key)
         * - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
         * - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
         */
        setStyle(t, n) {
          var o;
          this.originalLabelStyle.clear(), (o = this.minimap) == null || o.setStyle(t), this.forceLanguageUpdate = true, this.once("idle", () => {
            this.forceLanguageUpdate = false;
          });
          const a = yn(t);
          if (a.requiresUrlMonitoring && this.monitorStyleUrl(a.style), a.isFallback) {
            if (this.getStyle())
              return console.warn(
                "Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."
              ), this;
            console.warn(
              "Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
            );
          }
          return this.styleInProcess = true, super.setStyle(a.style, n), this;
        }
        /**
         * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
         * to the map's style.
         *
         * A layer defines how data from a specified source will be styled. Read more about layer types
         * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
         *
         * @param layer - The layer to add,
         * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
         * less commonly, the {@link CustomLayerInterface} specification.
         * The MapLibre Style Specification's layer definition is appropriate for most layers.
         *
         * @param beforeId - The ID of an existing layer to insert the new layer before,
         * resulting in the new layer appearing visually beneath the existing layer.
         * If this argument is not specified, the layer will be appended to the end of the layers array
         * and appear visually above all other layers.
         *
         * @returns `this`
         */
        addLayer(t, n) {
          var a;
          return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);
        }
        /**
         * Moves a layer to a different z-position.
         *
         * @param id - The ID of the layer to move.
         * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
         * @returns `this`
         *
         * @example
         * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
         * ```ts
         * map.moveLayer('polygon', 'country-label');
         * ```
         */
        moveLayer(t, n) {
          var a;
          return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);
        }
        /**
         * Removes the layer with the given ID from the map's style.
         *
         * An {@link ErrorEvent} will be fired if the image parameter is invald.
         *
         * @param id - The ID of the layer to remove
         * @returns `this`
         *
         * @example
         * If a layer with ID 'state-data' exists, remove it.
         * ```ts
         * if (map.getLayer('state-data')) map.removeLayer('state-data');
         * ```
         */
        removeLayer(t) {
          var n;
          return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);
        }
        /**
         * Sets the zoom extent for the specified style layer. The zoom extent includes the
         * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
         * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
         * at which the layer will be rendered.
         *
         * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
         * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
         * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
         * layer will not be rendered at all zoom levels in the zoom range.
         */
        setLayerZoomRange(t, n, a) {
          var o;
          return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);
        }
        /**
         * Sets the filter for the specified style layer.
         *
         * Filters control which features a style layer renders from its source.
         * Any feature for which the filter expression evaluates to `true` will be
         * rendered on the map. Those that are false will be hidden.
         *
         * Use `setFilter` to show a subset of your source data.
         *
         * To clear the filter, pass `null` or `undefined` as the second parameter.
         */
        setFilter(t, n, a) {
          var o;
          return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);
        }
        /**
         * Sets the value of a paint property in the specified style layer.
         *
         * @param layerId - The ID of the layer to set the paint property in.
         * @param name - The name of the paint property to set.
         * @param value - The value of the paint property to set.
         * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
         * @param options - Options object.
         * @returns `this`
         * @example
         * ```ts
         * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
         * ```
         */
        setPaintProperty(t, n, a, o) {
          var i;
          return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);
        }
        /**
         * Sets the value of a layout property in the specified style layer.
         * Layout properties define how the layer is styled.
         * Layout properties for layers of the same type are documented together.
         * Layers of different types have different layout properties.
         * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
         * @param layerId - The ID of the layer to set the layout property in.
         * @param name - The name of the layout property to set.
         * @param value - The value of the layout property to set.
         * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
         * @param options - Options object.
         * @returns `this`
         */
        setLayoutProperty(t, n, a, o) {
          var i;
          return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);
        }
        /**
         * Sets the value of the style's glyphs property.
         *
         * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
         * @param options - Options object.
         * @returns `this`
         * @example
         * ```ts
         * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
         * ```
         */
        setGlyphs(t, n) {
          var a;
          return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);
        }
        getStyleLanguage() {
          return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? getLanguageInfoFromFlag(this.style.stylesheet.metadata["maptiler:language"]) : null;
        }
        /**
         * Define the primary language of the map. Note that not all the languages shorthands provided are available.
         */
        setLanguage(t) {
          var n;
          (n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {
            this.setPrimaryLanguage(t);
          });
        }
        /**
         * Define the primary language of the map. Note that not all the languages shorthands provided are available.
         */
        setPrimaryLanguage(t) {
          const n = this.getStyleLanguage(), a = toLanguageInfo(t, M);
          if (!a) {
            console.warn(`The language "${a}" is not supported.`);
            return;
          }
          if (!(a.flag === M.STYLE.flag && n && (n.flag === M.AUTO.flag || n.flag === M.VISITOR.flag)) && (a.flag !== M.STYLE.flag && (this.languageAlwaysBeenStyle = false), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate))
            return;
          if (this.primaryLanguage.flag === M.STYLE_LOCK.flag) {
            console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
            return;
          }
          this.primaryLanguage = a;
          let o = a;
          if (a.flag === M.STYLE.flag) {
            if (!n) {
              console.warn("The style has no default languages or has an invalid one.");
              return;
            }
            o = n;
          }
          let i = M.LOCAL.flag, s = ["get", i];
          o.flag === M.VISITOR.flag ? (i = Dr().flag, s = [
            "case",
            ["all", ["has", i], ["has", M.LOCAL.flag]],
            [
              "case",
              ["==", ["get", i], ["get", M.LOCAL.flag]],
              ["get", M.LOCAL.flag],
              ["format", ["get", i], { "font-scale": 0.8 }, `
`, ["get", M.LOCAL.flag], { "font-scale": 1.1 }]
            ],
            ["get", M.LOCAL.flag]
          ]) : o.flag === M.VISITOR_ENGLISH.flag ? (i = M.ENGLISH.flag, s = [
            "case",
            ["all", ["has", i], ["has", M.LOCAL.flag]],
            [
              "case",
              ["==", ["get", i], ["get", M.LOCAL.flag]],
              ["get", M.LOCAL.flag],
              ["format", ["get", i], { "font-scale": 0.8 }, `
`, ["get", M.LOCAL.flag], { "font-scale": 1.1 }]
            ],
            ["get", M.LOCAL.flag]
          ]) : o.flag === M.AUTO.flag ? (i = Dr().flag, s = ["coalesce", ["get", i], ["get", M.LOCAL.flag]]) : o === M.LOCAL ? (i = M.LOCAL.flag, s = ["get", i]) : (i = o.flag, s = ["coalesce", ["get", i], ["get", M.LOCAL.flag]]);
          const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;
          if (u) {
            const c = oo(l, this);
            this.isStyleLocalized = Object.keys(c.localized).length > 0;
          }
          for (const c of l) {
            if (c.type !== "symbol")
              continue;
            const p = c, y = this.getSource(p.source);
            if (!y || !("url" in y && typeof y.url == "string") || new URL(y.url).host !== V.maptilerApiHost)
              continue;
            const { id: d, layout: m } = p;
            if (!m || !("text-field" in m))
              continue;
            let v;
            if (u ? (v = this.getLayoutProperty(d, "text-field"), this.originalLabelStyle.set(d, v)) : v = this.originalLabelStyle.get(d), typeof v == "string") {
              const { contains: w, exactMatch: b } = eo(v, this.isStyleLocalized);
              if (!w) continue;
              if (b)
                this.setLayoutProperty(d, "text-field", s);
              else {
                const T = to(v, s, this.isStyleLocalized);
                this.setLayoutProperty(d, "text-field", T);
              }
            } else {
              const w = Qa(v, s, this.isStyleLocalized);
              this.setLayoutProperty(d, "text-field", w);
            }
          }
          this.languageIsUpdated = true;
        }
        /**
         * Get the primary language
         * @returns
         */
        getPrimaryLanguage() {
          return this.primaryLanguage;
        }
        /**
         * Get the exaggeration factor applied to the terrain
         * @returns
         */
        getTerrainExaggeration() {
          return this.terrainExaggeration;
        }
        /**
         * Know if terrian is enabled or not
         * @returns
         */
        hasTerrain() {
          return this.isTerrainEnabled;
        }
        growTerrain(t) {
          if (!this.terrain)
            return;
          const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {
            if (!this.terrain || this.terrainFlattening)
              return;
            const s = (performance.now() - n) / this.terrainAnimationDuration;
            if (s < 0.99) {
              const l = 1 - (1 - s) ** 4, u = a + l * o;
              this.terrain.exaggeration = u, requestAnimationFrame(i);
            } else
              this.terrainGrowing = false, this.terrainFlattening = false, this.terrain.exaggeration = t, this.fire("terrainAnimationStop", { terrain: this.terrain });
            this._elevationFreeze = false, this.triggerRepaint();
          };
          !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = true, this.terrainFlattening = false, requestAnimationFrame(i);
        }
        /**
         * Enables the 3D terrain visualization
         */
        enableTerrain(t = this.terrainExaggeration) {
          if (t < 0) {
            console.warn("Terrain exaggeration cannot be negative.");
            return;
          }
          const n = (o) => {
            !this.terrain || o.type !== "data" || o.dataType !== "source" || !("source" in o) || o.sourceId !== "maptiler-terrain" || o.source.type !== "raster-dem" || o.isSourceLoaded && (this.off("data", n), this.growTerrain(t));
          }, a = () => {
            this.isTerrainEnabled = true, this.terrainExaggeration = t, this.on("data", n), this.addSource(V.terrainSourceId, {
              type: "raster-dem",
              url: V.terrainSourceURL
            }), this.setTerrain({
              source: V.terrainSourceId,
              exaggeration: 0
            });
          };
          if (this.getTerrain()) {
            this.isTerrainEnabled = true, this.growTerrain(t);
            return;
          }
          this.loaded() || this.isTerrainEnabled ? a() : this.once("load", () => {
            this.getTerrain() && this.getSource(V.terrainSourceId) || a();
          });
        }
        /**
         * Disable the 3D terrain visualization
         */
        disableTerrain() {
          if (!this.terrain)
            return;
          this.isTerrainEnabled = false;
          const t = performance.now(), n = this.terrain.exaggeration, a = () => {
            if (!this.terrain || this.terrainGrowing)
              return;
            const o = (performance.now() - t) / this.terrainAnimationDuration;
            if (this._elevationFreeze = false, o < 0.99) {
              const i = (1 - o) ** 4, s = n * i;
              this.terrain.exaggeration = s, requestAnimationFrame(a);
            } else
              this.terrain.exaggeration = 0, this.terrainGrowing = false, this.terrainFlattening = false, this.setTerrain(), this.getSource(V.terrainSourceId) && this.removeSource(V.terrainSourceId), this.fire("terrainAnimationStop", { terrain: null });
            this.triggerRepaint();
          };
          !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = false, this.terrainFlattening = true, requestAnimationFrame(a);
        }
        /**
         * Sets the 3D terrain exageration factor.
         * If the terrain was not enabled prior to the call of this method,
         * the method `.enableTerrain()` will be called.
         * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
         * If `animate` is `false`, no animated transition to the newly defined exaggeration.
         */
        setTerrainExaggeration(t, n = true) {
          !n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);
        }
        /**
         * Perform an action when the style is ready. It could be at the moment of calling this method
         * or later.
         */
        onStyleReady(t) {
          this.isStyleLoaded() ? t() : this.once("styledata", () => {
            t();
          });
        }
        async fitToIpBounds() {
          const t = await geolocation.info();
          this.fitBounds(t.country_bounds, {
            duration: 0,
            padding: 100
          });
        }
        async centerOnIpPoint(t) {
          const n = await geolocation.info();
          this.jumpTo({
            center: [n.longitude ?? 0, n.latitude ?? 0],
            zoom: t || 11
          });
        }
        getCameraHash() {
          const t = new Float32Array(5), n = this.getCenter();
          return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), gBase64.fromUint8Array(new Uint8Array(t.buffer));
        }
        /**
         * Get the SDK config object.
         * This is convenient to dispatch the SDK configuration to externally built layers
         * that do not directly have access to the SDK configuration but do have access to a Map instance.
         */
        getSdkConfig() {
          return O;
        }
        /**
         * Get the MapTiler session ID. Convenient to dispatch to externaly built component
         * that do not directly have access to the SDK configuration but do have access to a Map instance.
         * @returns
         */
        getMaptilerSessionId() {
          return ur;
        }
        /**
         *  Updates the requestManager's transform request with a new function.
         *
         * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
         *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
         *
         * @returns {Map} `this`
         *
         *  @example
         *  map.setTransformRequest((url: string, resourceType: string) => {});
         */
        setTransformRequest(t) {
          return super.setTransformRequest(Vr(t)), this;
        }
        /**
         * Returns whether a globe projection is currently being used
         */
        isGlobeProjection() {
          const t = this.getProjection();
          return t ? t.type === "globe" : false;
        }
        /**
         * Activate the globe projection.
         */
        enableGlobeProjection() {
          this.isGlobeProjection() !== true && (this.setProjection({ type: "globe" }), this.curentProjection = "globe");
        }
        /**
         * Activate the mercator projection.
         */
        enableMercatorProjection() {
          this.isGlobeProjection() !== false && (this.setProjection({ type: "mercator" }), this.curentProjection = "mercator");
        }
        /**
         * Returns `true` is the language was ever updated, meaning changed
         * from what is delivered in the style.
         * Returns `false` if language in use is the language from the style
         * and has never been changed.
         */
        isLanguageUpdated() {
          return this.languageIsUpdated;
        }
      };
      x = class _x extends Array {
        constructor(t = {}) {
          super();
          L(this, "min", 0);
          L(this, "max", 1);
          "min" in t && (this.min = t.min), "max" in t && (this.max = t.max), "stops" in t && this.setStops(t.stops, { clone: false });
        }
        /**
         * Converts a array-definition color ramp definition into a usable ColorRamp instance.
         * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
         * @param cr
         * @returns
         */
        static fromArrayDefinition(t) {
          return new _x({
            stops: t.map((n) => ({
              value: n[0],
              color: n[1]
            }))
          });
        }
        setStops(t, n = { clone: true }) {
          const a = n.clone ? this.clone() : this;
          a.length = 0;
          let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
          for (let s = 0; s < t.length; s += 1)
            o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({
              value: t[s].value,
              color: t[s].color.slice()
              // we want to make sure we do a deep copy and not a reference
            });
          return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;
        }
        scale(t, n, a = { clone: true }) {
          const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];
          for (let p = 0; p < this.length; p += 1) {
            const d = (this[p].value - i) / l * u + t;
            o ? c.push({
              value: d,
              color: this[p].color.slice()
            }) : this[p].value = d;
          }
          return o ? new _x({ stops: c }) : this;
        }
        // for some reason, I had to reimplement this
        at(t) {
          return t < 0 ? this[this.length + t] : this[t];
        }
        clone() {
          return new _x({ stops: this.getRawColorStops() });
        }
        getRawColorStops() {
          const t = [];
          for (let n = 0; n < this.length; n += 1)
            t.push({ value: this[n].value, color: this[n].color });
          return t;
        }
        reverse(t = { clone: true }) {
          const n = t.clone ? this.clone() : this;
          for (let a = 0; a < ~~(n.length / 2); a += 1) {
            const o = n[a].color;
            n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;
          }
          return n;
        }
        getBounds() {
          return { min: this.min, max: this.max };
        }
        getColor(t, n = { smooth: true }) {
          if (t <= this[0].value)
            return this[0].color;
          if (t >= this.at(-1).value)
            return this.at(-1).color;
          for (let a = 0; a < this.length - 1; a += 1) {
            if (t > this[a + 1].value)
              continue;
            const o = this[a].color;
            if (!n.smooth)
              return o.slice();
            const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);
            return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));
          }
          return [0, 0, 0];
        }
        /**
         * Get the color as an hexadecimal string
         */
        getColorHex(t, n = {
          smooth: true,
          withAlpha: false
        }) {
          return al(this.getColor(t, n));
        }
        /**
         * Get the color of the color ramp at a relative position in [0, 1]
         */
        getColorRelative(t, n = { smooth: true }) {
          const a = this.getBounds();
          return this.getColor(a.min + t * (a.max - a.min), n);
        }
        getCanvasStrip(t = {
          horizontal: true,
          size: 512,
          smooth: true
        }) {
          const n = document.createElement("canvas");
          n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;
          const a = n.getContext("2d");
          if (!a) throw new Error("Canvs context is missing");
          const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;
          for (let y = 0; y < s; y += 1) {
            const f = this.getColor(l + y * p, {
              smooth: t.smooth
            });
            i[y * 4] = f[0], i[y * 4 + 1] = f[1], i[y * 4 + 2] = f[2], i[y * 4 + 3] = f.length > 3 ? f[3] : 255;
          }
          return a.putImageData(o, 0, 0), n;
        }
        /**
         * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
         */
        resample(t, n = 15) {
          const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);
          let s;
          if (t === "ease-in-square")
            s = Array.from({ length: n }, (c, p) => {
              const y = p * i, f = y ** 2, d = o.getColor(f);
              return { value: y, color: d };
            });
          else if (t === "ease-out-square")
            s = Array.from({ length: n }, (c, p) => {
              const y = p * i, f = 1 - (1 - y) ** 2, d = o.getColor(f);
              return { value: y, color: d };
            });
          else if (t === "ease-out-sqrt")
            s = Array.from({ length: n }, (c, p) => {
              const y = p * i, f = y ** 0.5, d = o.getColor(f);
              return { value: y, color: d };
            });
          else if (t === "ease-in-sqrt")
            s = Array.from({ length: n }, (c, p) => {
              const y = p * i, f = 1 - (1 - y) ** 0.5, d = o.getColor(f);
              return { value: y, color: d };
            });
          else if (t === "ease-out-exp")
            s = Array.from({ length: n }, (c, p) => {
              const y = p * i, f = 1 - 2 ** (-10 * y), d = o.getColor(f);
              return { value: y, color: d };
            });
          else if (t === "ease-in-exp")
            s = Array.from({ length: n }, (c, p) => {
              const y = p * i, f = 2 ** (10 * y - 10), d = o.getColor(f);
              return { value: y, color: d };
            });
          else
            throw new Error("Invalid ressampling method.");
          return new _x({ stops: s }).scale(a.min, a.max);
        }
        /**
         * Makes a clone of this color ramp that is fully transparant at the begining of their range
         */
        transparentStart() {
          const t = this.getRawColorStops();
          t.unshift({
            value: t[0].value,
            color: t[0].color.slice()
          }), t[1].value += 1e-3;
          for (const n of t)
            n.color.length === 3 && n.color.push(255);
          return t[0].color[3] = 0, new _x({ stops: t });
        }
        /**
         * Check if this color ramp has a transparent start
         */
        hasTransparentStart() {
          return this[0].color.length === 4 && this[0].color[3] === 0;
        }
      };
      Sa = {
        /**
         * A fully transparent [0, 0, 0, 0] colorramp to hide data.
         * Defined in interval [0, 1], without unit.
         */
        NULL: new x({
          stops: [
            { value: 0, color: [0, 0, 0, 0] },
            { value: 1, color: [0, 0, 0, 0] }
          ]
        }),
        GRAY: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 1, color: [255, 255, 255] }
          ]
        }),
        /**
         * Classic jet color ramp.
         * Defined in interval [0, 1], without unit.
         */
        JET: new x({
          stops: [
            { value: 0, color: [0, 0, 131] },
            { value: 0.125, color: [0, 60, 170] },
            { value: 0.375, color: [5, 255, 255] },
            { value: 0.625, color: [255, 255, 0] },
            { value: 0.875, color: [250, 0, 0] },
            { value: 1, color: [128, 0, 0] }
          ]
        }),
        /**
         * Classic HSV color ramp (hue, saturation, value).
         * Defined in interval [0, 1], without unit.
         */
        HSV: new x({
          stops: [
            { value: 0, color: [255, 0, 0] },
            { value: 0.169, color: [253, 255, 2] },
            { value: 0.173, color: [247, 255, 2] },
            { value: 0.337, color: [0, 252, 4] },
            { value: 0.341, color: [0, 252, 10] },
            { value: 0.506, color: [1, 249, 255] },
            { value: 0.671, color: [2, 0, 253] },
            { value: 0.675, color: [8, 0, 253] },
            { value: 0.839, color: [255, 0, 251] },
            { value: 0.843, color: [255, 0, 245] },
            { value: 1, color: [255, 0, 6] }
          ]
        }),
        /**
         * Classic hot color ramp.
         * Defined in interval [0, 1], without unit.
         */
        HOT: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 0.3, color: [230, 0, 0] },
            { value: 0.6, color: [255, 210, 0] },
            { value: 1, color: [255, 255, 255] }
          ]
        }),
        /**
         * Classic spring color ramp.
         * Defined in interval [0, 1], without unit.
         */
        SPRING: new x({
          stops: [
            { value: 0, color: [255, 0, 255] },
            { value: 1, color: [255, 255, 0] }
          ]
        }),
        /**
         * Classic summer color ramp.
         * Defined in interval [0, 1], without unit.
         */
        SUMMER: new x({
          stops: [
            { value: 0, color: [0, 128, 102] },
            { value: 1, color: [255, 255, 102] }
          ]
        }),
        /**
         * Classic autommn color ramp.
         * Defined in interval [0, 1], without unit.
         */
        AUTOMN: new x({
          stops: [
            { value: 0, color: [255, 0, 0] },
            { value: 1, color: [255, 255, 0] }
          ]
        }),
        /**
         * Classic winter color ramp.
         * Defined in interval [0, 1], without unit.
         */
        WINTER: new x({
          stops: [
            { value: 0, color: [0, 0, 255] },
            { value: 1, color: [0, 255, 128] }
          ]
        }),
        /**
         * Classic bone color ramp.
         * Defined in interval [0, 1], without unit.
         */
        BONE: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 0.376, color: [84, 84, 116] },
            { value: 0.753, color: [169, 200, 200] },
            { value: 1, color: [255, 255, 255] }
          ]
        }),
        /**
         * Classic copper color ramp.
         * Defined in interval [0, 1], without unit.
         */
        COPPER: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 0.804, color: [255, 160, 102] },
            { value: 1, color: [255, 199, 127] }
          ]
        }),
        /**
         * Classic greys color ramp.
         * Defined in interval [0, 1], without unit.
         */
        GREYS: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 1, color: [255, 255, 255] }
          ]
        }),
        /**
         * Classic yignbu color ramp (blue to light yellow).
         * Defined in interval [0, 1], without unit.
         */
        YIGNBU: new x({
          stops: [
            { value: 0, color: [8, 29, 88] },
            { value: 0.125, color: [37, 52, 148] },
            { value: 0.25, color: [34, 94, 168] },
            { value: 0.375, color: [29, 145, 192] },
            { value: 0.5, color: [65, 182, 196] },
            { value: 0.625, color: [127, 205, 187] },
            { value: 0.75, color: [199, 233, 180] },
            { value: 0.875, color: [237, 248, 217] },
            { value: 1, color: [255, 255, 217] }
          ]
        }),
        /**
         * Classic greens color ramp.
         * Defined in interval [0, 1], without unit.
         */
        GREENS: new x({
          stops: [
            { value: 0, color: [0, 68, 27] },
            { value: 0.125, color: [0, 109, 44] },
            { value: 0.25, color: [35, 139, 69] },
            { value: 0.375, color: [65, 171, 93] },
            { value: 0.5, color: [116, 196, 118] },
            { value: 0.625, color: [161, 217, 155] },
            { value: 0.75, color: [199, 233, 192] },
            { value: 0.875, color: [229, 245, 224] },
            { value: 1, color: [247, 252, 245] }
          ]
        }),
        /**
         * Classic yiorrd color ramp (red to light yellow).
         * Defined in interval [0, 1], without unit.
         */
        YIORRD: new x({
          stops: [
            { value: 0, color: [128, 0, 38] },
            { value: 0.125, color: [189, 0, 38] },
            { value: 0.25, color: [227, 26, 28] },
            { value: 0.375, color: [252, 78, 42] },
            { value: 0.5, color: [253, 141, 60] },
            { value: 0.625, color: [254, 178, 76] },
            { value: 0.75, color: [254, 217, 118] },
            { value: 0.875, color: [255, 237, 160] },
            { value: 1, color: [255, 255, 204] }
          ]
        }),
        /**
         * Classic blue-red color ramp.
         * Defined in interval [0, 1], without unit.
         */
        BLUERED: new x({
          stops: [
            { value: 0, color: [0, 0, 255] },
            { value: 1, color: [255, 0, 0] }
          ]
        }),
        /**
         * Classic rdbu color ramp.
         * Defined in interval [0, 1], without unit.
         */
        RDBU: new x({
          stops: [
            { value: 0, color: [5, 10, 172] },
            { value: 0.35, color: [106, 137, 247] },
            { value: 0.5, color: [190, 190, 190] },
            { value: 0.6, color: [220, 170, 132] },
            { value: 0.7, color: [230, 145, 90] },
            { value: 1, color: [178, 10, 28] }
          ]
        }),
        /**
         * Classic picnic color ramp.
         * Defined in interval [0, 1], without unit.
         */
        PICNIC: new x({
          stops: [
            { value: 0, color: [0, 0, 255] },
            { value: 0.1, color: [51, 153, 255] },
            { value: 0.2, color: [102, 204, 255] },
            { value: 0.3, color: [153, 204, 255] },
            { value: 0.4, color: [204, 204, 255] },
            { value: 0.5, color: [255, 255, 255] },
            { value: 0.6, color: [255, 204, 255] },
            { value: 0.7, color: [255, 153, 255] },
            { value: 0.8, color: [255, 102, 204] },
            { value: 0.9, color: [255, 102, 102] },
            { value: 1, color: [255, 0, 0] }
          ]
        }),
        /**
         * Classic rainbow color ramp.
         * Defined in interval [0, 1], without unit.
         */
        RAINBOW: new x({
          stops: [
            { value: 0, color: [150, 0, 90] },
            { value: 0.125, color: [0, 0, 200] },
            { value: 0.25, color: [0, 25, 255] },
            { value: 0.375, color: [0, 152, 255] },
            { value: 0.5, color: [44, 255, 150] },
            { value: 0.625, color: [151, 255, 0] },
            { value: 0.75, color: [255, 234, 0] },
            { value: 0.875, color: [255, 111, 0] },
            { value: 1, color: [255, 0, 0] }
          ]
        }),
        /**
         * Classic Portland color ramp.
         * Defined in interval [0, 1], without unit.
         */
        PORTLAND: new x({
          stops: [
            { value: 0, color: [12, 51, 131] },
            { value: 0.25, color: [10, 136, 186] },
            { value: 0.5, color: [242, 211, 56] },
            { value: 0.75, color: [242, 143, 56] },
            { value: 1, color: [217, 30, 30] }
          ]
        }),
        /**
         * Classic blackbody color ramp.
         * Defined in interval [0, 1], without unit.
         */
        BLACKBODY: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 0.2, color: [230, 0, 0] },
            { value: 0.4, color: [230, 210, 0] },
            { value: 0.7, color: [255, 255, 255] },
            { value: 1, color: [160, 200, 255] }
          ]
        }),
        /**
         * Classic earth color ramp.
         * Defined in interval [0, 1], without unit.
         */
        EARTH: new x({
          stops: [
            { value: 0, color: [0, 0, 130] },
            { value: 0.1, color: [0, 180, 180] },
            { value: 0.2, color: [40, 210, 40] },
            { value: 0.4, color: [230, 230, 50] },
            { value: 0.6, color: [120, 70, 20] },
            { value: 1, color: [255, 255, 255] }
          ]
        }),
        /**
         * Classic electric color ramp.
         * Defined in interval [0, 1], without unit.
         */
        ELECTRIC: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 0.15, color: [30, 0, 100] },
            { value: 0.4, color: [120, 0, 100] },
            { value: 0.6, color: [160, 90, 0] },
            { value: 0.8, color: [230, 200, 0] },
            { value: 1, color: [255, 250, 220] }
          ]
        }),
        /**
         * Classic viridis color ramp.
         * Defined in interval [0, 1], without unit.
         */
        VIRIDIS: new x({
          stops: [
            { value: 0, color: [68, 1, 84] },
            { value: 0.13, color: [71, 44, 122] },
            { value: 0.25, color: [59, 81, 139] },
            { value: 0.38, color: [44, 113, 142] },
            { value: 0.5, color: [33, 144, 141] },
            { value: 0.63, color: [39, 173, 129] },
            { value: 0.75, color: [92, 200, 99] },
            { value: 0.88, color: [170, 220, 50] },
            { value: 1, color: [253, 231, 37] }
          ]
        }),
        /**
         * Classic inferno color ramp.
         * Defined in interval [0, 1], without unit.
         */
        INFERNO: new x({
          stops: [
            { value: 0, color: [0, 0, 4] },
            { value: 0.13, color: [31, 12, 72] },
            { value: 0.25, color: [85, 15, 109] },
            { value: 0.38, color: [136, 34, 106] },
            { value: 0.5, color: [186, 54, 85] },
            { value: 0.63, color: [227, 89, 51] },
            { value: 0.75, color: [249, 140, 10] },
            { value: 0.88, color: [249, 201, 50] },
            { value: 1, color: [252, 255, 164] }
          ]
        }),
        /**
         * Classic magma color ramp.
         * Defined in interval [0, 1], without unit.
         */
        MAGMA: new x({
          stops: [
            { value: 0, color: [0, 0, 4] },
            { value: 0.13, color: [28, 16, 68] },
            { value: 0.25, color: [79, 18, 123] },
            { value: 0.38, color: [129, 37, 129] },
            { value: 0.5, color: [181, 54, 122] },
            { value: 0.63, color: [229, 80, 100] },
            { value: 0.75, color: [251, 135, 97] },
            { value: 0.88, color: [254, 194, 135] },
            { value: 1, color: [252, 253, 191] }
          ]
        }),
        /**
         * Classic plasma color ramp.
         * Defined in interval [0, 1], without unit.
         */
        PLASMA: new x({
          stops: [
            { value: 0, color: [13, 8, 135] },
            { value: 0.13, color: [75, 3, 161] },
            { value: 0.25, color: [125, 3, 168] },
            { value: 0.38, color: [168, 34, 150] },
            { value: 0.5, color: [203, 70, 121] },
            { value: 0.63, color: [229, 107, 93] },
            { value: 0.75, color: [248, 148, 65] },
            { value: 0.88, color: [253, 195, 40] },
            { value: 1, color: [240, 249, 33] }
          ]
        }),
        /**
         * Classic warm color ramp.
         * Defined in interval [0, 1], without unit.
         */
        WARM: new x({
          stops: [
            { value: 0, color: [125, 0, 179] },
            { value: 0.13, color: [172, 0, 187] },
            { value: 0.25, color: [219, 0, 170] },
            { value: 0.38, color: [255, 0, 130] },
            { value: 0.5, color: [255, 63, 74] },
            { value: 0.63, color: [255, 123, 0] },
            { value: 0.75, color: [234, 176, 0] },
            { value: 0.88, color: [190, 228, 0] },
            { value: 1, color: [147, 255, 0] }
          ]
        }),
        /**
         * Classic cool color ramp.
         * Defined in interval [0, 1], without unit.
         */
        COOL: new x({
          stops: [
            { value: 0, color: [125, 0, 179] },
            { value: 0.13, color: [116, 0, 218] },
            { value: 0.25, color: [98, 74, 237] },
            { value: 0.38, color: [68, 146, 231] },
            { value: 0.5, color: [0, 204, 197] },
            { value: 0.63, color: [0, 247, 146] },
            { value: 0.75, color: [0, 255, 88] },
            { value: 0.88, color: [40, 255, 8] },
            { value: 1, color: [147, 255, 0] }
          ]
        }),
        /**
         * Classic rainboz soft color ramp.
         * Defined in interval [0, 1], without unit.
         */
        RAINBOW_SOFT: new x({
          stops: [
            { value: 0, color: [125, 0, 179] },
            { value: 0.1, color: [199, 0, 180] },
            { value: 0.2, color: [255, 0, 121] },
            { value: 0.3, color: [255, 108, 0] },
            { value: 0.4, color: [222, 194, 0] },
            { value: 0.5, color: [150, 255, 0] },
            { value: 0.6, color: [0, 255, 55] },
            { value: 0.7, color: [0, 246, 150] },
            { value: 0.8, color: [50, 167, 222] },
            { value: 0.9, color: [103, 51, 235] },
            { value: 1, color: [124, 0, 186] }
          ]
        }),
        /**
         * Classic bathymetry color ramp.
         * Defined in interval [0, 1], without unit.
         */
        BATHYMETRY: new x({
          stops: [
            { value: 0, color: [40, 26, 44] },
            { value: 0.13, color: [59, 49, 90] },
            { value: 0.25, color: [64, 76, 139] },
            { value: 0.38, color: [63, 110, 151] },
            { value: 0.5, color: [72, 142, 158] },
            { value: 0.63, color: [85, 174, 163] },
            { value: 0.75, color: [120, 206, 163] },
            { value: 0.88, color: [187, 230, 172] },
            { value: 1, color: [253, 254, 204] }
          ]
        }),
        /**
         * Classic cdom color ramp.
         * Defined in interval [0, 1], without unit.
         */
        CDOM: new x({
          stops: [
            { value: 0, color: [47, 15, 62] },
            { value: 0.13, color: [87, 23, 86] },
            { value: 0.25, color: [130, 28, 99] },
            { value: 0.38, color: [171, 41, 96] },
            { value: 0.5, color: [206, 67, 86] },
            { value: 0.63, color: [230, 106, 84] },
            { value: 0.75, color: [242, 149, 103] },
            { value: 0.88, color: [249, 193, 135] },
            { value: 1, color: [254, 237, 176] }
          ]
        }),
        /**
         * Classic chlorophyll color ramp.
         * Defined in interval [0, 1], without unit.
         */
        CHLOROPHYLL: new x({
          stops: [
            { value: 0, color: [18, 36, 20] },
            { value: 0.13, color: [25, 63, 41] },
            { value: 0.25, color: [24, 91, 59] },
            { value: 0.38, color: [13, 119, 72] },
            { value: 0.5, color: [18, 148, 80] },
            { value: 0.63, color: [80, 173, 89] },
            { value: 0.75, color: [132, 196, 122] },
            { value: 0.88, color: [175, 221, 162] },
            { value: 1, color: [215, 249, 208] }
          ]
        }),
        /**
         * Classic density color ramp.
         * Defined in interval [0, 1], without unit.
         */
        DENSITY: new x({
          stops: [
            { value: 0, color: [54, 14, 36] },
            { value: 0.13, color: [89, 23, 80] },
            { value: 0.25, color: [110, 45, 132] },
            { value: 0.38, color: [120, 77, 178] },
            { value: 0.5, color: [120, 113, 213] },
            { value: 0.63, color: [115, 151, 228] },
            { value: 0.75, color: [134, 185, 227] },
            { value: 0.88, color: [177, 214, 227] },
            { value: 1, color: [230, 241, 241] }
          ]
        }),
        /**
         * Classic freesurface blue color ramp.
         * Defined in interval [0, 1], without unit.
         */
        FREESURFACE_BLUE: new x({
          stops: [
            { value: 0, color: [30, 4, 110] },
            { value: 0.13, color: [47, 14, 176] },
            { value: 0.25, color: [41, 45, 236] },
            { value: 0.38, color: [25, 99, 212] },
            { value: 0.5, color: [68, 131, 200] },
            { value: 0.63, color: [114, 156, 197] },
            { value: 0.75, color: [157, 181, 203] },
            { value: 0.88, color: [200, 208, 216] },
            { value: 1, color: [241, 237, 236] }
          ]
        }),
        /**
         * Classic freesurface red color ramp.
         * Defined in interval [0, 1], without unit.
         */
        FREESURFACE_RED: new x({
          stops: [
            { value: 0, color: [60, 9, 18] },
            { value: 0.13, color: [100, 17, 27] },
            { value: 0.25, color: [142, 20, 29] },
            { value: 0.38, color: [177, 43, 27] },
            { value: 0.5, color: [192, 87, 63] },
            { value: 0.63, color: [205, 125, 105] },
            { value: 0.75, color: [216, 162, 148] },
            { value: 0.88, color: [227, 199, 193] },
            { value: 1, color: [241, 237, 236] }
          ]
        }),
        /**
         * Classic oxygen color ramp.
         * Defined in interval [0, 1], without unit.
         */
        OXYGEN: new x({
          stops: [
            { value: 0, color: [64, 5, 5] },
            { value: 0.13, color: [106, 6, 15] },
            { value: 0.25, color: [144, 26, 7] },
            { value: 0.38, color: [168, 64, 3] },
            { value: 0.5, color: [188, 100, 4] },
            { value: 0.63, color: [206, 136, 11] },
            { value: 0.75, color: [220, 174, 25] },
            { value: 0.88, color: [231, 215, 44] },
            { value: 1, color: [248, 254, 105] }
          ]
        }),
        /**
         * Classic par color ramp.
         * Defined in interval [0, 1], without unit.
         */
        PAR: new x({
          stops: [
            { value: 0, color: [51, 20, 24] },
            { value: 0.13, color: [90, 32, 35] },
            { value: 0.25, color: [129, 44, 34] },
            { value: 0.38, color: [159, 68, 25] },
            { value: 0.5, color: [182, 99, 19] },
            { value: 0.63, color: [199, 134, 22] },
            { value: 0.75, color: [212, 171, 35] },
            { value: 0.88, color: [221, 210, 54] },
            { value: 1, color: [225, 253, 75] }
          ]
        }),
        /**
         * Classic phase color ramp.
         * Defined in interval [0, 1], without unit.
         */
        PHASE: new x({
          stops: [
            { value: 0, color: [145, 105, 18] },
            { value: 0.13, color: [184, 71, 38] },
            { value: 0.25, color: [186, 58, 115] },
            { value: 0.38, color: [160, 71, 185] },
            { value: 0.5, color: [110, 97, 218] },
            { value: 0.63, color: [50, 123, 164] },
            { value: 0.75, color: [31, 131, 110] },
            { value: 0.88, color: [77, 129, 34] },
            { value: 1, color: [145, 105, 18] }
          ]
        }),
        /**
         * Classic salinity color ramp.
         * Defined in interval [0, 1], without unit.
         */
        SALINITY: new x({
          stops: [
            { value: 0, color: [42, 24, 108] },
            { value: 0.13, color: [33, 50, 162] },
            { value: 0.25, color: [15, 90, 145] },
            { value: 0.38, color: [40, 118, 137] },
            { value: 0.5, color: [59, 146, 135] },
            { value: 0.63, color: [79, 175, 126] },
            { value: 0.75, color: [120, 203, 104] },
            { value: 0.88, color: [193, 221, 100] },
            { value: 1, color: [253, 239, 154] }
          ]
        }),
        /**
         * Classic temperature color ramp.
         * Defined in interval [0, 1], without unit.
         */
        TEMPERATURE: new x({
          stops: [
            { value: 0, color: [4, 35, 51] },
            { value: 0.13, color: [23, 51, 122] },
            { value: 0.25, color: [85, 59, 157] },
            { value: 0.38, color: [129, 79, 143] },
            { value: 0.5, color: [175, 95, 130] },
            { value: 0.63, color: [222, 112, 101] },
            { value: 0.75, color: [249, 146, 66] },
            { value: 0.88, color: [249, 196, 65] },
            { value: 1, color: [232, 250, 91] }
          ]
        }),
        /**
         * Classic turbidity color ramp.
         * Defined in interval [0, 1], without unit.
         */
        TURBIDITY: new x({
          stops: [
            { value: 0, color: [34, 31, 27] },
            { value: 0.13, color: [65, 50, 41] },
            { value: 0.25, color: [98, 69, 52] },
            { value: 0.38, color: [131, 89, 57] },
            { value: 0.5, color: [161, 112, 59] },
            { value: 0.63, color: [185, 140, 66] },
            { value: 0.75, color: [202, 174, 88] },
            { value: 0.88, color: [216, 209, 126] },
            { value: 1, color: [233, 246, 171] }
          ]
        }),
        /**
         * Classic velocity blue color ramp.
         * Defined in interval [0, 1], without unit.
         */
        VELOCITY_BLUE: new x({
          stops: [
            { value: 0, color: [17, 32, 64] },
            { value: 0.13, color: [35, 52, 116] },
            { value: 0.25, color: [29, 81, 156] },
            { value: 0.38, color: [31, 113, 162] },
            { value: 0.5, color: [50, 144, 169] },
            { value: 0.63, color: [87, 173, 176] },
            { value: 0.75, color: [149, 196, 189] },
            { value: 0.88, color: [203, 221, 211] },
            { value: 1, color: [254, 251, 230] }
          ]
        }),
        /**
         * Classic velocity green color ramp.
         * Defined in interval [0, 1], without unit.
         */
        VELOCITY_GREEN: new x({
          stops: [
            { value: 0, color: [23, 35, 19] },
            { value: 0.13, color: [24, 64, 38] },
            { value: 0.25, color: [11, 95, 45] },
            { value: 0.38, color: [39, 123, 35] },
            { value: 0.5, color: [95, 146, 12] },
            { value: 0.63, color: [152, 165, 18] },
            { value: 0.75, color: [201, 186, 69] },
            { value: 0.88, color: [233, 216, 137] },
            { value: 1, color: [255, 253, 205] }
          ]
        }),
        /**
         * Classic cube helix color ramp.
         * Defined in interval [0, 1], without unit.
         */
        CUBEHELIX: new x({
          stops: [
            { value: 0, color: [0, 0, 0] },
            { value: 0.07, color: [22, 5, 59] },
            { value: 0.13, color: [60, 4, 105] },
            { value: 0.2, color: [109, 1, 135] },
            { value: 0.27, color: [161, 0, 147] },
            { value: 0.33, color: [210, 2, 142] },
            { value: 0.4, color: [251, 11, 123] },
            { value: 0.47, color: [255, 29, 97] },
            { value: 0.53, color: [255, 54, 69] },
            { value: 0.6, color: [255, 85, 46] },
            { value: 0.67, color: [255, 120, 34] },
            { value: 0.73, color: [255, 157, 37] },
            { value: 0.8, color: [241, 191, 57] },
            { value: 0.87, color: [224, 220, 93] },
            { value: 0.93, color: [218, 241, 142] },
            { value: 1, color: [227, 253, 198] }
          ]
        }),
        /**
         * The cividis color ramp is color blind friendly.
         * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239
         * Defined in interval [0, 1], without unit.
         */
        CIVIDIS: new x({
          stops: [
            { value: 0, color: [0, 32, 77, 255] },
            { value: 0.125, color: [5, 54, 110, 255] },
            { value: 0.25, color: [65, 77, 108, 255] },
            { value: 0.375, color: [97, 100, 111, 255] },
            { value: 0.5, color: [125, 124, 121, 255] },
            { value: 0.625, color: [156, 149, 120, 255] },
            { value: 0.75, color: [190, 175, 111, 255] },
            { value: 0.875, color: [225, 204, 94, 255] },
            { value: 1, color: [255, 235, 70, 255] }
          ]
        }),
        /**
         * Classic turbo color ramp.
         * This is a luminance-constant alternative to the jet, making it more
         * clor-blind friendly.
         * Defined in interval [0, 1], without unit.
         */
        TURBO: new x({
          stops: [
            { value: 0, color: [48, 18, 59, 255] },
            { value: 0.125, color: [70, 107, 227, 255] },
            { value: 0.25, color: [40, 187, 236, 255] },
            { value: 0.375, color: [49, 242, 153, 255] },
            { value: 0.5, color: [162, 252, 60, 255] },
            { value: 0.625, color: [237, 208, 58, 255] },
            { value: 0.75, color: [251, 128, 34, 255] },
            { value: 0.875, color: [210, 49, 5, 255] },
            { value: 1, color: [122, 4, 3, 255] }
          ]
        }),
        /**
         * The rocket color ramp is perceptually uniform, which makes it more
         * color bliend friendly than the classic magma color ramp.
         * Defined in interval [0, 1], without unit.
         */
        ROCKET: new x({
          stops: [
            { value: 0, color: [250, 235, 221, 0] },
            { value: 0.133, color: [250, 235, 221, 255] },
            { value: 0.266, color: [246, 170, 130, 255] },
            { value: 0.4, color: [240, 96, 67, 255] },
            { value: 0.533, color: [203, 27, 79, 255] },
            { value: 0.666, color: [132, 30, 90, 255] },
            { value: 0.8, color: [63, 27, 68, 255] },
            { value: 1, color: [3, 5, 26, 255] }
          ]
        }),
        /**
         * The mako color ramp is perceptually uniform and can be seen as
         * a color blind friendly alternative to bathymetry or yignbu.
         * Defined in interval [0, 1], without unit.
         */
        MAKO: new x({
          stops: [
            { value: 0, color: [11, 4, 5, 255] },
            { value: 0.125, color: [43, 28, 53, 255] },
            { value: 0.25, color: [62, 53, 107, 255] },
            { value: 0.375, color: [59, 86, 152, 255] },
            { value: 0.5, color: [53, 123, 162, 255] },
            { value: 0.625, color: [53, 158, 170, 255] },
            { value: 0.75, color: [73, 193, 173, 255] },
            { value: 0.875, color: [150, 221, 181, 255] },
            { value: 1, color: [222, 245, 229, 255] }
          ]
        })
      };
      Wa();
      Dl = import_maplibre_gl.default.Map;
      ql = import_maplibre_gl.default.Marker;
      Bl = import_maplibre_gl.default.Popup;
      Ul = import_maplibre_gl.default.Style;
      Vl = import_maplibre_gl.default.CanvasSource;
      Gl = import_maplibre_gl.default.GeoJSONSource;
      Hl = import_maplibre_gl.default.ImageSource;
      Kl = import_maplibre_gl.default.RasterTileSource;
      Wl = import_maplibre_gl.default.RasterDEMTileSource;
      Zl = import_maplibre_gl.default.VectorTileSource;
      Jl = import_maplibre_gl.default.VideoSource;
      Yl = import_maplibre_gl.default.NavigationControl;
      Xl = import_maplibre_gl.default.GeolocateControl;
      Ql = import_maplibre_gl.default.AttributionControl;
      eu = import_maplibre_gl.default.LogoControl;
      tu = import_maplibre_gl.default.ScaleControl;
      ru = import_maplibre_gl.default.FullscreenControl;
      nu = import_maplibre_gl.default.TerrainControl;
      au = import_maplibre_gl.default.BoxZoomHandler;
      ou = import_maplibre_gl.default.ScrollZoomHandler;
      iu = import_maplibre_gl.default.CooperativeGesturesHandler;
      su = import_maplibre_gl.default.KeyboardHandler;
      lu = import_maplibre_gl.default.TwoFingersTouchPitchHandler;
      uu = import_maplibre_gl.default.MapWheelEvent;
      cu = import_maplibre_gl.default.MapTouchEvent;
      pu = import_maplibre_gl.default.MapMouseEvent;
      fu = import_maplibre_gl.default.config;
      du = import_maplibre_gl.default.getVersion;
      ({
        setRTLTextPlugin: yu,
        getRTLTextPluginStatus: mu,
        LngLat: hu,
        LngLatBounds: gu,
        MercatorCoordinate: vu,
        Evented: bu,
        AJAXError: wu,
        prewarm: Su,
        clearPrewarmedResources: xu,
        Hash: ku,
        Point: Lu,
        EdgeInsets: Cu,
        DragRotateHandler: Au,
        DragPanHandler: Tu,
        TwoFingersTouchZoomRotateHandler: Iu,
        DoubleClickZoomHandler: Eu,
        TwoFingersTouchZoomHandler: Mu,
        TwoFingersTouchRotateHandler: _u,
        getWorkerCount: zu,
        setWorkerCount: Pu,
        getMaxParallelImageRequests: Ru,
        setMaxParallelImageRequests: $u,
        getWorkerUrl: ju,
        setWorkerUrl: Nu,
        addSourceType: Ou,
        importScriptInWorkers: Fu,
        addProtocol: Du,
        removeProtocol: qu
      } = import_maplibre_gl.default);
    }
  });

  // public/js/map.js
  var displayMap;
  var init_map = __esm({
    "public/js/map.js"() {
      init_maptiler_sdk();
      init_maptiler_sdk2();
      displayMap = (locations) => {
        O.apiKey = "zeYpMqgcTa20zTTj3vyr";
        const map = new zr({
          container: "map",
          style: MapStyle.STREETS,
          scrollZoom: false
        });
        const bounds = new gu();
        locations.forEach((loc) => {
          const el = document.createElement("div");
          el.className = "marker";
          new gl({ element: el, anchor: "bottom" }).setLngLat(loc.coordinates).addTo(map);
          new bl({
            offset: 30
          }).setLngLat(loc.coordinates).setHTML(`<p>Day ${loc.day}: ${loc.description}</p>`).addTo(map);
          bounds.extend(loc.coordinates);
        });
        map.on("load", () => {
          if (locations.length > 0) {
            map.fitBounds(bounds, {
              padding: {
                top: 200,
                bottom: 150,
                left: 100,
                right: 100
              },
              minZoom: 5,
              maxZoom: 9
            });
          } else {
            map.fitBounds(bounds, {
              padding: {
                top: 200,
                bottom: 150,
                left: 100,
                right: 100
              }
            });
          }
        });
      };
    }
  });

  // public/js/index.js
  var require_index = __commonJS({
    "public/js/index.js"() {
      var import_stable = __toESM(require_stable());
      var import_runtime = __toESM(require_runtime());
      init_login();
      init_signup();
      init_updateSettings();
      init_stripe();
      init_booking();
      init_alert();
      init_review();
      init_map();
      var mapBox = document.getElementById("map");
      var loginForm = document.querySelector(".form--login");
      var signupForm = document.querySelector(".form--signup");
      var logoutForm = document.querySelector(".nav__el--logout");
      var userDataForm = document.querySelector(".form-user-data");
      var userPasswordForm = document.querySelector(".form-user-password");
      var reviewForm = document.querySelector(".form--review");
      var popupButton = document.getElementById("open-booking");
      var bookBtn = document.getElementById("book-tour");
      var confirmEmailSuccess = document.getElementById("redirect-countdown");
      if (mapBox) {
        const locations = JSON.parse(mapBox.dataset.locations);
        displayMap(locations);
      }
      if (loginForm)
        loginForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const email = document.getElementById("email").value;
          const password = document.getElementById("password").value;
          login(email, password);
        });
      if (signupForm)
        signupForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const name = document.getElementById("username").value;
          const email = document.getElementById("email").value;
          const password = document.getElementById("password").value;
          const passwordConfirm = document.getElementById("passwordConfirm").value;
          signup({ name, email, password, passwordConfirm });
        });
      if (confirmEmailSuccess) startCountdownRedirect("/", 5);
      if (logoutForm) logoutForm.addEventListener("click", logout);
      if (userDataForm)
        userDataForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const form = new FormData();
          form.append("name", document.getElementById("name").value);
          form.append("email", document.getElementById("email").value);
          form.append("photo", document.getElementById("photo").files[0]);
          updateSettings(form, "data");
        });
      if (userPasswordForm)
        userPasswordForm.addEventListener("submit", async (e) => {
          e.preventDefault();
          document.querySelector(".btn--save-password").textContent = "Updating...";
          const passwordCurrent = document.getElementById("password-current").value;
          const password = document.getElementById("password").value;
          const passwordConfirm = document.getElementById("password-confirm").value;
          await updateSettings(
            { passwordCurrent, password, passwordConfirm },
            "password"
          );
          document.querySelector(".btn--save-password").textContent = "Save password";
          document.getElementById("password-current").value = "";
          document.getElementById("password").value = "";
          document.getElementById("password-confirm").value = "";
        });
      if (reviewForm)
        reviewForm.addEventListener("submit", (e) => {
          e.preventDefault();
          const review = document.getElementById("review").value;
          const rating = document.getElementById("rating").value;
          const { user, tour } = document.getElementById("btn-review").dataset;
          addReview({ review, rating: Number(rating), user, tour });
        });
      if (popupButton) {
        const bookingPopup = document.getElementById("popup-overlay");
        const popupContainer = document.querySelector(".popup-container");
        popupButton.addEventListener("click", () => {
          bookingPopup.classList.remove("hidden");
          bookingPopup.classList.add("popup-overlay");
        });
        bookingPopup.addEventListener("mousedown", (e) => {
          if (!popupContainer.contains(e.target)) {
            bookingPopup.classList.add("hidden");
            bookingPopup.classList.remove("popup-overlay");
          }
        });
        selectBookingDate();
      }
      if (bookBtn) {
        bookBtn.addEventListener("click", async (e) => {
          const { tourId, bookingDate } = e.target.dataset;
          if (!bookingDate)
            return showAlert("error", "You didn't select a start date");
          e.target.textContent = "Processing...";
          await bookTour(tourId, bookingDate);
        });
      }
    }
  });
  require_index();
})();
/*! Bundled license information:

maplibre-gl/dist/maplibre-gl.js:
  (**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.5.0/LICENSE.txt
   *)
*/
